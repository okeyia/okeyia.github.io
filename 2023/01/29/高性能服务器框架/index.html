<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>二 高性能服务器框架 | okeyia</title><meta name="keywords" content="服务器编程"><meta name="author" content="okeyia"><meta name="copyright" content="okeyia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第二篇 高性能服务器框架第5章 Linux网络编程基础API我们将从如 下3个方面讨论Linux网络API：  socket地址API。socket最开始的含义是一个IP地址和端口对 （ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket 地址。 socket基础API。socket的主要API都定义在sys&#x2F;socket.h头文件 中，包括创建socket、命名socke">
<meta property="og:type" content="article">
<meta property="og:title" content="二 高性能服务器框架">
<meta property="og:url" content="http://okeyia.github.io/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/index.html">
<meta property="og:site_name" content="okeyia">
<meta property="og:description" content="第二篇 高性能服务器框架第5章 Linux网络编程基础API我们将从如 下3个方面讨论Linux网络API：  socket地址API。socket最开始的含义是一个IP地址和端口对 （ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket 地址。 socket基础API。socket的主要API都定义在sys&#x2F;socket.h头文件 中，包括创建socket、命名socke">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091404676.png">
<meta property="article:published_time" content="2023-01-29T03:05:24.000Z">
<meta property="article:modified_time" content="2023-03-21T09:31:46.636Z">
<meta property="article:author" content="okeyia">
<meta property="article:tag" content="服务器编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091404676.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://okeyia.github.io/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '二 高性能服务器框架',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-03-21 17:31:46'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="okeyia" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202204171749626.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091404676.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">okeyia</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">二 高性能服务器框架</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-01-29T03:05:24.000Z" title="发表于 2023-01-29 11:05:24">2023-01-29</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-21T09:31:46.636Z" title="更新于 2023-03-21 17:31:46">2023-03-21</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="二 高性能服务器框架"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="第二篇-高性能服务器框架"><a href="#第二篇-高性能服务器框架" class="headerlink" title="第二篇 高性能服务器框架"></a>第二篇 高性能服务器框架</h2><h3 id="第5章-Linux网络编程基础API"><a href="#第5章-Linux网络编程基础API" class="headerlink" title="第5章 Linux网络编程基础API"></a>第5章 Linux网络编程基础API</h3><p>我们将从如 下3个方面讨论Linux网络API：</p>
<ul>
<li>socket地址API。socket最开始的含义是一个IP地址和端口对 （ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket 地址。</li>
<li>socket基础API。socket的主要API都定义在sys/socket.h头文件 中，包括创建socket、命名socket、监听socket、接受连接、发起连接、 读写数据、获取地址信息、检测带外标记，以及读取和设置socket选 项。</li>
<li>网络信息API。Linux提供了一套网络信息API，以实现主机名和 IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定 义在netdb.h头文件中，我们将讨论其中几个主要的函数。</li>
</ul>
<h4 id="5-1-socket地址API"><a href="#5-1-socket地址API" class="headerlink" title="5.1 socket地址API"></a>5.1 socket地址API</h4><h5 id="5-1-1-主机字节序和网络字节序"><a href="#5-1-1-主机字节序和网络字节序" class="headerlink" title="5.1.1 主机字节序和网络字节序"></a>5.1.1 主机字节序和网络字节序</h5><p>现代CPU的累加器一次都能装载（至少）4字节（这里考虑32位 机，下同），即一个整数。那么这4字节在内存中排列的顺序将影响它 被累加器装载成的整数的值。这就是字节序问题。</p>
<p>字节序分为大端字 节序（big endian）和小端字节序（little endian）。</p>
<ul>
<li>大端字节序是指一 个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0 ～7 bit）存储在内存的高地址处。</li>
<li>小端字节序则是指整数的高位字节存 储在内存的高地址处，而低位字节则存储在内存的低地址处。</li>
</ul>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224104317174-1678341964415.png" class="" title="image-20230224104317174">

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断机器字节序</span></span><br><span class="line"><span class="comment">// union 参考https://www.cnblogs.com/linyx/p/3998893.html</span></span><br><span class="line"><span class="comment">// 在一个union类型结构中,所有的成员公用同样的存储空间,其占用的大小为其成员中需要空间最大者；</span></span><br><span class="line"><span class="comment">// union本身只保留一块地址空间，因为只有一个成员真正存储于该地址， 但这块地址也要满足内存对齐原则。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">byteorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">		<span class="keyword">short</span> value;</span><br><span class="line">		<span class="keyword">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">	&#125; test;</span><br><span class="line"></span><br><span class="line">	test.value = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;little endian\n&quot;</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unknown...\n&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>发送端总是把要发送的数据转化成大端字节序数据后 再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所 以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转 换（小端机转换，大端机不转换）。</p>
<p>因此大端字节序也称为网络字节 序，它给所有接收数据的主机提供了一个正确解释收到的格式化数据 的保证。</p>
<p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的 转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="comment">// 如htonl表示“host to network long”，即将长整型（32 bit）的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>



<h5 id="5-1-2-通用socket地址"><a href="#5-1-2-通用socket地址" class="headerlink" title="5.1.2 通用socket地址"></a>5.1.2 通用socket地址</h5><p>socket网络编程接口中表示socket地址的是结构体sockaddr，其定义 如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>sa_family成员是地址族类型（sa_family_t）的变量。地址族类型通 常与协议族类型对应。常见的协议族（protocol family，也称domain， 见后文）和对应的地址族如表5-1所示。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224120412533-1678341964416.png" class="" title="image-20230224120412533">

<p>宏PF_<em>和AF_</em>都定义在bits/socket.h头文件中，且后者与前者有完 全相同的值，所以二者通常混用。</p>
<p>sa_data成员用于存放socket地址值。但是，不同的协议族的地址值 具有不同的含义和长度，如表5-2所示。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224133658704-1678341964416.png" class="" title="image-20230224133658704">

<p>由表5-2可见，<strong>14字节的sa_data根本无法完全容纳多数协议族的地 址值。</strong>因此，Linux定义了下面这个新的通用socket地址结构体：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> int__ss_align;</span><br><span class="line">	<span class="keyword">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-1-3-专用socket地址"><a href="#5-1-3-专用socket地址" class="headerlink" title="5.1.3 专用socket地址"></a>5.1.3 专用socket地址</h5><p>上面这两个通用socket地址结构体显然很不好用，比如设置与获取 IP地址和端口号就需要执行烦琐的位操作。</p>
<p>所以Linux为各个协议族提 供了专门的socket地址结构体。UNix忽略.</p>
<p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构 体，它们分别用于IPv4和IPv6：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipV4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sin_family;			<span class="comment">/*地址族：AF_INET*/</span></span><br><span class="line">	<span class="keyword">u_int16_t</span> sin_port;				<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>		<span class="comment">/*IPv4地址结构体，见下面*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> s_addr;  <span class="comment">/*IPv4地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipV6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sin6_family;<span class="comment">/*地址族：AF_INET6*/</span></span><br><span class="line">	<span class="keyword">u_int16_t</span> sin6_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> sin6_flowinfo;<span class="comment">/*流信息，应设置为0*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/*IPv6地址结构体，见下面*/</span></span><br><span class="line">	<span class="keyword">u_int32_t</span> sin6_scope_id;<span class="comment">/*scope ID，尚处于实验阶段*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];<span class="comment">/*IPv6地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使 用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因 为所有socket编程接口使用的地址参数的类型都是sockaddr。</strong></p>
<h5 id="5-1-4-IP地址转换函数"><a href="#5-1-4-IP地址转换函数" class="headerlink" title="5.1.4 IP地址转换函数"></a>5.1.4 IP地址转换函数</h5><p>下 面3个函数可用于用<strong>点分十进制字符串表示的IPv4地址</strong>和用<strong>网络字节序 整数表示的IPv4地址</strong>之间的转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络 字节序整数表示的IPv4地址。它失败时返回INADDR_NONE。</p>
</li>
<li><p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于 参数inp指向的地址结构中。它成功时返回1，失败则返回0。</p>
</li>
<li><p>inet_ntoa函数将用网络字节序整数表示的IPv4地址转化为用点分十 进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，<strong>函数的返回值指向该静态内存</strong>，因此inet_ntoa是 不可重入的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* szValue1=inet_ntoa(“<span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>”);</span><br><span class="line"><span class="keyword">char</span>* szValue2=inet_ntoa(“<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span>”);</span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">1</span>:%s\n”,szValue1);</span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">2</span>:%s\n”,szValue2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">address1:<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br><span class="line">address2:<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且它 们同时适用于IPv4地址和IPv6地址：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">char</span>* dst,<span class="keyword">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>inet_pton函数将用字符串表示的IP地址src（用点分十进制字符串表 示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节 序整数表示的IP地址，并把<strong>转换结果存储于dst指向的内存中</strong>。其中，af 参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返 回1，失败则返回0并设置errno[1]。</li>
<li>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参 数相同，最后一个参数cnt指定目标存储单元的大小。</li>
</ul>
<h4 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h4><p>UNIX/Linux的一个哲学是：所有东西都是文件。socket也不例 外，它就是可读、可写、可控制、可关闭的文件描述符。</p>
<p>下面的 socket系统调用可创建一个socket：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>domain参数告诉系统使用哪个底层协议族。对TCP/IP协议族而 言，该参数应该设置为PF_INET（Protocol Family of Internet，用于 IPv4）或PF_INET6（用于IPv6）；对于UNIX本地域协议族而言，该 参数应该设置为PF_UNIX。</li>
<li>type参数指定服务类型。服务类型主要有SOCK_STREAM服务 （流服务）和SOCK_UGRAM（数据报）服务。<strong>对TCP/IP协议族而 言，其值取SOCK_STREAM表示传输层使用TCP协议，取 SOCK_DGRAM表示传输层使用UDP协议。</strong></li>
<li>protocol参数是在前两个参数构成的协议集合下，再选择一个具体 的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它 的值）。几乎在所有情况下，我们都应该把它设置为0，表示使用默认 协议。</li>
</ul>
<p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1 并设置errno。</p>
<h4 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h4><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地 址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给 socket命名。</p>
<p>只有命名 后客户端才能知道该如何连接它。客户端则通常不需要命名socket， 而是采用匿名方式，即使用操作系统自动分配的socket地址。命名 socket的系统调用是bind，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>bind将my_addr所指的socket地址分配给未命名的sockfd文件描述 符，addrlen参数指出该socket地址的长度。</p>
<p>bind成功时返回0，失败则返回-1并设置errno。其中两种常见的 errno是EACCES和EADDRINUSE，它们的含义分别是：</p>
<ul>
<li>EACCES，被绑定的地址是受保护的地址，仅超级用户能够访 问。比如普通用户将socket绑定到知名服务端口（端口号为0～1023） 上时，bind将返回EACCES错误。</li>
<li>EADDRINUSE，被绑定的地址正在使用中。比如将socket绑定 到一个处于TIME_WAIT状态的socket地址。</li>
</ul>
<h4 id="5-4-监听socket"><a href="#5-4-监听socket" class="headerlink" title="5.4 监听socket"></a>5.4 监听socket</h4><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如 下系统调用来创建一个监听队列以存放待处理的客户连接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客 户连接，客户端也将收到ECONNREFUSED错误信息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/2/24.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_term</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	signal(SIGTERM, handle_term);</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">3</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number backlog\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> backlog = atoi(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(sock&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建一个IPv4 socket地址*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">	bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// inet_pton函数将用字符串表示的IP地址 src 转换成用网络字节 序整数表示的IP地址，</span></span><br><span class="line">	inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">	address.sin_port = htons(port);</span><br><span class="line">	<span class="keyword">int</span> ret = bind(sock,(struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	ret = listen(sock, backlog);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*循环等待连接，直到有SIGTERM信号将它中断*/</span></span><br><span class="line">	<span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">		sleep(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"><span class="comment">/*关闭socket，见后文*/</span></span><br><span class="line">	close(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224203335190-1678341964416.png" class="" title="image-20230224203335190">

<p>可见，在监听队列中，处于ESTABLISHED状态的连接只有6个 （backlog值加1），其他的连接都处于SYN_RCVD状态。</p>
<h4 id="5-5-接受连接"><a href="#5-5-接受连接" class="headerlink" title="5.5 接受连接"></a>5.5 接受连接</h4><p>下面的系统调用从listen监听队列中接受一个连接：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd参数是执行过listen系统调用的监听socket[1]。</li>
<li>addr参数用来获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数 指出。</li>
</ul>
<p>accept成功时返回一个新的连接socket，该socket唯一地标识了 被接受的这个连接，服务器可通过读写该socket来与被接受连接对应 的客户端通信。accept失败时返回-1并设置errno。</p>
<p>如果监听队列中处于ESTABLISHED状态的 连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么 服务器对这个连接执行的accept调用是否成功？</p>
<p>做实验说明,   <strong>accept只是从监听队列中取出连接，而不论连接处于 何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更 不关心任何网络状况的变化。</strong></p>
<h4 id="5-6-发起连接"><a href="#5-6-发起连接" class="headerlink" title="5.6 发起连接"></a>5.6 发起连接</h4><p>客户端主动建立连接</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockfd参数由socket系统调用返回一个socket。serv_addr参数是服 务器监听的socket地址，addrlen参数则指定这个地址的长度。</p>
<p>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了 这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失 败则返回-1并设置errno。</p>
<p>其中两种常见的errno是ECONNREFUSED和 ETIMEDOUT，它们的含义如下： </p>
<ul>
<li><p>ECONNREFUSED，目标端口不存在，连接被拒绝。我们在 3.5.1小节讨论过这种情况。 </p>
</li>
<li><p>ETIMEDOUT，连接超时。我们在3.3.3小节讨论过这种情况。</p>
</li>
</ul>
<h4 id="5-7-关闭连接"><a href="#5-7-关闭连接" class="headerlink" title="5.7 关闭连接"></a>5.7 关闭连接</h4><p>关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下<strong>关闭普通文件描述符的系统调用</strong>来完成：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd参数是待关闭的socket。不过，close系统调用并非总是立即关闭 一个连接，而是将fd的引用计数减1。<strong>只有当fd的引用计数为0时，才真正关闭连接。</strong>多进程程序中，一次fork系统调用默认将使父进程中打开 的socket的引用计数加1，因此我们必须在父进程和子进程中都对该 socket执行close调用才能将连接关闭。</p>
<p>如果想强制关闭的话, 可以使用如下的shutdown系统调用（相对于close来说，它是专门 为网络编程设计的）：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockfd参数是待关闭的socket。howto参数决定了shutdown的行为， 它可取表5-3中的某个值。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224204515803-1678341964416.png" class="" title="image-20230224204515803">

<p>由此可见，shutdown能够分别关闭socket上的读或写，或者都关 闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p>
<h4 id="5-8-数据读写"><a href="#5-8-数据读写" class="headerlink" title="5.8 数据读写"></a>5.8 数据读写</h4><h5 id="5-8-1-TCP数据读写"><a href="#5-8-1-TCP数据读写" class="headerlink" title="5.8.1 TCP数据读写"></a>5.8.1 TCP数据读写</h5><p><strong>对文件的读写操作read和write同样适用于socket。</strong>但是socket编程接 口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据 读写的控制。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>*buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>*buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。</strong></p>
<p>recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们 可能要多次调用recv，才能读取到完整的数据。recv可能返回0，这意 味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。</p>
<p>send往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置 和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置 errno。</p>
<p>flags参数为数据收发提供了额外的控制，它可以取表5-4所示选项 中的一个或几个的逻辑或。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224205138815-1678341964416.png" class="" title="image-20230224205138815">

<p>实验结果: </p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224211104916-1678341964416.png" class="" title="image-20230224211104916">

<p>客户端发送给服务器的3字节的带外数据“abc”中，仅有 最后一个字符“c”被服务器当成真正的带外数据接收（正如3.8节讨论的 那样）。并且，服务器对正常数据的接收将被带外数据截断，即前一 部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全 部读出的。</p>
<h5 id="5-8-2-UDP数据读写"><a href="#5-8-2-UDP数据读写" class="headerlink" title="5.8.2 UDP数据读写"></a>5.8.2 UDP数据读写</h5><p>socket编程接口中用于UDP数据报读写的系统调用是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags,struct sockaddr* src_addr,<span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags,<span class="keyword">const</span> struct sockaddr* dest_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位 置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都 需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。</li>
<li>sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置 和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该 地址的长度。 </li>
<li>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调 用的flags参数及返回值相同。</li>
</ul>
<h5 id="5-8-3-通用数据读写函数"><a href="#5-8-3-通用数据读写函数" class="headerlink" title="5.8.3 通用数据读写函数"></a>5.8.3 通用数据读写函数</h5><p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅 能用于TCP流数据，也能用于UDP数据报, 在第13.9章节进程间传递文件描述符 用到了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd,struct msghdr*msg,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd,struct msghdr*msg,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sockfd参数指定被操作的目标socket。</p>
</li>
<li><p>msg参数是msghdr结构体类 型的指针，msghdr结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">void</span>*msg_name;<span class="comment">/*socket地址*/</span></span><br><span class="line">	<span class="keyword">socklen_t</span> msg_namelen;<span class="comment">/*socket地址的长度*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>*<span class="title">msg_iov</span>;</span><span class="comment">/*分散的内存块，见后文*/</span></span><br><span class="line">	<span class="keyword">int</span> msg_iovlen;<span class="comment">/*分散内存块的数量*/</span></span><br><span class="line">    <span class="keyword">void</span>*msg_control;<span class="comment">/*指向辅助数据的起始位置*/</span></span><br><span class="line">	<span class="keyword">socklen_t</span> msg_controllen;<span class="comment">/*辅助数据的大小*/</span></span><br><span class="line">	<span class="keyword">int</span> msg_flags;<span class="comment">/*复制函数中的flags参数，并在调用过程中更新*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>msg_name成员指向一个socket地址结构变量。它指定通信对方的 socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置 为NULL。这是因为对数据流socket而言，对方的地址已经知道。</p>
</li>
<li><p>msg_namelen成员则指定了msg_name所指socket地址的长度。</p>
</li>
<li><p>msg_iov成员是iovec结构体类型的指针，iovec结构体封装了一块内存的起始位置和长度。 iovec结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">void</span>* iov_base;<span class="comment">/*内存起始地址*/</span></span><br><span class="line">	<span class="keyword">size_t</span> iov_len;<span class="comment">/*这块内存的长度*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>msg_iovlen指定这样的iovec结构对象有多少个。对于recvmsg而言，数 据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长 度则由msg_iov指向的数组指定，这称为分散读（scatter read）；对于 sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这称为 集中写（gather write）</p>
</li>
<li><p>msg_control和msg_controllen成员用于辅助数据的传送。我们不详 细讨论它们，仅在第13章介绍如何使用它们来实现在进程间传递文件 描述符。</p>
</li>
<li><p>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的 内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后 的标志设置到msg_flags中。</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-9-带外标记"><a href="#5-9-带外标记" class="headerlink" title="5.9 带外标记"></a>5.9 带外标记</h4><p>在实际应用中， 我们通常无法预期带外数据何时到来。好在<strong>Linux内核检测到TCP紧急 标志</strong>时，将通知应用程序有带外数据需要接收。内核通知应用程序带 外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信 号。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数 据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用 带MSG_OOB标志的recv调用来接收带外数据。如果不是，则 sockatmark返回0。</p>
<h4 id="5-10-地址信息函数"><a href="#5-10-地址信息函数" class="headerlink" title="5.10 地址信息函数"></a>5.10 地址信息函数</h4><p>在某些情况下，我们想知道一个连接socket的本端socket地址，以 及远端的socket地址。下面这两个函数正是用于解决这个问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure>

<p>getsockname获取sockfd对应的本端socket地址，并将其存储于 address参数指定的内存中，该socket地址的长度则存储于address_len参 数指向的变量中。</p>
<p>getpeername获取sockfd对应的远端socket地址，其参数及返回值的 含义与getsockname的参数及返回值相同。</p>
<h4 id="5-11-socket-选项"><a href="#5-11-socket-选项" class="headerlink" title="5.11 socket 选项"></a>5.11 socket 选项</h4><p>如果说<strong>fcntl系统调用（文件描述符控制）</strong>是控制文件描述符属性的通用POSIX（可移植操作系统接口）方法，那 么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的 方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> level,<span class="keyword">int</span> option_name,<span class="keyword">void</span>* option_value,<span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> level,<span class="keyword">int</span> option_name,<span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>sockfd参数指定被操作的目标socket。level参数指定要操作哪个协 议的选项（即属性），比如IPv4、IPv6、TCP等。option_name参数则指 定选项的名字。我们在表5-5中列举了socket通信中几个比较常用的 socket选项。option_value和option_len参数分别是被操作选项的值和长 度。</li>
<li><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304223735943.png" class="" title="image-20230304223735943">

</li>
</ul>
<p>暂时用不到， 略过一部分。</p>
<h5 id="5-11-1-SO-REUSEADDR选项"><a href="#5-11-1-SO-REUSEADDR选项" class="headerlink" title="5.11.1 SO_REUSEADDR选项"></a>5.11.1 SO_REUSEADDR选项</h5><p>我们在3.4.2小节讨论过TCP连接的TIME_WAIT状态，并提到服务 器程序可以通过设置socket选项SO_REUSEADDR来强制使用被处于 TIME_WAIT状态的连接占用的socket地址。具体实现方法如代码清单5- 9所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reuse=<span class="number">1</span>;</span><br><span class="line">setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,＆reuse,<span class="keyword">sizeof</span>(reuse));</span><br></pre></td></tr></table></figure>

<p>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之 绑定的socket地址也可以立即被重用。</p>
<h5 id="5-11-4-SO-LINGER选项"><a href="#5-11-4-SO-LINGER选项" class="headerlink" title="5.11.4 SO_LINGER选项"></a>5.11.4 SO_LINGER选项</h5><p>SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。</p>
<p>默认情况下，当我们使用close系统调用来关闭一个socket时，close 将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的 数据发送给对方。</p>
<p>设置（获取）SO_LINGER选项的值时，我们需要给 setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定 义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> l_onoff;<span class="comment">/*开启（非0）还是关闭（0）该选项*/</span></span><br><span class="line">	<span class="keyword">int</span> l_linger;<span class="comment">/*滞留时间*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据linger结构体中两个成员变量的不同值，close系统调用可能产 生如下3种行为之一：</p>
<ul>
<li>l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为 来关闭socket。</li>
<li>l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP 模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时 给对方发送一个复位报文段（见3.5.2小节）。因此，这种情况给服务 器提供了异常终止一个连接的方法。</li>
<li>l_onoff不为0，l_linger大于0。此时close的行为取决于两个条 件：一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数 据；二是该socket是阻塞的，还是非阻塞的。对于阻塞的socket，close 将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并 得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到 对方的确认，那么close系统调用将返回-1并设置errno为 EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我 们需要根据其返回值和errno来判断残留数据是否已经发送完毕。</li>
</ul>
<h4 id="5-12-网络信息API"><a href="#5-12-网络信息API" class="headerlink" title="5.12 网络信息API"></a>5.12 网络信息API</h4><p>socket地址的两个要素，即IP地址和端口号，都是用数值表示的。 这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。因此在前面 的章节中，我们用主机名来访问一台机器，而避免直接使用其IP地 址。同样，我们用服务名称来代替端口号。</p>
<h5 id="5-12-1-gethostbyname和gethostbyaddr"><a href="#5-12-1-gethostbyname和gethostbyaddr" class="headerlink" title="5.12.1 gethostbyname和gethostbyaddr"></a>5.12.1 gethostbyname和gethostbyaddr</h5><p>gethostbyname函数<strong>根据主机名称获取主机的完整信息</strong>， gethostbyaddr函数<strong>根据IP地址获取主机的完整信息。</strong></p>
<ul>
<li>gethostbyname函数 通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访 问DNS服务器。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function">struct hostent*<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*name)</span></span>;</span><br><span class="line"><span class="function">struct hostent*<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>name参数指定目标主机的主机名，</li>
<li>addr参数指定目标主机的IP地 址，</li>
<li>len参数指定addr所指IP地址的长度，</li>
<li>type参数指定addr所指IP地址 的类型，其合法取值包括AF_INET（用于IPv4地址）和AF_INET6（用 于IPv6地址）。</li>
</ul>
<p>这两个函数返回的都是hostent结构体类型的指针，hostent结构体的 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span>*h_name;	<span class="comment">/*主机名*/</span></span><br><span class="line">	<span class="keyword">char</span>**h_aliases;	<span class="comment">/*主机别名列表，可能有多个*/</span></span><br><span class="line">	<span class="keyword">int</span> h_addrtype;	<span class="comment">/*地址类型（地址族）*/</span></span><br><span class="line">	<span class="keyword">int</span> h_length;	<span class="comment">/*地址长度*/</span></span><br><span class="line">	<span class="keyword">char</span>**h_addr_list;	<span class="comment">/*按网络字节序列出的主机IP地址列表*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="5-12-2-getservbyname和getservbyport"><a href="#5-12-2-getservbyname和getservbyport" class="headerlink" title="5.12.2 getservbyname和getservbyport"></a>5.12.2 getservbyname和getservbyport</h5><p>getservbyname函数根据名称获取某个服务的完整信息， getservbyport函数根据端口号获取某个服务的完整信息。</p>
<p>它们实际上都 是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义 如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name,<span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port,<span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>name参数指定目标服务的名字，</li>
<li>port参数指定目标服务对应的端口 号。</li>
<li>proto参数指定服务类型，给它传递“tcp”表示获取流服务，给它传 递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的 服务。</li>
</ul>
<p>这两个函数返回的都是servent结构体类型的指针，结构体servent的 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span>*s_name;<span class="comment">/*服务名称*/</span></span><br><span class="line">	<span class="keyword">char</span>**s_aliases;<span class="comment">/*服务的别名列表，可能有多个*/</span></span><br><span class="line">	<span class="keyword">int</span> s_port;<span class="comment">/*端口号*/</span></span><br><span class="line">	<span class="keyword">char</span>*s_proto;<span class="comment">/*服务类型,通常是tcp或者udp*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="5-12-3-getaddrinfo"><a href="#5-12-3-getaddrinfo" class="headerlink" title="5.12.3 getaddrinfo"></a>5.12.3 getaddrinfo</h5><p>getaddrinfo函数既能通过主机名获得IP地址（内部使用的是 gethostbyname函数），也能通过服务名获得端口号（内部使用的是 getservbyname函数）。它是否可重入取决于其内部调用的 gethostbyname和getservbyname函数是否是它们的可重入版本。</p>
<p>该函数 的定义如下： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname,<span class="keyword">const</span> <span class="keyword">char</span>* service,<span class="keyword">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span>;</span><br></pre></td></tr></table></figure>

<p>hostname参数可以接收主机名，也可以接收字符串表示的IP地址 （IPv4采用点分十进制字符串，IPv6则采用十六进制字符串）。同样， service参数可以接收服务名，也可以接收字符串表示的十进制端口号。 hints参数是应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出 进行更精确的控制。hints参数可以被设置为NULL，表示允许 getaddrinfo反馈任何可用的结果。<strong>result参数指向一个链表，该链表用于 存储getaddrinfo反馈的结果。</strong></p>
<p>剩下内容 忽略.</p>
<h3 id="第6章-高级I-O函数"><a href="#第6章-高级I-O函数" class="headerlink" title="第6章 高级I/O函数"></a>第6章 高级I/O函数</h3><p>Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数 （比如open和read）那么常用（编写内核模块时一般要实现这些I/O函 数），但在<strong>特定的条件下却表现出优秀的性能</strong>。</p>
<p><strong>本章将讨论其中和网络编程相关的几个，这些函数大致分为三类：</strong></p>
<ul>
<li>用于创建文件描述符的函数，包括pipe、dup/dup2函数。</li>
<li>用于读写数据的函数，包括readv/writev、sendfile、 mmap/munmap、splice和tee函数。</li>
<li>用于控制I/O行为和属性的函数，包括fcntl函数。</li>
</ul>
<h4 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h4><p>pipe函数可用于创建一个管道，以实现进程间通信。13.4节会讲解如何使用管道实现进程间通信.</p>
<p>pipe函数定义如下:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>

<p>pipe函数的参数是一个包含两个int型整数的数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组。如 果失败，则返回-1并设置errno。</p>
<p><strong>通过pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端，往fd[1]写入的数据可以从fd[0]读出。并且，fd[0]只能用于从管道读出数据，fd[1]则只能用于往管道写入数据，而不能反过来使用。</strong>如果要实现双向的数据传输，就应该使用两个管道。</p>
<p>默认情况 下，这一对文件描述符都是阻塞的。此时如果我们用read系统调用来 读取一个空的管道，则read将被阻塞，直到管道内有数据可读；如果 我们用write系统调用来往一个满的管道（见后文）中写入数据，则 write亦将被阻塞，直到管道有足够多的空闲空间可用。</p>
<p>管道内部传输的数据是字节流, 自Linux 2.6.11 内核起，管道容量的大小默认是65536字节。我们可以使用fcntl函数来 修改管道容量（见后文）。</p>
<p>此外，socket的基础API中有一个socketpair函数。它能够方便地创建双向管道。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol,<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure>



<p>socketpair前三个参数的含义与socket系统调用的三个参数完全相 同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能 在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一 样，只不过socketpair创建的这对文件描述符都是既可读又可写的。 socketpair成功时返回0，失败时返回-1并设置errno。</p>
<h4 id="6-2-dup-函数和dup2函数"><a href="#6-2-dup-函数和dup2函数" class="headerlink" title="6.2 dup 函数和dup2函数"></a>6.2 dup 函数和dup2函数</h4><p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重 定向到一个网络连接（比如CGI编程）。这可以通过下面的用于复制 文件描述符的dup或dup2函数来实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> file_descriptor_one,<span class="keyword">int</span> file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure>

<p>dup函数创建一个新的文件描述符，该新文件描述符和原有文件描 述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回 的文件描述符总是取系统当前可用的最小整数值。</p>
<p>dup2和dup类似，不 过它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统 调用失败时返回-1并设置errno。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		address.sin_family = AF_INET;</span><br><span class="line">		inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">		address.sin_port = htons(port);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> connfd, sock;</span><br><span class="line">	&#123;</span><br><span class="line">		sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">		assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">int</span> ret = bind(sock, (struct sockaddr *) &amp; address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		assert(ret != <span class="number">-1</span>);</span><br><span class="line">		ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">		assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>&#123;</span>&#125;;</span><br><span class="line">		<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">		connfd = accept(sock, (struct sockaddr *) &amp;client, &amp;client_addrlength);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		close(STDOUT_FILENO);</span><br><span class="line">		dup(connfd);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;abcd\n&quot;</span>);</span><br><span class="line">		close(connfd);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>我们先关闭标准输出文件描述符 STDOUT_FILENO（其值是1）</li>
<li>然后复制socket文件描述符connfd。 因为dup总是返回系统中最小的可用文件描述符，所以它的返回值实际 上是1，即之前关闭的标准输出文件描述符的值。</li>
<li>这样一来，服务器输 出到标准输出的内容（这里是“abcd”）就会直接发送到与客户连接对 应的socket上，因此printf调用的输出将被客户端获得（而不是显示在 服务器程序的终端上）。<strong>这就是CGI服务器的基本工作原理。</strong></li>
</ul>
<h4 id="6-3-readv函数和writev函数"><a href="#6-3-readv函数和writev函数" class="headerlink" title="6.3 readv函数和writev函数"></a>6.3 readv函数和writev函数</h4><p><strong>readv函数将数据从文件描述符读到分散的内存块中，即分散读； writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。</strong>它们的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/uio.h＞</span></span><br><span class="line">ssize_t readv(int fd,const struct iovec* vector, int count)；</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd参数是被操作的目标文件描述符。vector参数的类型是iovec结构 数组。我们在第5章讨论过结构体iovec，该结构体描述一块内存区。 count参数是vector数组的长度，即有多少块内存数据需要从fd读出或 写到fd。</p>
<p>readv和writev在成功时返回读出/写入fd的字节数，失败则返 回-1并设置errno。</p>
<p>清单6.2 </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="6-4-sendfile函数"><a href="#6-4-sendfile函数" class="headerlink" title="6.4 sendfile函数"></a>6.4 sendfile函数</h4><p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中 操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率 很高，这被称为零拷贝。</p>
<p>sendfile函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sendfile.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd,<span class="keyword">int</span> in_fd,<span class="keyword">off_t</span>*offset,<span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure>

<p><strong>in_fd参数是待读出内容的文件描述符，out_fd参数是待写入内容的文件描述符。</strong> offset参数指定从读入文件流的哪个位置开始读，如果 为空，则使用读入文件流默认的起始位置。count参数指定在文件描述 符in_fd和out_fd之间传输的字节数。</p>
<p><strong>in_fd 必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。由此可见， sendfile几乎是专门为在网络上传输文件而设计的。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键部分</span></span><br><span class="line"><span class="comment">// connfd 是socket, filefd是打开的文件描述符, </span></span><br><span class="line"><span class="keyword">int</span> filefd=open(file_name,O_RDONLY);</span><br><span class="line">assert(filefd＞<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">fstat(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line">sendfile(connfd,filefd,<span class="literal">NULL</span>,stat_buf.st_size);</span><br></pre></td></tr></table></figure>

<p>我们将目标文件作为第3个参数传递给服务器程 序，客户telnet到该服务器上即可获得该文件。代码清单6-3没有为目标文件分配任何用户空间的缓存，也没有执行读取 文件的操作，但同样实现了文件的发送，其效率显然要高得多。</p>
<h4 id="6-5-mmap函数和nummap函数"><a href="#6-5-mmap函数和nummap函数" class="headerlink" title="6.5 mmap函数和nummap函数"></a>6.5 mmap函数和nummap函数</h4><p><strong>mmap函数用于申请一段内存空间。我们可以将这段内存作为进程间通信的共享内存，也可以==将文件直接映射到其中==。</strong>munmap函数则释 放由mmap创建的这段内存空间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/mman.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>*start,<span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>start参数允许用户使用某个特定的地址作为这段内存的起始地址。 如果它被设置成NULL，则系统自动分配一个地址。</p>
</li>
<li><p>length参数指定内 存段的长度。</p>
</li>
<li><p>prot参数用来设置内存段的访问权限。它可以取以下几个 值的按位或：</p>
<ul>
<li>PROT_READ，内存段可读。 </li>
<li>PROT_WRITE，内存段可写。 </li>
<li>PROT_EXEC，内存段可执行。 </li>
<li>PROT_NONE，内存段不能被访问。</li>
</ul>
</li>
<li><p>flags参数控制内存段内容被修改后程序的行为。它可以被设置为 表6-1中的某些值（这里仅列出了常用的值）的按位或（其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226134942673-1678341964416.png" class="" title="image-20230226134942673">
</li>
<li><p>fd参数是被映射文件对应的文件描述符。它一般通过open系统调用获得。</p>
</li>
<li><p>offset参数设置从文件的何处开始映射（对于不需要读入整个文 件的情况）。</p>
</li>
</ul>
<p><strong>mmap函数成功时返回指向目标内存区域的指针</strong>，失败则返回 MAP_FAILED（(void*)-1）并设置errno。munmap函数成功时返回0， 失败则返回-1并设置errno。</p>
<h4 id="6-6-splice函数"><a href="#6-6-splice函数" class="headerlink" title="6.6 splice函数"></a>6.6 splice函数</h4><p>splice函数用于在两个文件描述符之间移动数据，也是零拷贝操 作。splice函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in,<span class="keyword">loff_t</span>* off_in,<span class="keyword">int</span> fd_out,<span class="keyword">loff_t</span>* off_out,<span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd_in参数是<strong>待输入数据</strong>的文件描述符。</p>
<p>如果fd_in是一个管道文件 描述符，那么off_in参数必须被设置为NULL。如果fd_in不是一个管道 文件描述符（比如socket），那么off_in表示从输入数据流的何处开始 读取数据。此时，若off_in被设置为NULL，则表示从输入数据流的当 前偏移位置读入；若off_in不为NULL，则它将指出具体的偏移位置。 </p>
<p>fd_out/off_out参数的含义与fd_in/off_in相同，不过用于输出数据流。len 参数指定移动数据的长度；flags参数则控制数据如何移动，它可以被 设置为表6-2中的某些值的按位或。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226135725302-1678341964416.png" class="" title="image-20230226135725302">

<p><strong>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。</strong></p>
<h4 id="6-7-tee函数"><a href="#6-7-tee函数" class="headerlink" title="6.7 tee函数"></a>6.7 tee函数</h4><p><strong>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。</strong> 它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操 作。tee函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="keyword">int</span> fd_in,<span class="keyword">int</span> fd_out,<span class="keyword">size_t</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数的参数的含义与splice相同（但fd_in和fd_out必须都是管道 文件描述符）。tee函数成功时返回在两个文件描述符之间复制的数据 数量（字节数）。返回0表示没有复制任何数据。tee失败时返回-1并设 置errno。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="6-8-fcntl函数"><a href="#6-8-fcntl函数" class="headerlink" title="6.8 fcntl函数"></a>6.8 fcntl函数</h4><p>fcntl函数，正如其名字（file control）描述的那样，提供了对文件 描述符的各种控制操作。另外一个常见的控制文件描述符属性和行为 的系统调用是ioctl，而且ioctl比fcntl能够执行更多的控制。但是，对于控制文件描述符常用的属性和行为，<strong>fcntl函数是由POSIX规范指定的首 选方法。所以本书仅讨论fcntl函数</strong>。fcntl函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,…)</span></span>;</span><br></pre></td></tr></table></figure>

<p>fd参数是被操作的文件描述符，cmd参数指定执行何种类型的操 作。根据操作类型的不同，该函数可能还需要第三个可选参数arg。 </p>
<p>fcntl函数支持的常用操作及其参数如表6-4所示。</p>
<p>![image-20230226141140857](二 高性能服务器框架/image-20230226141140857.png)</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226141206370-1678341964416.png" class="" title="image-20230226141206370">

<p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的，如代码清单6-6所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option=fcntl(fd,F_GETFL);<span class="comment">/*获取文件描述符旧的状态标志*/</span></span><br><span class="line">	<span class="keyword">int</span> new_option=old_option|O_NONBLOCK;<span class="comment">/*设置非阻塞标志*/</span></span><br><span class="line">	fcntl(fd,F_SETFL,new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;<span class="comment">/*返回文件描述符旧的状态标志，以便*/</span></span><br><span class="line">	<span class="comment">/*日后恢复该状态标志*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h3><p>除了网络通信外，服务器程序通常还必须考虑许多其他细节问 题。这些细节问题涉及面广且零碎，而且基本上是模板式的，所以我 们称之为服务器程序规范。比如：</p>
<ul>
<li>Linux服务器程序一般以后台进程形式运行。后台进程又称<strong>守护进程（daemon）</strong>。它没有控制终端，因而也不会意外接收到用户输 入。守护进程的父进程通常是init进程（PID为1的进程）。</li>
<li>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台 进程都在/var/log目录下拥有自己的日志目录。</li>
<li>Linux服务器程序一般以某个专门的非root身份运行。比如 mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、 apache和syslog。</li>
<li>Linux服务器程序通常是可配置的。服务器程序通常能处理很多 命令行选项，<strong>如果一次运行的选项太多，则可以用配置文件来管理。</strong> 绝大多数服务器程序都有配置文件，并存放在/etc目录下。比如第4章 讨论的squid服务器的配置文件是/etc/squid3/squid.conf。</li>
<li>Linux服务器进程通常会在启动的时候生成一个PID文件并存 入/var/run目录中，以记录该后台进程的PID。比如syslogd的PID文件 是/var/run/syslogd.pid。</li>
<li>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能 承受多大负荷，比如进程可用文件描述符总数和内存总量等。</li>
</ul>
<h4 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h4><h5 id="7-1-1-Linux系统日志"><a href="#7-1-1-Linux系统日志" class="headerlink" title="7.1.1 Linux系统日志"></a>7.1.1 Linux系统日志</h5><p>服务器的调试和维护都需要一个专业 的日志系统。Linux提供一个守护进程来处理系统日志——syslogd，不 过现在的Linux系统上使用的都是它的升级版——rsyslogd。</p>
<p>rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日 志。<strong>用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件/dev/log中， rsyslogd则监听该文件以获取用户进程的输出。</strong></p>
<p><strong>内核日志在老的系统上</strong>是通过另外一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等函数打印至内核的环状缓存 （ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。 rsyslogd则通过读取该文件获得内核日志。</p>
<p>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。<strong>默认情况下，调试信息会保存 至/var/log/debug文件，普通信息保存至/var/log/messages文件，内核消息则保存至/var/log/kern.log文件。</strong></p>
<p>rsyslogd的主配置文件 是/etc/rsyslog.conf，其中主要可以设置的项包括：</p>
<ul>
<li>内核日志输入路径</li>
<li>是否接收UDP日志及其监听端口（默认是514，见/etc/services文件）</li>
<li>是否接收TCP日志及其监听端口</li>
<li>日志文件的权限</li>
<li>包含哪些子配置文 件（比如/etc/rsyslog.d/*.conf）</li>
</ul>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092105214-1678341964416.png" class="" title="image-20230228092105214">



<h5 id="7-1-2-syslog-函数"><a href="#7-1-2-syslog-函数" class="headerlink" title="7.1.2 syslog 函数"></a>7.1.2 syslog 函数</h5><p><strong>应用程序使用syslog函数与rsyslogd守护进程通信。</strong> syslog函数的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span>*message,...)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数采用可变参数（第二个参数message和第三个参数…）来结 构化输出。</p>
<ul>
<li><p>priority参数是所谓的<strong>设施值与日志级别的按位或</strong>。设施值的默认值是LOG_USER，我们下面的讨论也只限于这一种设施值。日 志级别有如下几个：</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092428475-1678341964416.png" class="" title="image-20230228092428475">

</li>
</ul>
<p>下面这个函数可以改变syslog的默认输出方式，进一步结构化日志 内容：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ident,<span class="keyword">int</span> logopt,<span class="keyword">int</span> facility)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ident参数指定的字符串将被添加到日志消息的日期和时间之后， 它通常被设置为程序的名字</p>
</li>
<li><p>logopt参数对后续syslog调用的行为进行配置，它可取<strong>下列值的按位或</strong>：</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092709404-1678341964416.png" class="" title="image-20230228092709404">
</li>
<li><p>facility参数可用来修改syslog函数中的默认设施值。</p>
</li>
</ul>
<p>此外，日志的过滤也很重要。程序在开发阶段可能需要输出很多 调试信息，而发布之后我们又需要将这些调试信息关闭。简单地设置日志掩码，使<strong>日志级别大于日志掩码的日志信息被系统忽略。</strong>下面这个函数用于设置syslog的日志掩码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>maskpri参数指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值。</li>
</ul>
<p>最后，不要忘了使用如下函数关闭日志功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h4><h5 id="7-2-1-UID、EUID和EGID"><a href="#7-2-1-UID、EUID和EGID" class="headerlink" title="7.2.1 UID、EUID和EGID"></a>7.2.1 UID、EUID和EGID</h5><p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分 服务器就必须以root身份启动，但不能以root身份运行。</p>
<p>下面这一组函 数可以获取和设置当前进程的<strong>真实用户ID（UID）</strong>、<strong>有效用户 ID（EUID）</strong>、真实组ID（GID）和<strong>有效组ID（EGID）</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;<span class="comment">/*获取真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;<span class="comment">/*获取有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;<span class="comment">/*获取真实组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;<span class="comment">/*获取有效组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置真实组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置有效组ID*/</span></span><br></pre></td></tr></table></figure>



<p>需要指出的是，一个进程拥有两个用户ID：UID和EUID。<strong>EUID 存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。</strong> </p>
<blockquote>
<p>比如su程序，任何用户都可以使用它来修改自己的账 户信息，但修改账户时su程序不得不访问/etc/passwd文件，而访问该 文件是需要root权限的。那么以普通用户身份启动的su程序如何能访 问/etc/passwd文件呢？窍门就在EUID。用ls命令可以查看到，su程序的所有者是root，<strong>并且它被设置了set-user-id标志。</strong></p>
<p>这个标志表示，任 何普通用户运行su程序时，其有效用户就是该程序的所有者root。那 么，根据有效用户的含义，任何运行su程序的普通用户都能够访 问/etc/passwd文件。有效用户为root的进程称为特权进程（privileged processes）。</p>
</blockquote>
<p>EGID的含义与EUID类似：<strong>给运行目标程序的组用户提 供有效组的权限</strong>。</p>
<p>代码: 编译该文件，将生成的可执行文件（名为test_uid）的所有者设置 为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID 和EUID。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo chown root:root test_uid<span class="comment">#修改目标文件的所有者为root</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo chmod+s test_uid<span class="comment">#设置目标文件的set-user-id标志</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./test_uid<span class="comment">#运行程序</span></span></span><br><span class="line">userid is 1000,effective userid is:0</span><br></pre></td></tr></table></figure>

<p>从测试程序的输出来看，进程的UID是启动程序的用户的ID，而 EUID则是root账户（文件所有者）的ID。</p>
<h5 id="7-2-2-切换用户"><a href="#7-2-2-切换用户" class="headerlink" title="7.2.2 切换用户"></a>7.2.2 切换用户</h5><p>下面的代码清单7-2展示了如何将以root身份启动的进程切换为以 一个普通用户身份运行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">switch_to_user</span><span class="params">(<span class="keyword">uid_t</span> user_id, <span class="keyword">gid_t</span> gp_id)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*先确保目标用户不是root*/</span></span><br><span class="line">	<span class="keyword">if</span> ((user_id == <span class="number">0</span>) &amp;&amp; (gp_id == <span class="number">0</span>))</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*确保当前用户是合法用户：root或者目标用户*/</span></span><br><span class="line">	<span class="keyword">gid_t</span> gid = getgid();</span><br><span class="line">	<span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line">	<span class="keyword">if</span> (((gid != <span class="number">0</span>) || (uid != <span class="number">0</span>)) &amp;&amp; ((gid != gp_id) || (uid != user_id))) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*如果不是root，则已经是目标用户*/</span></span><br><span class="line">	<span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*切换到目标用户*/</span></span><br><span class="line">	<span class="keyword">if</span> ((setgid(gp_id) &lt; <span class="number">0</span>) || (setuid(user_id) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h4><h5 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h5><p>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息 外，还有进程组ID（PGID）。我们可以用如下函数来获取指定进程的 PGID：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>该函数成功时返回进程pid所属进程组的PGID，失败则返回-1并设 置errno。</li>
</ul>
<p><strong>每个进程组都有一个首领进程，其PGID和PID相同</strong>。进程组将一 直存在，直到其中所有进程都退出，或者加入到其他进程组。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数将PID为pid的进程的PGID设置为pgid。</p>
<ul>
<li>如果pid和pgid相 同，则由pid指定的进程将被设置为进程组首领；</li>
<li>如果pid为0，则表示 设置当前进程的PGID为pgid；</li>
<li>如果pgid为0，则使用pid作为目标 PGID。</li>
</ul>
<p>一个进程只能设置自己或者其子进程的PGID。并且，当子进程调 用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p>
<h5 id="7-3-2-会话（session）"><a href="#7-3-2-会话（session）" class="headerlink" title="7.3.2 会话（session）"></a>7.3.2 会话（session）</h5><p>一些有关联的进程组将形成一个会话（session）。下面的函数用于创建一个会话：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>



<p><strong>该函数不能由进程组的首领进程调用，否则将产生一个错误。</strong></p>
<p>对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：</p>
<ul>
<li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li>
<li>新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领。</li>
<li>调用进程将甩开终端（如果有的话）。</li>
</ul>
<p>Linux进程并未提供所谓会话ID（SID）的概念，但Linux系统认为 它等于会话首领所在的进程组的PGID，并提供了如下函数来读取 SID：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure>



<h5 id="7-3-3-用ps命令查看进程关系"><a href="#7-3-3-用ps命令查看进程关系" class="headerlink" title="7.3.3 用ps命令查看进程关系"></a>7.3.3 用ps命令查看进程关系</h5><p>执行ps命令可查看进程、进程组和会话之间的关系：</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228100733965-1678341964416.png" class="" title="image-20230228100733965">

<ul>
<li>我们是在bash shell下执行ps和less命令的，所以ps和less命令的父进程是bash命令，这可以从PPID（父进程PID）一列看出。</li>
<li>这3条命令创 建了1个会话（SID是1943）和2个进程组（PGID分别是1943和 2298）。</li>
<li>bash命令的PID、PGID和SID都相同，很明显它既是会话的首 领，也是组1943的首领。</li>
<li>ps命令则是组2298的首领，因为其PID也是 2298。</li>
</ul>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228100847532-1678341964416.png" class="" title="image-20230228100847532">

<h4 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h4><p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制 （CPU数量、内存数量等）、系统策略限制（CPU时间等），以及具 体实现的限制（比如文件名的最大长度）。</p>
<p>Linux系统资源限制可以通 过如下一对函数来读取和设置：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/resource.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource,struct rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource,<span class="keyword">const</span> struct rlimit* rlim)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>resource参数指定资源限制类型。</p>
<p>![image-20230228101329120](二 高性能服务器框架/image-20230228101329120.png)</p>
</li>
<li><p>setrlimit和getrlimit成功时返回0，失败则返回-1并设置errno。</p>
</li>
</ul>
<p>rlim参数是rlimit结构体类型的指针，rlimit结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line">	<span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>rlim_t是一个整数类型，它描述资源级别。</p>
</li>
<li><p>rlim_cur成员指定资源 的软限制，rlim_max成员指定资源的硬限制。</p>
<blockquote>
<p>软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。例如，当进程CPU时间超过其软限制时，系统将向进 程发送SIGXCPU信号；当文件尺寸超过其软限制时，系统将向进程发 送SIGXFSZ信号（见第10章）。</p>
<p>硬限制一般是软限制的上限。普通程 序可以减小硬限制，而只有以root身份运行的程序才能增加硬限制。</p>
</blockquote>
</li>
<li><p>我们可以使用ulimit命令修改当前shell环境下的资源限制（软限制 或/和硬限制），这种修改将对该shell启动的所有后续程序有效。</p>
</li>
</ul>
<h4 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h4><p>有些服务器程序还需要改变工作目录和根目录，<strong>获取进程当前工作目录和改变进程工作目录的函数分别是：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>buf参数指向的内存用于存储进程当前工作目录的绝对路径名，其 大小由size参数指定。</li>
<li>如果当前工作目录的绝对路径的长度（再加上 一个空结束字符“\0”）超过了size，则getcwd将返回NULL，并设置 errno为ERANGE。</li>
<li>如果buf为NULL并且size非0，则getcwd可能在内部 使用malloc动态分配内存，并将进程的当前工作目录存储在其中。如 果是这种情况，则我们必须自己来释放getcwd在内部创建的这块内 存。</li>
<li>getcwd函数成功时返回一个指向目标存储区（buf指向的缓存区或 是getcwd在内部动态创建的缓存区）的指针，失败则返回NULL并设 置errno。</li>
</ul>
<p><strong>改变进程根目录</strong>的函数是chroot，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>只有特权进程才能改变根目录。</li>
<li>path参数指定要切换到的目标根目录。它成功时返回0，失败时返 回-1并设置errno。</li>
<li><strong>chroot并不改变进程的当前工作目录，所以调用 chroot之后，我们仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。</strong></li>
<li>在调用chroot之后，进程原先打开的文件描述符依然生效，所以我们 可以利用这些早先打开的文件描述符来访问调用chroot之后不能直接 访问的文件（和目录），尤其是一些日志文件。</li>
</ul>
<h4 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h4><p>最后，我们讨论如何在代码中让一个进程以守护进程的方式运 行。守护进程的编写遵循一定的步骤[2]，下面我们通过一个具体实现 来探讨，如代码清单7-3所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">daemonize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*创建子进程，关闭父进程，这样可以使程序在后台运行*/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，</span></span><br><span class="line"><span class="comment">	 * 文件的权限将是mode &amp;0777*/</span></span><br><span class="line">	umask(<span class="number">0</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*创建新的会话，设置本进程为进程组的首领*/</span></span><br><span class="line">	<span class="keyword">pid_t</span> sid = setsid();</span><br><span class="line">	<span class="keyword">if</span> (sid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*切换工作目录*/</span></span><br><span class="line">	<span class="keyword">if</span> ((chdir(<span class="string">&quot;/&quot;</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span></span><br><span class="line">	close(STDIN_FILENO);</span><br><span class="line">	close(STDOUT_FILENO);</span><br><span class="line">	close(STDERR_FILENO);</span><br><span class="line">	<span class="comment">/*关闭其他已经打开的文件描述符，代码省略*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/</span></span><br><span class="line">	open(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY);</span><br><span class="line">	open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">	open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>实际上，Linux提供了完成同样功能的库函数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir,<span class="keyword">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>其中，nochdir参数用于指定是否改变工作目录，如果给它传递 0，则工作目录将被设置为“/”（根目录），否则继续使用当前工作目 录。</li>
<li>noclose参数为0时，标准输入、标准输出和标准错误输出都被重 定向到/dev/null文件，否则依然使用原来的设备。</li>
<li>该函数成功时返回 0，失败则返回-1并设置errno。</li>
</ul>
<h3 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h3><p>在这一章中，我们 按照服务器程序的一般原理，将服务器解构为如下三个主要模块：</p>
<ul>
<li>I/O处理单元。本章将介绍I/O处理单元的四种I/O模型和两种高效事件处理模式。</li>
<li>逻辑单元。本章将介绍逻辑单元的两种高效并发模式，以及高效的逻辑处理方式——有限状态机。</li>
<li>存储单元。本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关。</li>
</ul>
<h4 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h4><h5 id="8-1-1-C-S-模型"><a href="#8-1-1-C-S-模型" class="headerlink" title="8.1.1 C/S 模型"></a>8.1.1 C/S 模型</h5><p>所有客户端都通过访问 服务器来获取所需的资源。</p>
<p><img src="高性能服务器框架/image-20230321094137455.png" alt="image-20230321094137455" style="zoom: 67%;" /><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230321094201254.png" class="" title="image-20230321094201254"></p>
<p>C/S模型的逻辑很简单。服务器启动后，首先创建一个（或多个） 监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后 调用listen函数等待客户连接。</p>
<p>服务器稳定运行之后，<strong>客户端就可以调 用connect函数向服务器发起连接了</strong>。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。</p>
<img src="高性能服务器框架/image-20230321094231509.png" alt="image-20230321094231509" style="zoom:67%;" />

<p>I/O模型有多种，图8-2中，<strong>服务器使用的是I/O复用技术之一的select系统调用。</strong>当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。<strong>逻辑单元可以是新创建的子进程、子线程或者 其他。</strong> 图8-2中，服务器给客户端分配的逻辑单元是由fork系统调用创 建的子进程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端接收到服务器反馈的结果之后，可以继续向服 务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连 接，则服务器执行被动关闭连接。至此，双方的通信结束。</p>
<h5 id="8-1-2-P2P模型"><a href="#8-1-2-P2P模型" class="headerlink" title="8.1.2 P2P模型"></a>8.1.2 P2P模型</h5><p>P2P（Peer to Peer，点对点）模型比C/S模型更符合网络通信的实 际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回 归对等的地位。P2P模型如图8-3a所示。</p>
<p>但P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络 的负载将加重。</p>
<p>图8-3a所示的P2P模型存在一个显著的问题，即主机之间很难互相 发现。所以实际使用的P2P模型通常带有一个专门的发现服务器，如图 8-3b所示。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228201859415-1678341964416.png" class="" title="image-20230228201859415">



<h4 id="8-2-服务器编程框架"><a href="#8-2-服务器编程框架" class="headerlink" title="8.2 服务器编程框架"></a>8.2 服务器编程框架</h4><p>为了让读者能从设计的角度把握服务器编程，本章先讨论 基本框架，如图8-4所示。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228201956583-1678341964416.png" class="" title="image-20230228201956583">

<p>该图既能用来描述一台服务器，也能用来描述一个服务器机群。 各个部件的含义和功能如下表所示:</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228202116872-1678341964417.png" class="" title="image-20230228202116872">

<ul>
<li>I/O处理单元是服务器管理客户连接的模块。它通常要完成以下工 作：<strong>等待并接受新的客户连接，接收客户数据，将服务器响应数据返 回给客户端。</strong>但是，数据的收发不一定在I/O处理单元中执行，也可能 在逻辑单元中执行，具体在何处执行取决于事件处理模式（见后 文）。</li>
<li>一个逻辑单元通常是一个进程或线程。它分析并处理客户数据， 然后将结果传递给I/O处理单元或者直接发送给客户端（具体使用哪种 方式取决于事件处理模式）。</li>
<li>网络存储单元可以是数据库、缓存和文件，甚至是一台独立的服 务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单 元。</li>
<li>请求队列是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样， 多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调 处理竞态条件。<strong>请求队列通常被实现为池的一部分，我们将在后面讨 论池的概念</strong>。</li>
</ul>
<h4 id="8-3-I-O模型"><a href="#8-3-I-O模型" class="headerlink" title="8.3 I/O模型"></a>8.3 I/O模型</h4><p>第5章讲到，socket在创建的时候默认是阻塞的。我们可以给socket 系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的。</p>
<p>阻塞和非阻塞的概念能应用于所有文件描述符，而不仅仅是socket。<strong>我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。</strong></p>
<blockquote>
<p><strong>针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。</strong>比如，客户端通过connect向服务器 发起连接时，connect将首先发送同步报文段给服务器，然后等待服务 器返回确认报文段。如果服务器的确认报文段没有立即到达客户端， 则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调 用。socket的基础API中，可能被阻塞的系统调用包括accept、send、 recv和connect。</p>
<p><strong>针对非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。</strong>此时我们必须根据errno来区分这两种情况。对accept、send 和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一 次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言， errno则被设置成EINPROGRESS（意为“在处理中”）。</p>
</blockquote>
<p>很显然，<strong>我们只有在事件已经发生的情况下操作非阻塞I/O（读、 写等），才能提高程序的效率。</strong>因此，<strong>非阻塞I/O通常要和其他I/O通知机制一起使用</strong>，比如I/O复用和SIGIO信号。</p>
<p><strong>I/O复用是最常使用的I/O通知机制。它指的是，应用程序通过I/O 复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。</strong> Linux上常用的I/O复用函数是select、poll和 epoll_wait，我们将在第9章详细讨论它们。  需要指出的是，<strong>I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。</strong></p>
<p><strong>SIGIO信号也可以用来报告I/O事件。6.8节的最后一段提到，我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。</strong> 这样，当目标文件描述符上有事件发生时，SIGIO 信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了。关于信号的使用，我们将在第 10章讨论。</p>
<p>从理论上说，<strong>阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型。</strong> 因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后， 由应用程序来完成的。</p>
<p>而POSIX规范所定义的异步I/O模型则不同。<strong>对异步I/O而言，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已经由内核接管。</strong></p>
<blockquote>
<p>也就是说，<strong>同步I/O模型要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据 从用户缓冲区写入内核缓冲区），而异步I/O机制则由内核来执行I/O操 作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完 成的）。</strong>你可以这样认为，<strong>同步I/O向应用程序通知的是I/O就绪事件， 而异步I/O向应用程序通知的是I/O完成事件。</strong></p>
</blockquote>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228203724545-1678341964417.png" class="" title="image-20230228203724545">

<h4 id="8-4-两种高效的事件处理模式"><a href="#8-4-两种高效的事件处理模式" class="headerlink" title="8.4 两种高效的事件处理模式"></a>8.4 两种高效的事件处理模式</h4><p>这一节先从整体上介绍一下两种高效的事件处理模式：Reactor和Proactor。同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现 Proactor模式。</p>
<h5 id="8-4-1-Reactor模式"><a href="#8-4-1-Reactor模式" class="headerlink" title="8.4.1 Reactor模式"></a>8.4.1 Reactor模式</h5><p>Reactor是这样一种模式，它要求<strong>主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程</strong>（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。<strong>读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</strong></p>
<p>工作流程如下:</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将 socket可读事件放入请求队列。 </li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，<strong>然后往epoll内核事件表中注册该socket上的写就绪事件。</strong></li>
<li>主线程调用epoll_wait等待socket可写。 </li>
<li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 </li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入 服务器处理客户请求的结果。</li>
</ol>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228204723763-1678341964417.png" class="" title="image-20230228204723763">



<h5 id="8-4-2-Proactor模式"><a href="#8-4-2-Proactor模式" class="headerlink" title="8.4.2 Proactor模式"></a>8.4.2 Proactor模式</h5><p>与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p>
<p>使用异步I/O模型（以aio_read和aio_write为例）实现的Proactor模 式的工作流程是：</p>
<ol>
<li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序 （这里以信号为例，详情请参考sigevent的man手册）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操 作完成时如何通知应用程序（仍然以信号为例）。</li>
<li>主线程继续处理其他逻辑。</li>
<li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li>
<li>应用程序预先定义好的信号处理函数选择一个工作线程来做善 后处理，比如决定是否关闭socket。</li>
</ol>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228205315653-1678341964417.png" class="" title="image-20230228205315653">

<p>在图8-6中，连接socket上的读写事件是通过aio_read/aio_write向内 核注册的，<strong>因此内核将通过信号来向应用程序报告连接socket上的读写 事件。</strong> 所以，主线程中的epoll_wait调用仅能用来检测监听socket上的连 接请求事件，而不能用来检测连接socket上的读写事件。</p>
<h5 id="8-4-3-模拟Proactor模式"><a href="#8-4-3-模拟Proactor模式" class="headerlink" title="8.4.3 模拟Proactor模式"></a>8.4.3 模拟Proactor模式</h5><p>使用同步I/O方式模拟出Proactor模式的一种方 法。其原理是：<strong>主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</strong></p>
<p>使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式 的工作流程如下：</p>
<ol>
<li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li>
<li>主线程调用epoll_wait等待socket上有数据可读。</li>
<li>当socket上有数据可读时，epoll_wait通知主线程。主线程从 socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封 装成一个请求对象并插入请求队列。</li>
<li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并 处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</li>
<li>主线程调用epoll_wait等待socket可写。</li>
<li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入 服务器处理客户请求的结果。</li>
</ol>
<img src="高性能服务器框架/image-20230228210636117.png" alt="image-20230228210636117" style="zoom:67%;" />



<h4 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h4><p>并发编程的目的是让程序“同时”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。 但如果程序是I/O密集型的，比如经常读写文件，访问数据库等，则情况就不同了。由于I/O操作的速度远没有CPU的计算速度快，所以让程 序阻塞于I/O操作将浪费大量的CPU时间。如果程序有多个执行线程， 则当前被I/O操作所阻塞的执行线程可主动放弃CPU（或由操作系统来 调度），并将执行权转移到其他线程。</p>
<p>从实现上来说，并发编程主要有多进程和多线程两种方式，我们 将在后续章节详细讨论它们，这一节先讨论并发模式。 <strong>并发模式是指I/O处理单元和多个逻辑单元之间协调完成任务的方法。 服务器主要有两种并发编程模式：半同步/半异步（half-sync/half-async）模式和领导者/追随者（Leader/Followers）模式。</strong></p>
<h5 id="8-5-1-半同步-半异步模式"><a href="#8-5-1-半同步-半异步模式" class="headerlink" title="8.5.1 半同步/半异步模式"></a>8.5.1 半同步/半异步模式</h5><p>首先，半同步/半异步模式中的“同步”和“异步”与前面讨论的I/O模 型中的“同步”和“异步”是完全不同的概念。</p>
<blockquote>
<p>在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。</p>
</blockquote>
<p>在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“<strong>异步”指 的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、 信号等。</strong>比如，图8-8a描述了同步的读操作，而图8-8b则描述了异步的 读操作。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228211515292-1678341964417.png" class="" title="image-20230228211515292">

<p>对于像服务器 这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程 序，我们就应该同时使用同步线程和异步线程来实现，即采用半同步/ 半异步模式来实现。</p>
<p><strong>半同步/半异步模式中，同步线程用于处理客户逻辑，相当于图8-4 中的逻辑单元；异步线程用于处理I/O事件，相当于图8-4中的I/O处理单元。</strong> 异步线程监听到客户请求后，就将其封装成请求对象并插入请 求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并 处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则 取决于请求队列的设计。</p>
<p>在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模 型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆（half-sync/half-reactive）模式，如图8-10所示。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228212216219-1678341964417.png" class="" title="image-20230228212216219">

<p>异步线程只有一个，由主线程来充当。它负责监听所有 socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生， 即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接 socket插入请求队列中。</p>
<p>所有工作线程都睡眠在请求队列上，当有任务 到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这 种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。</p>
<blockquote>
<p>主线程插入请求队列中的任务是就绪的连接socket。这 说明该图所示的半同步/半反应堆模式采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中“half-reactive”的含义。</p>
</blockquote>
<p>存在的缺点:</p>
<ul>
<li>主线程和工作线程共享请求队列。主线程往请求队列中添加任 务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保 护，从而白白耗费CPU时间。</li>
<li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题， 则工作线程的切换也将耗费大量CPU时间。</li>
</ul>
<p>下图描述了一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228212643003-1678341964417.png" class="" title="image-20230228212643003">

<p>图8-11中，主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。</p>
<p>主线程向工作线程派发socket的最 简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测 到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。 如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表 中。</p>
<p>可见，图8-11中，每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同 步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义 上的半同步/半异步模式。</p>
<h5 id="8-5-2-领导者-追随者模式"><a href="#8-5-2-领导者-追随者模式" class="headerlink" title="8.5.2 领导者/追随者模式"></a>8.5.2 领导者/追随者模式</h5><h4 id="8-6-有限状态机"><a href="#8-6-有限状态机" class="headerlink" title="8.6 有限状态机"></a>8.6 有限状态机</h4><p>前面两节探讨的是服务器的I/O处理单元、请求队列和逻辑单元之 间协调完成任务的各种模式，这一节我们介绍逻辑单元内部的一种高 效编程方法：有限状态机（finite state machine）。</p>
<p>有的应用层协议头部包含数据包类型字段，每种类型可以映射为 逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻 辑，如代码清单8-1所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE(Package_pack)</span><br><span class="line">&#123;</span><br><span class="line">	PackageType _type=_pack.GetType();</span><br><span class="line">	<span class="keyword">switch</span>(_type)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">case</span> type_A:</span><br><span class="line">			process_package_A(_pack);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> type_B:</span><br><span class="line">			process_package_B(_pack);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这就是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。</p>
<p>状态之间的转移是需要状态 机内部驱动的，如代码清单8-2所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE()</span><br><span class="line">&#123;</span><br><span class="line">	State cur_State=type_A;</span><br><span class="line">	<span class="keyword">while</span>(cur_State!=type_C)</span><br><span class="line">	&#123;</span><br><span class="line">		Package _pack=getNewPackage();</span><br><span class="line">		<span class="keyword">switch</span>(cur_State)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">case</span> type_A:</span><br><span class="line">				process_package_state_A(_pack);</span><br><span class="line">				cur_State=type_B;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> type_B:</span><br><span class="line">				process_package_state_B(_pack);</span><br><span class="line">				cur_State=type_C;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>该状态机包含三种状态：type_A、type_B和type_C，其中type_A是 状态机的开始状态，type_C是状态机的结束状态。状态机的当前状态 记录在cur_State变量中。在一趟循环过程中，状态机先通过 getNewPackage方法获得一个新的数据包，然后根据cur_State变量的值 判断如何处理该数据包。数据包处理完之后，状态机通过给cur_State变 量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环 时，它将执行新的状态对应的逻辑。</p>
</blockquote>
<h5 id="8-6-1-有限状态机实例"><a href="#8-6-1-有限状态机实例" class="headerlink" title="8.6.1 有限状态机实例"></a>8.6.1 有限状态机实例</h5><p>HTTP请求的读取和分 析。很多网络协议，包括TCP协议和IP协议，都在其头部中提供头部长度字段。程序根据该字段的值就可以知道是否接收到一个完整的协议头部。</p>
<p>但HTTP协议并未提供这样的头部长度字段，并且其头部长度变 化也很大，可以只有十几字节，也可以有上百字节。根据协议规定， <strong>我们判断HTTP头部结束的依据是遇到一个空行，该空行仅包含一对回 车换行符（＜CR＞＜LF＞）。</strong>如果一次读操作没有读入HTTP请求的 整个头部，即没有遇到空行，那么我们必须等待客户继续写数据并再 次读入。因此，我们每完成一次读操作，就要分析新读入的数据中是 否有空行。不过在寻找空行的过程中，我们可以同时完成对整个HTTP 请求头部的分析（记住，空行前面还有请求行和头部域），以提高解 析HTTP请求的效率。</p>
<p>代码清单8-3使用主、从两个有限状态机实现了最 简单的HTTP请求的读取和分析。为了使表述简洁，我们约定，直接称 HTTP请求的一行（包括请求行和头部字段）为行。</p>
<p><strong>我们将代码清单8-3中的两个有限状态机分别称为主状态机和从状 态机，这体现了它们之间的关系：主状态机在内部调用从状态机。下 面先分析从状态机，即parse_line函数，它从buffer中解析出一个行。图 8-15描述了其可能的状态及状态转移过程。</strong></p>
<img src="高性能服务器框架/image-20230309185019935.png" alt="image-20230309185019935" style="zoom: 33%;" />



<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="8-7-提高服务器的其他建议"><a href="#8-7-提高服务器的其他建议" class="headerlink" title="8.7 提高服务器的其他建议"></a>8.7 提高服务器的其他建议</h4><p>前面我们介绍了几种高效的事件处理模式和并发模式，以及高效 的逻辑处理方式——有限状态机，它们都有助于提高服务器的整体性 能。</p>
<h5 id="8-7-1-池"><a href="#8-7-1-池" class="headerlink" title="8.7.1 池"></a>8.7.1 池</h5><p>既然服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其 运行效率。这就是池（pool）的概念。</p>
<p>池是一组资源的集合，这组资 源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。 <strong>当服务器进入正式运行阶段，即开始处理客户请求的时候，如果 它需要相关的资源，就可以直接从池中获取，无须动态分配。 ** **当服务器处理完一个客户连 接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。</strong></p>
<p>根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。它们的含义都很明确。</p>
<ul>
<li>内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字 节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的 大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。</li>
<li>进程池和线程池都是并发编程常用的“伎俩”。当我们需要一个工 作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程 池或线程池中取得一个执行实体，而无须动态地调用fork或 pthread_create等函数来创建进程和线程。</li>
<li>连接池通常用于服务器或服务器机群的内部永久连接。图8-4中， 每个逻辑单元可能都需要频繁地访问本地的某个数据库。连接池是服务器预先和数据库程序建立的一组 连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接 池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑 单元再将该连接返还给连接池。</li>
</ul>
<h5 id="8-7-2-数据复制"><a href="#8-7-2-数据复制" class="headerlink" title="8.7.2 数据复制"></a>8.7.2 数据复制</h5><p>高性能服务器应该<strong>避免不必要的数据复制</strong>，尤其是当数据复制发 生在用户代码和内核之间的时候。如果内核可以直接处理从socket或 者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复 制到应用程序缓冲区中。这里说的“直接处理”指的是应用程序不关心 这些数据的内容，不需要对它们做任何分析。</p>
<blockquote>
<p>比如ftp服务器，当客户 请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是 否有读取它的权限，而绝对不会关心文件的具体内容。这样的话，ftp 服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调 用send函数来发送，而是可以使用“零拷贝”函数sendfile来直接将其发 送给客户端。</p>
</blockquote>
<p>此外，用户代码内部（不访问内核）的数据复制也是应该避免 的。当两个工作进程之间要传递大量的数据时，我们就应 该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管 道或者消息队列来传递。</p>
<h5 id="8-7-3-上下文切换和锁"><a href="#8-7-3-上下文切换和锁" class="headerlink" title="8.7.3 上下文切换和锁"></a>8.7.3 上下文切换和锁</h5><p>并发程序必须考虑上下文切换（context switch）的问题，即进程 切换或线程切换导致的的系统开销。</p>
<p>即使是I/O密集型的服务器，也不 应该使用过多的工作线程（或工作进程，下同），否则线程间的切换 将占用大量的CPU时间，服务器真正用于处理业务逻辑的CPU时间的 比重就显得不足了。</p>
<p>因此，为每个客户连接都创建一个工作线程的服 务器模型是不可取的。图8-11所描述的半同步/半异步模式是一种比较 合理的解决方案，它允许一个线程同时处理多个客户连接</p>
<p>并发程序需要考虑的另外一个问题是<strong>共享资源的加锁保护</strong>。锁通 常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不 仅不处理任何业务逻辑，而且需要访问内核资源。</p>
<p>如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写锁。</p>
<h3 id="第9章-I-O复用"><a href="#第9章-I-O复用" class="headerlink" title="第9章 I/O复用"></a>第9章 I/O复用</h3><p><strong>I/O复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。</strong>通常，网络程序在下列情况下需要使用I/O复用技术：</p>
<ul>
<li>客户端程序要同时处理多个socket。比如本章将要讨论的非阻塞 connect技术。</li>
<li>客户端程序要同时处理用户输入和网络连接。比如本章将要讨论的聊天室程序。</li>
<li>TCP服务器要同时处理监听socket和连接socket。这是I/O复用使 用最多的场合。</li>
<li>服务器要同时处理TCP请求和UDP请求。比如本章将要讨论的 回射服务器。</li>
<li>服务器要同时监听多个端口，或者处理多种服务。比如本章将 要讨论的xinetd服务器。</li>
</ul>
<h4 id="9-1-select系统调用"><a href="#9-1-select系统调用" class="headerlink" title="9.1 select系统调用"></a>9.1 select系统调用</h4><p><strong>select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</strong></p>
<h5 id="9-1-1-select-API"><a href="#9-1-1-select-API" class="headerlink" title="9.1.1 select API"></a>9.1.1 select API</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>nfds参数指定被监听的文件描述符的总数。它通常被设置为 select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开 始计数的。</p>
</li>
<li><p><strong>readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。</strong>应用程序调用select函数时，通过这3 个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。</p>
</li>
<li><p>fd_set结构体仅包含一个整型数组，该数组的每 个元素的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述 符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述 符的总量。由于位操作过于烦琐，我们应该使用下面的一系列宏来访问fd_set 结构体中的位：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞</span></span><br><span class="line">FD_ZERO(fd_set* fdset);<span class="comment">/*清除fdset的所有位*/</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set* fdset);<span class="comment">/*设置fdset的位fd*/</span></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set* fdset);<span class="comment">/*清除fdset的位fd*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;<span class="comment">/*测试fdset的位fd是否被设置*/</span></span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p>timeout参数用来设置select函数的超时时间。它是一个timeval 结构类型的指针，采用指针参数是因为内核将修改它以告诉应用程序 select等待了多久。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">long</span> tv_sec;<span class="comment">/*秒数*/</span></span><br><span class="line">	<span class="keyword">long</span> tv_usec;<span class="comment">/*微秒数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>select成功时返回就绪（可读、可写和异常）文件描述符的总数。 如果在超时时间内没有任何文件描述符就绪，select将返回0。select失 败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则 select立即返回-1，并设置errno为EINTR。</p>
<h5 id="9-1-2-文件描述符就绪条件"><a href="#9-1-2-文件描述符就绪条件" class="headerlink" title="9.1.2 文件描述符就绪条件"></a>9.1.2 文件描述符就绪条件</h5><p>哪些情况下文件描述符可以被认为是可读、可写或者出现异常， 对于select的使用非常关键。</p>
<p>在网络编程中，下列情况下socket可读：</p>
<ul>
<li>socket内核接收缓存区中的字节数大于或等于其低水位标记 SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返 回的字节数大于0。</li>
<li>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</li>
<li>监听socket上有新的连接请求。</li>
<li>socket上有未处理的错误。此时我们可以使用getsockopt来读取 和清除该错误。</li>
</ul>
<p>下列情况下socket可写：</p>
<ul>
<li>socket内核发送缓存区中的可用字节数大于或等于其低水位标记 SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返 回的字节数大于0。</li>
<li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将 触发一个SIGPIPE信号。</li>
<li>socket使用非阻塞connect连接成功或者失败（超时）之后。</li>
<li>socket上有未处理的错误。此时我们可以使用getsockopt来读取 和清除该错误。</li>
</ul>
<p>网络程序中，select能处理的异常情况只有一种：socket上接收到 带外数据。下面我们详细讨论之。</p>
<h5 id="9-1-3-处理带外数据"><a href="#9-1-3-处理带外数据" class="headerlink" title="9.1.3 处理带外数据"></a>9.1.3 处理带外数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// select是如何同时接收普通数据和带外数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		address.sin_family = AF_INET;</span><br><span class="line">		inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">		address.sin_port = htons(port);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">	<span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">	<span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">		close(listenfd);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	fd_set read_fds;</span><br><span class="line">	fd_set exception_fds;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 清除fdset的所有位</span></span><br><span class="line">	FD_ZERO(&amp;read_fds);</span><br><span class="line">	FD_ZERO(&amp;exception_fds);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">		<span class="comment">/*每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，</span></span><br><span class="line"><span class="comment">		 * 因为事件发生之后，文件描述符集合将被内核修改</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		FD_SET(connfd, &amp;read_fds);</span><br><span class="line">		FD_SET(connfd, &amp;exception_fds);</span><br><span class="line">		ret = select(connfd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, &amp;exception_fds, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;selection failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*对于可读事件，采用普通的recv函数读取数据*/</span></span><br><span class="line">		<span class="keyword">if</span> (FD_ISSET(connfd, &amp;read_fds)) &#123;</span><br><span class="line">			ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of normal data:%s\n&quot;</span>, ret, buf);</span><br><span class="line">			<span class="comment">/*对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据*/</span></span><br><span class="line">		&#125;<span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(connfd, &amp;exception_fds)) &#123;</span><br><span class="line">			ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, MSG_OOB);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of oob data:%s\n&quot;</span>, ret, buf);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	close(connfd);</span><br><span class="line">	close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-2-poll系统调用"><a href="#9-2-poll系统调用" class="headerlink" title="9.2 poll系统调用"></a>9.2 poll系统调用</h4><p>poll系统调用和select类似，也是在指定时间内轮询一定数量的文件 描述符，以测试其中是否有就绪者。poll的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜poll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>fds参数是一个pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。pollfd结构体的定义 如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> fd;<span class="comment">/*文件描述符*/</span></span><br><span class="line">	<span class="keyword">short</span> events;<span class="comment">/*注册的事件*/</span></span><br><span class="line">	<span class="keyword">short</span> revents;<span class="comment">/*实际发生的事件，由内核填充*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，fd成员指定文件描述符；</span></span><br><span class="line"><span class="comment">// events成员告诉poll监听fd上的哪些事件，它是一系列事件的按位或；</span></span><br><span class="line"><span class="comment">// revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件。</span></span><br></pre></td></tr></table></figure>

<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230301214431734-1678341964417.png" class="" title="image-20230301214431734">
</li>
<li><p>nfds参数指定被监听事件集合fds的大小。其类型nfds_t的定义 如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">nfds_t</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>timeout参数指定poll的超时值，单位是毫秒。当timeout为-1 时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。</p>
</li>
</ul>
<p>poll系统调用的返回值的含义与select相同。</p>
<h4 id="9-3-epoll系列系统调用"><a href="#9-3-epoll系列系统调用" class="headerlink" title="9.3 epoll系列系统调用"></a>9.3 epoll系列系统调用</h4><h5 id="9-3-1-内核事件表"><a href="#9-3-1-内核事件表" class="headerlink" title="9.3.1 内核事件表"></a>9.3.1 内核事件表</h5><p>epoll是Linux特有的I/O复用函数。它在实现和使用上与select、 poll有很大差异。</p>
<p>首先，epoll使用一组函数来完成任务，而不是单个 函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一 个事件表中，从而无须像select和poll那样每次调用都要重复传入文件 描述符集或事件集。<strong>但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。</strong></p>
<p>这个文件描述符使用如下epoll_create函数 来创建：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>size参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。</li>
<li><strong>该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。</strong></li>
</ul>
<p>下面的函数用来操作epoll的内核事件表：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>fd参数是要操作的文件描述符，</p>
</li>
<li><p>op参数则指定操作类型。</p>
<ul>
<li>EPOLL_CTL_ADD，往事件表中注册fd上的事件。</li>
<li>EPOLL_CTL_MOD，修改fd上的注册事件。</li>
<li>EPOLL_CTL_DEL，删除fd上的注册事件。</li>
</ul>
</li>
<li><p>event参数指定事件，它是epoll_event结构指针类型。epoll_event的 定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">__uint32_t</span> events;<span class="comment">/*epoll事件*/</span></span><br><span class="line">	<span class="keyword">epoll_data_t</span> data;<span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">void</span>*ptr;</span><br><span class="line">	<span class="keyword">int</span> fd;</span><br><span class="line">	<span class="keyword">uint32_t</span> u32;</span><br><span class="line">	<span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>

<p>epoll_data_t是一个联合体，其4个成员中使用最多的是fd，它指定 事件所从属的目标文件描述符。ptr成员可用来指定与fd相关的用户数 据。</p>
</li>
<li><p>其中events成员描述事件类型。epoll支持的事件类型和poll基本相 同。表示epoll事件类型的宏是在poll对应的宏前加上“E”，比如epoll的 数据可读事件是EPOLLIN。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230301214431734-1678341964417.png" class="" title="image-20230301214431734">
</li>
<li><p>但epoll有两个额外的事件类型—— EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键， 我们将在后面讨论它们。</p>
</li>
</ul>
<p>epoll_ctl成功时返回0，失败则返回-1并设置errno。</p>
<h5 id="9-3-2-epoll-wait函数"><a href="#9-3-2-epoll-wait函数" class="headerlink" title="9.3.2 epoll_wait函数"></a>9.3.2 epoll_wait函数</h5><p>epoll系列系统调用的主要接口是epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数成功时返回就绪的文件描述符的个数，失败时返回-1并设 置errno。</p>
<ul>
<li>timeout参数的含义与 poll接口的timeout参数相同。</li>
<li>maxevents参数指定最多监听多少个事 件，它必须大于0。</li>
<li>epoll_wait函数如果检测到事件，就 <strong>将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。</strong> <strong>这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和poll 的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到 的就绪事件</strong>。这就极大地提高了应用程序索引就绪文件描述符的效率。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  如何索引poll返回的就绪文件描述符</span></span><br><span class="line">	<span class="comment">// 当timeout为-1 时，poll调用将永远阻塞，直到某个事件发生</span></span><br><span class="line">	<span class="keyword">int</span> ret = poll(fds, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line">		<span class="keyword">if</span> (fds[i].revents &amp; POLLIN)<span class="comment">/*判断第i个文件描述符是否就绪*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = fds[i].fd;</span><br><span class="line">			<span class="comment">/*处理sockfd*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line"><span class="comment">//  如何索引epoll返回的就绪文件描述符</span></span><br><span class="line">	<span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">/*仅遍历就绪的ret个文件描述符*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">		<span class="comment">/*sockfd肯定就绪，直接处理*/</span></span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>



<h5 id="9-3-3-LT和ET模式"><a href="#9-3-3-LT和ET模式" class="headerlink" title="9.3.3 LT和ET模式"></a>9.3.3 LT和ET模式</h5><p>epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平 触发）模式和ET（Edge Trigger，边沿触发）模式。</p>
<p><strong>LT模式是默认的 工作模式，这种模式下epoll相当于一个效率较高的poll。</strong> 对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事 件。这样，<strong>当应用程序下一次调用epoll_wait时，epoll_wait还会再次向 应用程序通告此事件，直到该事件被处理。</strong></p>
<p><strong>当往epoll内 核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET 模式来操作该文件描述符。ET模式是epoll的高效工作模式。</strong>而对于采用ET工作模式的 文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，<strong>应用程序必须立即处理该事件，因为后续的epoll_wait调用将 不再向应用程序通知这一事件。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件描述符设置成非阻塞的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);  <span class="comment">// 获取状态标志</span></span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，</span></span><br><span class="line"><span class="comment"> * 参数enable_et指定是否对fd启用ET模式</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et)</span> </span>&#123;</span><br><span class="line">	epoll_event event&#123;&#125;;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN;</span><br><span class="line">	<span class="keyword">if</span> (enable_et) &#123;</span><br><span class="line">		event.events |= EPOLLET;</span><br><span class="line">		<span class="comment">// 等价于 event.events = event.events | EPOLLET</span></span><br><span class="line">	&#125;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">	setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*LT模式的工作流程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">		<span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">			<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">			<span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address,</span><br><span class="line">					&amp;client_addrlength);</span><br><span class="line">			addfd(epollfd, connfd, <span class="literal">false</span>); <span class="comment">/*对connfd禁用ET模式*/</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123; <span class="comment">/*只要socket读缓存中还有未读出的数据，这段代码就被触发*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line">			<span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">			<span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">				close(sockfd);</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of content:%s\n&quot;</span>, ret, buf);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*ET模式的工作流程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">		<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">		<span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">			<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">			<span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;</span><br><span class="line">					client_addrlength);</span><br><span class="line">			addfd(epollfd, connfd, <span class="literal">true</span>); <span class="comment">/*对connfd开启ET模式*/</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">			<span class="comment">/*这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出*/</span></span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line">			<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">				<span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">				<span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">/*</span></span><br><span class="line"><span class="comment">					 * 对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。</span></span><br><span class="line"><span class="comment">					 * 此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class="line"><span class="comment">					 * */</span></span><br><span class="line">					<span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					close(sockfd);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">					close(sockfd);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of content:%s\n&quot;</span>, ret, buf);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> ret, listenfd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		address.sin_family = AF_INET;</span><br><span class="line">		inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">		address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">		listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">		assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">		ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">		assert(ret != <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">	<span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">	assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">	addfd(epollfd, listenfd, <span class="literal">true</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		lt(events, ret, epollfd, listenfd); <span class="comment">/*使用LT模式*/</span></span><br><span class="line">		<span class="comment">//et(events,ret,epollfd,listenfd);    /*使用ET模式*/</span></span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读者不妨运行一下这段代码，然后telnet到这个服务器程序上并一 次传输超过10字节（BUFFER_SIZE的大小）的数据，然后比较LT模式 和ET模式的异同。你会发现，正如我们预期的，ET模式下事件被触发 的次数要比LT模式下少很多。 </p>
<p>注意每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直 处于阻塞状态（饥渴状态）。</p>
<h5 id="9-3-4-EPOLLONESHOT事件"><a href="#9-3-4-EPOLLONESHOT事件" class="headerlink" title="9.3.4 EPOLLONESHOT事件"></a>9.3.4 EPOLLONESHOT事件</h5><p>即使我们使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程（或进程， 下同）在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发）， 此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线 程同时操作一个socket的局面。</p>
<p><strong>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事 件。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fds</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> epollfd;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中，参</span></span><br><span class="line"><span class="comment">数oneshot指定是否注册fd上的EPOLLONESHOT事件*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> oneshot)</span> </span>&#123;</span><br><span class="line">	epoll_event event&#123;&#125;;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN | EPOLLET;</span><br><span class="line">	<span class="keyword">if</span> (oneshot) &#123;</span><br><span class="line">		event.events |= EPOLLONESHOT;</span><br><span class="line">	&#125;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">	setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，但是操</span></span><br><span class="line"><span class="comment">作系统仍然会触发fd上的EPOLLIN事件，且只触发一次*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_oneshot</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	epoll_event event&#123;&#125;;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*工作线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sockfd = ((fds *) arg)-&gt;sockfd;</span><br><span class="line">	<span class="keyword">int</span> epollfd = ((fds *) arg)-&gt;epollfd;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;start new thread to receive data on fd:%d\n&quot;</span>, sockfd);</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">	<span class="comment">/*循环读取sockfd上的数据，直到遇到EAGAIN错误*/</span></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">			close(sockfd);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;foreiner closed the connection\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">				reset_oneshot(epollfd, sockfd);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;get content:%s\n&quot;</span>, buf);</span><br><span class="line">			<span class="comment">/*休眠5s，模拟数据处理过程*/</span></span><br><span class="line">			sleep(<span class="number">5</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;end thread receiving data on fd:%d\n&quot;</span>, sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">	bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">	address.sin_port = htons(port);</span><br><span class="line">	<span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">	ret = bind(listenfd, (</span><br><span class="line">			struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">	<span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">	assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 注意，监听socket listenfd上是不能注册EPOLLONESHOT事件的，否则应用程序</span></span><br><span class="line"><span class="comment">	 * 只能处理一个客户连接！因为后续的客户连接请求将不再触发listenfd上的EPOLLIN事件</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	addfd(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">			<span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">				<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">				<span class="keyword">int</span> connfd = accept(listenfd, (</span><br><span class="line">						struct sockaddr *) &amp;client_address, &amp;</span><br><span class="line">						                    client_addrlength);</span><br><span class="line">				<span class="comment">/*对每个非监听文件描述符都注册EPOLLONESHOT事件*/</span></span><br><span class="line">				addfd(epollfd, connfd, <span class="literal">true</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">				<span class="keyword">pthread_t</span> thread;</span><br><span class="line">				fds fds_for_new_worker&#123;&#125;;</span><br><span class="line">				fds_for_new_worker.epollfd = epollfd;</span><br><span class="line">				fds_for_new_worker.sockfd = sockfd;</span><br><span class="line">				<span class="comment">/*新启动一个工作线程为sockfd服务*/</span></span><br><span class="line">				pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, (<span class="keyword">void</span> *) &amp;fds_for_new_worker);</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>从工作线程函数worker来看，如果一个工作线程处理完某个socket 上的一次请求（我们用休眠5 s来模拟这个过程）之后，又接收到该 socket上新的客户请求，则该线程将继续为这个socket服务。并且因为该socket上注册了EPOLLONESHOT事件，其他线程没有机会接触这个 socket，如果工作线程等待5 s后仍然没收到该socket上的下一批客户数 据，则它将放弃为该socket服务。</p>
<p>同时，它调用reset_oneshot函数来重 置该socket上的注册事件，这将使epoll有机会再次检测到该socket上的 EPOLLIN事件，进而使得其他线程有机会为该socket服务。</p>
<h4 id="9-4-三组I-O复用函数的比较"><a href="#9-4-三组I-O复用函数的比较" class="headerlink" title="9.4 三组I/O复用函数的比较"></a>9.4 三组I/O复用函数的比较</h4><p>前面我们讨论了select、poll和epoll三组I/O复用系统调用，这3组系 统调用都能同时监听多个文件描述符。它们将等待由timeout参数指定 的超时时间，直到一个或者多个文件描述符上有事件发生时返回，返 回值是就绪的文件描述符的数量。返回0表示没有事件发生。</p>
<ul>
<li>事件集合<ul>
<li>select的参数类型fd_set没有将文件描述符和事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件。这一方面使得select不能处理更多类型的 事件，另一方面由于内核对fd_set集合的在线修改，应用程序下次调用 select前不得不重置这3个fd_set集合。</li>
<li>poll的参数类型pollfd则多少“聪 明”一些。它把文件描述符和事件都定义其中，任何事件都被统一处理，从而使得编程接口简洁得多。并且内核每次修改的是pollfd结构体 的revents成员，而events成员保持不变，因此下次调用poll时应用程序 无须重置pollfd类型的事件集参数。由于每次select和poll调用都返回整 个用户注册的事件集合（其中包括就绪的和未就绪的），所以应用程 序索引就绪文件描述符的时间复杂度为O（n）。</li>
<li>epoll则采用与select和 poll完全不同的方式来管理用户注册的事件。它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除、 修改事件。这样，每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文 件描述符的时间复杂度达到O（1）。</li>
</ul>
</li>
<li>最大文件描述符</li>
</ul>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302141655751-1678341964417.png" class="" title="image-20230302141655751">



<h4 id="9-5-I-O复用的高级应用一：非阻塞connect"><a href="#9-5-I-O复用的高级应用一：非阻塞connect" class="headerlink" title="9.5 I/O复用的高级应用一：非阻塞connect"></a>9.5 I/O复用的高级应用一：非阻塞connect</h4><p>在对非阻塞的socket调用connect，而连接又没有立即建立时。会出现一种errno值：EINPROGRESS。 根据man文档的解释，在这种情况下，我们可以调用select、poll 等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。 如果错误码是0，表示连接成功建立，否则连接失败。</p>
<p>通过上面描述的非阻塞connect方式，我们就能同时发起多个连接 并一起等待。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1023</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 超时连接函数，参数分别是服务器IP地址、端口号和超时时间（毫秒）。</span></span><br><span class="line"><span class="comment"> * 函数成功时返回已经处于连接状态的socket，失败则返回-1</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unblock_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		address.sin_family = AF_INET;</span><br><span class="line">		inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">		address.sin_port = htons(port);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> fdopt = setnonblocking(sockfd);</span><br><span class="line">	ret = connect(sockfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	<span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*如果连接成功，则恢复sockfd的属性，并立即返回之*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connect with server immediately\n&quot;</span>);</span><br><span class="line">		fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line">		<span class="keyword">return</span> sockfd;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno != EINPROGRESS) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * 如果连接没有立即建立，那么只有当errno是EINPROGRESS时才表示连接还在进行，否则出错返回</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;unblock connect not support\n&quot;</span>);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	fd_set writefds;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		FD_ZERO(&amp;writefds);</span><br><span class="line">		FD_SET(sockfd, &amp;writefds);</span><br><span class="line">		timeout.tv_sec = time;</span><br><span class="line">		timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	ret = select(sockfd + <span class="number">1</span>, <span class="literal">nullptr</span>, &amp;writefds, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line">	<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*select超时或者出错，立即返回*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connection time out\n&quot;</span>);</span><br><span class="line">		close(sockfd);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 测试fdset的位fd是否被设置</span></span><br><span class="line">	<span class="keyword">if</span> (!FD_ISSET(sockfd, &amp;writefds)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;no events on sockfd found\n&quot;</span>);</span><br><span class="line">		close(sockfd);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(error);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 调用getsockopt来获取并清除sockfd上的错误, getsockopt和setsockopt这两个函数成功时返回0，</span></span><br><span class="line">	<span class="comment">// 失败时返回-1并设置errno。</span></span><br><span class="line">	<span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">		close(sockfd);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 错误号不为0表示连接出错</span></span><br><span class="line">	<span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connection failed after select with the error:%d\n&quot;</span>, error);</span><br><span class="line">		close(sockfd);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 连接成功</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;connection ready after select with the socket:%d\n&quot;</span>, sockfd);</span><br><span class="line">	fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line">	<span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> sockfd = unblock_connect(ip, port, <span class="number">10</span>);</span><br><span class="line">	<span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>**5.11 章节 socket选项 : **     getsockopt, setsockopt, 两个系统调用则是专门用来读取和设置socket文件描述符属性的 方法。</p>
<h4 id="9-6-I-O复用的高级应用二：聊天室程序"><a href="#9-6-I-O复用的高级应用二：聊天室程序" class="headerlink" title="9.6 I/O复用的高级应用二：聊天室程序"></a>9.6 I/O复用的高级应用二：聊天室程序</h4><p>本节我们以poll为例实现一个简单的聊天室 程序，以阐述如何使用I/O复用技术来同时处理网络连接和用户输入。 该聊天室程序能让所有用户同时在线群聊，它分为客户端和服务器两个部分。</p>
<p>其中客户端程序有两个功能：一是从标准输入终端读入用户 数据，并将用户数据发送至服务器；二是往标准输出终端打印服务器 发送给它的数据。</p>
<p>服务器的功能是接收客户数据，并把客户数据发送 给每一个登录到该服务器上的客户端（数据发送者除外）。</p>
<h5 id="9-6-1-客户端"><a href="#9-6-1-客户端" class="headerlink" title="9.6.1 客户端"></a>9.6.1 客户端</h5><p>客户端程序使用poll同时监听用户输入和网络连接，并利用splice 函数将用户输入内容直接定向到网络连接上以发送之，从而实现数据 零拷贝，提高了程序执行效率。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">	bzero(&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">	server_address.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, ip, &amp;server_address.sin_addr);</span><br><span class="line">	server_address.sin_port = htons(port);</span><br><span class="line">	<span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (connect(sockfd, (struct sockaddr *) &amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">		close(sockfd);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pollfd fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*注册文件描述符0（标准输入）和文件描述符sockfd上的可读事件*/</span></span><br><span class="line">	fds[<span class="number">0</span>].fd = <span class="number">0</span>;</span><br><span class="line">	fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">	fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">	fds[<span class="number">1</span>].fd = sockfd;</span><br><span class="line">	fds[<span class="number">1</span>].events = POLLIN | POLLRDHUP;</span><br><span class="line">	fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">char</span> read_buf[BUFFER_SIZE];</span><br><span class="line">	<span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = poll(fds, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLRDHUP) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;server close the connection\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">			<span class="built_in">memset</span>(read_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">			recv(fds[<span class="number">1</span>].fd, read_buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, read_buf);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line">			<span class="comment">/*使用splice将用户输入的数据直接写到sockfd上（零拷贝）*/</span></span><br><span class="line">			ret = splice(<span class="number">0</span>, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">			ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, sockfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(sockfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="9-6-2-服务端"><a href="#9-6-2-服务端" class="headerlink" title="9.6.2 服务端"></a>9.6.2 服务端</h5><p>服务器程序使用poll同时管理监听socket和连接socket，并且使用牺牲空间换取时间的策略来提高服务器性能</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_LIMIT 5    <span class="comment">/*最大用户数量*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64  <span class="comment">/*读缓冲区的大小*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535  <span class="comment">/*文件描述符数量限制*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户数据：客户端socket地址、待写到客户端的数据的位置、从客户端读入的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">	sockaddr_in address;</span><br><span class="line">	<span class="keyword">char</span> *write_buf;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">	address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">	ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * 创建users数组，分配FD_LIMIT个client_data对象。可以预期：</span></span><br><span class="line"><span class="comment">	 * 每个可能的socket连接都可以获得一个这样的对象，并且socket的值可以直接用来索引（作为数组的下标）</span></span><br><span class="line"><span class="comment">	 * socket连接对应的client_data对象，这是将socket和客户数据关联的简单而高效的方式</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line"></span><br><span class="line">	client_data *users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管我们分配了足够多的client_data对象，但为了提高poll的性能，仍然有必要限制用户的数量</span></span><br><span class="line">	pollfd fds[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> user_counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= USER_LIMIT; ++i) &#123;</span><br><span class="line">		fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">		fds[i].events = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">	fds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">	fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		ret = poll(fds, user_counter + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; user_counter + <span class="number">1</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// fds[0] 用于建立连接</span></span><br><span class="line">			<span class="keyword">if</span> ((fds[i].fd == listenfd) &amp;&amp; (fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">				<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">				<span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">				<span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*如果请求太多，则关闭新到的连接*/</span></span><br><span class="line">				<span class="keyword">if</span> (user_counter &gt;= USER_LIMIT) &#123;</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">					send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">					close(connfd);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * 对于新的连接，同时修改fds和users数组。前文已经提到，</span></span><br><span class="line"><span class="comment">				 * users[connfd]对应于新连接文件描述符connfd的客户数据</span></span><br><span class="line"><span class="comment">				 * */</span></span><br><span class="line"></span><br><span class="line">				user_counter++;</span><br><span class="line">				users[connfd].address = client_address;</span><br><span class="line">				setnonblocking(connfd);</span><br><span class="line">				fds[user_counter].fd = connfd;</span><br><span class="line">				fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR;</span><br><span class="line">				fds[user_counter].revents = <span class="number">0</span>;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;comes a new user,now have%d users\n&quot;</span>, user_counter);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLERR) &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;get an error from%d\n&quot;</span>, fds[i].fd);</span><br><span class="line">				<span class="keyword">char</span> errors[<span class="number">100</span>];</span><br><span class="line">				<span class="built_in">memset</span>(errors, <span class="string">&#x27;\0&#x27;</span>, <span class="number">100</span>);</span><br><span class="line">				<span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(errors);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (getsockopt(fds[i].fd, SOL_SOCKET, SO_ERROR, &amp;errors,&amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLRDHUP) &#123;</span><br><span class="line">				<span class="comment">// 如果客户端关闭连接，则服务器也关闭对应的连接，并将用户总数减1</span></span><br><span class="line">				users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">				close(fds[i].fd);</span><br><span class="line">				fds[i] = fds[user_counter];</span><br><span class="line">				i--;</span><br><span class="line">				user_counter--;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;a client left\n&quot;</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line">				<span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line">				<span class="built_in">memset</span>(users[connfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">				ret = recv(connfd, users[connfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of client data%s from%d\n&quot;</span>, ret, users[connfd].buf, connfd);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">/*如果读操作出错，则关闭连接*/</span></span><br><span class="line">					<span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">						close(connfd);</span><br><span class="line">						users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">						fds[i] = fds[user_counter];</span><br><span class="line">						i--;</span><br><span class="line">						user_counter--;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/*如果接收到客户数据，则通知其他socket连接准备写数据*/</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= user_counter; ++j) &#123;</span><br><span class="line">						<span class="keyword">if</span> (fds[j].fd == connfd) &#123;</span><br><span class="line">							<span class="keyword">continue</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						fds[j].events |= ~POLLIN;</span><br><span class="line">						fds[j].events |= POLLOUT;</span><br><span class="line">						users[fds[j].fd].write_buf = users[connfd].buf;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLOUT) &#123;</span><br><span class="line">				<span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line">				<span class="keyword">if</span> (!users[connfd].write_buf) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				ret = send(connfd, users[connfd].write_buf, <span class="built_in">strlen</span>(users[connfd].write_buf), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				users[connfd].write_buf = <span class="literal">NULL</span>;</span><br><span class="line">				<span class="comment">/*写完数据后需要重新注册fds[i]上的可读事件*/</span></span><br><span class="line">				fds[i].events |= ~POLLOUT;</span><br><span class="line">				fds[i].events |= POLLIN;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[]users;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="9-7-I-O-复用的高级应用三-同时处理TCP和UDP服务"><a href="#9-7-I-O-复用的高级应用三-同时处理TCP和UDP服务" class="headerlink" title="9.7 I/O 复用的高级应用三: 同时处理TCP和UDP服务"></a>9.7 I/O 复用的高级应用三: 同时处理TCP和UDP服务</h4><p>在实际应用 中，有不少服务器程序能同时监听多个端口，比如超级服务inetd和 android的调试服务adbd。</p>
<p>从bind系统调用的参数来看，一个socket只能与一个socket地址绑 定，即一个socket只能用来监听一个端口。因此，服务器如果要同时 监听多个端口，就必须创建多个socket，并将它们分别绑定到各个端 口上。这样一来，服务器程序就需要同时管理多个监听socket，I/O复 用技术就有了用武之地。</p>
<p>另外，即使是同一个端口，如果服务器要同 时处理该端口上的TCP和UDP请求，则也需要创建两个不同的socket： 一个是流socket，另一个是数据报socket，并将它们都绑定到该端口 上。比如代码清单9-8所示的回射服务器(比如echo)就能同时处理一个端口上的 TCP和UDP请求。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	epoll_event event;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN | EPOLLET;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">	setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">	bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">	address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建TCP socket，并将其绑定到端口port上*/</span></span><br><span class="line">	<span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">	ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建UDP socket，并将其绑定到端口port上*/</span></span><br><span class="line">	bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">	address.sin_port = htons(port);</span><br><span class="line">	<span class="keyword">int</span> udpfd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">	assert(udpfd &gt;= <span class="number">0</span>);</span><br><span class="line">	ret = bind(udpfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">	<span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">	assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*注册TCP socket和UDP socket上的可读事件*/</span></span><br><span class="line">	addfd(epollfd, listenfd);</span><br><span class="line">	addfd(epollfd, udpfd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">			<span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">				<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">				<span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">				addfd(epollfd, connfd);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockfd == udpfd) &#123;</span><br><span class="line">				<span class="keyword">char</span> buf[UDP_BUFFER_SIZE];</span><br><span class="line">				<span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, UDP_BUFFER_SIZE);</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">				<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">				<span class="comment">// udp数据读取</span></span><br><span class="line">				ret = recvfrom(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>,(struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">// udp 数据发送</span></span><br><span class="line">					sendto(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>,(struct sockaddr *) &amp;client_address, client_addrlength);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">				<span class="keyword">char</span> buf[TCP_BUFFER_SIZE];</span><br><span class="line">				<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">					<span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, TCP_BUFFER_SIZE);</span><br><span class="line">					ret = recv(sockfd, buf, TCP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">					<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line">							<span class="keyword">break</span>;</span><br><span class="line">						&#125;</span><br><span class="line">						close(sockfd);</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">						close(sockfd);</span><br><span class="line">					&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">						send(sockfd, buf, ret, <span class="number">0</span>);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="9-8-超级服务xinetd"><a href="#9-8-超级服务xinetd" class="headerlink" title="9.8 超级服务xinetd"></a>9.8 超级服务xinetd</h4><p>Linux因特网服务inetd是超级服务。它同时管理着多个子服务，即 监听多个端口。现在Linux系统上使用的inetd服务程序通常是其升级版 本xinetd。</p>
<h5 id="9-8-1-xinetd-配置文件"><a href="#9-8-1-xinetd-配置文件" class="headerlink" title="9.8.1 xinetd 配置文件"></a>9.8.1 xinetd 配置文件</h5><p>xinetd采用/etc/xinetd.conf主配置文件和/etc/xinetd.d目录下的子配置 文件来管理所有服务。主配置文件包含的是通用选项，这些选项将被 所有子配置文件继承。不过子配置文件可以覆盖这些选项。每一个子 配置文件用于设置一个子服务的参数。</p>
<p>比如，telnet子服务的配置文 件/etc/xinetd.d/telnet的典型内容如下：</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211328677-1678341964417.png" class="" title="image-20230302211328677">

<p>/etc/xinetd. d/telnet文件中的每一项的含义如表9-3所示。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211402685-1678341964417.png" class="" title="image-20230302211402685">

<h5 id="9-8-2-xinetd-服务流程"><a href="#9-8-2-xinetd-服务流程" class="headerlink" title="9.8.2 xinetd 服务流程"></a>9.8.2 xinetd 服务流程</h5><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211732296-1678341964417.png" class="" title="image-20230302211732296">



<h3 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h3><p><strong>信号是由用户、系统或者进程发送给目标进程的信息</strong>，以通知目 标进程某个状态的改变或系统异常。Linux信号可由如下条件产生：</p>
<ul>
<li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</li>
<li>系统异常。比如浮点异常和非法内存段访问。</li>
<li>系统状态变化。比如alarm定时器到期将引起SIGALRM信号。</li>
<li>运行kill命令或调用kill函数。</li>
</ul>
<h4 id="10-1-Linux信号概述"><a href="#10-1-Linux信号概述" class="headerlink" title="10.1 Linux信号概述"></a>10.1 Linux信号概述</h4><h5 id="10-1-1-发送信号"><a href="#10-1-1-发送信号" class="headerlink" title="10.1.1 发送信号"></a>10.1.1 发送信号</h5><p>Linux下，一个进程给其他进程发送信号的API是kill函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该函数把信号sig发送给目标进程，Linux定义的信号值都大于0，如果sig取值为0，则kill函数不发送 任何信号。但将sig设置为0可以用来检测目标进程或进程组是否存在， 因为检查工作总是在信号发送之前就执行。</p>
</li>
<li><p>目标进程由pid参数指定，其可 能的取值及含义如表10-1所示。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304135652650-1678341964417.png" class="" title="image-20230304135652650">



</li>
</ul>
<h5 id="10-1-2-信号处理方式"><a href="#10-1-2-信号处理方式" class="headerlink" title="10.1.2 信号处理方式"></a>10.1.2 信号处理方式</h5><p>目标进程在收到信号时，需要定义一个接收函数来处理之。信号 处理函数的原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">__sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>信号处理函数只带有一个整型参数，该参数用来指示信号类型。</p>
<h5 id="10-1-3-Linux信号"><a href="#10-1-3-Linux信号" class="headerlink" title="10.1.3 Linux信号"></a>10.1.3 Linux信号</h5><p>Linux的可用信号都定义在bits/signum.h头文件中，其中包括标准信 号和POSIX实时信号。本书仅讨论标准信号， 以下列举几种与网络编程关系紧密的几个信号：</p>
<ol>
<li>SIGHUP：控制终端挂起</li>
<li>SIGPIPE：往读端被关闭的管道或者socket连接中写数据</li>
<li>SIGURG：socket连接上接收到紧急数据</li>
<li>SIGALRM：由alarm或setitimer设置的实时闹钟超时引起</li>
<li>SIGCHLD：子进程状态发生变化（退出或者暂停）</li>
</ol>
<h5 id="10-1-4-中断系统调用"><a href="#10-1-4-中断系统调用" class="headerlink" title="10.1.4 中断系统调用"></a>10.1.4 中断系统调用</h5><p>如果程序在执行处于阻塞状态的系统调用时接收到信号，并且我 们为该信号设置了信号处理函数，则默认情况下系统调用将被中断， 并且errno被设置为EINTR。</p>
<p>我们可以使用sigaction函数（见后文）为信 号设置SA_RESTART标志以自动重启被该信号中断的系统调用。</p>
<h4 id="10-2-信号函数"><a href="#10-2-信号函数" class="headerlink" title="10.2 信号函数"></a>10.2 信号函数</h4><h5 id="10-2-1-signal系统调用"><a href="#10-2-1-signal系统调用" class="headerlink" title="10.2.1 signal系统调用"></a>10.2.1 signal系统调用</h5><p>要为一个<strong>信号设置处理函数</strong>，可以使用下面的signal系统调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">_sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">_sighandler_t</span> _handler)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li>sig参数指出要捕获的信号类型。</li>
<li>_handler参数是_sighandler_t类型 的函数指针，用于指定信号sig的处理函数。</li>
</ul>
<p>signal函数成功时返回一个函数指针，该函数指针的类型也是 _sighandler_t。 <strong>这个返回值是前一次调用signal函数时传入的函数指针， 或者是信号sig对应的默认处理函数指针SIG_DEF（如果是第一次调用 signal的话）。</strong></p>
<p>signal系统调用出错时返回SIG_ERR，并设置errno。</p>
<h5 id="10-2-2-sigaction系统调用"><a href="#10-2-2-sigaction系统调用" class="headerlink" title="10.2.2 sigaction系统调用"></a>10.2.2 sigaction系统调用</h5><p>设置<strong>信号处理函数</strong>的更健壮的接口是如下的系统调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction* act,struct sigaction* oact)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>sig参数指出要捕获的信号类型</li>
<li>act参数指定新的信号处理方式</li>
<li>oact参数则输出信号先前的处理方式（如果不为NULL的话）</li>
</ul>
<p>sigaction结构体描述了信号处理 的细节，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure describing the action to be taken when a signal arrives.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* Signal handler.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line">	<span class="comment">/* Used if SA_SIGINFO is not set.  */</span></span><br><span class="line">	<span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line">	<span class="comment">/* Used if SA_SIGINFO is set.  */</span></span><br><span class="line">	<span class="keyword">void</span> (*sa_sigaction) (<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">      &#125;</span><br><span class="line">    __sigaction_handler;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> sa_handler	__sigaction_handler.sa_handler</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> sa_sigaction	__sigaction_handler.sa_sigaction</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional set of signals to be blocked.  */</span></span><br><span class="line">    <span class="keyword">__sigset_t</span> sa_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Special flags.  */</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore handler.  */</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer) (<span class="keyword">void</span>);</span><br><span class="line">    <span class="comment">// 指向返回值是void, 参数是void类型的 函数指针</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>该结构体中的sa_hander成员指定信号处理函数。</p>
</li>
<li><p>sa_mask成员设置进程的信号掩码（确切地说是在进程原有信号掩码的基础上增加信号 掩码），以指定哪些信号不能发送给本进程。<strong>sa_mask是信号集 sigset_t（_sigset_t的同义词）类型，该类型指定一组信号。</strong> 下一节介绍sigset_t</p>
</li>
<li><p>sa_flags成员用于设置程序收到信号时的行 为，其可选值如表10-4所示：</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304142154845-1678341964417.png" class="" title="image-20230304142154845">



</li>
</ul>
<h4 id="10-3-信号集"><a href="#10-3-信号集" class="headerlink" title="10.3 信号集"></a>10.3 信号集</h4><h5 id="10-3-1-信号集函数"><a href="#10-3-1-信号集函数" class="headerlink" title="10.3.1 信号集函数"></a>10.3.1 信号集函数</h5><p>前文提到，Linux使用数据结构sigset_t来表示一组信号。其定义如 下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/sigset.h＞</span></span><br><span class="line">#define_SIGSET_NWORDS(<span class="number">1024</span>/(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>)))</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> int__val[_SIGSET_NWORDS];</span><br><span class="line">&#125;<span class="keyword">__sigset_t</span>;</span><br></pre></td></tr></table></figure>

<p>sigset_t实际上是一个长整型数组，数组的每个元素的每个位表示一个信号。这种定义方式和文件描述符集fd_set类似。</p>
<p>Linux提供了如下一组函数来设置、修改、删除和查询信号集：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*清空信号集*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*在信号集中设置所有信号*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>*_set,<span class="keyword">int</span> _signo)</span><span class="comment">/*将信号_signo添加至信号集中*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>* _set,<span class="keyword">int</span> _signo)</span><span class="comment">/*将信号_signo从信号集中删除*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(_const <span class="keyword">sigset_t</span>* _set, int_signo)</span><span class="comment">/*测试_signo是否在信号集中*/</span></span></span><br></pre></td></tr></table></figure>



<h5 id="10-3-2-进程信号掩码"><a href="#10-3-2-进程信号掩码" class="headerlink" title="10.3.2 进程信号掩码"></a>10.3.2 进程信号掩码</h5><p>我们可以利用<strong>sigaction结构体的sa_mask成员来设置进程的信号掩码</strong>。此外，如下函数也可以用于设置或查看进程的信号掩 码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> _how, _const <span class="keyword">sigset_t</span>* _set, <span class="keyword">sigset_t</span>* _oset)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>_set</code>参数指定新的信号掩码，</p>
</li>
<li><p>_oset参数则输出原来的信号掩码（如 果不为NULL的话）。</p>
</li>
<li><p>如果_set参数不为NULL，则_how参数指定设置 进程信号掩码的方式，其可选值如表10-5所示。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304143250709-1678341964417.png" class="" title="image-20230304143250709">

</li>
</ul>
<p>sigprocmask成功时返回0，失败则返回-1并设置errno。</p>
<h5 id="10-3-3-被挂起的信号"><a href="#10-3-3-被挂起的信号" class="headerlink" title="10.3.3 被挂起的信号"></a>10.3.3 被挂起的信号</h5><p>设置进程信号掩码后，被屏蔽的信号将不能被进程接收。<strong>如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个被挂起的信号。</strong>如果我们取消对被挂起信号的屏蔽，则它能立即被进 程接收到</p>
<p>如下函数可以获得进程当前被挂起的信号集：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>set参数用于保存被挂起的信号集。显然，进程即使多次接收到同 一个被挂起的信号，sigpending函数也只能反映一次。并且，当我们再 次使用sigprocmask使能该挂起的信号时，该信号的处理函数也只被触 发一次。</p>
<p>sigpending成功时返回0，失败时返回-1并设置errno。</p>
<h4 id="10-4-统一事件源"><a href="#10-4-统一事件源" class="headerlink" title="10.4 统一事件源"></a>10.4 统一事件源</h4><p>信号是一种异步事件：信号处理函数和程序的主循环是两条不同 的执行路线。很显然，信号处理函数需要尽可能快地执行完毕，以确 保该信号不被屏蔽（前面提到过，为了避免一些竞态条件，信号在处 理期间，系统不会再次触发它）太久。</p>
<p>一种典型的解决方案是：<strong>把信号的主要处理逻辑放到程序的主循环中</strong>，当信号处理函数被触发时， 它<strong>只是简单地通知主循环程序接收到信号</strong>，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。</p>
<p><strong>信号处理函数通常使用管道来将信号“传递”给主循环</strong>：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么 主循环怎么知道管道上何时有数据可读呢  ?</p>
<p>这很简单，<strong>我们只需要使用 I/O复用系统调用来监听管道的读端文件描述符上的可读事件</strong>。如此一 来，信号事件就能和其他I/O事件一样被处理，即统一事件源。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将事件添加到 epoll的内核事件表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	epoll_event event&#123;&#125;;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN | EPOLLET;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">	setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*保留原来的errno，在函数最后恢复，以保证函数的可重入性*/</span></span><br><span class="line">	<span class="keyword">int</span> save_errno = errno;</span><br><span class="line">	<span class="keyword">int</span> msg = sig;</span><br><span class="line">	send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">/*将信号值写入管道，以通知主循环*/</span></span><br><span class="line">	errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置信号的处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">	sa.sa_handler = sig_handler;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// SA_RESTART 重新调用被该信号终止的系统调用</span></span><br><span class="line">	sa.sa_flags |= SA_RESTART;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*在信号集中设置所有信号*/</span></span><br><span class="line">	sigfillset(&amp;sa.sa_mask);</span><br><span class="line">	assert(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="keyword">int</span> listenfd;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		address.sin_family = AF_INET;</span><br><span class="line">		inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">		address.sin_port = htons(port);</span><br><span class="line">		listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">		assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">		ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;errno is%d\n&quot;</span>, errno);</span><br><span class="line">			<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">		assert(ret != <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表</span></span><br><span class="line"><span class="comment">	 * 文件描述符使用如下epoll_create函数 来创建</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">	assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*使用socketpair创建管道，注册pipefd[0]上的可读事件*/</span></span><br><span class="line">	ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line"></span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">	addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*设置一些信号的处理函数*/</span></span><br><span class="line">	addsig(SIGHUP);</span><br><span class="line">	addsig(SIGCHLD);</span><br><span class="line">	addsig(SIGTERM);</span><br><span class="line">	addsig(SIGINT);</span><br><span class="line">	<span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line">		<span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">			<span class="comment">/*如果就绪的文件描述符是listenfd，则处理新的连接*/</span></span><br><span class="line">			<span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">				<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">				<span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">				addfd(epollfd, connfd);</span><br><span class="line">			&#125;</span><br><span class="line">				<span class="comment">/*如果就绪的文件描述符是pipefd[0]，则处理信号*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">				<span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">				ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/*因为每个信号值占1字节，所以按字节来逐个接收信号。我们以SIGTERM为例，</span></span><br><span class="line"><span class="comment">					 * 来说明如何安全地终止服务器主循环*/</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">						<span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line">							<span class="keyword">case</span> SIGCHLD:</span><br><span class="line">							<span class="keyword">case</span> SIGHUP: &#123;</span><br><span class="line">								<span class="keyword">continue</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">case</span> SIGTERM:</span><br><span class="line">							<span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">								stop_server = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;close fds\n&quot;</span>);</span><br><span class="line">	close(listenfd);</span><br><span class="line">	close(pipefd[<span class="number">1</span>]);</span><br><span class="line">	close(pipefd[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="10-5-网络编程相关信号"><a href="#10-5-网络编程相关信号" class="headerlink" title="10.5 网络编程相关信号"></a>10.5 网络编程相关信号</h4><p>本节中我们详细探讨三个和网络编程密切相关的信号。</p>
<h5 id="10-5-1-SIGHUP"><a href="#10-5-1-SIGHUP" class="headerlink" title="10.5.1 SIGHUP"></a>10.5.1 SIGHUP</h5><p><strong>当挂起进程的控制终端时，SIGHUP信号将被触发。</strong>对于没有控 制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务 器重读配置文件。一个典型的例子是xinetd超级服务程序。</p>
<p>xinetd程序在接收到SIGHUP信号之后将调用hard_reconfig函数 （见xinetd源码），它循环读取/etc/xinetd.d/目录下的每个子配置文 件，并检测其变化。如果某个正在运行的子服务的配置文件被修改以停止服务，则xinetd主进程将给该子服务进程发送SIGTERM信号以结 束它。如果某个子服务的配置文件被修改以开启服务，则xinetd将创建 新的socket并将其绑定到该服务对应的端口上。</p>
<h5 id="10-5-2-SIGPIPE"><a href="#10-5-2-SIGPIPE" class="headerlink" title="10.5.2 SIGPIPE"></a>10.5.2 SIGPIPE</h5><p>默认情况下，往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号。我们需要在<strong>代码中捕获并处理该信号</strong>，或者至少忽 略它，因为程序接收到SIGPIPE信号的默认行为是结束进程，而我们 绝对不希望因为错误的写操作而导致程序退出。引起SIGPIPE信号的 写操作将设置errno为EPIPE。</p>
<p>第5章提到，我们可以使用send函数的MSG_NOSIGNAL标志来禁 止写操作触发SIGPIPE信号。在这种情况下，我们应该使用send函数反 馈的errno值来判断管道或者socket连接的读端是否已经关闭。 </p>
<p>此外，我们也可以利用I/O复用系统调用来检测管道和socket连接 的读端是否已经关闭。以poll为例，当管道的读端关闭时，写端文件 描述符上的POLLHUP事件将被触发；当socket连接被对方关闭时， socket上的POLLRDHUP事件将被触发。</p>
<h5 id="10-5-3-SIGURG"><a href="#10-5-3-SIGURG" class="headerlink" title="10.5.3 SIGURG"></a>10.5.3 SIGURG</h5><p>在Linux环境下，内核通知应用程序带外数据到达主要有两种方 法：</p>
<ol>
<li>一种是第9章介绍的I/O复用技术，select等系统调用在接收到带外 数据时将返回，并向应用程序报告socket上的异常事件, 代码9_1</li>
<li>另外一种方法就是使用SIGURG信号，如 代码清单10-3所示。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGURG信号的处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_urg</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> save_errno=errno;</span><br><span class="line">	<span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line">	<span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line">	<span class="keyword">int</span> ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,MSG_OOB);<span class="comment">/*接收带外数据*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of oob data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">	errno=save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig,<span class="keyword">void</span>(*sig_handler)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;sa,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(sa));</span><br><span class="line">	sa.sa_handler=sig_handler;</span><br><span class="line">	sa.sa_flags|=SA_RESTART;</span><br><span class="line">	sigfillset(&amp;sa.sa_mask);</span><br><span class="line">	assert(sigaction(sig,&amp;sa,<span class="literal">nullptr</span>)!=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(argc&lt;=<span class="number">2</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">	bzero(&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">	address.sin_family=AF_INET;</span><br><span class="line">	inet_pton(AF_INET,ip,&amp;address.sin_addr);</span><br><span class="line">	address.sin_port=htons(port);</span><br><span class="line">	<span class="keyword">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">	assert(sock&gt;=<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> ret=bind(sock,(struct sockaddr*)&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret!=<span class="number">-1</span>);</span><br><span class="line">	ret=listen(sock,<span class="number">5</span>);</span><br><span class="line">	assert(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client);</span><br><span class="line">	connfd=accept(sock,(struct sockaddr*)&amp;client,&amp;client_addrlength);</span><br><span class="line">	<span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>,errno);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		addsig(SIGURG,sig_urg);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*使用SIGURG信号之前，我们必须设置socket的宿主进程或进程组</span></span><br><span class="line"><span class="comment">		 * F_SETOWN 设定SIGIO和SIGURG信号的宿主进程的PID或者进程组的组id</span></span><br><span class="line"><span class="comment">		 * */</span></span><br><span class="line">		fcntl(connfd,F_SETOWN, getpid());</span><br><span class="line">		<span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line">		<span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">/*循环接收普通数据*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line">			ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of normal data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">		&#125;</span><br><span class="line">		close(connfd);</span><br><span class="line">	&#125;</span><br><span class="line">	close(sock);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第11章-定时器"><a href="#第11章-定时器" class="headerlink" title="第11章 定时器"></a>第11章 定时器</h3><hr>
<p>网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态。服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。</p>
<p>为此，<strong>我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构</strong>， 比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定 时事件的统一管理。本章主要讨论的就是两种高效的管理定时器的容器：时间轮和时间堆。</p>
<p><strong>注</strong>: 定时器容器是容器类数据结构，比如时间轮；定时器则是容器内容纳的一个个对象，它是对定时事件的封装。</p>
<p>我们先要介绍定时的方法。 定时是指在一段时间之后触发某段代码的机制，我们可以在这段代码 中依次处理所有到期的定时器。换言之，定时机制是定时器得以被处 理的原动力。Linux提供了三种定时方法，它们是：</p>
<ul>
<li>socket选项SO_RCVTIMEO和SO_SNDTIMEO。</li>
<li>SIGALRM信号。</li>
<li>I/O复用系统调用的超时参数</li>
</ul>
<h4 id="11-1-socket选项SO-RCVTIMEO和-SO-SNDTIMEO"><a href="#11-1-socket选项SO-RCVTIMEO和-SO-SNDTIMEO" class="headerlink" title="11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO"></a>11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO</h4><p>第5章中我们介绍过socket选项SO_RCVTIMEO和 SO_SNDTIMEO，它们分别用来设置socket接收数据超时时间和发送数 据超时时间。</p>
<p>这两个选项仅对与数据接收和发送相关的socket专用系统调用有效，这些系统调用包括send、sendmsg、recv、recvmsg、 accept和connect。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304222359944-1678341964417.png" class="" title="image-20230304222359944">

<p>我们可以<strong>根据系统调用（send、 sendmsg、recv、recvmsg、accept和connect）的返回值以及errno来判断 超时时间是否已到</strong>，进而决定是否开始处理定时任务。</p>
<h4 id="11-2-SIGALRM-信号"><a href="#11-2-SIGALRM-信号" class="headerlink" title="11.2 SIGALRM 信号"></a>11.2 SIGALRM 信号</h4><p>第10章提到，<strong>由alarm和setitimer函数设置的实时闹钟一旦超时</strong>， 将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来 处理定时任务。</p>
<p>但是，如果要处理多个定时任务，我们就需要不断地 触发SIGALRM信号，并在其信号处理函数中执行到期的任务。一般而言，<strong>SIGALRM信号按照固定的频率生成，即由alarm或setitimer函数设 置的定时周期T保持不变。</strong>如果某个定时任务的超时时间不是T的整数 倍，那么它实际被执行的时间和预期的时间将略有偏差。因此定时周 期T反映了定时的精度。</p>
<p>我们需要先给出一种简单的定时器实现 ——基于升序链表的定时器，并把它应用到处理非活动连接这个实例 中。</p>
<p>这样，我们才能观察到<strong>SIGALRM信号处理函数是如何处理定时器 并执行定时任务的</strong>。此外，我们介绍这种定时器也是为了和后面要讨论的高效定时器——时间轮和时间堆做对比。</p>
<h5 id="11-2-1-基于升序链表的定时器"><a href="#11-2-1-基于升序链表的定时器" class="headerlink" title="11.2.1 基于升序链表的定时器"></a>11.2.1 基于升序链表的定时器</h5><p>定时器通常至少要包含两个成员：</p>
<ul>
<li>一个超时时间（相对时间或者 绝对时间）</li>
<li>一个任务回调函数</li>
<li>有的时候还可能包含回调函数被执 行时需要传入的参数，以及是否重启定时器等信息。</li>
<li>如果使用链表作为容器来串联所有的定时器，则每个定时器还要包含指向下一个定时 器的指针成员。进一步，如果链表是双向的，则每个定时器还需要包 含指向前一个定时器的指针成员。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LST_TIMER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">util_timer</span>;</span><span class="comment">/*前向声明*/</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*用户数据结构：客户端socket地址、socket文件描述符、读缓存和定时器*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">		sockaddr_in address;</span><br><span class="line">		<span class="keyword">int</span> sockfd;</span><br><span class="line">		<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">		util_timer *timer;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*定时器类*/</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">util_timer</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		util_timer() : prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		<span class="keyword">time_t</span> expire&#123;&#125;;<span class="comment">/*任务的超时时间，这里使用绝对时间*/</span></span><br><span class="line">		<span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*任务回调函数*/</span></span><br><span class="line">		<span class="comment">/*回调函数处理的客户数据，由定时器的执行者传递给回调函数*/</span></span><br><span class="line"></span><br><span class="line">		client_data *user_data&#123;&#125;;</span><br><span class="line">		util_timer *prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">		util_timer *next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*定时器链表。它是一个升序、双向链表，且带有头结点和尾节点*/</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">sort_timer_lst</span> &#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line">		sort_timer_lst() : head(<span class="literal">nullptr</span>), tail(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*链表被销毁时，删除其中所有的定时器*/</span></span><br><span class="line">		~sort_timer_lst() &#123;</span><br><span class="line">			util_timer *tmp = head;</span><br><span class="line">			<span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">				head = tmp-&gt;next;</span><br><span class="line">				<span class="keyword">delete</span> tmp;</span><br><span class="line">				tmp = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*将目标定时器timer添加到链表中*/</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (!head) &#123;</span><br><span class="line">				head = tail = timer;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 如果目标定时器的超时时间小于当前链表中所有定时器的超时时间，</span></span><br><span class="line"><span class="comment">			 * 则把该定时器插入链表头部，作为链表新的头节点。否则就需要调用重载函数</span></span><br><span class="line"><span class="comment">				add_timer(util_timer*timer,util_timer*lst_head)，把它插入链表中合适的位</span></span><br><span class="line"><span class="comment">				置，以保证链表的升序特性</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire) &#123;</span><br><span class="line">				timer-&gt;next = head;</span><br><span class="line">				head-&gt;prev = timer;</span><br><span class="line">				head = timer;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			add_timer(timer, head);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*当某个定时任务发生变化时，调整对应的定时器在链表中的位置。这个函数只考虑被</span></span><br><span class="line"><span class="comment">			调整的定时器的超时时间延长的情况，即该定时器需要往链表的尾部移动*/</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			util_timer *tmp = timer-&gt;next;</span><br><span class="line">			<span class="comment">/*如果被调整的目标定时器处在链表尾部，或者该定时器新的超时值仍然小于其下一个</span></span><br><span class="line"><span class="comment">			定时器的超时值，则不用调整*/</span></span><br><span class="line">			<span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire)) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*如果目标定时器是链表的头节点，则将该定时器从链表中取出并重新插入链表*/</span></span><br><span class="line">			<span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">				head = head-&gt;next;</span><br><span class="line">				head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">				timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">				add_timer(timer, head);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*如果目标定时器不是链表的头节点，则将该定时器从链表中取出，然后插入其原来所</span></span><br><span class="line"><span class="comment">			在位置之后的部分链表中*/</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">				timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">				add_timer(timer, timer-&gt;next);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*将目标定时器timer从链表中删除*/</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*下面这个条件成立表示链表中只有一个定时器，即目标定时器*/</span></span><br><span class="line">			<span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail)) &#123;</span><br><span class="line">				<span class="keyword">delete</span> timer;</span><br><span class="line">				head = <span class="literal">nullptr</span>;</span><br><span class="line">				tail = <span class="literal">nullptr</span>;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的头结点，</span></span><br><span class="line"><span class="comment">			 * 则将链表的头结点重置为原头节点的下一个节点，然后删除目标定时器*/</span></span><br><span class="line">			<span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">				head = head-&gt;next;</span><br><span class="line">				head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">				<span class="keyword">delete</span> timer;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的尾结点，</span></span><br><span class="line"><span class="comment">			 * 则将链表的尾结点重置为原尾节点的前一个节点，然后删除目标定时器*/</span></span><br><span class="line">			<span class="keyword">if</span> (timer == tail) &#123;</span><br><span class="line">				tail = tail-&gt;prev;</span><br><span class="line">				tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">				<span class="keyword">delete</span> timer;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*如果目标定时器位于链表的中间，则把它前后的定时器串联起来，然后删除目标定时器*/</span></span><br><span class="line">			timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">			timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">			<span class="keyword">delete</span> timer;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*SIGALRM信号每次被触发就在其信号处理函数（如果使用统一事件源，则是主函数）</span></span><br><span class="line"><span class="comment">		中执行一次tick函数，以处理链表上到期的任务*/</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (!head) &#123;</span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;timer tick\n&quot;</span>);</span><br><span class="line">			<span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);<span class="comment">/*获得系统当前的时间*/</span></span><br><span class="line"></span><br><span class="line">			util_timer *tmp = head;</span><br><span class="line">			<span class="comment">/*从头结点开始依次处理每个定时器，直到遇到一个尚未到期的定时器，这就是定时器的核心逻辑*/</span></span><br><span class="line">			<span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 因为每个定时器都使用绝对时间作为超时值，所以我们可以把定时器的超时值和系统当前时间，</span></span><br><span class="line"><span class="comment">			 * 比较以判断定时器是否到期*/</span></span><br><span class="line">				<span class="keyword">if</span> (cur &lt; tmp-&gt;expire) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*调用定时器的回调函数，以执行定时任务*/</span></span><br><span class="line">				tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头结点*/</span></span><br><span class="line">				head = tmp-&gt;next;</span><br><span class="line">				<span class="keyword">if</span> (head) &#123;</span><br><span class="line">					head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">delete</span> tmp;</span><br><span class="line">				tmp = head;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		<span class="comment">/*一个重载的辅助函数，它被公有的add_timer函数和adjust_timer函数调用。</span></span><br><span class="line"><span class="comment">		 * 该函数表示将目标定时器timer添加到节点lst_head之后的部分链表中*/</span></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span> </span>&#123;</span><br><span class="line">			util_timer *prev = lst_head;</span><br><span class="line">			util_timer *tmp = prev-&gt;next;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* 遍历lst_head节点之后的部分链表，直到找到一个超时时间大于目标定时器的超时时间的节点，</span></span><br><span class="line"><span class="comment">			 * 并将目标定时器插入该节点之前*/</span></span><br><span class="line">			<span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">				<span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire) &#123;</span><br><span class="line">					prev-&gt;next = timer;</span><br><span class="line">					timer-&gt;next = tmp;</span><br><span class="line">					tmp-&gt;prev = timer;</span><br><span class="line">					timer-&gt;prev = prev;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				prev = tmp;</span><br><span class="line">				tmp = tmp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*如果遍历完lst_head节点之后的部分链表，仍未找到超时时间大于目标定时器的超</span></span><br><span class="line"><span class="comment">			时时间的节点，则将目标定时器插入链表尾部，并把它设置为链表新的尾节点*/</span></span><br><span class="line">			<span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">				prev-&gt;next = timer;</span><br><span class="line">				timer-&gt;prev = prev;</span><br><span class="line">				timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">				tail = timer;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		util_timer *head;</span><br><span class="line">		util_timer *tail;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>sort_timer_lst是一 个升序链表。其核心函数tick相当于一个心搏函数，它每隔一段固定的 时间就执行一次，以检测并处理到期的任务。判断定时任务到期的依据是定时器的expire值小于当前的系统时间。</p>
<p><strong>从执行效率来看，添加定时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)（因为是双向链表），执行定时任务的时间复杂度是O(1)。</strong></p>
<h5 id="11-2-2-处理非活动连接"><a href="#11-2-2-处理非活动连接" class="headerlink" title="11.2.2 处理非活动连接"></a>11.2.2 处理非活动连接</h5><p>现在我们考虑上述升序定时器链表的实际应用——处理非活动连接。服务器程序通常要定期处理非活动连接：给客户端发一个重连请 求，或者关闭该连接，或者其他。</p>
<blockquote>
<p>Linux在内核中提供了对连接是否处 于活动状态的定期检查机制，我们可以通过socket选项KEEPALIVE来 激活它。不过使用这种方式将使得应用程序对连接的管理变得复杂。</p>
</blockquote>
<p>比如，代码清单11-3利用alarm函 数周期性地触发SIGALRM信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../11 timer/lst_timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMESLOT 5</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">static</span> sort_timer_lst timer_lst; <span class="comment">/*利用代码清单11-2中的升序链表来管理定时器*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll 添加到内核表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	epoll_event event&#123;&#125;;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN | EPOLLET;</span><br><span class="line">	epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">	setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> save_errno = errno;</span><br><span class="line">	<span class="keyword">int</span> msg = sig;</span><br><span class="line">	send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">	sa.sa_handler = sig_handler;</span><br><span class="line">	sa.sa_flags |= SA_RESTART;</span><br><span class="line">	sigfillset(&amp;sa.sa_mask);</span><br><span class="line">	assert(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*定时处理任务，实际上就是调用tick函数*/</span></span><br><span class="line">	timer_lst.tick();</span><br><span class="line">	<span class="comment">/*因为一次alarm调用只会引起一次SIGALRM信号，所以我们要重新定时，以不断触发SIGALRM信号*/</span></span><br><span class="line">	alarm(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器回调函数，它删除非活动连接socket上的注册事件，并关闭之*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span> </span>&#123;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">	assert(user_data);</span><br><span class="line">	close(user_data-&gt;sockfd);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;close fd%d\n&quot;</span>, user_data-&gt;sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">	bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">	address.sin_port = htons(port);</span><br><span class="line">	<span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">	ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">	epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">	assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	addfd(epollfd, listenfd);</span><br><span class="line">	ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">	addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*设置信号处理函数*/</span></span><br><span class="line">	addsig(SIGALRM);</span><br><span class="line">	addsig(SIGTERM);  <span class="comment">// 主进程发给子进程的结束信号</span></span><br><span class="line">	<span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">auto</span> *users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line">	<span class="keyword">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">	alarm(TIMESLOT);<span class="comment">/*定时*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line">		<span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*处理新到的客户连接*/</span></span><br><span class="line">			<span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">				<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">				<span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">				addfd(epollfd, connfd);</span><br><span class="line">				users[connfd].address = client_address;</span><br><span class="line">				users[connfd].sockfd = connfd;</span><br><span class="line">				</span><br><span class="line">				<span class="comment">/*创建定时器，设置其回调函数与超时时间，然后绑定定时器与用户数据，最后将定时器添加到链表timer_lst中*/</span></span><br><span class="line">				<span class="keyword">auto</span> *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">				timer-&gt;user_data = &amp;users[connfd];</span><br><span class="line">				timer-&gt;cb_func = cb_func;</span><br><span class="line">				<span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);</span><br><span class="line">				</span><br><span class="line">				timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">				users[connfd].timer = timer;</span><br><span class="line">				timer_lst.add_timer(timer);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*处理信号*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">				<span class="keyword">int</span> sig;</span><br><span class="line">				<span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">				ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// recv成功时返回实际读取到的数据的长度</span></span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="comment">//handle the error</span></span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ret; ++j) &#123;</span><br><span class="line">						<span class="keyword">switch</span> (signals[j]) &#123;</span><br><span class="line">							<span class="keyword">case</span> SIGALRM: &#123;</span><br><span class="line">							<span class="comment">/* 用timeout变量标记有定时任务需要处理，但不立即处理定时任务。这是因为定时任</span></span><br><span class="line"><span class="comment">								务的优先级不是很高，我们优先处理其他更重要的任务*/</span></span><br><span class="line">								timeout = <span class="literal">true</span>;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">case</span> SIGTERM: &#123;</span><br><span class="line">								stop_server = <span class="literal">true</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*处理客户连接上接收到的数据*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">				<span class="built_in">memset</span>(users[sockfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">				ret = recv(sockfd, users[sockfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of client data%s from%d\n&quot;</span>, ret, users[sockfd].buf, sockfd);</span><br><span class="line">				util_timer *timer = users[sockfd].timer;</span><br><span class="line">				<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">/*如果发生读错误，则关闭连接，并移除其对应的定时器*/</span></span><br><span class="line">					<span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">						cb_func(&amp;users[sockfd]);</span><br><span class="line">						<span class="keyword">if</span> (timer) &#123;</span><br><span class="line">							timer_lst.del_timer(timer);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">/*如果对方已经关闭连接，则我们也关闭连接，并移除对应的定时器*/</span></span><br><span class="line">					cb_func(&amp;users[sockfd]);</span><br><span class="line">					<span class="keyword">if</span> (timer) &#123;</span><br><span class="line">						timer_lst.del_timer(timer);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/*如果某个客户连接上有数据可读，则我们要调整该连接对应的定时器，以延迟该连接被关闭的时间*/</span></span><br><span class="line">					<span class="keyword">if</span> (timer) &#123;</span><br><span class="line">						<span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);</span><br><span class="line">						timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;adjust timer once\n&quot;</span>);</span><br><span class="line">						timer_lst.adjust_timer(timer);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="comment">//others</span></span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*最后处理定时事件，因为I/O事件有更高的优先级。当然，这样做将导致定时任务不能精确地按照预期的时间执行*/</span></span><br><span class="line">		<span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">			timer_handler();</span><br><span class="line">			timeout = <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	close(pipefd[<span class="number">1</span>]);</span><br><span class="line">	close(pipefd[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">delete</span>[]users;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="11-3-I-O复用系统调用的超时参数"><a href="#11-3-I-O复用系统调用的超时参数" class="headerlink" title="11.3 I/O复用系统调用的超时参数"></a>11.3 I/O复用系统调用的超时参数</h4><p>Linux下的3组I/O复用系统调用都带有超时参数，因此它们不仅能 统一处理信号和I/O事件，也能统一处理定时事件。</p>
<p>但是由于I/O复用 系统调用可能在超时时间到期之前就返回（有I/O事件发生），所以如 果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT 5000</span></span><br><span class="line"><span class="keyword">int</span> timeout = TIMEOUT;</span><br><span class="line"><span class="keyword">time_t</span> start = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">time_t</span> end = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;the timeout is now%d mil-seconds\n&quot;</span>, timeout);</span><br><span class="line">	start = time(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, timeout);</span><br><span class="line">	<span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">		<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">       </span><br><span class="line">	<span class="comment">/*如果epoll_wait成功返回0，则说明超时时间到，此时便可处理定时任务，并重置定时时间*/</span></span><br><span class="line">	<span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">		timeout = TIMEOUT;</span><br><span class="line">		<span class="keyword">continue</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	end = time(<span class="literal">NULL</span>);</span><br><span class="line">	<span class="comment">/*如果epoll_wait的返回值大于0，则本次epoll_wait调用持续的时间是(endstart)*1000 ms，</span></span><br><span class="line"><span class="comment">	 * 我们需要将定时时间timeout减去这段时间，以获得下次epoll_wait调用的超时参数*/</span></span><br><span class="line">	timeout -= (end - start) * <span class="number">1000</span>;</span><br><span class="line">	<span class="comment">/*重新计算之后的timeout值有可能等于0，说明本次epoll_wait调用返回时，不仅有文件描述符就绪，</span></span><br><span class="line"><span class="comment">	 * 而且其超时时间也刚好到达，此时我们也要处理定时任务，并重置定时时间*/</span></span><br><span class="line">	<span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">		timeout = TIMEOUT;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//handle connections</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="11-4-高性能计时器"><a href="#11-4-高性能计时器" class="headerlink" title="11.4 高性能计时器"></a>11.4 高性能计时器</h4><h5 id="11-4-1-时间轮"><a href="#11-4-1-时间轮" class="headerlink" title="11.4.1 时间轮"></a>11.4.1 时间轮</h5><p>前文提到，基于排序链表的定时器存在一个问题：添加定时器的效率偏低。</p>
<p>下面我们要讨论的时间轮解决了这个问题。一种简单的时 间轮如图11-1所示。</p>
<img src="高性能服务器框架/image-20230305172536051.png" alt="image-20230305172536051" style="zoom:67%;" />



<p>图11-1所示的时间轮内，（实线）指针指向轮子上的一个槽 （slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽 （虚线指针指向的槽），每次转动称为一个滴答（tick）。一个滴答的 时间称为时间轮的槽间隔si（slot interval），它实际上就是心搏时间。该时间轮共有N个槽，因此它运转一周的时间是<code>N*si</code>。每个槽指向一条 定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间 相差<code>N*si</code>的整数倍。</p>
<p>时间轮正是利用这个关系将定时器散列到不同的 链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时 器，则该定时器将被插入槽ts（timer slot）对应的链表中：</p>
<p><strong>ts = (cs + (ti / si)) % N</strong></p>
<p>很显然，对时间轮而言，要提高定时精度，就要使si值足够小；要 提高执行效率，则要求N值足够大。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIME_WHEEL_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_WHEEL_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">	sockaddr_in address;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	tw_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	tw_timer(<span class="keyword">int</span> rot, <span class="keyword">int</span> ts): next(<span class="literal">nullptr</span>), prev(<span class="literal">nullptr</span>), rotation(rot), time_slot(ts) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">int</span> rotation;<span class="comment">/*记录定时器在时间轮转多少圈后生效*/</span></span><br><span class="line">	<span class="keyword">int</span> time_slot;<span class="comment">/*记录定时器属于时间轮上哪个槽（对应的链表，下同）*/</span></span><br><span class="line">	<span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*定时器回调函数*/</span></span><br><span class="line">	client_data *user_data&#123;&#125;;<span class="comment">/*客户数据*/</span></span><br><span class="line">	tw_timer *next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">	tw_timer *prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_wheel</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	time_wheel() : cur_slot(<span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">			slots[i] = <span class="literal">nullptr</span>;<span class="comment">/*初始化每个槽的头结点*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~time_wheel() &#123;</span><br><span class="line">	<span class="comment">/*遍历每个槽，并销毁其中的定时器*/</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">auto</span> &amp; slot : slots) &#123;</span><br><span class="line">			tw_timer *tmp = slot;</span><br><span class="line">			<span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">				slot = tmp-&gt;next;</span><br><span class="line">				<span class="keyword">delete</span> tmp;</span><br><span class="line">				tmp = slot;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*根据定时值timeout创建一个定时器，并把它插入合适的槽中*/</span></span><br><span class="line">	<span class="function">tw_timer *<span class="title">add_timer</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ticks = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/*下面根据待插入定时器的超时值计算它将在时间轮转动多少个滴答后被触发，并将该</span></span><br><span class="line"><span class="comment">		滴答数存储于变量ticks中。如果待插入定时器的超时值小于时间轮的槽间隔SI，则将</span></span><br><span class="line"><span class="comment">		ticks向上折合为1，否则就将ticks向下折合为timeout/SI*/</span></span><br><span class="line">		<span class="keyword">if</span> (timeout &lt; SI) &#123;</span><br><span class="line">			ticks = <span class="number">1</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			ticks = timeout / SI;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*计算待插入的定时器在时间轮转动多少圈后被触发*/</span></span><br><span class="line">		<span class="keyword">int</span> rotation = ticks / N;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*计算待插入的定时器应该被插入哪个槽中*/</span></span><br><span class="line">		<span class="keyword">int</span> ts = (cur_slot + (ticks % N)) % N;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*创建新的定时器，它在时间轮转动rotation圈之后被触发，且位于第ts个槽上*/</span></span><br><span class="line">		tw_timer *timer = <span class="keyword">new</span> tw_timer(rotation, ts);</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*如果第ts个槽中尚无任何定时器，则把新建的定时器插入其中，并将该定时器设置为该槽的头结点*/</span></span><br><span class="line">		<span class="keyword">if</span> (!slots[ts]) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;add timer,rotation is%d,ts is%d,cur_slotis%d\n&quot;</span>, rotation, ts, cur_slot);</span><br><span class="line">			slots[ts] = timer;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*否则，将定时器插入第ts个槽中*/</span></span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			timer-&gt;next = slots[ts];</span><br><span class="line">			slots[ts]-&gt;prev = timer;</span><br><span class="line">			slots[ts] = timer;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> timer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(tw_timer *timer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">int</span> ts = timer-&gt;time_slot;</span><br><span class="line">		<span class="comment">/*slots[ts]是目标定时器所在槽的头结点。如果目标定时器就是该头结点，则需要重置第ts个槽的头结点*/</span></span><br><span class="line">		<span class="keyword">if</span> (timer == slots[ts]) &#123;</span><br><span class="line">			slots[ts] = slots[ts]-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (slots[ts]) &#123;</span><br><span class="line">				slots[ts]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> timer;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">			<span class="keyword">if</span> (timer-&gt;next) &#123;</span><br><span class="line">				timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">delete</span> timer;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*SI时间到后，调用该函数，时间轮向前滚动一个槽的间隔*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		tw_timer *tmp = slots[cur_slot];<span class="comment">/*取得时间轮上当前槽的头结点*/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;current slot is%d\n&quot;</span>, cur_slot);</span><br><span class="line">		<span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;tick the timer once\n&quot;</span>);</span><br><span class="line">			<span class="comment">/*如果定时器的rotation值大于0，则它在这一轮不起作用*/</span></span><br><span class="line">			<span class="keyword">if</span> (tmp-&gt;rotation &gt; <span class="number">0</span>) &#123;</span><br><span class="line">				tmp-&gt;rotation--;</span><br><span class="line">				tmp = tmp-&gt;next;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*否则，说明定时器已经到期，于是执行定时任务，然后删除该定时器*/</span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line">				<span class="keyword">if</span> (tmp == slots[cur_slot]) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;delete header in cur_slot\n&quot;</span>);</span><br><span class="line">					slots[cur_slot] = tmp-&gt;next;</span><br><span class="line">					<span class="keyword">delete</span> tmp;</span><br><span class="line">					<span class="keyword">if</span> (slots[cur_slot]) &#123;</span><br><span class="line">						slots[cur_slot]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					tmp = slots[cur_slot];</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					tmp-&gt;prev-&gt;next = tmp-&gt;next;</span><br><span class="line">					<span class="keyword">if</span> (tmp-&gt;next) &#123;</span><br><span class="line">						tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">					&#125;</span><br><span class="line">					tw_timer *tmp2 = tmp-&gt;next;</span><br><span class="line">					<span class="keyword">delete</span> tmp;</span><br><span class="line">					tmp = tmp2;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		cur_slot = ++cur_slot % N;<span class="comment">/*更新时间轮的当前槽，以反映时间轮的转动*/</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*时间轮上槽的数目*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*每1 s时间轮转动一次，即槽间隔为1 s*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SI = <span class="number">1</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*时间轮的槽，其中每个元素指向一个定时器链表，链表无序*/</span></span><br><span class="line">	tw_timer *slots[N]&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">int</span> cur_slot;<span class="comment">/*时间轮的当前槽*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TIME_WHEEL_TIMER_H</span></span></span><br></pre></td></tr></table></figure>

<p><strong>可见，对时间轮而言，添加一个定时器的时间复杂度是O（1）， 删除一个定时器的时间复杂度也是O（1），执行一个定时器的时间复 杂度是O（n）。</strong>但实际上执行一个定时器任务的效率要比O（n）好得 多，因为时间轮将所有的定时器散列到了不同的链表上。时间轮的槽 越多，等价于散列表的入口（entry）越多，从而每条链表上的定时器 数量越少。</p>
<h5 id="11-4-2-时间堆"><a href="#11-4-2-时间堆" class="headerlink" title="11.4.2 时间堆"></a>11.4.2 时间堆</h5><p>设计 定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器。<strong>然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。</strong></p>
<p>最小堆很适合处理这种定时方案。最小堆是指每个节点的值都小 于或等于其子节点的值的完全二叉树。图11-2给出了一个具有6个元素 的最小堆。</p>
<img src="高性能服务器框架/image-20230305174923066.png" alt="image-20230305174923066" style="zoom:33%;" />



<p>由于最小堆是一种完全二叉树，所以我们可以用数组来组织其中 的元素。</p>
<p>比如，图11-2所示的最小堆可以用图11-5所示的数组来表示。 <strong>对于数组中的任意一个位置i上的元素，其左儿子节点在位置2i+1上， 其右儿子节点在位置2i+2上，其父节点则在位置[（i-1）/2]（i＞0） 上</strong>。与用链表来表示堆相比，用数组表示堆不仅节省空间，而且更容 易实现堆的插入、删除等操作[5]。</p>
<img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230305175239841-1678341964417.png" class="" title="image-20230305175239841">

<p>假设我们已经有一个包含N个元素的数组，现在要把它初始化为一 个最小堆。那么最简单的方法是：初始化一个空堆，然后将数组中的 每个元素插入该堆中。不过这样做的效率偏低。</p>
<p>实际上，我们只需要 对数组中的第[（N-1）/2]～0个元素执行下虑操作，即可确保该数组构 成一个最小堆。这是因为对包含N个元素的完全二叉树而言，它具有 [（N-1）/2]个非叶子节点，这些非叶子节点正是该完全二叉树的第0～ [（N-1）/2]个节点。我们只要确保这些非叶子节点构成的子树都具有 堆序性质，整个树就具有堆序性质。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MIN_HEAP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_HEAP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::exception;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span>;</span><span class="comment">/*前向声明*/</span></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">	sockaddr_in address;</span><br><span class="line">	<span class="keyword">int</span> sockfd;</span><br><span class="line">	<span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">	heap_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">heap_timer</span><span class="params">(<span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">		expire = time(<span class="literal">nullptr</span>) + delay;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">time_t</span> expire;<span class="comment">/*定时器生效的绝对时间*/</span></span><br><span class="line">	<span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*定时器的回调函数*/</span></span><br><span class="line">	client_data *user_data&#123;&#125;;<span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时间堆类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_heap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*构造函数之一，初始化一个大小为cap的空堆*/</span></span><br><span class="line">	explicit time_heap(int cap) throw(std::exception): capacity(cap), cur_size(0) &#123;</span><br><span class="line">		<span class="built_in">array</span> = <span class="keyword">new</span> heap_timer *[capacity];<span class="comment">/*创建堆数组*/</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line">			<span class="built_in">array</span>[i] = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*构造函数之二，用已有数组来初始化堆*/</span></span><br><span class="line">	time_heap(heap_timer **init_array, <span class="keyword">int</span> size, <span class="keyword">int</span> capacity) <span class="keyword">throw</span></span><br><span class="line">	(<span class="built_in">std</span>::exception): cur_size(size), capacity(capacity) &#123;</span><br><span class="line">		<span class="keyword">if</span> (capacity &lt; size) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">array</span> = <span class="keyword">new</span> heap_timer *[capacity];<span class="comment">/*创建堆数组*/</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line">			<span class="built_in">array</span>[i] = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*初始化堆数组*/</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">				<span class="built_in">array</span>[i] = init_array[i];</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = (cur_size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;<span class="comment">/*对数组中的第[(cur_size-1)/2]～0个元素执行下虑操作*/</span></span><br><span class="line">				percolate_down(i);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*销毁时间堆*/</span></span><br><span class="line">	~time_heap() &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line">			<span class="keyword">delete</span> <span class="built_in">array</span>[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*添加目标定时器timer*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(heap_timer *timer)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (cur_size &gt;= capacity)<span class="comment">/*如果当前堆数组容量不够，则将其扩大1倍*/</span></span><br><span class="line">		&#123;</span><br><span class="line">			resize();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*新插入了一个元素，当前堆大小加1，hole是新建空穴的位置*/</span></span><br><span class="line">		<span class="keyword">int</span> hole = cur_size++;</span><br><span class="line">		<span class="keyword">int</span> parent = <span class="number">0</span>;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/*对从空穴到根节点的路径上的所有节点执行上虑操作*/</span></span><br><span class="line">		<span class="keyword">for</span> (; hole &gt; <span class="number">0</span>; hole = parent) &#123;</span><br><span class="line">			parent = (hole - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[parent]-&gt;expire &lt;= timer-&gt;expire) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="built_in">array</span>[hole] = <span class="built_in">array</span>[parent];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">array</span>[hole] = timer;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(heap_timer *timer)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (!timer) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*仅仅将目标定时器的回调函数设置为空，即所谓的延迟销毁。这将节省真正删除该定</span></span><br><span class="line"><span class="comment">		时器造成的开销，但这样做容易使堆数组膨胀*/</span></span><br><span class="line">		timer-&gt;cb_func = <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*获得堆顶部的定时器*/</span></span><br><span class="line">	<span class="function">heap_timer *<span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*删除堆顶部的定时器*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">pop_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (empty()) &#123;</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]) &#123;</span><br><span class="line">			<span class="keyword">delete</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">			<span class="comment">/*将原来的堆顶元素替换为堆数组中最后一个元素*/</span></span><br><span class="line">			<span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[--cur_size];</span><br><span class="line">			percolate_down(<span class="number">0</span>);<span class="comment">/*对新的堆顶元素执行下虑操作*/</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*心搏函数*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		heap_timer *tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">		<span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>);<span class="comment">/*循环处理堆中到期的定时器*/</span></span><br><span class="line">		<span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*如果堆顶定时器没到期，则退出循环*/</span></span><br><span class="line">			<span class="keyword">if</span> (tmp-&gt;expire &gt; cur) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*否则就执行堆顶定时器中的任务*/</span></span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func) &#123;</span><br><span class="line">				<span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func(<span class="built_in">array</span>[<span class="number">0</span>]-&gt;user_data);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*将堆顶元素删除，同时生成新的堆顶定时器（array[0]）*/</span></span><br><span class="line">			pop_timer();</span><br><span class="line">			tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> cur_size == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*最小堆的下虑操作，它确保堆数组中以第hole个节点作为根的子树拥有最小堆性质*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">percolate_down</span><span class="params">(<span class="keyword">int</span> hole)</span> </span>&#123;</span><br><span class="line">		heap_timer *temp = <span class="built_in">array</span>[hole];</span><br><span class="line">		<span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">for</span> (; ((hole * <span class="number">2</span> + <span class="number">1</span>) &lt;= (cur_size - <span class="number">1</span>)); hole = child) &#123;</span><br><span class="line">			child = hole * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">			<span class="keyword">if</span> ((child &lt; (cur_size - <span class="number">1</span>)) &amp;&amp; (<span class="built_in">array</span>[child + <span class="number">1</span>]-&gt;expire &lt; <span class="built_in">array</span>[child]-&gt;expire)) &#123;</span><br><span class="line">				++child;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">if</span> (<span class="built_in">array</span>[child]-&gt;expire &lt; temp-&gt;expire) &#123;</span><br><span class="line">				<span class="built_in">array</span>[hole] = <span class="built_in">array</span>[child];</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">array</span>[hole] = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*将堆数组容量扩大1倍*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">auto</span> **temp = <span class="keyword">new</span> heap_timer *[<span class="number">2</span> * capacity];</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * capacity; ++i) &#123;</span><br><span class="line">			temp[i] = <span class="literal">NULL</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!temp) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line">		capacity = <span class="number">2</span> * capacity;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line">			temp[i] = <span class="built_in">array</span>[i];</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line">		<span class="built_in">array</span> = temp;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	heap_timer **<span class="built_in">array</span>;<span class="comment">/*堆数组*/</span></span><br><span class="line">	<span class="keyword">int</span> capacity;<span class="comment">/*堆数组的容量*/</span></span><br><span class="line">	<span class="keyword">int</span> cur_size;<span class="comment">/*堆数组当前包含元素的个数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>由代码清单11-6可见，对时间堆而言，添加一个定时器的时间复杂 度是O（lgn），删除一个定时器的时间复杂度是O（1），执行一个定 时器的时间复杂度是O（1）。因此，时间堆的效率是很高的。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">okeyia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://okeyia.github.io/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/">http://okeyia.github.io/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://okeyia.github.io" target="_blank">okeyia</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">服务器编程</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"><img class="prev-cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091408284.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">三 高性能服务器编程</div></div></a></div><div class="next-post pull-right"><a href="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091414085.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">一 TCP/IP协议详解</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/03/11/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E4%B8%8E%E6%A3%80%E6%B5%8B/" title="四 性能检测和优化"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303101636855.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-11</div><div class="title">四 性能检测和优化</div></div></a></div><div><a href="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" title="一 TCP/IP协议详解"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091414085.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-09</div><div class="title">一 TCP/IP协议详解</div></div></a></div><div><a href="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/" title="三 高性能服务器编程"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091408284.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-02-10</div><div class="title">三 高性能服务器编程</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AF%87-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6"><span class="toc-text">第二篇 高性能服务器框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC5%E7%AB%A0-Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80API"><span class="toc-text">第5章 Linux网络编程基础API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-socket%E5%9C%B0%E5%9D%80API"><span class="toc-text">5.1 socket地址API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-1-%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="toc-text">5.1.1 主机字节序和网络字节序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-2-%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-text">5.1.2 通用socket地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-3-%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="toc-text">5.1.3 专用socket地址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-1-4-IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="toc-text">5.1.4 IP地址转换函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-%E5%88%9B%E5%BB%BAsocket"><span class="toc-text">5.2 创建socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%91%BD%E5%90%8Dsocket"><span class="toc-text">5.3 命名socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E7%9B%91%E5%90%ACsocket"><span class="toc-text">5.4 监听socket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="toc-text">5.5 接受连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5"><span class="toc-text">5.6 发起连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="toc-text">5.7 关闭连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-text">5.8 数据读写</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-8-1-TCP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-text">5.8.1 TCP数据读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-8-2-UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="toc-text">5.8.2 UDP数据读写</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-8-3-%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="toc-text">5.8.3 通用数据读写函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0"><span class="toc-text">5.9 带外标记</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10-%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="toc-text">5.10 地址信息函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-11-socket-%E9%80%89%E9%A1%B9"><span class="toc-text">5.11 socket 选项</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-11-1-SO-REUSEADDR%E9%80%89%E9%A1%B9"><span class="toc-text">5.11.1 SO_REUSEADDR选项</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-11-4-SO-LINGER%E9%80%89%E9%A1%B9"><span class="toc-text">5.11.4 SO_LINGER选项</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-12-%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AFAPI"><span class="toc-text">5.12 网络信息API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-12-1-gethostbyname%E5%92%8Cgethostbyaddr"><span class="toc-text">5.12.1 gethostbyname和gethostbyaddr</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-12-2-getservbyname%E5%92%8Cgetservbyport"><span class="toc-text">5.12.2 getservbyname和getservbyport</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-12-3-getaddrinfo"><span class="toc-text">5.12.3 getaddrinfo</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC6%E7%AB%A0-%E9%AB%98%E7%BA%A7I-O%E5%87%BD%E6%95%B0"><span class="toc-text">第6章 高级I&#x2F;O函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-pipe%E5%87%BD%E6%95%B0"><span class="toc-text">6.1 pipe函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-dup-%E5%87%BD%E6%95%B0%E5%92%8Cdup2%E5%87%BD%E6%95%B0"><span class="toc-text">6.2 dup 函数和dup2函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-readv%E5%87%BD%E6%95%B0%E5%92%8Cwritev%E5%87%BD%E6%95%B0"><span class="toc-text">6.3 readv函数和writev函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-sendfile%E5%87%BD%E6%95%B0"><span class="toc-text">6.4 sendfile函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-mmap%E5%87%BD%E6%95%B0%E5%92%8Cnummap%E5%87%BD%E6%95%B0"><span class="toc-text">6.5 mmap函数和nummap函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-splice%E5%87%BD%E6%95%B0"><span class="toc-text">6.6 splice函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-7-tee%E5%87%BD%E6%95%B0"><span class="toc-text">6.7 tee函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-8-fcntl%E5%87%BD%E6%95%B0"><span class="toc-text">6.8 fcntl函数</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC7%E7%AB%A0-Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E8%A7%84%E8%8C%83"><span class="toc-text">第7章 Linux服务器程序规范</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-%E6%97%A5%E5%BF%97"><span class="toc-text">7.1 日志</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-1-Linux%E7%B3%BB%E7%BB%9F%E6%97%A5%E5%BF%97"><span class="toc-text">7.1.1 Linux系统日志</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-1-2-syslog-%E5%87%BD%E6%95%B0"><span class="toc-text">7.1.2 syslog 函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-%E7%94%A8%E6%88%B7%E4%BF%A1%E6%81%AF"><span class="toc-text">7.2 用户信息</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-1-UID%E3%80%81EUID%E5%92%8CEGID"><span class="toc-text">7.2.1 UID、EUID和EGID</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-2-2-%E5%88%87%E6%8D%A2%E7%94%A8%E6%88%B7"><span class="toc-text">7.2.2 切换用户</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-%E8%BF%9B%E7%A8%8B%E9%97%B4%E5%85%B3%E7%B3%BB"><span class="toc-text">7.3 进程间关系</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-1-%E8%BF%9B%E7%A8%8B%E7%BB%84"><span class="toc-text">7.3.1 进程组</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-%E4%BC%9A%E8%AF%9D%EF%BC%88session%EF%BC%89"><span class="toc-text">7.3.2 会话（session）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-3-%E7%94%A8ps%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8B%E8%BF%9B%E7%A8%8B%E5%85%B3%E7%B3%BB"><span class="toc-text">7.3.3 用ps命令查看进程关系</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90%E9%99%90%E5%88%B6"><span class="toc-text">7.4 系统资源限制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-%E6%94%B9%E5%8F%98%E5%B7%A5%E4%BD%9C%E7%9B%AE%E5%BD%95%E5%92%8C%E6%A0%B9%E7%9B%AE%E5%BD%95"><span class="toc-text">7.5 改变工作目录和根目录</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E5%90%8E%E5%8F%B0%E5%8C%96"><span class="toc-text">7.6 服务器程序后台化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC8%E7%AB%A0-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6"><span class="toc-text">第8章 高性能服务器程序框架</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text">8.1 服务器模型</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-1-C-S-%E6%A8%A1%E5%9E%8B"><span class="toc-text">8.1.1 C&#x2F;S 模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-1-2-P2P%E6%A8%A1%E5%9E%8B"><span class="toc-text">8.1.2 P2P模型</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A1%86%E6%9E%B6"><span class="toc-text">8.2 服务器编程框架</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-I-O%E6%A8%A1%E5%9E%8B"><span class="toc-text">8.3 I&#x2F;O模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.4 两种高效的事件处理模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-1-Reactor%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.4.1 Reactor模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-2-Proactor%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.4.2 Proactor模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-3-%E6%A8%A1%E6%8B%9FProactor%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.4.3 模拟Proactor模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E4%B8%A4%E7%A7%8D%E9%AB%98%E6%95%88%E7%9A%84%E5%B9%B6%E5%8F%91%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.5 两种高效的并发模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-5-1-%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.5.1 半同步&#x2F;半异步模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-5-2-%E9%A2%86%E5%AF%BC%E8%80%85-%E8%BF%BD%E9%9A%8F%E8%80%85%E6%A8%A1%E5%BC%8F"><span class="toc-text">8.5.2 领导者&#x2F;追随者模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA"><span class="toc-text">8.6 有限状态机</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-6-1-%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA%E5%AE%9E%E4%BE%8B"><span class="toc-text">8.6.1 有限状态机实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-7-%E6%8F%90%E9%AB%98%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E5%85%B6%E4%BB%96%E5%BB%BA%E8%AE%AE"><span class="toc-text">8.7 提高服务器的其他建议</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-7-1-%E6%B1%A0"><span class="toc-text">8.7.1 池</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-7-2-%E6%95%B0%E6%8D%AE%E5%A4%8D%E5%88%B6"><span class="toc-text">8.7.2 数据复制</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-7-3-%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2%E5%92%8C%E9%94%81"><span class="toc-text">8.7.3 上下文切换和锁</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC9%E7%AB%A0-I-O%E5%A4%8D%E7%94%A8"><span class="toc-text">第9章 I&#x2F;O复用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-select%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">9.1 select系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-1-select-API"><span class="toc-text">9.1.1 select API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-2-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E5%B0%B1%E7%BB%AA%E6%9D%A1%E4%BB%B6"><span class="toc-text">9.1.2 文件描述符就绪条件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-3-%E5%A4%84%E7%90%86%E5%B8%A6%E5%A4%96%E6%95%B0%E6%8D%AE"><span class="toc-text">9.1.3 处理带外数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-poll%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">9.2 poll系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-epoll%E7%B3%BB%E5%88%97%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">9.3 epoll系列系统调用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-1-%E5%86%85%E6%A0%B8%E4%BA%8B%E4%BB%B6%E8%A1%A8"><span class="toc-text">9.3.1 内核事件表</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-2-epoll-wait%E5%87%BD%E6%95%B0"><span class="toc-text">9.3.2 epoll_wait函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-3-LT%E5%92%8CET%E6%A8%A1%E5%BC%8F"><span class="toc-text">9.3.3 LT和ET模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-4-EPOLLONESHOT%E4%BA%8B%E4%BB%B6"><span class="toc-text">9.3.4 EPOLLONESHOT事件</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-%E4%B8%89%E7%BB%84I-O%E5%A4%8D%E7%94%A8%E5%87%BD%E6%95%B0%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-text">9.4 三组I&#x2F;O复用函数的比较</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-5-I-O%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%80%EF%BC%9A%E9%9D%9E%E9%98%BB%E5%A1%9Econnect"><span class="toc-text">9.5 I&#x2F;O复用的高级应用一：非阻塞connect</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-6-I-O%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%BA%8C%EF%BC%9A%E8%81%8A%E5%A4%A9%E5%AE%A4%E7%A8%8B%E5%BA%8F"><span class="toc-text">9.6 I&#x2F;O复用的高级应用二：聊天室程序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-6-1-%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-text">9.6.1 客户端</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-6-2-%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-text">9.6.2 服务端</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-7-I-O-%E5%A4%8D%E7%94%A8%E7%9A%84%E9%AB%98%E7%BA%A7%E5%BA%94%E7%94%A8%E4%B8%89-%E5%90%8C%E6%97%B6%E5%A4%84%E7%90%86TCP%E5%92%8CUDP%E6%9C%8D%E5%8A%A1"><span class="toc-text">9.7 I&#x2F;O 复用的高级应用三: 同时处理TCP和UDP服务</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-8-%E8%B6%85%E7%BA%A7%E6%9C%8D%E5%8A%A1xinetd"><span class="toc-text">9.8 超级服务xinetd</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-8-1-xinetd-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-text">9.8.1 xinetd 配置文件</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-8-2-xinetd-%E6%9C%8D%E5%8A%A1%E6%B5%81%E7%A8%8B"><span class="toc-text">9.8.2 xinetd 服务流程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC10%E7%AB%A0-%E4%BF%A1%E5%8F%B7"><span class="toc-text">第10章 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-Linux%E4%BF%A1%E5%8F%B7%E6%A6%82%E8%BF%B0"><span class="toc-text">10.1 Linux信号概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-1-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7"><span class="toc-text">10.1.1 发送信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-2-%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86%E6%96%B9%E5%BC%8F"><span class="toc-text">10.1.2 信号处理方式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-3-Linux%E4%BF%A1%E5%8F%B7"><span class="toc-text">10.1.3 Linux信号</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-1-4-%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">10.1.4 中断系统调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E4%BF%A1%E5%8F%B7%E5%87%BD%E6%95%B0"><span class="toc-text">10.2 信号函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-2-1-signal%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">10.2.1 signal系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-2-2-sigaction%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">10.2.2 sigaction系统调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E4%BF%A1%E5%8F%B7%E9%9B%86"><span class="toc-text">10.3 信号集</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-1-%E4%BF%A1%E5%8F%B7%E9%9B%86%E5%87%BD%E6%95%B0"><span class="toc-text">10.3.1 信号集函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-2-%E8%BF%9B%E7%A8%8B%E4%BF%A1%E5%8F%B7%E6%8E%A9%E7%A0%81"><span class="toc-text">10.3.2 进程信号掩码</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-3-%E8%A2%AB%E6%8C%82%E8%B5%B7%E7%9A%84%E4%BF%A1%E5%8F%B7"><span class="toc-text">10.3.3 被挂起的信号</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-%E7%BB%9F%E4%B8%80%E4%BA%8B%E4%BB%B6%E6%BA%90"><span class="toc-text">10.4 统一事件源</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-5-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9B%B8%E5%85%B3%E4%BF%A1%E5%8F%B7"><span class="toc-text">10.5 网络编程相关信号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-5-1-SIGHUP"><span class="toc-text">10.5.1 SIGHUP</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-5-2-SIGPIPE"><span class="toc-text">10.5.2 SIGPIPE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-5-3-SIGURG"><span class="toc-text">10.5.3 SIGURG</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC11%E7%AB%A0-%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">第11章 定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-1-socket%E9%80%89%E9%A1%B9SO-RCVTIMEO%E5%92%8C-SO-SNDTIMEO"><span class="toc-text">11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-SIGALRM-%E4%BF%A1%E5%8F%B7"><span class="toc-text">11.2 SIGALRM 信号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-2-1-%E5%9F%BA%E4%BA%8E%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">11.2.1 基于升序链表的定时器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-2-2-%E5%A4%84%E7%90%86%E9%9D%9E%E6%B4%BB%E5%8A%A8%E8%BF%9E%E6%8E%A5"><span class="toc-text">11.2.2 处理非活动连接</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-3-I-O%E5%A4%8D%E7%94%A8%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8%E7%9A%84%E8%B6%85%E6%97%B6%E5%8F%82%E6%95%B0"><span class="toc-text">11.3 I&#x2F;O复用系统调用的超时参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-%E9%AB%98%E6%80%A7%E8%83%BD%E8%AE%A1%E6%97%B6%E5%99%A8"><span class="toc-text">11.4 高性能计时器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#11-4-1-%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="toc-text">11.4.1 时间轮</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#11-4-2-%E6%97%B6%E9%97%B4%E5%A0%86"><span class="toc-text">11.4.2 时间堆</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By okeyia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>