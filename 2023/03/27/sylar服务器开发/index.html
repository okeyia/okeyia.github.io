<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>sylar服务器开发 | okeyia</title><meta name="keywords" content="C++,服务器开发"><meta name="author" content="okeyia"><meta name="copyright" content="okeyia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="sylar服务器开发〇 开发环境cmake  clang++ clion + ubuntu 参考链接:    从零开始重写sylar C++高性能分布式服务器框架 的copy, 原因有二,  一是怕作者的网站什么时候挂了,  二是写下来加深一下自己的理解。  一 日志系统日志模块概述 用于格式化输出程序日志，方便从日志中定位程序运行过程中出现的问题。这里的日志除了日志内容本身之外，还应该包括文件名">
<meta property="og:type" content="article">
<meta property="og:title" content="sylar服务器开发">
<meta property="og:url" content="http://okeyia.github.io/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/index.html">
<meta property="og:site_name" content="okeyia">
<meta property="og:description" content="sylar服务器开发〇 开发环境cmake  clang++ clion + ubuntu 参考链接:    从零开始重写sylar C++高性能分布式服务器框架 的copy, 原因有二,  一是怕作者的网站什么时候挂了,  二是写下来加深一下自己的理解。  一 日志系统日志模块概述 用于格式化输出程序日志，方便从日志中定位程序运行过程中出现的问题。这里的日志除了日志内容本身之外，还应该包括文件名">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303270940537.png">
<meta property="article:published_time" content="2023-03-27T01:38:49.000Z">
<meta property="article:modified_time" content="2023-03-27T01:40:23.280Z">
<meta property="article:author" content="okeyia">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="服务器开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303270940537.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://okeyia.github.io/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'sylar服务器开发',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-03-27 09:40:23'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="okeyia" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202204171749626.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">32</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">22</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303270940537.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">okeyia</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">sylar服务器开发</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-27T01:38:49.000Z" title="发表于 2023-03-27 09:38:49">2023-03-27</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-27T01:40:23.280Z" title="更新于 2023-03-27 09:40:23">2023-03-27</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="sylar服务器开发"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h2 id="sylar服务器开发"><a href="#sylar服务器开发" class="headerlink" title="sylar服务器开发"></a>sylar服务器开发</h2><h3 id="〇-开发环境"><a href="#〇-开发环境" class="headerlink" title="〇 开发环境"></a>〇 开发环境</h3><p>cmake </p>
<p>clang++</p>
<p>clion + ubuntu</p>
<p>参考链接: </p>
<ol>
<li> <a target="_blank" rel="noopener" href="https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952">从零开始重写sylar C++高性能分布式服务器框架</a> 的copy, 原因有二,  一是怕作者的网站什么时候挂了,  二是写下来加深一下自己的理解。</li>
</ol>
<h3 id="一-日志系统"><a href="#一-日志系统" class="headerlink" title="一 日志系统"></a>一 日志系统</h3><p>日志模块概述</p>
<p>用于格式化输出程序日志，方便从日志中定位程序运行过程中出现的问题。这里的日志除了日志内容本身之外，还应该包括文件名/行号，时间戳，线程/协程号，模块名称，日志级别等额外信息，甚至在打印致命的日志时，还应该附加程序的栈回溯信息，以便于分析和排查问题。</p>
<p>从设计上看，一个完整的日志模块应该具备以下功能：</p>
<ol>
<li><p>区分不同的级别，比如常的DEBUG/INFO/WARN/ERROR等级别。日志模块可以通过指定级别实现只输出某个级别以上的日志，这样可以灵活开关一些不重要的日志输出，比如程序在调试阶段可以设置一个较低的级别，以便看到更多的调度日志信息，程序发布之后可以设置一个较高的级别，以减少日志输出，提高性能。</p>
</li>
<li><p>区分不同的输出地。不同的日志可以输出到不同的位置，比如可以输出到标准输出，输出到文件，输出到syslog，输出到网络上的日志服务器等，甚至同一条日志可以同时输出到多个输出地。</p>
</li>
<li><p>区分不同的类别。日志可以分类并命名，一个程序的各个模块可以使用不同的名称来输出日志，这样可以很方便地判断出当前日志是哪个程序模块输出的。</p>
</li>
<li><p>日志格式可灵活配置。可以按需指定每条日志是否包含文件名/行号、时间戳、线程/协程号、日志级别、启动时间等内容。</p>
</li>
<li><p>可通过配置文件的方式配置以上功能。</p>
</li>
</ol>
<h4 id="1-1-日志模块设计"><a href="#1-1-日志模块设计" class="headerlink" title="1.1 日志模块设计"></a>1.1 日志模块设计</h4><p>首先是日志级别，这个参考log4cpp即可，一共定义以下几个级别：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Level</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    FATAL  = <span class="number">0</span>,				<span class="comment">/// 致命情况，系统不可用</span></span><br><span class="line">    ALERT  = <span class="number">100</span>,			<span class="comment">/// 高优先级情况，例如数据库系统崩溃</span></span><br><span class="line">    CRIT   = <span class="number">200</span>,			<span class="comment">/// 严重错误，例如硬盘错误</span></span><br><span class="line">    ERROR  = <span class="number">300</span>,			<span class="comment">/// 错误</span></span><br><span class="line">    WARN   = <span class="number">400</span>,			<span class="comment">/// 警告 </span></span><br><span class="line">    NOTICE = <span class="number">500</span>,			<span class="comment">/// 正常但值得注意</span></span><br><span class="line">    INFO   = <span class="number">600</span>,			<span class="comment">/// 一般信息 </span></span><br><span class="line">    DEBUG  = <span class="number">700</span>,			<span class="comment">/// 调试信息</span></span><br><span class="line">    NOTSET = <span class="number">800</span>,			<span class="comment">/// 未设置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>接下来是关键的几个类: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogFormatter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogAppender</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogEvent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogEventWrap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogManager</span>;</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>LogFormatter</code>: 日志格式器，与log4cpp的PatternLayout对应，用于格式化一个日志事件。该类构建时可以指定pattern，表示如何进行格式化。提供format方法，用于将日志事件格式化成字符串。</p>
</li>
<li><p><code>LogAppender</code>: 日志输出器，用于将一个日志事件输出到对应的输出地。该类内部包含一个LogFormatter成员和一个log方法，日志事件先经过LogFormatter格式化后再输出到对应的输出地。从这个类可以派生出不同的Appender类型，比如StdoutLogAppender和FileLogAppender，分别表示输出到终端和文件。</p>
</li>
<li><p><code>Logger</code>: 日志器，负责进行日志输出。一个Logger包含多个LogAppender和一个日志级别，提供log方法，<strong>传入日志事件，判断该日志事件的级别高于日志器本身的级别之后调用LogAppender将日志进行输出</strong>，否则该日志被抛弃。</p>
</li>
<li><p><code>LogEvent</code>: 日志事件，用于记录日志现场，比如该日志的级别，文件名/行号，日志消息，线程/协程号，所属日志器名称等。</p>
</li>
<li><p><code>LogEventWrap</code>: 日志事件包装类，其实就是将日志事件和日志器包装到一起，因为一条日志只会在一个日志器上进行输出。将日志事件和日志器包装到一起后，方便通过宏定义来简化日志模块的使用。另外，LogEventWrap还负责在构建时指定日志事件和日志器，在析构时调用日志器的log方法将日志事件进行输出。</p>
</li>
<li><p><code>LogManager</code>: 日志器管理类，单例模式，用于统一管理所有的日志器，提供日志器的创建与获取方法。LogManager自带一个root Logger，用于为日志模块提供一个初始可用的日志器。</p>
<blockquote>
<p>单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p>
</blockquote>
</li>
</ul>
<h4 id="1-2-日志模块工作流程"><a href="#1-2-日志模块工作流程" class="headerlink" title="1.2 日志模块工作流程"></a>1.2 日志模块工作流程</h4><p>至此，日志模块的设计就基本结束了，总结一下日志模块的工作流程：</p>
<ol>
<li><p>初始化LogFormatter，LogAppender, Logger。</p>
</li>
<li><p>通过宏定义提供<strong>流式风格和格式化风格</strong>的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，并且将日志事件和日志器Logger包装到一起，生成一个LogEventWrap对象。</p>
</li>
<li><p>日志接口执行结束后，LogEventWrap对象析构，在析构函数里调用Logger的log方法将日志事件进行输出。</p>
</li>
</ol>
<h4 id="1-3-日志关键模块实现"><a href="#1-3-日志关键模块实现" class="headerlink" title="1.3 日志关键模块实现"></a>1.3 日志关键模块实现</h4><h5 id="1-3-1-LogEvent"><a href="#1-3-1-LogEvent" class="headerlink" title="1.3.1 LogEvent"></a>1.3.1 LogEvent</h5><p>日志事件, 用来记录日志现场, 具体包含以下内容:</p>
<ul>
<li>日志内容</li>
<li>日志器名称</li>
<li>日志级别</li>
<li>文件名, 对应 <code>__FILE_</code>_ 宏</li>
<li>行号, 对应 <code>__LINE__</code> 宏</li>
<li>程序运行时间，通过sylar::GetElapsedMS()获取</li>
<li>线程ID</li>
<li>协程ID</li>
<li>UTC时间戳, 对应time(0) : 是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数</li>
<li>线程名称</li>
</ul>
<p>日志事件的构造需要通过宏来简化，否则，每次生成一个日志事件时都要对上面这些内容进行赋值，够麻烦的。</p>
<h5 id="1-3-2-LogFormatter"><a href="#1-3-2-LogFormatter" class="headerlink" title="1.3.2 LogFormatter"></a>1.3.2 LogFormatter</h5><p><strong>日志格式器，用于格式化一个日志事件，将其转化成一串字符串。</strong> </p>
<p>由于一个日志事件包括了很多的内容（这里将每个内容称为一个item），但实际上用户并不希望每次输出日志时都将这些items全部进行输出，而是希望可以自由地选择要输出的item。并且，用户还可能需要在每条日志里增加一些指定的字符，比如在文件名和行号之间加上一个冒号的情况。为了实现这项功能，LogFormatter使用了一个模板字符串来指定格式化的方式，这个模板字符串是一串像下面这样的字符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125; [%rms]%T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n&quot;</span></span><br></pre></td></tr></table></figure>

<p>模板字符串由普通字符和转义字符构成，转义字符以%开头，比如%m，%p等。除了转义字符，剩下的全部都是普通字符，包括空格。</p>
<p>LogFormatter根据模板字符串来格式化日志事件。首先，在构造LogFormatter对象时会指定一串模板字符，LogFormatter会首先解析该模板字符串，将其中的转义字符和普通字符解析出来。然后，在格式化日志事件时，根据模板字符串，将其中的转义字符替换成日志事件的具体内容，普通字符保持不变。</p>
<p>当前实现支持以下转义字符：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%m 消息</span><br><span class="line">%p 日志级别</span><br><span class="line">%c 日志器名称</span><br><span class="line">%d 日期时间，后面可跟一对括号指定时间格式，比如%d&#123;%Y-%m-%d %H:%M:%S&#125;，这里的格式字符与C语言strftime一致</span><br><span class="line">%r 该日志器创建后的累计运行毫秒数</span><br><span class="line">%f 文件名</span><br><span class="line">%l 行号</span><br><span class="line">%t 线程id</span><br><span class="line">%F 协程id</span><br><span class="line">%N 线程名称</span><br><span class="line">%% 百分号</span><br><span class="line">%T 制表符</span><br><span class="line">%n 换行</span><br></pre></td></tr></table></figure>



<p>举例说明:  假设一个LogFormatter的模板字符串为 <code>[%c] [%p] %t %F %f:%l %m%n</code> ，那么它输出的日志可能是像下面这样的一行字符串：LogFormatter的模板字符串为 <code>[%c] [%p] %t %F %f:%l %m%n</code>，那么它输出的日志可能是像下面这样的一行字符串：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root] [info] <span class="number">1000</span> <span class="number">0</span> main.cpp:<span class="number">12</span> hello world</span><br></pre></td></tr></table></figure>



<h5 id="1-3-3-LogAppender"><a href="#1-3-3-LogAppender" class="headerlink" title="1.3.3 LogAppender"></a>1.3.3 LogAppender</h5><p>日志输出器，用于输出一个日志事件。这是一个虚类，可以派生出不同的具体实现，比如<strong>往输出到终端的StdoutLogAppender</strong>，以及<strong>输出到文件的FileLogAppender</strong>。</p>
<p>LogAppender的实现包含了一个用户指定的LogFormatter和一个默认的LogFormatter，以及log方法，不同类型的Appender通过重载log方法来实现往不同的目的地进行输出，这部分直接阅读源码即可，不难理解。</p>
<h5 id="1-3-4-Logger"><a href="#1-3-4-Logger" class="headerlink" title="1.3.4 Logger"></a>1.3.4 Logger</h5><p>日志器，用于输出日志。这个类是直接与用户进行交互的类，提供log方法用于输出日志事件。</p>
<p>Logger的实现包含了日志级别，日志器名称，创建时间，以及一个LogAppender数组，日志事件由log方法输出，log方法首先判断日志级别是否达到本Logger的级别要求，是则将日志传给各个LogAppender进行输出，否则抛弃这条日志。</p>
<h5 id="1-3-5-LogEventWrap"><a href="#1-3-5-LogEventWrap" class="headerlink" title="1.3.5 LogEventWrap"></a>1.3.5 LogEventWrap</h5><p>日志事件包装类，在日志现场构造，包装了日志器和日志事件两个对象，<strong>在日志记录结束后, LogEventWrap析构时，调用日志器的log方法输出日志事件。</strong></p>
<h5 id="1-3-6-LogManager"><a href="#1-3-6-LogManager" class="headerlink" title="1.3.6 LogManager"></a>1.3.6 LogManager</h5><p>日志器管理类，单例模式，用于统一管理全部的日志器，提供getLogger()方法用于创建/获取日志器。内部维护一个名称到日志器的map，当获取的日志器存在时，直接返回对应的日志器指针，否则创建对应的日志器并返回。</p>
<h4 id="1-4-工具宏"><a href="#1-4-工具宏" class="headerlink" title="1.4 工具宏"></a>1.4 工具宏</h4><p>sylar定义了一系列工具宏用于简化编码以及实现流式风格的日志输出和格式化风格的日志输出，下面以流式风格的实现为例分析一下宏的设计：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用流式方式将日志级别level的日志写入到logger</span></span><br><span class="line"><span class="comment"> * @details 构造一个LogEventWrap对象，包裹包含日志器和日志事件，在对象析构时调用日志器写日志事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_LEVEL(logger , level) \</span></span><br><span class="line">    <span class="keyword">if</span>(level &lt;= logger-&gt;getLevel()) \</span><br><span class="line">        sylar::LogEventWrap(logger, sylar::LogEvent::ptr(<span class="keyword">new</span> sylar::LogEvent(logger-&gt;getName(), \</span><br><span class="line">            level, __FILE__, __LINE__, sylar::GetElapsedMS() - logger-&gt;getCreateTime(), \</span><br><span class="line">            sylar::GetThreadId(), sylar::GetFiberId(), time(<span class="number">0</span>), sylar::GetThreadName()))).getLogEvent()-&gt;getSS()</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_FATAL(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::FATAL)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_ALERT(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::ALERT)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_CRIT(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::CRIT)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_ERROR(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::ERROR)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_WARN(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::WARN)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_NOTICE(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::NOTICE)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_INFO(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::INFO)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_DEBUG(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::DEBUG)</span></span><br></pre></td></tr></table></figure>



<p>调用语句如下: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sylar::Logger::ptr g_logger = SYLAR_LOG_ROOT();</span><br><span class="line">SYLAR_LOG_INFO(g_logger) &lt;&lt; <span class="string">&quot;info msg&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>这里要实现通过g_logger打印一条INFO级别的消息。那么，首先判断INFO级别是否高于g_logger本身的日志级别（这里的设计与原版sylar相反，数字越小，优先级越高），如果不高于，那if语句执行不到，这条日志也不会打印，否则，临时构造一个LogEventWrap对象，传入日志器g_logger，以及现场构造的日志事件。通过LogEventWrap的getLogEvent()方法拿到日志事件，再用日志事件的流式日志消息成员输出日志消息。由于LogEventWrap是在if语句内部构建的，一旦if语句执行结束，LogEventWrap对象就会析构，日志事件也就会被g_logger进行输出，这个设计可以说是非常巧妙。</p>
<h3 id="二-配置系统"><a href="#二-配置系统" class="headerlink" title="二 配置系统"></a>二 配置系统</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>提供程序运行时的环境变量管理功能。这里的环境变量不仅包括<strong>系统环境变量</strong>，还包括程<strong>序自定义环境变量</strong>，<strong>命令行参数</strong>，<strong>帮助选项与描述</strong>，以及<strong>程序运行路径相关的信息</strong>。</p>
<p>所谓环境变量就是程序运行时可直接获取和设置的一组变量，它们往往代表一些特定的含义。所有的环境变量都以key-value的形式存储，key和value都是字符串形式。</p>
<blockquote>
<p>这里可以参考系统环境变量来理解，在程序运行时，可以通过调用<code>getenv()/setenv()</code>接口来获取/设置系统环境变量，比如<code>getenv(&quot;PWD&quot;)</code>来获取当前路径。在<strong>shell中可以通过<code>printenv</code>命令来打印当前所有的环境变量</strong>，并且在当前shell中运行的所有程序都共享这组环境变量值。</p>
</blockquote>
<p>其他类型的环境变量也可以类比系统环境变量，只不过系统环境变量由shell来保存，而<strong>其他类型的环境变量由程序自己内部存储</strong>，但两者效果是一样的。具体地，sylar定义了以下几类环境变量：</p>
<ul>
<li><strong>系统环境变量</strong>，由shell保存，sylar环境变量模块提供getEnv()/setEnv()方法用于操作系统环境变量。</li>
<li><strong>程序自定义环境变量</strong>，对应get()/add()/has()/del()接口，自定义环境变量保存在程序自己的内存空间中，在内部实现为一个<code>std::map&lt;std::string, std::string&gt;</code>结构。</li>
<li><strong>命令行参数</strong>，通过解析main函数的参数得到。所有参数都被解析成选项-选项值的形式，选项只能以<code>-</code>开头，后面跟选项值。如果一个参数只有选项没有值，那么值为空字符串。命令行参数也保存在程序自定义环境变量中。</li>
<li><strong>帮助选项与描述</strong>。这里是为了统一生成程序的命令行帮助信息，在执行程序时如果指定了<code>-h</code>选项，那么就打印这些帮助信息。帮助选项与描述也是存储在程序自己的内存空间中，在内部实现为一个<code>std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;</code>结构。</li>
<li>与程序运行路径相关的信息，包括记录程序名，程序路径，当前路径，这些由单独的成员变量来存储。</li>
</ul>
<h4 id="2-2-环境变量模块设计"><a href="#2-2-环境变量模块设计" class="headerlink" title="2.2 环境变量模块设计"></a>2.2 环境变量模块设计</h4><p><strong>与环境变量相关的类只有一个<code>class Env</code>，并且这个类被包装成了单例模式。通过单例可以保证程序的环境变量是全局唯一的，便于统一管理。</strong></p>
<p>Env类提供以下方法：</p>
<ol>
<li><p><strong>init:</strong> 环境变量模块初始化，需要将main函数的参数原样传入init接口中，以便于从main函数参数中提取命令行选项与值，以及通过argv[0]参数获取命令行程序名称。</p>
</li>
<li><p><strong>add/get/has/del：</strong>用于操作程序自定义环境变量，参数为key-value，get操作支持传入默认值，在对应的环境变量不存在时，返回这个默认值。</p>
</li>
<li><p><strong>setEnv/getEnv:</strong> 用于操作系统环境变量，对应标准库的setenv/getenv操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> * value,<span class="keyword">int</span> overwrite)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>setenv()用来改变或增加环境变量的内容。</p>
</li>
<li><p>参数name为环境变量名称字符串。</p>
</li>
<li><p>参数 value则为变量内容</p>
</li>
<li><p>参数overwrite用来决定是否要改变已存在的环境变量。若环境变量存在，当<strong>overwrite不为0时，原内容会被改为参数value所指的变量内容；</strong>当overwrite为0时，则参数value会被忽略。</p>
</li>
</ul>
</li>
</ol>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">char</span> *envvar)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>参数envvar为环境变量的名称，如果该变量存在则会返回指向该内容的指针。</p>
</li>
<li><p>找不到符合的环境变量名称则返回NULL。</p>
</li>
</ul>
<ol start="4">
<li><p><strong>addHelp/removeHelp/printHelp:</strong> 用于操作帮助选项和描述信息。</p>
</li>
<li><p><strong>getExe/getCwd/getAbsolutePath:</strong> 用于获取程序名称，程序路径，绝对路径。</p>
</li>
<li><p><strong>getConfigPath:</strong> 获取配置文件夹路径，配置文件夹路径由命令行-c选项传入。</p>
</li>
</ol>
<h4 id="2-3-环境变量模块实现"><a href="#2-3-环境变量模块实现" class="headerlink" title="2.3 环境变量模块实现"></a>2.3 环境变量模块实现</h4><p>这里只描述环境变量环境的一些实现细节。</p>
<ol>
<li><p>获取<strong>程序的bin文件绝对路径</strong>是通过/proc/$pid/目录下exe软链接文件指向的路径来确定的, 用到了用到了<code>readlink</code>系统调用。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">readlink</span><br><span class="line">Follow symlinks and get symlink information.</span><br><span class="line"></span><br><span class="line"> - Get the actual file to which the symlink points:</span><br><span class="line">   readlink &#123;&#123;filename&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Get the absolute path to a file:</span><br><span class="line">   readlink -f &#123;&#123;filename&#125;&#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">ssize_t readlink(const char *path, char *buf, size_t bufsiz);</span><br><span class="line">readlink()会将参数path的符号链接内容存储到参数buf所指的内存空间。若参数bufsiz小于符号连接的内容长度，过长的内容会被截断，</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过bin文件绝对路径可以<strong>得到bin文件所在的目录</strong>，只需要将最后的文件名部分去掉即可。</p>
</li>
<li><p>通过argv[0]获得命令行输入的<strong>程序路径</strong>，注意这里的路径可能是以./开头的相对路径。</p>
</li>
<li><p>通过<strong>setenv/getenv操作系统环境变量</strong>，参考setenv, getenv。</p>
</li>
<li><p>提供getAbsolutePath方法，<strong>传入一个相对于bin文件的路径，返回这个路径的绝对路径</strong>。比如默认的配置文件路径就是通过getAbsolutePath(get(“c”, “conf”))来获取的，也就是配置文件夹默认在bin文件所在目录的conf文件夹。</p>
</li>
<li><p>按使用惯例，<strong>main函数执行的第一条语句应该就是调用Env的init方法初始化命令行参数。</strong></p>
</li>
</ol>
<h3 id="三-配置模块"><a href="#三-配置模块" class="headerlink" title="三 配置模块"></a>三 配置模块</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>用于定义/声明配置项，并且从配置文件中加载用户配置。</p>
<p>一般而言，一项配置应该包括以下要素：</p>
<ol>
<li><p>名称，对应一个字符串，必须唯一，不能与其他配置项产生冲突。</p>
</li>
<li><p> 类型，可以是基本类型，但也应该支持复杂类型和自定义类型。</p>
</li>
<li><p> 值。默认值，考虑到用户不一定总是会显式地给配置项赋值，所以配置项最好有一个默认值。</p>
</li>
<li><p>配置变更通知，一旦用户更新了配置值，那么应该通知所有使用了这项配置的代码，以便于进行一些具体的操作，比如重新打开文件，重新起监听端口等。</p>
</li>
<li><p>校验方法，更新配置时会调用校验方法进行校验，以保证用户不会给配置项设置一个非法的值。</p>
</li>
</ol>
<p>一个配置模块应具备的基本功能：</p>
<ol>
<li><strong>支持定义/声明配置项</strong>，也就是在提供配置名称、类型以及可选的默认值的情况下生成一个可用的配置项。由于一项配置可能在多个源文件中使用，所以配置模块还应该支持跨文件声明配置项的方法。</li>
<li><strong>支持更新配置项的值</strong>。这点很好理解，配置项刚被定义时可能有一个初始默认值，但用户可能会有新的值来覆盖掉原来的值。</li>
<li><strong>支持从预置的途径中加载配置项，一般是配置文件，也可以是命令行参数，或是网络服务器</strong>。这里不仅应该支持基本数据类型的加载，也应该支持复杂数据类型的加载，比如直接从配置文件中加载一个map类型的配置项，或是直接从一个预定格式的配置文件中加载一个自定义结构体。</li>
<li><strong>支持给配置项注册配置变更通知。</strong>配置模块应该提供方法让程序知道某项配置被修改了，以便于进行一些操作。比如对于网络服务器而言，如果服务器端口配置变化了，那程序应该重新起监听端口。这个功能一般是通过注册回调函数来实现的，配置使用方预先给配置项注册一个配置变更回调函数，配置项发生变化时，触发对应的回调函数以通知调用方。由于一项配置可能在多个地方引用，所以配置变更回调函数应该是一个数组的形式。</li>
<li><strong>支持给配置项设置校验方法。</strong>配置项在定义时也可以指定一个校验方法，以保证该项配置不会被设置成一个非法的值，比如对于文件路径类的配置，可以通过校验方法来确保该路径一定存在。</li>
<li><strong>支持导出当前配置。</strong></li>
</ol>
<h4 id="3-2-配置模块设计"><a href="#3-2-配置模块设计" class="headerlink" title="3.2 配置模块设计"></a>3.2 配置模块设计</h4><p>采用约定优于配置的思想, 简单来说，约定优于配置的背景条件是，一般来说，<strong>程序所依赖的配置项都有一个公认的默认值，也就是所谓的约定。</strong> 这点有可许多可以参考的例子，比如对于一个http网络服务器，服务端口通常都是80端口。对于这些具有公认约定的配置，可以初始时就将配置项设置成对应的值。这样，程序员就可以只修改那些约定之外的配置项，然后<strong>以最小的代价让程序跑起来。</strong></p>
<p>在代码上，约定优于配置的思路体现为所有的配置项在定义时都带一个的默认值，以下是一个sylar配置项的示例，这是一个int类型的配置项，名称为<code>tcp.connect.timeout</code>，初始值为5000。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> sylar::ConfigVar&lt;<span class="keyword">int</span>&gt;::ptr g_tcp_connect_timeout = sylar::Config::Lookup(<span class="string">&quot;tcp.connect.timeout&quot;</span>, <span class="number">5000</span>, <span class="string">&quot;tcp connect timeout&quot;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>sylar的配置项定义之后即可使用，比如上面的配置项可以直接使用<code>g_tcp_connect_timeout-&gt;getValue()</code>获取参数的值，这里获取的为默认值5000。</p>
<p>sylar使用YAML做为配置文件，配置名称大小写不敏感，并且支持级别格式的数据类型，比如上面的配置项对应的YAML配置文件内容如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tcp:</span></span><br><span class="line">    <span class="attr">connect:</span></span><br><span class="line">        <span class="attr">timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>这里指定了配置名称为 <code>tcp.connect.timeout</code>的配置项的值为10000。<strong>由于配置文件指定的值与默认值不一样，当配置文件加载后，对应的配置项值会被自动更新为10000，如果配置项还注册了配置变更回调函数的话，会一并调用配置变更回调函数以通知配置使用方。</strong></p>
<p>sylar支持STL容器（vector, list, set, map等等），支持自定义类型（需要<strong>实现序列化和反序列化方法)。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义类型举例, 实现自定义配置的YAML序列化与反序列化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Person <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;v)</span> </span>&#123;</span><br><span class="line">        YAML::Node node = YAML::Load(v);</span><br><span class="line">        Person p;</span><br><span class="line">        p.m_name = node[<span class="string">&quot;name&quot;</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        p.m_age = node[<span class="string">&quot;age&quot;</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        p.m_sex = node[<span class="string">&quot;sex&quot;</span>].as&lt;<span class="keyword">bool</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span>Person, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span> </span>&#123;</span><br><span class="line">        YAML::Node node;</span><br><span class="line">        node[<span class="string">&quot;name&quot;</span>] = p.m_name;</span><br><span class="line">        node[<span class="string">&quot;age&quot;</span>] = p.m_age;</span><br><span class="line">        node[<span class="string">&quot;sex&quot;</span>] = p.m_sex;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</blockquote>
<p>与配置模块相关的类:</p>
<ul>
<li><p><code>ConfigVarBase</code>: <strong>配置项基类，虚基类，定义了配置项公有的成员和方法。</strong>sylar对每个配置项都包括名称和描述两项成员，以及toString/fromString两个纯虚函数方法。ConfigVarBase并不包含配置项类型和值，这些由继承类实现，由<strong>继承类实现的还包括具体类型的toString/fromString方法，用于和YAML字符串进行相互转换。</strong></p>
</li>
<li><p><code>ConfigVar</code>:  <strong>具体的配置参数类，继承自ConfigVarBase，并且是一个模板类，有3个模板参数。</strong>第一个模板参数是类型T，表示配置项的类型。另外两个模板参数是FromStr和ToStr，这两个参数是仿函数，FromStr用于将YAML字符串转类型T，ToStr用于将T转YAML字符串。这两个模板参数具有默认值<code>LexicalCast&lt;std::string, T&gt;</code>和<code>LexicalCast&lt;T, std::string&gt;</code>，根据不同的类型T，FromStr和ToStr具有不同的偏特化实现。  可以理解为:   <strong>所有的偏特化实现都是为configVar服务的</strong>。</p>
<p><strong>ConfigVar类在ConfigVarBase上基础上包含了一个T类型的成员和一个变更回调函数数组</strong>，此外，ConfigVar还提供了setValue/getValue方法用于获取/更新配置值（更新配置时会一并触发全部的配置变更回调函数），以及addListener/delListener方法用于添加或删除配置变更回调函数。</p>
</li>
<li><p><code>Config</code>: <strong>ConfigVar的管理类，负责托管全部的ConfigVar对象，单例模式。</strong> 提供Lookup方法，用于根据配置名称查询配置项。如果调用Lookup查询时同时提供了默认值和配置项的描述信息，那么在未找到对应的配置时，会自动创建一个对应的配置项，这样就保证了配置模块定义即可用的特性。除此外，Config类还提供了LoadFromYaml和LoadFromConfDir两个方法，用于从YAML对象或从命令行-c选项指定的配置文件路径中加载配置。<strong>Config的全部成员变量和方法都是static类型，保证了全局只有一个实例。</strong></p>
</li>
</ul>
<h4 id="3-3-配置模块实现"><a href="#3-3-配置模块实现" class="headerlink" title="3.3 配置模块实现"></a>3.3 配置模块实现</h4><p>sylar的配置模块使用了yaml-cpp作为YAML解析库，关于yaml-cpp的编译和使用可参考GitHub链接：<a target="_blank" rel="noopener" href="https://github.com/jbeder/yaml-cpp">jbeder/yaml-cpp: A YAML parser and emitter in C++</a>，关于YAML格式的介绍可参考<a target="_blank" rel="noopener" href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程 | 菜鸟教程</a>。</p>
<p><strong>配置模块实现的一大难点是类型转换类（仿函数）的偏特化实现。</strong> 对于每种类型的配置，在对应的ConfigVar模板类实例化时都要提供其FromStr和ToStr两个仿函数，用于实现该类型和YAML字符串的相互转换。</p>
<p>配置项的类型众多，包括全部的基本数据类型（int, float, double, string等），以及vector/list/set/unordered_set/map/unordered_map这几个复杂数据类型，还有用户自定义的类型。</p>
<h5 id="3-3-1-转换简单类"><a href="#3-3-1-转换简单类" class="headerlink" title="3.3.1 转换简单类"></a>3.3.1 转换简单类</h5><p>为了简化代码编写，sylar从一个基本类型的转换类开始，特化出了剩余类型的转换类，这个基本类型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 类型转换模板类(F 源类型, T 目标类型)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 类型转换</span></span><br><span class="line"><span class="comment">     * @param[in] v 源类型值</span></span><br><span class="line"><span class="comment">     * @return 返回v转换后的目标类型</span></span><br><span class="line"><span class="comment">     * @exception 当类型不可转换时抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> F &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boost::lexical_cast&lt;T&gt;(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里的LexicalCast类是一个仿函数，它支持<code>LexicalCast&lt;F, T&gt;()(const F &amp;v)</code>调用，可将传入的F类型的参数v进行转换，并返回T类型的结果。实际的转换语句是<code>boost::lexical_cast&lt;T&gt;(v)</code>。</p>
<blockquote>
<p>仿函数（Functor）又称为函数对象（Function Object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 operator() 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。</p>
</blockquote>
<p>但是，受限于<code>boost::lexical_cast</code>, <strong>LexicalCast当前只能实现基本数据类型和std::string的相互转换</strong>，不能实现复杂类型的转换，下面的代码可用于演示当前LexicalCast的功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 = LexicalCast&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(<span class="number">123</span>);     <span class="comment">// ok, str1等于&quot;123&quot;</span></span><br><span class="line"><span class="keyword">int</span> int1 = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;()(<span class="string">&quot;123&quot;</span>);           <span class="comment">// ok, int1等于123</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = LexicalCast&lt;<span class="keyword">float</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(<span class="number">3.14</span>);  <span class="comment">// ok，str2等于&quot;3.14&quot;</span></span><br><span class="line"><span class="keyword">float</span> float2 = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">float</span>&gt;()(<span class="string">&quot;3.14&quot;</span>);    <span class="comment">// ok，float2等于3.14</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;()(...); <span class="comment">// 错误，LexicalCast目前还不支持实例化T类型为vector&lt;int&gt;的模板参数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = LexicalCast&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(...); <span class="comment">// 错误，同上</span></span><br></pre></td></tr></table></figure>
</blockquote>
<h5 id="3-3-2-复杂类型转换"><a href="#3-3-2-复杂类型转换" class="headerlink" title="3.3.2 复杂类型转换"></a>3.3.2 复杂类型转换</h5><p>为了实现YAML字符串和vector/list/set/unordered_set/map/unordered_map的相互转换，就要对每个类型都进行特化，分别实现其转换类，下面是YAML字符串和vector的相互转换实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 类型转换模板类片特化(YAML String 转换成 std::vector&lt;T&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;v)</span> </span>&#123;</span><br><span class="line">        YAML::Node node = YAML::Load(v);</span><br><span class="line">        <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; vec;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; node.size(); ++i) &#123;</span><br><span class="line">            ss.str(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            ss &lt;&lt; node[i];</span><br><span class="line">            vec.push_back(LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, T&gt;()(ss.str()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 类型转换模板类片特化(std::vector&lt;T&gt; 转换成 YAML String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Sequence)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v) &#123;</span><br><span class="line">            node.push_back(YAML::Load(LexicalCast&lt;T, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>上面分别实现了<code>LexicalCast&lt;std::string, std::vector&lt;T&gt;&gt;</code>和<code>LexicalCast&lt;std::vector&lt;T&gt;, std::string&gt;</code>，其中在转换单个的数组元素时，再次用到了<code>LexicalCast&lt;std::string, T&gt;</code>和<code>LexicalCast&lt;T, std::string&gt;</code>，如果这里T是基本数据类型，那么就可以用最开始的基本类型的转换类进行模板实例化并完成转换了，</p>
<p>下面是针对vector和YAML字符串相互转换的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;()(<span class="string">&quot;[1, 2, 3]&quot;</span>);  <span class="comment">// ok,     v等于[1, 2, 3]</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// ok，  s等于YAML格式的数组[1,2,3],如下:</span></span><br><span class="line">                                                                                         <span class="comment">// - 1                                                                         // - 2                                                                         // - 3</span></span><br></pre></td></tr></table></figure>



<p>另外，由于这里的模板实例化是可以嵌套的，由vector和vector组合出来的全部类型都可以顺利地实现和YAML的转化，以下是一个二维数组的示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt;()(<span class="string">&quot;[[1,2,3],[4,5,6]]&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ss = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(vv);</span><br></pre></td></tr></table></figure>

<p>上面的代码运行之后，vv将具有二维数组<code>&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</code>的值，而字符串ss则是与之对应YAML格式的二维数组，如下：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">3</span></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">5</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>其他复杂类型的偏特化与vector类型，参考源码理解即可。</p>
<p>每实现一个新类型的转换，那这个类型和之前已实现的类型组合出的数据类型也可以顺利实现转换，比如<code>vector&lt;set&gt;, set&lt;vector&gt;，set&lt;map&gt;, map&lt;set&gt;, map&lt;map&gt;</code>这种。这种基于偏特化实现类型转换的方法可以说是非常巧妙了，代码可以做到高度简化，但功能却非常强大，这也变相展示了泛型程序设计的强大之处吧。</p>
<h3 id="四-线程模块"><a href="#四-线程模块" class="headerlink" title="四 线程模块"></a>四 线程模块</h3><p>提供线程类和线程同步类，基于pthread实现，包括以下类：</p>
<p><code>Thread</code>：线程类，构造函数传入线程入口函数和线程名称，线程入口函数类型为void()，如果带参数，则需要用 <code>std::bind</code> 进行绑定。线程类构造之后线程即开始运行，构造函数在线程真正开始运行之后返回。</p>
<p>线程同步类（这部分被拆分到mutex.h)中：</p>
<ul>
<li><p><code>Semaphore</code>: 计数信号量，基于<code>sem_t</code>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Semaphore::Semaphore(<span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_init(&amp;m_semaphore, <span class="number">0</span>, count)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;sem_init error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::~Semaphore() &#123;</span><br><span class="line">    sem_destroy(&amp;m_semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_wait(&amp;m_semaphore)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;sem_wait error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_post(&amp;m_semaphore)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;sem_post error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>Mutex</code>: 互斥锁，基于<code>pthread_mutex_t</code>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 互斥量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> :</span> Noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 局部锁</span></span><br><span class="line">    <span class="keyword">typedef</span> ScopedLockImpl&lt;Mutex&gt; Lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mutex() &#123;</span><br><span class="line">        pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~Mutex() &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// mutex</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> m_mutex&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>RWMutex</code>: 读写锁，基于<code>pthread_rwlock_t</code>实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读写互斥量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWMutex</span> :</span> Noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 局部读锁</span></span><br><span class="line">    <span class="keyword">typedef</span> ReadScopedLockImpl&lt;RWMutex&gt; ReadLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 局部写锁</span></span><br><span class="line">    <span class="keyword">typedef</span> WriteScopedLockImpl&lt;RWMutex&gt; WriteLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RWMutex() &#123;</span><br><span class="line">        pthread_rwlock_init(&amp;m_lock, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~RWMutex() &#123;</span><br><span class="line">        pthread_rwlock_destroy(&amp;m_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 上读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rdlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;m_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 上写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wrlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;m_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_rwlock_unlock(&amp;m_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 读写锁</span></span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> m_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>Spinlock</code>: 自旋锁，基于<code>pthread_spinlock_t</code>实现,   自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁已经被另外一个线程占有了，那么此线程就无法获取这把锁，该线程会等待，间隔一段时间后再次尝试获取。这种采用循环加锁,等待锁释放的机制就称为自旋锁。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spinlock</span> :</span> Noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 局部锁</span></span><br><span class="line">    <span class="keyword">typedef</span> ScopedLockImpl&lt;Spinlock&gt; Lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Spinlock() &#123;</span><br><span class="line">        pthread_spin_init(&amp;m_mutex, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~Spinlock() &#123;</span><br><span class="line">        pthread_spin_destroy(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_spin_lock(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_spin_unlock(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 自旋锁</span></span><br><span class="line">    <span class="keyword">pthread_spinlock_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<ul>
<li><p><code>CASLock</code>: 原子锁，基于<code>std::atomic_flag</code>实现， 不常用</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 原子锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CASLock</span> :</span> Noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 局部锁</span></span><br><span class="line">    <span class="keyword">typedef</span> ScopedLockImpl&lt;CASLock&gt; Lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CASLock() &#123;</span><br><span class="line">        m_mutex.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~CASLock() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">std</span>::atomic_flag_test_and_set_explicit(&amp;m_mutex, <span class="built_in">std</span>::memory_order_acquire))</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::atomic_flag_clear_explicit(&amp;m_mutex, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 原子状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="built_in">std</span>::atomic_flag m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





</li>
</ul>
<p>线程模块总体比较简单，在对pthread相关的接口有一定了解的情况下，参考源码应该不难理解，这里说几个重点：</p>
<ol>
<li><p>为什么不直接使用C++11提供的thread类。按sylar的描述，因为<strong>thread其实也是基于pthread实现的</strong>。并且C++11里面没有提供读写互斥量，RWMutex，Spinlock等，在高并发场景，这些对象是经常需要用到的，所以选择自己封装pthread。</p>
</li>
<li><p>关于线程入口函数。sylar的线程只支持void(void)类型的入口函数，不支持给线程传参数，但实际使用时可以结合std::bind来绑定参数，这样就相当于支持任何类型和数量的参数。</p>
</li>
<li><p>关于子线程的执行时机。<strong>sylar的线程类可以保证在构造完成之后线程函数一定已经处于运行状态</strong>，这是通过一个信号量来实现的，构造函数在创建线程后会一直阻塞，直到线程函数运行并且通知信号量，构造函数才会返回，而构造函数一旦返回，就说明线程函数已经在执行了。</p>
</li>
<li><p>关于线程局部变量。sylar的每个线程都有两个线程局部变量，一个用于存储当前线程的Thread指针，另一个存储线程名称，通过Thread::GetThis()可以拿到当前线程的指针。</p>
</li>
<li><p>关于范围锁。sylar大量使用了范围锁来实现互斥，范围锁是指用类的构造函数来加锁，用析造函数来释放锁。这种方式可以简化锁的操作，也可以避免忘记解锁导致的死锁问题，以下是一个范围锁的示例和说明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sylar::Mutex mutex;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    sylar::<span class="function">Mutex::Lock <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// 定义lock对象，类型为sylar::Mutex::Lock，传入互斥量，在构造函数中完成加锁操作，如果该锁已经被持有，那构造lock时就会阻塞，直到锁被释放</span></span><br><span class="line">    <span class="comment">//临界区操作</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 大括号范围结束，所有在该范围内定义的自动变量都会被回收，lock对象被回收时触发析构函数，在析构函数中释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>




</li>
</ol>
<h3 id="五-线程模块"><a href="#五-线程模块" class="headerlink" title="五 线程模块"></a>五 线程模块</h3><h4 id="5-1-协程概述"><a href="#5-1-协程概述" class="headerlink" title="5.1 协程概述"></a>5.1 协程概述</h4><p>最简单的理解，可以将协程当成一种看起来花里胡哨，并且使用起来也花里胡哨的函数。</p>
<p>每个协程在创建时都会指定一个入口函数，这点可以类比线程。协程的本质就是函数和函数运行状态的组合 。</p>
<p>协程和函数的不同之处是，函数一旦被调用，只能从头开始执行，直到函数执行结束退出，而协程则可以执行到一半就退出（称为yield），但此时协程并未真正结束，只是<strong>暂时让出CPU执行权，在后面适当的时机协程可以重新恢复运行</strong>（称为resume），在这段时间里其他的协程可以获得CPU并运行，所以协程也称为轻量级线程。</p>
<blockquote>
<p>协程能够半路yield、再重新resume的关键是<strong>协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文</strong>。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。在Linux系统里这个上下文用ucontext_t结构体来表示，通getcontext()来获取。</p>
</blockquote>
<p><strong>搞清楚协程和线程的区别。</strong> <strong>协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。</strong>其实这点也好理解，毕竟协程只是以一种花里胡哨的方式去运行一个函数，不管实现得如何巧妙，也不可能在单线程里做到同时运行两个函数，否则还要多线程有何用？</p>
<p>因为单线程下协程并不是并发执行，而是顺序执行的，所以<strong>不要在协程里使用线程级别的锁来做协程同步，比如pthread_mutex_t。</strong> 如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。</p>
<p>同样是单线程环境下，协程的yield和resume一定是同步进行的，一个协程的yield，必然对应另一个协程的resume，因为线程不可能没有执行主体。并且，协程的yield和resume是完全由应用程序来控制的。与线程不同，线程创建之后，线程的运行和调度也是由操作系统自动完成的，但协程创建后，协程的运行和调度都要由应用程序来完成，就和调用函数一样，所以协程也被称为用户态线程。</p>
<p>所谓<strong>创建协程</strong>，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓<strong>协程调度</strong>，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；所谓<strong>IO协程调度</strong>，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；所谓<strong>定时器</strong>，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。</p>
<h4 id="5-2-ucontext-t-接口"><a href="#5-2-ucontext-t-接口" class="headerlink" title="5.2 ucontext_t 接口"></a>5.2 ucontext_t 接口</h4><p>sylar的协程模块基于ucontext_t实现，在学习之前，必须对ucontext_t和ucontext_t的操作函数非常熟悉。关于ucontext_t的定义和相关的接口如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文结构体定义, 这个结构体是平台相关的，因为不同平台的寄存器不一样</span></span><br><span class="line"><span class="comment">// 下面列出的是所有平台都至少会包含的4个成员</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="comment">// 当前上下文的信号屏蔽掩码</span></span><br><span class="line">    <span class="keyword">sigset_t</span>          uc_sigmask;</span><br><span class="line">    <span class="comment">// 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效</span></span><br><span class="line">    <span class="keyword">stack_t</span>           uc_stack;</span><br><span class="line">    <span class="comment">// 平台相关的上下文具体内容，包含寄存器的值</span></span><br><span class="line">    <span class="keyword">mcontext_t</span>        uc_mcontext;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">ucontext_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取当前的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setcontext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数，</span></span><br><span class="line"><span class="comment">// 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp-&gt;uc_stack中，这段内存空间将作为func函数运行时的栈空间，</span></span><br><span class="line"><span class="comment">// 同时也可以指定ucp-&gt;uc_link，表示函数运行结束后恢复uc_link指向的上下文，</span></span><br><span class="line"><span class="comment">// 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了</span></span><br><span class="line"><span class="comment">// makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makecontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp, <span class="keyword">void</span> (*func)(), <span class="keyword">int</span> argc, ...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，</span></span><br><span class="line"><span class="comment">// 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数</span></span><br><span class="line"><span class="comment">// swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swapcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *oucp, <span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br></pre></td></tr></table></figure>



<h4 id="5-3-协程模块设计"><a href="#5-3-协程模块设计" class="headerlink" title="5.3 协程模块设计"></a>5.3 协程模块设计</h4><p>sylar使用非对称协程模型，也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束，像下面这样：</p>
<img src="sylar服务器开发/image-20230318192033881.png" alt="image-20230318192033881" style="zoom:50%;" />

<p><strong>非对称协程:</strong>  是跟一个特定的调用者绑定的，协程让出 CPU 时，只能让回给原调用者。非对称在于程序控制流转移到被调协程时使用的是 call/resume 操作，而当被调协程让出 CPU 时使用的却是 return/yield 操作。此外，协程间的地位也不对等，caller 与 callee 关系是确定的，不可更改的，非对称协程只能返回最初调用它的协程。</p>
<p><strong>对称协程（symmetric coroutines）：</strong>  对称协程则不一样，启动之后就跟启动之前的协程没有任何关系了。协程的切换操作，一般而言只有一个操作 — yield，用于将程序控制流转移给另外的协程。对称协程机制一般需要一个调度器的支持，按一定调度算法去选择 yield 的目标协程。</p>
<p>sylar借助了线程局部变量的功能来实现协程模块。<strong>线程局部变量与全局变量类似，不同之处在于声明的线程局部变量在每个线程都独有一份，而全局变量是全部线程共享一份。</strong></p>
<p>sylar使用线程局部变量（C++11 thread_local变量）来保存协程上下文对象，这点很好理解，因为协程是在线程里运行的，不同线程的协程相互不影响，每个线程都要独自处理当前线程的协程切换问题。</p>
<p>对于每个线程的协程上下文，sylar设计了两个线程局部变量来存储上下文信息（对应源码的t_fiber和t_thread_fiber），也就是说，一个线程在任何时候最多只能知道两个协程的上下文。又由于sylar只使用swapcontext来做协程切换，那就意味着，<strong>这两个线程局部变量必须至少有一个是用来保存线程主协程的上下文的，</strong>如果这两个线程局部变量存储的都是子协程的上下文，那么不管怎么调用swapcontext，都没法恢复主协程的上下文，也就意味着程序最终无法回到主协程去执行，程序也就跑飞了。</p>
<p>如果将线程的局部变量设置成一个类似链表的数据结构，那理论上应该也可以实现对称协程，也就是子协程可以直接和子协程切换，但代码复杂度上肯定会增加不少，因为要考虑多线程和公平调度的问题。</p>
<p>sylar的非对称协程代码实现简单，并且在后面实现协程调度时可以做到公平调度，缺点是子协程只能和线程主协程切换，意味着子协程无法创建并运行新的子协程，并且在后面实现协程调度时，完成一次子协程调度需要额外多切换一次上下文。</p>
<h4 id="5-4-协程模块实现"><a href="#5-4-协程模块实现" class="headerlink" title="5.4 协程模块实现"></a>5.4 协程模块实现</h4><h5 id="5-4-1-协程状态"><a href="#5-4-1-协程状态" class="headerlink" title="5.4.1 协程状态"></a>5.4.1 协程状态</h5><p>这里在sylar的基础上进行简化，对每个协程，只设计了3种状态，分别是READY，代表就绪态，RUNNING，代表正在运行，TERM，代表运行结束。</p>
<p>sylar的INIT状态是协程对象刚创建时的状态，这个状态可以直接归到READY状态里，sylar的HOLD状态和READY状态与协程调度有关，READY状态的协程会被调度器自动重新调度，而HOLD状态的协程需要显式地再次将协程加入调度，这两个状态也可以归到READY状态里，反正都表示可执行状态。sylar还给协程设计了一个EXCEPT状态，表示协程入口函数执行时出现异常的状态，这个状态可以不管，具体到协程调度模块再讨论。</p>
<p>去掉这几个状态后，协程的状态模型就简单得一目了然了，一个协程要么正在运行（RUNNING），要么准备运行（READY），要运行结束（TERM）。</p>
<img src="sylar服务器开发/image-20230318194016768.png" alt="image-20230318194016768" style="zoom:67%;" />

<p><strong>状态简化后，唯一的缺陷是无法区分一个READY状态的协程对象是刚创建，还是已经运行到一半yield了，这在重置协程对象时有影响。</strong></p>
<p>重置协程时，如果协程对象只是刚创建但一次都没运行过，那应该是允许重置的，但如果协程的状态是运行到一半yield了，那应该不允许重置。虽然可以把INIT状态加上以区分READY状态，但既然简化了状态，那就简化到底，让协程只有在TERM状态下才允许重置，问题迎刃而解。</p>
<h5 id="5-4-2-协程原语"><a href="#5-4-2-协程原语" class="headerlink" title="5.4.2 协程原语"></a>5.4.2 协程原语</h5><p>对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是resume，表示恢复协程运行，一种是yield，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。</p>
<h5 id="5-4-3-协程类实现"><a href="#5-4-3-协程类实现" class="headerlink" title="5.4.3 协程类实现"></a>5.4.3 协程类实现</h5><p>sylar的协程通过Fiber类来表示，这个类包含以下成员变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 协程id</span></span><br><span class="line"><span class="keyword">uint64_t</span> m_id        = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// 协程栈大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> m_stacksize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// 协程状态</span></span><br><span class="line">State m_state        = READY;</span><br><span class="line"><span class="comment">/// 协程上下文</span></span><br><span class="line"><span class="keyword">ucontext_t</span> m_ctx;</span><br><span class="line"><span class="comment">/// 协程栈地址</span></span><br><span class="line"><span class="keyword">void</span> *m_stack = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">/// 协程入口函数</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; m_cb;</span><br></pre></td></tr></table></figure>



<p>接下来是与协程有关的全局变量和线程局部变量。</p>
<p>Fiber的源码定义了两个全局静态变量，用于生成协程id和统计当前的协程数，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局静态变量，用于生成协程id</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; s_fiber_id&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/// 全局静态变量，用于统计当前的协程数</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; s_fiber_count&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure>



<p>然后是线程局部变量，对于每个线程，sylar设计了以下两个线程局部变量用于保存协程上下文信息：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 线程局部变量，当前线程正在运行的协程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber *t_fiber = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">/// 线程局部变量，当前线程的主协程，切换到这个协程，就相当于切换到了主线程中运行，智能指针形式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber::ptr t_thread_fiber = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>t_fiber</code>：保存当前正在运行的协程指针，必须时刻指向当前正在运行的协程对象。协程模块初始化时，t_fiber指向线程主协程对象。</li>
<li><code>t_thread_fiber</code>：保存线程主协程指针，智能指针形式。协程模块初始化时，t_thread_fiber指向线程主协程对象。当子协程resume时，通过swapcontext将主协程的上下文保存到t_thread_fiber的ucontext_t成员中，同时激活子协程的ucontext_t上下文。当子协程yield时，从t_thread_fiber中取得主协程的上下文并恢复运行。</li>
</ul>
<p>接下来是协程类Fiber的成员方法。</p>
<p>首先是协程的构建函数。Fiber类提供了两个构造函数，带参数的构造函数用于构造子协程，初始化子协程的ucontext_t上下文和栈空间，要求必须传入协程的入口函数，以及可选的协程栈大小。不带参的构造函数用于初始化当前线程的协程功能，构造线程主协程对象，以及对t_fiber和t_thread_fiber进行赋值。这个构造函数被定义成私有方法，不允许在类外部调用，只能通过GetThis()方法，在返回当前正在运行的协程时，如果发现当前线程的主协程未被初始化，那就用不带参的构造函数初始化线程主协程。因为GetThis()兼具初始化主协程的功能，在使用协程之前必须显式调用一次GetThis()。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 构造函数</span></span><br><span class="line"><span class="comment"> * @attention 无参构造函数只用于创建线程的第一个协程，也就是线程主函数对应的协程，</span></span><br><span class="line"><span class="comment"> * 这个协程只能由GetThis()方法调用，所以定义成私有方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Fiber::Fiber()&#123;</span><br><span class="line">    SetThis(<span class="keyword">this</span>);</span><br><span class="line">    m_state = RUNNING;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (getcontext(&amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;getcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ++s_fiber_count;</span><br><span class="line">    m_id = s_fiber_id++; <span class="comment">// 协程id从0开始，用完加1</span></span><br><span class="line"> </span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;Fiber::Fiber() main id = &quot;</span> &lt;&lt; m_id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 构造函数，用于创建用户协程</span></span><br><span class="line"><span class="comment"> * @param[] cb 协程入口函数</span></span><br><span class="line"><span class="comment"> * @param[] stacksize 栈大小，默认为128k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Fiber::Fiber(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb, <span class="keyword">size_t</span> stacksize)</span><br><span class="line">    : m_id(s_fiber_id++)</span><br><span class="line">    , m_cb(cb) &#123;</span><br><span class="line">    ++s_fiber_count;</span><br><span class="line">    m_stacksize = stacksize ? stacksize : g_fiber_stack_size-&gt;getValue();</span><br><span class="line">    m_stack     = StackAllocator::Alloc(m_stacksize);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (getcontext(&amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;getcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_ctx.uc_link          = <span class="literal">nullptr</span>;</span><br><span class="line">    m_ctx.uc_stack.ss_sp   = m_stack;</span><br><span class="line">    m_ctx.uc_stack.ss_size = m_stacksize;</span><br><span class="line"> </span><br><span class="line">    makecontext(&amp;m_ctx, &amp;Fiber::MainFunc, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;Fiber::Fiber() id = &quot;</span> &lt;&lt; m_id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回当前线程正在执行的协程</span></span><br><span class="line"><span class="comment"> * @details 如果当前线程还未创建协程，则创建线程的第一个协程，</span></span><br><span class="line"><span class="comment"> * 且该协程为当前线程的主协程，其他协程都通过这个协程来调度，也就是说，其他协程</span></span><br><span class="line"><span class="comment"> * 结束时,都要切回到主协程，由主协程重新选择新的协程进行resume</span></span><br><span class="line"><span class="comment"> * @attention 线程如果要创建协程，那么应该首先执行一下Fiber::GetThis()操作，以初始化主函数协程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Fiber::ptr <span class="title">GetThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t_fiber) &#123;</span><br><span class="line">        <span class="keyword">return</span> t_fiber-&gt;shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Fiber::ptr <span class="title">main_fiber</span><span class="params">(<span class="keyword">new</span> Fiber)</span></span>;</span><br><span class="line">    SYLAR_ASSERT(t_fiber == main_fiber.get());</span><br><span class="line">    t_thread_fiber = main_fiber;</span><br><span class="line">    <span class="keyword">return</span> t_fiber-&gt;shared_from_this();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>个人感觉这里的GetThis()方法设计得不太好，用函数的副作用掩盖了线程协程初始化这一重要的操作步骤，更好的设计应该是把线程协程初始化和GetThis()分开，让用户知道自己真正在做的事。</p>
<p>接下来是协程原语的实现，也就是resume和yield。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将当前协程切到到执行状态</span></span><br><span class="line"><span class="comment"> * @details 当前协程和正在运行的协程进行交换，前者状态变为RUNNING，后者状态变为READY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_ASSERT(m_state != TERM &amp;&amp; m_state != RUNNING);</span><br><span class="line">    SetThis(<span class="keyword">this</span>);</span><br><span class="line">    m_state = RUNNING;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (swapcontext(&amp;(t_thread_fiber-&gt;m_ctx), &amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 当前协程让出执行权</span></span><br><span class="line"><span class="comment"> * @details 当前协程与上次resume时退到后台的协程进行交换，前者状态变为READY，后者状态变为RUNNING</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::yield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 协程运行完之后会自动yield一次，用于回到主协程，此时状态已为结束状态</span></span><br><span class="line">    SYLAR_ASSERT(m_state == RUNNING || m_state == TERM);</span><br><span class="line">    SetThis(t_thread_fiber.get());</span><br><span class="line">    <span class="keyword">if</span> (m_state != TERM) &#123;</span><br><span class="line">        m_state = READY;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (swapcontext(&amp;m_ctx, &amp;(t_thread_fiber-&gt;m_ctx))) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在非对称协程里，执行resume时的当前执行环境一定是位于线程主协程里，所以这里的swapcontext操作的结果把主协程的上下文保存到<code>t_thread_fiber-&gt;m_ctx</code>中，并且激活子协程的上下文；而执行yield时，当前执行环境一定是位于子协程里，所以这里的swapcontext操作的结果是把子协程的上下文保存到协程自己的m_ctx中，同时从t_thread_fiber获得主协程的上下文并激活。</p>
<p>接下来是协程入口函数，sylar在用户传入的协程入口函数上进行了一次封装，这个封装类似于线程模块的对线程入口函数的封装。通过封装协程入口函数，可以实现协程在结束自动执行yield的操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 协程入口函数</span></span><br><span class="line"><span class="comment"> * @note 这里没有处理协程函数出现异常的情况，同样是为了简化状态管理，并且个人认为协程的异常不应该由框架处理，应该由开发者自行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::MainFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fiber::ptr cur = GetThis(); <span class="comment">// GetThis()的shared_from_this()方法让引用计数加1</span></span><br><span class="line">    SYLAR_ASSERT(cur);</span><br><span class="line"> </span><br><span class="line">    cur-&gt;m_cb(); <span class="comment">// 这里真正执行协程的入口函数</span></span><br><span class="line">    cur-&gt;m_cb    = <span class="literal">nullptr</span>;</span><br><span class="line">    cur-&gt;m_state = TERM;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> raw_ptr = cur.get(); <span class="comment">// 手动让t_fiber的引用计数减1</span></span><br><span class="line">    cur.reset();</span><br><span class="line">    raw_ptr-&gt;yield(); <span class="comment">// 协程结束时自动yield，以回到主协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来是协程的重置，重置协程就是重复利用已结束的协程，复用其栈空间，创建新协程，实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里为了简化状态管理，强制只有TERM状态的协程才可以重置，但其实刚创建好但没执行过的协程也应该允许重置的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::reset</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb)</span> </span>&#123;</span><br><span class="line">    SYLAR_ASSERT(m_stack);</span><br><span class="line">    SYLAR_ASSERT(m_state == TERM);</span><br><span class="line">    m_cb = cb;</span><br><span class="line">    <span class="keyword">if</span> (getcontext(&amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;getcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_ctx.uc_link          = <span class="literal">nullptr</span>;</span><br><span class="line">    m_ctx.uc_stack.ss_sp   = m_stack;</span><br><span class="line">    m_ctx.uc_stack.ss_size = m_stacksize;</span><br><span class="line"> </span><br><span class="line">    makecontext(&amp;m_ctx, &amp;Fiber::MainFunc, <span class="number">0</span>);</span><br><span class="line">    m_state = READY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="5-4-4-其他实现细节"><a href="#5-4-4-其他实现细节" class="headerlink" title="5.4.4 其他实现细节"></a>5.4.4 其他实现细节</h5><p>关于协程id。sylar通过全局静态变量s_fiber_id的自增来生成协程id，每创建一个新协程，s_fiber_id自增1，并作为新协程的id（实际是先取值，再自增1）。</p>
<p>关于线程主协程的构建。线程主协程代表线程入口函数或是main函数所在的协程，这两种函数都不是以协程的手段创建的，所以它们只有ucontext_t上下文，但没有入口函数，也没有分配栈空间。</p>
<p>关于协程切换。子协程的resume操作一定是在主协程里执行的，主协程的resume操作一定是在子协程里执行的，这点完美和swapcontext匹配，参考上面协程原语的实现。</p>
<p>关于智能指针的引用计数，由于t_fiber和t_thread_fiber一个是原始指针一个是智能指针，混用时要注意智能指针的引用计数问题，不恰当的混用可能导致协程对象已经运行结束，但未析构问题。关于协程对象的智能指针引用计数跟踪可参考test_fiber.cc。</p>
<h4 id="5-5-shared-from-this"><a href="#5-5-shared-from-this" class="headerlink" title="5.5 shared_from_this()"></a>5.5 shared_from_this()</h4><p>使用场景</p>
<ul>
<li>当类被 <code>share_ptr</code> 管理</li>
<li>调用类的成员函数时</li>
<li>需要把当前对象指针作为参数传给其他函数时</li>
<li>需要传递一个指向自身的share_ptr</li>
</ul>
<p>使用前提</p>
<ul>
<li>继承enable_shared_from_this</li>
</ul>
<p>通过 shared_ptr 的构造函数，可以让 shared_ptr 对象托管一个 new 运算符返回的指针，写法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> T)</span></span>; <span class="comment">// T 可以是 int、char、类等各种类型</span></span><br></pre></td></tr></table></figure>





<h3 id="六-协程调度模块"><a href="#六-协程调度模块" class="headerlink" title="六 协程调度模块"></a>六 协程调度模块</h3><p>实现了一个N-M的协程调度器，N个线程运行M个协程，协程可以在线程之间进行切换，也可以绑定到指定线程运行。</p>
<p><strong>实现协程调度之后，可以解决前一章协程模块中子协程不能运行另一个子协程的缺陷，子协程可以通过向调度器添加调度任务的方式来运行另一个子协程。</strong></p>
<p>协程调度最难理解的地方是当caller线程也参与调度时调度协程和主线程切换的情况，注意对照源码进行理解。</p>
<h4 id="6-1-协程调度概述"><a href="#6-1-协程调度概述" class="headerlink" title="6.1 协程调度概述"></a>6.1 协程调度概述</h4><p>**协程调度定义: ** 当你有很多协程时，如何把这些协程都消耗掉。</p>
<p>在前面的协程模块中，对于每个协程，都需要用户手动调用协程的resume方法将协程运行起来，然后等协程运行结束并返回，再运行下一个协程。这种运行协程的方式其实是用户自己在挑选协程执行，<strong>相当于用户在充当调度器</strong>，显然不够灵活.</p>
<p>引入协程调度后，则可以先创建一个协程调度器，然后把这些要调度的协程传递给调度器，由调度器负责把这些协程一个一个消耗掉。</p>
<p>从某种程度来看，协程调度其实非常简单，简单到用下面的代码就可以实现一个调度器，这个调度器可以添加调度任务，运行调度任务，并且还是完全公平调度的，先添加的任务先执行，后添加的任务后执行。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file simple_fiber_scheduler.cc</span></span><br><span class="line"><span class="comment"> * @brief 一个简单的协程调度器实现</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2021-07-10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sylar/sylar.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 简单协程调度类，支持添加调度任务以及运行调度任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加协程调度任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(sylar::Fiber::ptr task)</span> </span>&#123;</span><br><span class="line">        m_tasks.push_back(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 执行调度任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sylar::Fiber::ptr task;</span><br><span class="line">        <span class="keyword">auto</span> it = m_tasks.begin();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(it != m_tasks.end()) &#123;</span><br><span class="line">            task = *it;</span><br><span class="line">            m_tasks.erase(it++);</span><br><span class="line">            task-&gt;resume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 任务队列</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;sylar::Fiber::ptr&gt; m_tasks;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_fiber</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 初始化当前线程的主协程</span></span><br><span class="line">    sylar::Fiber::GetThis();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 创建调度器</span></span><br><span class="line">    Scheduler sc;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 添加调度任务</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sylar::<span class="function">Fiber::ptr <span class="title">fiber</span><span class="params">(<span class="keyword">new</span> sylar::Fiber(<span class="built_in">std</span>::bind(test_fiber, i)))</span></span>;</span><br><span class="line">        sc.schedule(fiber);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 执行调度任务</span></span><br><span class="line">    sc.run();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>不要觉得上面这个调度器扯淡，除了不支持多线程，sylar的协程调度器和它的设计思路完全相同，甚至，上面的实现可以看成是sylar的协程调度器的一个特例，当sylar的协程调度器只使用main函数所在线程进行调度时，它的工作原理和上面的完全一样，只不过代码看起来更花里胡哨一些。</p>
</blockquote>
<p><strong>接下来将从上面这个调度器开始，来分析一些和协程调度器相关的概念。</strong></p>
<p>首先是关于调度任务的定义，对于协程调度器来说，协程当然可以作为调度任务，但实际上，函数也应可以，因为函数也是可执行的对象，调度器应当支持直接调度一个函数。这在代码实现上也很简单，只需要<strong>将函数包装成协程即可，协程调度器的实现重点还是以协程为基础。</strong></p>
<p>接下来是多线程，通过前面协程模块的知识我们可以知道，一个线程同一时刻只能运行一个协程，所以，作为<strong>协程调度器，势必要用到多线程来提高调度的效率，</strong>因为有多个线程就意味着有多个协程可以同时执行，这显然是要好过单线程的。</p>
<p>既然多线程可以提高协程调度的效率，那么，能不能把调度器所在的线程（称为caller线程）也加入进来作为调度线程呢？比如典型地，在main函数中定义的调度器，能不能把main函数所在的线程也用来执行调度任务呢？答案是肯定的，在实现相同调度能力的情况下（指能够同时调度的协程数量），线程数越小，线程切换的开销也就越小，效率就更高一些，所以，调度器所在的线程，也应该支持用来执行调度任务。甚至，调度器完全可以不创建新的线程，而只使用caller线程来进行协程调度，比如只使用main函数所在的线程来进行协程调度。</p>
<p>接下来是调度器如何运行，这里可以简单地认为，<strong>调度器创建后，内部首先会创建一个调度线程池，调度开始后，所有调度线程按顺序从任务队列里取任务执行，调度线程数越多，能够同时调度的任务也就越多，当所有任务都调度完后，调度线程就停下来等新的任务进来。</strong></p>
<p>接下来是添加调度任务，添加调度任务的本质就是往调度器的任务队列里塞任务，但是，只添加调度任务是不够的，还应该有一种方式用于通知调度线程有新的任务加进来了，因为调度线程并不一定知道有新任务进来了。当然调度线程也可以不停地轮询有没有新任务，但是这样CPU占用率会很高。</p>
<p>接下来是调度器的停止。调度器应该支持停止调度的功能，以便回收调度线程的资源，只有当所有的调度线程都结束后，调度器才算真正停止。</p>
<p>通过上面的描述，一个协程调度器的大概设计也就出炉了：</p>
<p><strong>调度器内部维护一个任务队列和一个调度线程池。开始调度后，线程池从任务队列里按顺序取任务执行。调度线程可以包含caller线程。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。</strong></p>
<h4 id="6-2-协程调度模块设计"><a href="#6-2-协程调度模块设计" class="headerlink" title="6.2 协程调度模块设计"></a>6.2 协程调度模块设计</h4><p>sylar的协程调度模块支持多线程，支持使用caller线程进行调度，支持添加函数或协程作为调度对象，并且支持将函数或协程绑定到一个具体的线程上执行。</p>
<ul>
<li><strong>首先是协程调度器的初始化。</strong> sylar的协程调度器在初始化时支持传入线程数和一个布尔型的use_caller参数，表示是否使用caller线程。在使用caller线程的情况下，线程数自动减一，并且调度器内部会初始化一个属于caller线程的调度协程并保存起来（比如，在main函数中创建的调度器，如果use_caller为true，那调度器会初始化一个属于main函数线程的调度协程）。</li>
</ul>
<p>调度器创建好后，即可调用调度器的schedule方法向调度器添加调度任务，但此时调度器并不会立刻执行这些任务，而是将它们保存到内部的一个任务队列中。</p>
<ul>
<li><p><strong>接下来是调用start方法启动调度。</strong>start方法调用后会创建调度线程池，线程数量由初始化时的线程数和use_caller确定。调度线程一旦创建，就会立刻从任务队列里取任务执行。比较特殊的一点是，如果初始化时指定线程数为1且use_caller为true，那么start方法什么也不做，因为不需要创建新线程用于调度。并且，由于没有创建新的调度线程，那只能由caller线程的调度协程来负责调度协程，而caller线程的调度协程的执行时机与start方法并不在同一个地方。</p>
</li>
<li><p><strong>接下来是调度协程，对应run方法。</strong>调度协程负责从调度器的任务队列中取任务执行。取出的任务即子协程，这里调度协程和子协程的切换模型即为前一章介绍的非对称模型，每个子协程执行完后都必须返回调度协程，由调度协程重新从任务队列中取新的协程并执行。如果任务队列空了，那么调度协程会切换到一个idle协程，这个idle协程什么也不做，等有新任务进来时，idle协程才会退出并回到调度协程，重新开始下一轮调度。</p>
</li>
</ul>
<p>在非caller线程里，调度协程就是调度线程的主线程，但在caller线程里，调度协程并不是caller线程的主协程，而是相当于caller线程的子协程，这在协程切换时会有大麻烦（这点是sylar协程调度模块最难理解的地方），如何处理这个问题将在下面的章节专门进行讨论。</p>
<ul>
<li><strong>接下来是添加调度任务，对应schedule方法，</strong>这个方法支持传入协程或函数，并且支持一个线程号参数，表示是否将这个协程或函数绑定到一个具体的线程上执行。如果任务队列为空，那么在添加任务之后，要调用一次tickle方法以通知各调度线程的调度协程有新任务来了。</li>
</ul>
<p>在执行调度任务时，还可以通过调度器的GetThis()方法获取到当前调度器，再通过schedule方法继续添加新的任务，这就变相实现了在子协程中创建并运行新的子协程的功能。</p>
<ul>
<li><strong>接下来是调度器的停止。</strong>调度器的停止行为要分两种情况讨论，首先是use_caller为false的情况，这种情况下，由于没有使用caller线程进行调度，那么只需要简单地等各个调度线程的调度协程退出就行了。如果use_caller为true，表示caller线程也要参于调度，这时，调度器初始化时记录的属于caller线程的调度协程就要起作用了，在调度器停止前，应该让这个caller线程的调度协程也运行一次，让caller线程完成调度工作后再退出。如果调度器只使用了caller线程进行调度，那么所有的调度任务要在调度器停止时才会被调度。</li>
</ul>
<h4 id="6-3-调度协程切换问题"><a href="#6-3-调度协程切换问题" class="headerlink" title="6.3 调度协程切换问题"></a>6.3 调度协程切换问题</h4><p>这里分两种典型情况来讨论一下调度协程的切换情况，其他情况可以看成以下两种情况的组合，原理是一样的。</p>
<ol>
<li><p>线程数为1，且use_caller为true，对应只使用main函数线程进行协程调度的情况。</p>
</li>
<li><p>线程数为1，且use_caller为false，对应额外创建一个线程进行协程调度、main函数线程不参与调度的情况。</p>
</li>
</ol>
<p>这里先说情况2。情况2比较好理解，因为有单独的线程用于协程调度，那<strong>只需要让新线程的入口函数作为调度协程，从任务队列里取任务执行就行了，main函数与调度协程完全不相关，main函数只需要向调度器添加任务，然后在适当的时机停止调度器即可</strong>。当调度器停止时，main函数要等待调度线程结束后再退出，参考下面的图示：</p>
<img src="sylar服务器开发/image-20230319203546110.png" alt="image-20230319203546110" style="zoom:50%;" />



<p><strong>情况1则比较复杂，因为没有额外的线程进行协程调度，那只能用main函数所在的线程来进行调度，而梳理一下main函数线程要运行的协程，会发现有以下三类协程：</strong></p>
<ol>
<li><p>main函数对应的主协程</p>
</li>
<li><p>调度协程</p>
</li>
<li><p>待调度的任务协程</p>
</li>
</ol>
<p>在main函数线程里这三类协程运行的顺序是这样的：</p>
<ol>
<li><p>main函数主协程运行，创建调度器</p>
</li>
<li><p>仍然是main函数主协程运行，向调度器添加一些调度任务</p>
</li>
<li><p>开始协程调度，main函数主协程让出执行权，切换到调度协程，调度协程从任务队列里按顺序执行所有的任务</p>
</li>
<li><p>每次执行一个任务，调度协程都要让出执行权，再切到该任务的协程里去执行，任务执行结束后，还要再切回调度协程，继续下一个任务的调度</p>
</li>
<li><p>所有任务都执行完后，调度协程还要让出执行权并切回main函数主协程，以保证程序能顺利结束。</p>
</li>
</ol>
<p>上面的过程也可以总结为：main函数先攒下一波协程，然后切到调度协程里去执行，等把这些协程都消耗完后，再从调度协程切回来，像下面这样第一幅图：</p>
<img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230319212526038.png" class="" title="image-20230319212526038"><img src="sylar服务器开发/image-20230319204322600.png" alt="image-20230319204322600" style="zoom: 50%;" />



<p>然而，回顾一下前面协程模块就会发现，上面这种协程切换实际是有问题的，参考上面第二幅图：</p>
<blockquote>
<p><strong>在非对称协程里，子协程只能和线程主协程切换，而不能和另一个子协程切换。</strong> 在上面的情况1中，线程主协程是main函数对应的协程，另外的两类协程，也就是调度协程和任务协程，都是子协程，也就是说，调度协程不能直接和任务协程切换，一旦切换，程序的main函数协程就跑飞了。</p>
</blockquote>
<p>==解决单线程环境下caller线程主协程-调度协程-任务协程之间的上下文切换，是sylar协程调度实现的关键。==</p>
<blockquote>
<p>其实，子协程和子协程切换导致线程主协程跑飞的<strong>关键原因在于，每个线程只有两个线程局部变量用于保存当前的协程上下文信息。也就是说线程任何时候都最多只能知道两个协程的上下文，其中一个是当前正在运行协程的上下文，另一个是线程主协程的上下文，如果子协程和子协程切换，那这两个上下文都会变成子协程的上下文，线程主协程的上下文丢失了，程序也就跑飞了。</strong> 如果不改变这种局部，就只能线程主协程去充当调度协程，这就相当于又回到了让用户充当调度器的情况。</p>
</blockquote>
<p>那么，如何改变这种情况呢？其实非常简单，<strong>只需要给每个线程增加一个线程局部变量用于保存调度协程的上下文就可以了</strong>，这样，每个线程可以同时保存三个协程的上下文，一个是当前正在执行的协程上下文，另一个是线程主协程的上下文，最后一个是调度协程的上下文。有了这三个上下文，协程就可以根据自己的身份来选择和每次和哪个协程进行交换，具体操作如下：</p>
<ul>
<li>给协程类增加一个bool类型的成员m_runInScheduler，用于记录该协程是否通过调度器来运行。</li>
<li>  创建协程时，根据协程的身份指定对应的协程类型，具体来说，只有想让调度器调度的协程的m_runInScheduler值为true，线程主协程和线程调度协程的m_runInScheduler都为false。</li>
<li>resume一个协程时，如果如果这个协程的m_runInScheduler值为true，表示这个协程参与调度器调度，那它应该和三个线程局部变量中的调度协程上下文进行切换，同理，在协程yield时，也应该恢复调度协程的上下文，表示从子协程切换回调度协程；</li>
<li>如果协程的m_runInScheduler值为false，表示这个协程不参与调度器调度，那么在resume协程时，直接和线程主协程切换就可以了，yield也一样，应该恢复线程主协程的上下文。m_runInScheduler值为false的协程上下文切换完全和调度协程无关，可以脱离调度器使用。</li>
</ul>
<p>经过上面的改造了，就可以解决单线程环境下caller线程主协程-调度协程-任务协程之间的上下文切换问题了，假设caller线程主协程的上下文为main_ctx，调度协程的上下文为scheduler_ctx，任务协程上下文为child_ctx，那么单线程下的协程切换将像下面这样</p>
<img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230319212615489.png" class="" title="image-20230319212615489">





<h4 id="6-4-其他情况的讨论"><a href="#6-4-其他情况的讨论" class="headerlink" title="6.4 其他情况的讨论"></a>6.4 其他情况的讨论</h4><ol>
<li><strong>调度器的退出问题</strong>。调度器内部有一个协程任务队列，调度器调度的实质就是内部的线程池从这个任务队列拿任务并执行，那么，停止调度时，如果任务队列还有任务剩余，要怎么处理？这里可以简化处理，强制规定只有所有的任务都完成调度时，调度器才可以退出，如果有一个任务没有执行完，那调度器就不能退出。</li>
<li><strong>任务协程执行过程中主动调用yield让出了执行权，调度器要怎么处理？</strong>协程在主动执行yield前，必须先将自己重新添加到调度器的任务队列中。如果协程不顾后果地执行yield，最后的后果就是协程将永远无法再被执行，也就是所说的逃逸状态。（sylar的处理方法比较折衷一些，sylar定义了两种yield操作，一种是yield to ready，这种yield调度器会再次将协程加入任务队列并等待调度，另一种是yield to hold，这种yield调度器不会再将协程加入任务队列，协程在yield之前必须自己先将自己加入到协程的调度队列中，否则协程就处于逃逸状态。再说一点，sylar定义的yield to ready，在整个sylar框架内一次都没用到，看来sylar也同意，一个成熟的协程要学会自我管理。）</li>
<li>只使用调度器所在的线程进行调度，典型的就是main函数中定义调度器并且只使用main函数线程执行调度任务。这种场景下，可以认为是main函数先攒下一波协程，然后切到调度协程，把这些协程消耗完后再从调度协程切回main函数协程。每个协程在运行时也可以继续创建新的协程并加入调度。如果所有协程都调度完了，并且没有创建新的调度任务，那么下一步就是讨论idle(闲置)该如何处理。</li>
<li><strong>idle如何处理，也就是当调度器没有协程可调度时，调度协程该怎么办。</strong> 直觉上来看这里应该有一些同步手段，比如，没有调度任务时，调度协程阻塞住，比如阻塞在一个idle协程上，等待新任务加入后退出idle协程，恢复调度。然而这种方案是无法实现的，因为每个线程同一时间只能有一个协程在执行，如果调度线程阻塞在idle协程上，那么除非idle协程自行让出执行权，否则其他的协程都得不到执行，这里就造成了一个先有鸡还是先有蛋的问题：只有创建新任务idle协程才会退出，只有idle协程退出才能创建新任务。<strong>为了解决这个问题，sylar采取了一个简单粗暴的办法，如果任务队列空了，调度协程会不停地检测任务队列，看有没有新任务，俗称忙等待，CPU使用率爆表。</strong> 这点可以从sylar的源码上发现，一是Scheduler的tickle函数什么也不做，因为根本不需要通知调度线程是否有新任务，二是idle协程在协程调度器未停止的情况下只会yield to hold，而调度协程又会将idle协程重新swapIn，相当于idle啥也不做直接返回。这个问题在sylar框架内无解，只有一种方法可以规避掉，那就是设置autostop标志，这个标志会使得调度器在调度完所有任务后自动退出。在后续的IOManager中，上面的问题会得到一定的改善，并且tickle和idle可以实现得更加巧妙一些，以应对IO事件。</li>
<li><strong>只有main函数线程参与调度时的调度执行时机。</strong> 前面说过，当只有main函数线程参与调度时，可以认为是主线程先攒下一波协程，然后切到调度协程开始调度这些协程，等所有的协程都调度完了，调度协程进idle状态，这个状态下<strong>调度器只能执行忙等待，啥也做不了。</strong> 这也就是说，主线程main函数一旦开启了协程调度，就无法回头了，位于开始调度点之后的代码都执行不到。对于这个问题，<strong>sylar把调度器的开始点放在了stop方法中，也就是，调度开始即结束，干完活就下班(这样的话 就可以理解上面的那副图了)。</strong>IOManager也是类似，除了可以调用stop方法外，IOManager类的析构函数也有一个stop方法，可以保证所有的任务都会被调度到。</li>
<li><strong>额外创建了调度线程时的调度执行时机。</strong> 如果不额外创建线程，也就是线程数为1并且use caller，那所有的调度任务都在stop()时才会进行调度。但如果额外创建了线程，那么，在添加完调度任务之后任务马上就可以在另一个线程中调度执行。归纳起来，如果只使用caller线程进行调度，那所有的任务协程都在stop之后排队调度，如果有额外线程，那任务协程在刚添加到任务队列时就可以得到调度。</li>
<li>协程中的异常要怎么处理，子协程抛出了异常该怎么办？这点其实非常好办，类比一下线程即可，你会在线程外面处理线程抛出的异常吗？答案是不会，所以协程抛出的异常我们也不处理，直接让程序按默认的处理方式来处理即可。一个成熟的协程应该自己处理掉自己的异常，而不是让调度器来帮忙。顺便说一下，sylar的协程调度器处理了协程抛出的异常，并且给异常结束的协程设置了一个EXCEPT状态，这看似贴心，但从长远的角度来看，其实是非常不利于协程的健康成长的。</li>
<li>关于协程调度器的优雅停止。sylar停止调度器的策略如下：<ul>
<li>设置m_stopping标志，该标志表示正在停止</li>
<li>检测是否使用了caller线程进行调度，如果使用了caller线程进行调度，那要保证stop方法是由caller线程发起的</li>
<li>通知其他调度线程的调度协程退出调度</li>
<li>通知当前线程的调度协程退出调度</li>
<li>如果使用了caller线程进行调度，那执行一次caller线程的调度协程（只使用caller线程时的协程调度全仰仗这个操作）</li>
<li>等caller线程的调度协程返回</li>
<li>等所有调度线程结束</li>
</ul>
</li>
</ol>
<h4 id="6-5-调度模块实现"><a href="#6-5-调度模块实现" class="headerlink" title="6.5 调度模块实现"></a>6.5 调度模块实现</h4><h5 id="6-5-1-协程模块改造"><a href="#6-5-1-协程模块改造" class="headerlink" title="6.5.1 协程模块改造"></a>6.5.1 协程模块改造</h5><p>首先是对协程模块的改造，<strong>增加m_runInScheduler成员，表示当前协程是否参与调度器调度，在协程的resume和yield时，根据协程的运行环境确定是和线程主协程进行交换还是和调度协程进行交换：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Fiber::Fiber(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb, <span class="keyword">size_t</span> stacksize, <span class="keyword">bool</span> run_in_scheduler)</span><br><span class="line">    : m_id(s_fiber_id++)</span><br><span class="line">    , m_cb(cb)</span><br><span class="line">    , m_runInScheduler(run_in_scheduler) &#123;</span><br><span class="line">    ++s_fiber_count;</span><br><span class="line">    m_stacksize = stacksize ? stacksize : g_fiber_stack_size-&gt;getValue();</span><br><span class="line">    m_stack     = StackAllocator::Alloc(m_stacksize);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (getcontext(&amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;getcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_ctx.uc_link          = <span class="literal">nullptr</span>;</span><br><span class="line">    m_ctx.uc_stack.ss_sp   = m_stack;</span><br><span class="line">    m_ctx.uc_stack.ss_size = m_stacksize;</span><br><span class="line"> </span><br><span class="line">    makecontext(&amp;m_ctx, &amp;Fiber::MainFunc, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;Fiber::Fiber() id = &quot;</span> &lt;&lt; m_id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_ASSERT(m_state != TERM &amp;&amp; m_state != RUNNING);</span><br><span class="line">    SetThis(<span class="keyword">this</span>);</span><br><span class="line">    m_state = RUNNING;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果协程参与调度器调度，那么应该和调度器的主协程进行swap，而不是线程主协程</span></span><br><span class="line">    <span class="keyword">if</span> (m_runInScheduler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (swapcontext(&amp;(Scheduler::GetMainFiber()-&gt;m_ctx), &amp;m_ctx)) &#123;</span><br><span class="line">            SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (swapcontext(&amp;(t_thread_fiber-&gt;m_ctx), &amp;m_ctx)) &#123;</span><br><span class="line">            SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::yield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 协程运行完之后会自动yield一次，用于回到主协程，此时状态已为结束状态</span></span><br><span class="line">    SYLAR_ASSERT(m_state == RUNNING || m_state == TERM);</span><br><span class="line">    SetThis(t_thread_fiber.get());</span><br><span class="line">    <span class="keyword">if</span> (m_state != TERM) &#123;</span><br><span class="line">        m_state = READY;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果协程参与调度器调度，那么应该和调度器的主协程进行swap，而不是线程主协程</span></span><br><span class="line">    <span class="keyword">if</span> (m_runInScheduler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (swapcontext(&amp;m_ctx, &amp;(Scheduler::GetMainFiber()-&gt;m_ctx))) &#123;</span><br><span class="line">            SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (swapcontext(&amp;m_ctx, &amp;(t_thread_fiber-&gt;m_ctx))) &#123;</span><br><span class="line">            SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="6-5-2-调度任务"><a href="#6-5-2-调度任务" class="headerlink" title="6.5.2 调度任务"></a>6.5.2 调度任务</h5><p>然后是对调度任务的定义，如下，这里任务类型可以是协程/函数二选一，并且可指定调度线程。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 调度任务，协程/函数二选一，可指定在哪个线程上调度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScheduleTask</span> &#123;</span></span><br><span class="line">    Fiber::ptr fiber;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb;</span><br><span class="line">    <span class="keyword">int</span> thread;</span><br><span class="line"> </span><br><span class="line">    ScheduleTask(Fiber::ptr f, <span class="keyword">int</span> thr) &#123;</span><br><span class="line">        fiber  = f;</span><br><span class="line">        thread = thr;</span><br><span class="line">    &#125;</span><br><span class="line">    ScheduleTask(Fiber::ptr *f, <span class="keyword">int</span> thr) &#123;</span><br><span class="line">        fiber.swap(*f);</span><br><span class="line">        thread = thr;</span><br><span class="line">    &#125;</span><br><span class="line">    ScheduleTask(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f, <span class="keyword">int</span> thr) &#123;</span><br><span class="line">        cb     = f;</span><br><span class="line">        thread = thr;</span><br><span class="line">    &#125;</span><br><span class="line">    ScheduleTask() &#123; thread = <span class="number">-1</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fiber  = <span class="literal">nullptr</span>;</span><br><span class="line">        cb     = <span class="literal">nullptr</span>;</span><br><span class="line">        thread = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>接下来是调度器的成员变量，包括以下成员：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 协程调度器名称</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"><span class="comment">/// 互斥锁</span></span><br><span class="line">MutexType m_mutex;</span><br><span class="line"><span class="comment">/// 线程池</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Thread::ptr&gt; m_threads;</span><br><span class="line"><span class="comment">/// 任务队列</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;ScheduleTask&gt; m_tasks;</span><br><span class="line"><span class="comment">/// 线程池的线程ID数组</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m_threadIds;</span><br><span class="line"><span class="comment">/// 工作线程数量，不包含use_caller的主线程</span></span><br><span class="line"><span class="keyword">size_t</span> m_threadCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// 活跃线程数</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; m_activeThreadCount = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/// idle线程数</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; m_idleThreadCount = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 是否use caller</span></span><br><span class="line"><span class="keyword">bool</span> m_useCaller;</span><br><span class="line"><span class="comment">/// use_caller为true时，调度器所在线程的调度协程</span></span><br><span class="line">Fiber::ptr m_rootFiber;</span><br><span class="line"><span class="comment">/// use_caller为true时，调度器所在线程的id</span></span><br><span class="line"><span class="keyword">int</span> m_rootThread = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 是否正在停止</span></span><br><span class="line"><span class="keyword">bool</span> m_stopping = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure>



<h5 id="6-5-3-三个协程上下文信息"><a href="#6-5-3-三个协程上下文信息" class="headerlink" title="6.5.3 三个协程上下文信息"></a>6.5.3 三个协程上下文信息</h5><p>接下来是协程调度模块的全局变量和线程局部变量，这里只有以下两个线程局部变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 当前线程的调度器，同一个调度器下的所有线程指同同一个调度器实例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Scheduler *t_scheduler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 当前线程的调度协程，每个线程都独有一份，包括caller线程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber *t_scheduler_fiber = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure>

<p>t_scheduler_fiber保存当前线程的调度协程，加上Fiber模块的t_fiber和t_thread_fiber，每个线程总共可以记录三个协程的上下文信息。</p>
<h5 id="6-5-4-调度器的构造方法"><a href="#6-5-4-调度器的构造方法" class="headerlink" title="6.5.4 调度器的构造方法"></a>6.5.4 调度器的构造方法</h5><p>调度器的构造方法，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建调度器</span></span><br><span class="line"><span class="comment"> * @param[in] threads 线程数</span></span><br><span class="line"><span class="comment"> * @param[in] use_caller 是否将当前线程也作为调度线程</span></span><br><span class="line"><span class="comment"> * @param[in] name 名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Scheduler::Scheduler(<span class="keyword">size_t</span> threads, <span class="keyword">bool</span> use_caller, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) &#123;</span><br><span class="line">    SYLAR_ASSERT(threads &gt; <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    m_useCaller = use_caller;</span><br><span class="line">    m_name      = name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (use_caller) &#123;</span><br><span class="line">        --threads;</span><br><span class="line">        sylar::Fiber::GetThis();</span><br><span class="line">        SYLAR_ASSERT(GetThis() == <span class="literal">nullptr</span>);</span><br><span class="line">        t_scheduler = <span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在user_caller为true的情况下，初始化caller线程的调度协程</span></span><br><span class="line"><span class="comment">         * caller线程的调度协程不会被调度器调度，而且，caller线程的调度协程停止时，应该返回caller线程的主协程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        m_rootFiber.reset(<span class="keyword">new</span> Fiber(<span class="built_in">std</span>::bind(&amp;Scheduler::run, <span class="keyword">this</span>), <span class="number">0</span>, <span class="literal">false</span>));</span><br><span class="line"> </span><br><span class="line">        sylar::Thread::SetName(m_name);</span><br><span class="line">        t_scheduler_fiber = m_rootFiber.get();</span><br><span class="line">        m_rootThread      = sylar::GetThreadId();</span><br><span class="line">        m_threadIds.push_back(m_rootThread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m_rootThread = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_threadCount = threads;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Scheduler *<span class="title">Scheduler::GetThis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_scheduler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来是两个get方法，用于获取当前线程的调度器的调度协程，这两个都是静态方法：</span><br><span class="line"></span><br><span class="line"><span class="function">Scheduler *<span class="title">Scheduler::GetThis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_scheduler;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Fiber *<span class="title">Scheduler::GetMainFiber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_scheduler_fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来是协程调度器的start方法实现，这里主要初始化调度线程池，如果只使用caller线程进行调度，那这个方法啥也不做：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (m_stopping) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;Scheduler is stopped&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SYLAR_ASSERT(m_threads.empty());</span><br><span class="line">    m_threads.resize(m_threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_threadCount; i++) &#123;</span><br><span class="line">        m_threads[i].reset(<span class="keyword">new</span> Thread(<span class="built_in">std</span>::bind(&amp;Scheduler::run, <span class="keyword">this</span>),</span><br><span class="line">                                      m_name + <span class="string">&quot;_&quot;</span> + <span class="built_in">std</span>::to_string(i)));</span><br><span class="line">        m_threadIds.push_back(m_threads[i]-&gt;getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来判断调度器是否已经停止的方法，只有当所有的任务都被执行完了，调度器才可以停止：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Scheduler::stopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> m_stopping &amp;&amp; m_tasks.empty() &amp;&amp; m_activeThreadCount == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来是调度器的tickle和idle实现，可以看到这两个方法并没有什么卵用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::tickle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;ticlke&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::idle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;idle&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stopping()) &#123;</span><br><span class="line">        sylar::Fiber::GetThis()-&gt;yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来是调度协程的实现，内部有一个while(true)循环，不停地从任务队列取任务并执行，由于Fiber类改造过，每个被调度器执行的协程在结束时都会回到调度协程，所以这里不用担心跑飞问题，当任务队列为空时，代码会进idle协程，但idle协程啥也不做直接就yield了，状态还是READY状态，所以这里其实就是个忙等待，CPU占用率爆炸，只有当调度器检测到停止标志时，idle协程才会真正结束，调度协程也会检测到idle协程状态为TERM，并且随之退出整个调度协程。这里还可以看出一点，对于一个任务协程，只要其从resume中返回了，那不管它的状态是TERM还是READY，调度器都不会自动将其再次加入调度，因为前面说过，一个成熟的协程是要学会自我管理的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;run&quot;</span>;</span><br><span class="line">    setThis();</span><br><span class="line">    <span class="keyword">if</span> (sylar::GetThreadId() != m_rootThread) &#123;</span><br><span class="line">        t_scheduler_fiber = sylar::Fiber::GetThis().get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Fiber::ptr <span class="title">idle_fiber</span><span class="params">(<span class="keyword">new</span> Fiber(<span class="built_in">std</span>::bind(&amp;Scheduler::idle, <span class="keyword">this</span>)))</span></span>;</span><br><span class="line">    Fiber::ptr cb_fiber;</span><br><span class="line"> </span><br><span class="line">    ScheduleTask task;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        task.reset();</span><br><span class="line">        <span class="keyword">bool</span> tickle_me = <span class="literal">false</span>; <span class="comment">// 是否tickle其他线程进行任务调度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> it = m_tasks.begin();</span><br><span class="line">            <span class="comment">// 遍历所有调度任务</span></span><br><span class="line">            <span class="keyword">while</span> (it != m_tasks.end()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;thread != <span class="number">-1</span> &amp;&amp; it-&gt;thread != sylar::GetThreadId()) &#123;</span><br><span class="line">                    <span class="comment">// 指定了调度线程，但不是在当前线程上调度，标记一下需要通知其他线程进行调度，然后跳过这个任务，继续下一个</span></span><br><span class="line">                    ++it;</span><br><span class="line">                    tickle_me = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 找到一个未指定线程，或是指定了当前线程的任务</span></span><br><span class="line">                SYLAR_ASSERT(it-&gt;fiber || it-&gt;cb);</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;fiber) &#123;</span><br><span class="line">                    <span class="comment">// 任务队列时的协程一定是READY状态，谁会把RUNNING或TERM状态的协程加入调度呢？</span></span><br><span class="line">                    SYLAR_ASSERT(it-&gt;fiber-&gt;getState() == Fiber::READY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前调度线程找到一个任务，准备开始调度，将其从任务队列中剔除，活动线程数加1</span></span><br><span class="line">                task = *it;</span><br><span class="line">                m_tasks.erase(it++);</span><br><span class="line">                ++m_activeThreadCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前线程拿完一个任务后，发现任务队列还有剩余，那么tickle一下其他线程</span></span><br><span class="line">            tickle_me |= (it != m_tasks.end());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (tickle_me) &#123;</span><br><span class="line">            tickle();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (task.fiber) &#123;</span><br><span class="line">            <span class="comment">// resume协程，resume返回时，协程要么执行完了，要么半路yield了，总之这个任务就算完成了，活跃线程数减一</span></span><br><span class="line">            task.fiber-&gt;resume();</span><br><span class="line">            --m_activeThreadCount;</span><br><span class="line">            task.reset();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.cb) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cb_fiber) &#123;</span><br><span class="line">                cb_fiber-&gt;reset(task.cb);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cb_fiber.reset(<span class="keyword">new</span> Fiber(task.cb));</span><br><span class="line">            &#125;</span><br><span class="line">            task.reset();</span><br><span class="line">            cb_fiber-&gt;resume();</span><br><span class="line">            --m_activeThreadCount;</span><br><span class="line">            cb_fiber.reset();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进到这个分支情况一定是任务队列空了，调度idle协程即可</span></span><br><span class="line">            <span class="keyword">if</span> (idle_fiber-&gt;getState() == Fiber::TERM) &#123;</span><br><span class="line">                <span class="comment">// 如果调度器没有调度任务，那么idle协程会不停地resume/yield，不会结束，如果idle协程结束了，那一定是调度器停止了</span></span><br><span class="line">                SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;idle fiber term&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++m_idleThreadCount;</span><br><span class="line">            idle_fiber-&gt;resume();</span><br><span class="line">            --m_idleThreadCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;Scheduler::run() exit&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>最后是调度器的stop方法，在使用了caller线程的情况下，调度器依赖stop方法来执行caller线程的调度协程，如果调度器只使用了caller线程来调度，那调度器真正开始执行调度的位置就是这个stop方法。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (stopping()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_stopping = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 如果use caller，那只能由caller线程发起stop</span></span><br><span class="line">    <span class="keyword">if</span> (m_useCaller) &#123;</span><br><span class="line">        SYLAR_ASSERT(GetThis() == <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SYLAR_ASSERT(GetThis() != <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_threadCount; i++) &#123;</span><br><span class="line">        tickle();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (m_rootFiber) &#123;</span><br><span class="line">        tickle();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 在use caller情况下，调度器协程结束时，应该返回caller协程</span></span><br><span class="line">    <span class="keyword">if</span> (m_rootFiber) &#123;</span><br><span class="line">        m_rootFiber-&gt;resume();</span><br><span class="line">        SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;m_rootFiber end&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Thread::ptr&gt; thrs;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        thrs.swap(m_threads);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : thrs) &#123;</span><br><span class="line">        i-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="6-6-注意事项"><a href="#6-6-注意事项" class="headerlink" title="6.6 注意事项"></a>6.6 注意事项</h4><p>sylar的协程调度模块因为存任务队列空闲时调度线程忙等待的问题，所以<strong>实际上并不实用，真正实用的是后面基于Scheduler实现的IOManager。</strong>由于任务队列的任务是按顺序执行的，如果有一个任务占用了比较长时间，那其他任务的执行会受到影响，如果任务执行的是像while(1)这样的循环，那线程数不够时，后面的任务都不会得到执行。另外，当前还没有实现hook功能，像sleep和等待IO就绪这样的操作也会阻塞协程调度。</p>
<h3 id="七-IO协程调度模块"><a href="#七-IO协程调度模块" class="headerlink" title="七 IO协程调度模块"></a>七 IO协程调度模块</h3><p>继承自协程调度器，封装了epoll，支持为socket fd注册读写事件回调函数。</p>
<p><strong>IO协程调度还解决了调度器在idle状态下忙等待导致CPU占用率高的问题。</strong> IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。</p>
<h4 id="7-1-IO协程调度概述"><a href="#7-1-IO协程调度概述" class="headerlink" title="7.1 IO协程调度概述"></a>7.1 IO协程调度概述</h4><p>IO协程调度可以看成是增强版的协程调度。</p>
<blockquote>
<p>在前面的协程调度模块中，调度器对协程的调度是无条件执行的，在调度器已经启动调度的情况下，任务一旦添加成功，就会排队等待调度器执行。调度器不支持删除调度任务，并且调度器在正常退出之前一定会执行完全部的调度任务，所以在某种程度上可以认为，把一个协程添加到调度器的任务队列，就相当于调用了协程的resume方法。</p>
</blockquote>
<p>IO协程调度支持协程调度的全部功能，因为IO协程调度器是直接继承协程调度器实现的。除了协程调度，<strong>IO协程调度还增加了IO事件调度的功能，这个功能是针对描述符（一般是套接字描述符）的。</strong> IO协程调度支持为描述符注册可读和可写事件的回调函数，当描述符可读或可写时，执行对应的回调函数。（这里可以直接把回调函数等效成协程，所以这个功能被称为IO协程调度）</p>
<p>IO事件调度功能对服务器开发至关重要，因为服务器通常需要处理大量来自客户端的socket fd，<strong>使用IO事件调度可以将开发者从判断socket fd是否可读或可写的工作中解放出来，使得程序员只需要关心socket fd的IO操作。</strong> 后续的socket api hook模块也依赖IO协程调度。</p>
<blockquote>
<p>很多的库都可以实现类似的工作，比如libevent，libuv，libev等，这些库被称为异步事件库或异步IO库，从网上可以很容易地找到大把的资料介绍这类库。有的库不仅可以处理socket fd事件，还可以处理定时器事件和信号事件。</p>
<p>这些事件库的实现原理基本类似，都是先将套接字设置成非阻塞状态，然后将套接字与回调函数绑定，接下来进入一个基于IO多路复用的事件循环，等待事件发生，然后调用对应的回调函数。这里可以参考一个基于epoll实现的简单事件库：<a target="_blank" rel="noopener" href="https://www.kancloud.cn/aceld/libevent_aceld/1858559">3.2 epoll的反应堆模式实现 · libevent深入浅出 · 看云</a>，sylar的IO调度和这种写法类似。</p>
</blockquote>
<h4 id="7-2-IO协程调度模块设计"><a href="#7-2-IO协程调度模块设计" class="headerlink" title="7.2 IO协程调度模块设计"></a>7.2 IO协程调度模块设计</h4><p>sylar的IO协程调度模块基于epoll实现，只支持Linux平台。<strong>对每个fd，sylar支持两类事件，一类是可读事件，对应<code>EPOLLIN</code>，一类是可写事件，对应<code>EPOLLOUT</code>，sylar的事件枚举值直接继承自epoll。</strong></p>
<p>当然epoll本身除了支持了EPOLLIN和EPOLLOUT两类事件外，还支持其他事件，比如EPOLLRDHUP, EPOLLERR, EPOLLHUP等，对于这些事件，sylar的做法是将其进行归类，分别对应到EPOLLIN和EPOLLOUT中，也就是所有的事件都可以表示为可读或可写事件，甚至有的事件还可以同时表示可读及可写事件，比如EPOLLERR事件发生时，fd将同时触发可读和可写事件。</p>
<p>对于IO协程调度来说，每次调度都包含一个三元组信息，分别是<strong>描述符-事件类型（可读或可写）-回调函数</strong>，调度器记录全部需要调度的三元组信息，其中描述符和事件类型用于epoll_wait，回调函数用于协程调度。这个三元组信息在源码上通过<code>FdContext</code>结构体来存储，在执行epoll_wait时通过epoll_event的私有数据指针data.ptr来保存FdContext结构体信息。</p>
<p>IO协程调度器在idle时会epoll_wait所有注册的fd，如果有fd满足条件，epoll_wait返回，从私有数据中拿到fd的上下文信息，并且执行其中的回调函数。（<strong>实际是idle协程只负责收集所有已触发的fd的回调函数并将其加入调度器的任务队列，真正的执行时机是idle协程退出后，调度器在下一轮调度时执行</strong>）</p>
<p>与协程调度器不一样的是，IO协程调度器支持取消事件。取消事件表示不关心某个fd的某个事件了，如果某个fd的可读或可写事件都被取消了，那这个fd会从调度器的epoll_wait中删除。</p>
<h4 id="7-3-IO协程调度器实现"><a href="#7-3-IO协程调度器实现" class="headerlink" title="7.3 IO协程调度器实现"></a>7.3 IO协程调度器实现</h4><h5 id="7-3-1-IOManger类"><a href="#7-3-1-IOManger类" class="headerlink" title="7.3.1 IOManger类"></a>7.3.1 IOManger类</h5><p>sylar的IO协程调度器对应IOManager，这个类直接继承自Scheduler：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOManager</span> :</span> <span class="keyword">public</span> Scheduler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IOManager&gt; ptr;</span><br><span class="line">    <span class="keyword">typedef</span> RWMutex RWMutexType;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>首先是读写事件的定义，这里直接继承epoll的枚举值，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief IO事件，继承自epoll对事件的定义</span></span><br><span class="line"><span class="comment"> * @details 这里只关心socket fd的读和写事件，其他epoll事件会归类到这两类事件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">    <span class="comment">/// 无事件</span></span><br><span class="line">    NONE = <span class="number">0x0</span>,</span><br><span class="line">    <span class="comment">/// 读事件(EPOLLIN)</span></span><br><span class="line">    READ = <span class="number">0x1</span>,</span><br><span class="line">    <span class="comment">/// 写事件(EPOLLOUT)</span></span><br><span class="line">    WRITE = <span class="number">0x4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<p>接下来是IOManager的成员变量。IOManager包含一个epoll实例的句柄m_epfd以及用于tickle的一对pipe fd，还有全部的fd上下文m_fdContexts，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// epoll 文件句柄</span></span><br><span class="line"><span class="keyword">int</span> m_epfd = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// pipe 文件句柄，fd[0]读端，fd[1]写端</span></span><br><span class="line"><span class="keyword">int</span> m_tickleFds[<span class="number">2</span>];</span><br><span class="line"><span class="comment">/// 当前等待执行的IO事件数量</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; m_pendingEventCount = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/// IOManager的Mutex</span></span><br><span class="line">RWMutexType m_mutex;</span><br><span class="line"><span class="comment">/// socket事件上下文的容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FdContext *&gt; m_fdContexts;</span><br></pre></td></tr></table></figure>





<h5 id="7-3-2-fd上下文"><a href="#7-3-2-fd上下文" class="headerlink" title="7.3.2 fd上下文"></a>7.3.2 fd上下文</h5><p>接下来是对描述符-事件类型-回调函数三元组的定义，这个三元组也称为fd上下文，使用结构体FdContext来表示。<strong>由于fd有可读和可写两种事件，每种事件的回调函数也可以不一样，所以每个fd都需要保存两个事件类型-回调函数组合。</strong> FdContext结构体定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief socket fd上下文类</span></span><br><span class="line"><span class="comment"> * @details 每个socket fd都对应一个FdContext，包括fd的值，fd上的事件，以及fd的读写事件上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FdContext</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Mutex MutexType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 事件上下文类</span></span><br><span class="line"><span class="comment">     * @details fd的每个事件都有一个事件上下文，保存这个事件的回调函数以及执行回调函数的调度器</span></span><br><span class="line"><span class="comment">     *       sylar对fd事件做了简化，只预留了读事件和写事件，所有的事件都被归类到这两类事件中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EventContext</span> &#123;</span></span><br><span class="line">        <span class="comment">/// 执行事件回调的调度器</span></span><br><span class="line">        Scheduler *scheduler = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">/// 事件回调协程</span></span><br><span class="line">        Fiber::ptr fiber;</span><br><span class="line">        <span class="comment">/// 事件回调函数</span></span><br><span class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取事件上下文类</span></span><br><span class="line"><span class="comment">     * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment">     * @return 返回对应事件的上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">EventContext &amp;<span class="title">getEventContext</span><span class="params">(Event event)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重置事件上下文</span></span><br><span class="line"><span class="comment">     * @param[in, out] ctx 待重置的事件上下文对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetEventContext</span><span class="params">(EventContext &amp;ctx)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 触发事件</span></span><br><span class="line"><span class="comment">     * @details 根据事件类型调用对应上下文结构中的调度器去调度回调协程或回调函数</span></span><br><span class="line"><span class="comment">     * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">triggerEvent</span><span class="params">(Event event)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 读事件上下文</span></span><br><span class="line">    EventContext read;</span><br><span class="line">    <span class="comment">/// 写事件上下文</span></span><br><span class="line">    EventContext write;</span><br><span class="line">    <span class="comment">/// 事件关联的句柄</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// 该fd添加了哪些事件的回调函数，或者说该fd关心哪些事件</span></span><br><span class="line">    Event events = NONE;</span><br><span class="line">    <span class="comment">/// 事件的Mutex</span></span><br><span class="line">    MutexType mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="7-3-3-改造协程调度器"><a href="#7-3-3-改造协程调度器" class="headerlink" title="7.3.3 改造协程调度器"></a>7.3.3 改造协程调度器</h5><p>接下来是在继承类IOManager中改造协程调度器，使其支持epoll，并重载tickle和idle，实现通知调度协程和IO协程调度功能：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 构造函数</span></span><br><span class="line"><span class="comment"> * @param[in] threads 线程数量</span></span><br><span class="line"><span class="comment"> * @param[in] use_caller 是否将调用线程包含进去</span></span><br><span class="line"><span class="comment"> * @param[in] name 调度器的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">IOManager::IOManager(<span class="keyword">size_t</span> threads, <span class="keyword">bool</span> use_caller, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">    : Scheduler(threads, use_caller, name) &#123;</span><br><span class="line">    <span class="comment">// 创建epoll实例</span></span><br><span class="line">    m_epfd = epoll_create(<span class="number">5000</span>);</span><br><span class="line">    SYLAR_ASSERT(m_epfd &gt; <span class="number">0</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 创建pipe，获取m_tickleFds[2]，其中m_tickleFds[0]是管道的读端，m_tickleFds[1]是管道的写端</span></span><br><span class="line">    <span class="keyword">int</span> rt = pipe(m_tickleFds);</span><br><span class="line">    SYLAR_ASSERT(!rt);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注册pipe读句柄的可读事件，用于tickle调度协程，通过epoll_event.data.fd保存描述符</span></span><br><span class="line">    epoll_event event;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event));</span><br><span class="line">    event.events  = EPOLLIN | EPOLLET;</span><br><span class="line">    event.data.fd = m_tickleFds[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 非阻塞方式，配合边缘触发</span></span><br><span class="line">    rt = fcntl(m_tickleFds[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">    SYLAR_ASSERT(!rt);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将管道的读描述符加入epoll多路复用，如果管道可读，idle中的epoll_wait会返回</span></span><br><span class="line">    rt = epoll_ctl(m_epfd, EPOLL_CTL_ADD, m_tickleFds[<span class="number">0</span>], &amp;event);</span><br><span class="line">    SYLAR_ASSERT(!rt);</span><br><span class="line"> </span><br><span class="line">    contextResize(<span class="number">32</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 这里直接开启了Schedluer，也就是说IOManager创建即可调度协程</span></span><br><span class="line">    start();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通知调度器有任务要调度</span></span><br><span class="line"><span class="comment"> * @details 写pipe让idle协程从epoll_wait退出，待idle协程yield之后Scheduler::run就可以调度其他任务</span></span><br><span class="line"><span class="comment"> * 如果当前没有空闲调度线程，那就没必要发通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IOManager::tickle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;tickle&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!hasIdleThreads()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rt = write(m_tickleFds[<span class="number">1</span>], <span class="string">&quot;T&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    SYLAR_ASSERT(rt == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief idle协程</span></span><br><span class="line"><span class="comment"> * @details 对于IO协程调度来说，应阻塞在等待IO事件上，idle退出的时机是epoll_wait返回，对应的操作是tickle或注册的IO事件就绪</span></span><br><span class="line"><span class="comment"> * 调度器无调度任务时会阻塞idle协程上，对IO调度器而言，idle状态应该关注两件事，一是有没有新的调度任务，对应Schduler::schedule()，</span></span><br><span class="line"><span class="comment"> * 如果有新的调度任务，那应该立即退出idle状态，并执行对应的任务；二是关注当前注册的所有IO事件有没有触发，如果有触发，那么应该执行</span></span><br><span class="line"><span class="comment"> * IO事件对应的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IOManager::idle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;idle&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一次epoll_wait最多检测256个就绪事件，如果就绪事件超过了这个数，那么会在下轮epoll_wati继续处理</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> MAX_EVNETS = <span class="number">256</span>;</span><br><span class="line">    epoll_event *events       = <span class="keyword">new</span> epoll_event[MAX_EVNETS]();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;epoll_event&gt; <span class="title">shared_events</span><span class="params">(events, [](epoll_event *ptr) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">delete</span>[] ptr;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stopping()) &#123;</span><br><span class="line">            SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; getName() &lt;&lt; <span class="string">&quot;idle stopping exit&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞在epoll_wait上，等待事件发生</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">int</span> rt = epoll_wait(m_epfd, events, MAX_EVNETS, MAX_TIMEOUT);</span><br><span class="line">        <span class="keyword">if</span>(rt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_wait(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;) (rt=&quot;</span></span><br><span class="line">                                      &lt;&lt; rt &lt;&lt; <span class="string">&quot;) (errno=&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (errstr:&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 遍历所有发生的事件，根据epoll_event的私有指针找到对应的FdContext，进行事件处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rt; ++i) &#123;</span><br><span class="line">            epoll_event &amp;event = events[i];</span><br><span class="line">            <span class="keyword">if</span> (event.data.fd == m_tickleFds[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// ticklefd[0]用于通知协程调度，这时只需要把管道里的内容读完即可，本轮idle结束Scheduler::run会重新执行协程调度</span></span><br><span class="line">                <span class="keyword">uint8_t</span> dummy[<span class="number">256</span>];</span><br><span class="line">                <span class="keyword">while</span> (read(m_tickleFds[<span class="number">0</span>], dummy, <span class="keyword">sizeof</span>(dummy)) &gt; <span class="number">0</span>)</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 通过epoll_event的私有指针获取FdContext</span></span><br><span class="line">            FdContext *fd_ctx = (FdContext *)event.data.ptr;</span><br><span class="line">            FdContext::<span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * EPOLLERR: 出错，比如写读端已经关闭的pipe</span></span><br><span class="line"><span class="comment">             * EPOLLHUP: 套接字对端关闭</span></span><br><span class="line"><span class="comment">             * 出现这两种事件，应该同时触发fd的读和写事件，否则有可能出现注册的事件永远执行不到的情况</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (event.events &amp; (EPOLLERR | EPOLLHUP)) &#123;</span><br><span class="line">                event.events |= (EPOLLIN | EPOLLOUT) &amp; fd_ctx-&gt;events;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> real_events = NONE;</span><br><span class="line">            <span class="keyword">if</span> (event.events &amp; EPOLLIN) &#123;</span><br><span class="line">                real_events |= READ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (event.events &amp; EPOLLOUT) &#123;</span><br><span class="line">                real_events |= WRITE;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> ((fd_ctx-&gt;events &amp; real_events) == NONE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 剔除已经发生的事件，将剩下的事件重新加入epoll_wait，</span></span><br><span class="line">            <span class="comment">// 如果剩下的事件为0，表示这个fd已经不需要关注了，直接从epoll中删除</span></span><br><span class="line">            <span class="keyword">int</span> left_events = (fd_ctx-&gt;events &amp; ~real_events);</span><br><span class="line">            <span class="keyword">int</span> op          = left_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">            event.events    = EPOLLET | left_events;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> rt2 = epoll_ctl(m_epfd, op, fd_ctx-&gt;fd, &amp;event);</span><br><span class="line">            <span class="keyword">if</span> (rt2) &#123;</span><br><span class="line">                SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                          &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd_ctx-&gt;fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)event.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                          &lt;&lt; rt2 &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 处理已经发生的事件，也就是让调度器调度指定的函数或协程</span></span><br><span class="line">            <span class="keyword">if</span> (real_events &amp; READ) &#123;</span><br><span class="line">                fd_ctx-&gt;triggerEvent(READ);</span><br><span class="line">                --m_pendingEventCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (real_events &amp; WRITE) &#123;</span><br><span class="line">                fd_ctx-&gt;triggerEvent(WRITE);</span><br><span class="line">                --m_pendingEventCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end for</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一旦处理完所有的事件，idle协程yield，这样可以让调度协程(Scheduler::run)重新检查是否有新任务要调度</span></span><br><span class="line"><span class="comment">         * 上面triggerEvent实际也只是把对应的fiber重新加入调度，要执行的话还要等idle协程退出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Fiber::ptr cur = Fiber::GetThis();</span><br><span class="line">        <span class="keyword">auto</span> raw_ptr   = cur.get();</span><br><span class="line">        cur.reset();</span><br><span class="line"> </span><br><span class="line">        raw_ptr-&gt;yield();</span><br><span class="line">    &#125; <span class="comment">// end while(true)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<h5 id="7-3-4-事件回调函数"><a href="#7-3-4-事件回调函数" class="headerlink" title="7.3.4 事件回调函数"></a>7.3.4 事件回调函数</h5><p>接下来是注册事件回调addEvent，删除事件回调delEvent，取消事件回调cancelEvent，以及取消全部事件cancelAll：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 添加事件</span></span><br><span class="line"><span class="comment"> * @details fd描述符发生了event事件时执行cb函数</span></span><br><span class="line"><span class="comment"> * @param[in] fd socket句柄</span></span><br><span class="line"><span class="comment"> * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment"> * @param[in] cb 事件回调函数，如果为空，则默认把当前协程作为回调执行体</span></span><br><span class="line"><span class="comment"> * @return 添加成功返回0,失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IOManager::addEvent</span><span class="params">(<span class="keyword">int</span> fd, Event event, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到fd对应的FdContext，如果不存在，那就分配一个</span></span><br><span class="line">    FdContext *fd_ctx = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_fdContexts.size() &gt; fd) &#123;</span><br><span class="line">        fd_ctx = m_fdContexts[fd];</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="function">RWMutexType::WriteLock <span class="title">lock2</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        contextResize(fd * <span class="number">1.5</span>);</span><br><span class="line">        fd_ctx = m_fdContexts[fd];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 同一个fd不允许重复添加相同的事件</span></span><br><span class="line">    FdContext::<span class="function">MutexType::Lock <span class="title">lock2</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (SYLAR_UNLIKELY(fd_ctx-&gt;events &amp; event)) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;addEvent assert fd=&quot;</span> &lt;&lt; fd</span><br><span class="line">                                  &lt;&lt; <span class="string">&quot; event=&quot;</span> &lt;&lt; (EPOLL_EVENTS)event</span><br><span class="line">                                  &lt;&lt; <span class="string">&quot; fd_ctx.event=&quot;</span> &lt;&lt; (EPOLL_EVENTS)fd_ctx-&gt;events;</span><br><span class="line">        SYLAR_ASSERT(!(fd_ctx-&gt;events &amp; event));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将新的事件加入epoll_wait，使用epoll_event的私有指针存储FdContext的位置</span></span><br><span class="line">    <span class="keyword">int</span> op = fd_ctx-&gt;events ? EPOLL_CTL_MOD : EPOLL_CTL_ADD;</span><br><span class="line">    epoll_event epevent;</span><br><span class="line">    epevent.events   = EPOLLET | fd_ctx-&gt;events | event;</span><br><span class="line">    epevent.data.ptr = fd_ctx;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                  &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                  &lt;&lt; rt &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;) fd_ctx-&gt;events=&quot;</span></span><br><span class="line">                                  &lt;&lt; (EPOLL_EVENTS)fd_ctx-&gt;events;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 待执行IO事件数加1</span></span><br><span class="line">    ++m_pendingEventCount;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 找到这个fd的event事件对应的EventContext，对其中的scheduler, cb, fiber进行赋值</span></span><br><span class="line">    fd_ctx-&gt;events                     = (Event)(fd_ctx-&gt;events | event);</span><br><span class="line">    FdContext::EventContext &amp;event_ctx = fd_ctx-&gt;getEventContext(event);</span><br><span class="line">    SYLAR_ASSERT(!event_ctx.scheduler &amp;&amp; !event_ctx.fiber &amp;&amp; !event_ctx.cb);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 赋值scheduler和回调函数，如果回调函数为空，则把当前协程当成回调执行体</span></span><br><span class="line">    event_ctx.scheduler = Scheduler::GetThis();</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        event_ctx.cb.swap(cb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event_ctx.fiber = Fiber::GetThis();</span><br><span class="line">        SYLAR_ASSERT2(event_ctx.fiber-&gt;getState() == Fiber::RUNNING, <span class="string">&quot;state=&quot;</span> &lt;&lt; event_ctx.fiber-&gt;getState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除事件</span></span><br><span class="line"><span class="comment"> * @param[in] fd socket句柄</span></span><br><span class="line"><span class="comment"> * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment"> * @attention 不会触发事件</span></span><br><span class="line"><span class="comment"> * @return 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IOManager::delEvent</span><span class="params">(<span class="keyword">int</span> fd, Event event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到fd对应的FdContext</span></span><br><span class="line">    <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_fdContexts.size() &lt;= fd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FdContext *fd_ctx = m_fdContexts[fd];</span><br><span class="line">    lock.unlock();</span><br><span class="line"> </span><br><span class="line">    FdContext::<span class="function">MutexType::Lock <span class="title">lock2</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (SYLAR_UNLIKELY(!(fd_ctx-&gt;events &amp; event))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 清除指定的事件，表示不关心这个事件了，如果清除之后结果为0，则从epoll_wait中删除该文件描述符</span></span><br><span class="line">    Event new_events = (Event)(fd_ctx-&gt;events &amp; ~event);</span><br><span class="line">    <span class="keyword">int</span> op           = new_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">    epoll_event epevent;</span><br><span class="line">    epevent.events   = EPOLLET | new_events;</span><br><span class="line">    epevent.data.ptr = fd_ctx;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                  &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                  &lt;&lt; rt &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 待执行事件数减1</span></span><br><span class="line">    --m_pendingEventCount;</span><br><span class="line">    <span class="comment">// 重置该fd对应的event事件上下文</span></span><br><span class="line">    fd_ctx-&gt;events                     = new_events;</span><br><span class="line">    FdContext::EventContext &amp;event_ctx = fd_ctx-&gt;getEventContext(event);</span><br><span class="line">    fd_ctx-&gt;resetEventContext(event_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 取消事件</span></span><br><span class="line"><span class="comment"> * @param[in] fd socket句柄</span></span><br><span class="line"><span class="comment"> * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment"> * @attention 如果该事件被注册过回调，那就触发一次回调事件</span></span><br><span class="line"><span class="comment"> * @return 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IOManager::cancelEvent</span><span class="params">(<span class="keyword">int</span> fd, Event event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到fd对应的FdContext</span></span><br><span class="line">    <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_fdContexts.size() &lt;= fd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FdContext *fd_ctx = m_fdContexts[fd];</span><br><span class="line">    lock.unlock();</span><br><span class="line"> </span><br><span class="line">    FdContext::<span class="function">MutexType::Lock <span class="title">lock2</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (SYLAR_UNLIKELY(!(fd_ctx-&gt;events &amp; event))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除事件</span></span><br><span class="line">    Event new_events = (Event)(fd_ctx-&gt;events &amp; ~event);</span><br><span class="line">    <span class="keyword">int</span> op           = new_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">    epoll_event epevent;</span><br><span class="line">    epevent.events   = EPOLLET | new_events;</span><br><span class="line">    epevent.data.ptr = fd_ctx;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                  &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                  &lt;&lt; rt &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除之前触发一次事件</span></span><br><span class="line">    fd_ctx-&gt;triggerEvent(event);</span><br><span class="line">    <span class="comment">// 活跃事件数减1</span></span><br><span class="line">    --m_pendingEventCount;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 取消所有事件</span></span><br><span class="line"><span class="comment"> * @details 所有被注册的回调事件在cancel之前都会被执行一次</span></span><br><span class="line"><span class="comment"> * @param[in] fd socket句柄</span></span><br><span class="line"><span class="comment"> * @return 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IOManager::cancelAll</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到fd对应的FdContext</span></span><br><span class="line">    <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_fdContexts.size() &lt;= fd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FdContext *fd_ctx = m_fdContexts[fd];</span><br><span class="line">    lock.unlock();</span><br><span class="line"> </span><br><span class="line">    FdContext::<span class="function">MutexType::Lock <span class="title">lock2</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fd_ctx-&gt;events) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除全部事件</span></span><br><span class="line">    <span class="keyword">int</span> op = EPOLL_CTL_DEL;</span><br><span class="line">    epoll_event epevent;</span><br><span class="line">    epevent.events   = <span class="number">0</span>;</span><br><span class="line">    epevent.data.ptr = fd_ctx;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                  &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                  &lt;&lt; rt &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 触发全部已注册的事件</span></span><br><span class="line">    <span class="keyword">if</span> (fd_ctx-&gt;events &amp; READ) &#123;</span><br><span class="line">        fd_ctx-&gt;triggerEvent(READ);</span><br><span class="line">        --m_pendingEventCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fd_ctx-&gt;events &amp; WRITE) &#123;</span><br><span class="line">        fd_ctx-&gt;triggerEvent(WRITE);</span><br><span class="line">        --m_pendingEventCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    SYLAR_ASSERT(fd_ctx-&gt;events == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h5 id="7-3-5-IOManager析构函数"><a href="#7-3-5-IOManager析构函数" class="headerlink" title="7.3.5 IOManager析构函数"></a>7.3.5 IOManager析构函数</h5><p>接下来是IOManager的析构函数实现和stopping重载。对于IOManager的析构，首先要等Scheduler调度完所有的任务，然后再关闭epoll句柄和pipe句柄，然后释放所有的FdContext；对于stopping，IOManager在判断是否可退出时，还要加上所有IO事件都完成调度的条件：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IOManager::~IOManager() &#123;</span><br><span class="line">    stop();</span><br><span class="line">    close(m_epfd);</span><br><span class="line">    close(m_tickleFds[<span class="number">0</span>]);</span><br><span class="line">    close(m_tickleFds[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_fdContexts.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_fdContexts[i]) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_fdContexts[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IOManager::stopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于IOManager而言，必须等所有待调度的IO事件都执行完了才可以退出</span></span><br><span class="line">    <span class="keyword">return</span> m_pendingEventCount == <span class="number">0</span> &amp;&amp; Scheduler::stopping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="7-4-IO协程调度的几点总结"><a href="#7-4-IO协程调度的几点总结" class="headerlink" title="7.4 IO协程调度的几点总结"></a>7.4 IO协程调度的几点总结</h4><p>总得来说，sylar的IO协程调度模块可分为两部分，<strong>第一部分是对协程调度器的改造，将epoll与协程调度融合，重新实现tickle和idle，并保证原有的功能不变。第二部分是基于epoll实现IO事件的添加、删除、调度、取消等功能。</strong></p>
<ol>
<li> IO协程调度关注的是FdContext信息，也就是描述符-事件-回调函数三元组，IOManager需要保存所有关注的三元组，并且在epoll_wait检测到描述符事件就绪时执行对应的回调函数。</li>
<li>epoll是线程安全的，即使调度器有多个调度线程，它们也可以共用同一个epoll实例，而不用担心互斥。由于空闲时所有线程都阻塞的epoll_wait上，所以也不用担心CPU占用问题。</li>
<li>addEvent是一次性的，比如说，注册了一个读事件，当fd可读时会触发该事件，但触发完之后，这次注册的事件就失效了，后面fd再次可读时，并不会继续执行该事件回调，如果要持续触发事件的回调，那每次事件处理完都要手动再addEvent。这样在应对fd的WRITE事件时会比较好处理，因为fd可写是常态，如果注册一次就一直有效，那么可写事件就必须在执行完之后就删除掉。</li>
<li>cancelEvent和cancelAll都会触发一次事件，但delEvent不会。</li>
<li>FdContext的寻址问题，sylar直接使用fd的值作为FdContext数组的下标，这样可以快速找到一个fd对应的FdContext。由于关闭的fd会被重复利用，所以这里也不用担心FdContext数组膨胀太快，或是利用率低的问题。</li>
<li> IO协程调度器的退出，不但所有协程要完成调度，所有IO事件也要完成调度。</li>
<li> sylar的IO协程调度器应该配合非阻塞IO来使用，如果使用阻塞模式，可能会阻塞进程，参考<a target="_blank" rel="noopener" href="https://www.zhihu.com/question/37271342">为什么 IO 多路复用要搭配非阻塞 IO? - 知乎</a>。</li>
</ol>
<h3 id="八-定时器模块"><a href="#八-定时器模块" class="headerlink" title="八 定时器模块"></a>八 定时器模块</h3><p>基于epoll超时实现定时器功能，精度毫秒级，支持在指定超时时间结束之后执行回调函数。</p>
<h4 id="8-1-定时器概述"><a href="#8-1-定时器概述" class="headerlink" title="8.1 定时器概述"></a>8.1 定时器概述</h4><p><strong>通过定时器可以实现给服务器注册定时事件</strong>，这是服务器上经常要处理的一类事件，比如3秒后关闭一个连接，或是定期检测一个客户端的连接状态。</p>
<p>定时事件依赖于Linux提供的定时机制，它是驱动定时事件的原动力，目前Linux提供了以下几种可供程序利用的定时机制：</p>
<ol>
<li><p>alarm()或setitimer()，这俩的本质都是先设置一个超时时间，然后等SIGALARM信号触发，通过捕获信号来判断超时</p>
</li>
<li><p>套接字超时选项，对应SO_RECVTIMEO和SO_SNDTIMEO，通过errno来判断超时</p>
</li>
<li><p>多路复用超时参数，select/poll/epoll都支持设置超时参数，通过判断返回值为0来判断超时</p>
</li>
<li><p>timer_create系统接口，实质也是借助信号，参考man 2 timer_create</p>
</li>
<li><p>timerfd_create系列接口，通过判断文件描述符可读来判断超时，可配合IO多路复用，参考man 2 timerfd_create</p>
</li>
</ol>
<p>服务器程序通常需要处理众多定时事件，如何有效地组织与管理这些定时事件对服务器的性能至关重要。<strong>为此，我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理。</strong></p>
<p>每个定时器通常至少包含两个成员：一个超时时间（相对时间或绝对时间）和一个任务回调函数。除此外，定时器还可以包括回调函数参数及是否自动重启等信息。</p>
<p>有两种高效管理定时器的容器：时间轮和时间堆，<strong>sylar使用时间堆的方式管理定时器。</strong></p>
<h4 id="8-2-几种定时器实现"><a href="#8-2-几种定时器实现" class="headerlink" title="8.2 几种定时器实现"></a>8.2 几种定时器实现</h4><h5 id="8-2-1-基于升序链表的定时器"><a href="#8-2-1-基于升序链表的定时器" class="headerlink" title="8.2.1 基于升序链表的定时器"></a>8.2.1 基于升序链表的定时器</h5><ol>
<li><p> 所有定时器组织成链表结构，链表成员包含超时时间，回调函数，回调函数参数，以及链表指针域。</p>
</li>
<li><p>定时器在链表中按超时时间进行升序排列，超时时间短的在前，长的在后。每次添加定时器时，都要按超时时间将定时器插入到链表的指定位置。</p>
</li>
<li><p>程序运行后维护一个周期性触发的tick信号，比如利用alarm函数周期性触发ALARM信号，在信号处理函数中从头遍历定时器链表，判断定时器是否超时。如果定时器超时，则记录下该定时器，然后将其从链表中删除。</p>
</li>
<li><p>执行所有超时的定时器的回调函数。</p>
</li>
</ol>
<p>以上就是一个基于升序链表的定时器实现，这种方式添加定时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)(<strong>双向链表</strong>)，执行定时任务的时间复杂度是O(1)。</p>
<p>tick信号的周期对定时器的性能有较大的影响，当tick信号周期较小时，定时器精度高，但CPU负担较高，因为要频繁执行信号处理函数；当tick信号周期较大时，CPU负担小，但定时精度差。</p>
<p>当定时器数量较多时，链表插入操作开销比较大。</p>
<h5 id="8-2-2-时间轮"><a href="#8-2-2-时间轮" class="headerlink" title="8.2.2 时间轮"></a>8.2.2 时间轮</h5><p>与上面的升序链表实现方式类似，也需要维护一个周期性触发的tick信号，但不同的是，定时器不再组织成单链表结构，而是按照超时时间，通过散列分布到不同的时间轮上，像下面这样：</p>
<img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230305172536051.png" class="" title="image-20230305172536051">

<p>上图所示的时间轮内，（实线）指针指向轮子上的一个槽 （slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽 （虚线指针指向的槽），每次转动称为一个滴答（tick）。一个滴答的 时间称为时间轮的槽间隔si（slot interval），它实际上就是心搏时间。该时间轮共有N个槽，因此它运转一周的时间是<code>N*si</code>。每个槽指向一条定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间 相差<code>N*si</code>的整数倍。</p>
<p>时间轮正是利用这个关系将定时器散列到不同的 链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时 器，则该定时器将被插入槽ts（timer slot）对应的链表中：</p>
<p><strong>ts = (cs + (ti / si)) % N</strong></p>
<p>很显然，对时间轮而言，要提高定时精度，就要使si值足够小；要 提高执行效率，则要求N值足够大。</p>
<h5 id="8-2-3-时间堆"><a href="#8-2-3-时间堆" class="headerlink" title="8.2.3 时间堆"></a>8.2.3 时间堆</h5><p><strong>上面的两种定时器设计都依赖一个固定周期触发的tick信号。</strong> <strong>设计定时器的另一种实现思路是直接将超时时间当作tick周期，具体操作是每次都取出所有定时器中超时时间最小的超时值作为一个tick，这样，一旦tick触发，超时时间最小的定时器必然到期</strong>。处理完已超时的定时器后，再从剩余的定时器中找出超时时间最小的一个，并将这个最小时间作为下一个tick，如此反复，就可以实现较为精确的定时。</p>
<p>最小堆很适合处理这种定时方案，将所有定时器按最小堆来组织，可以很方便地获取到当前的最小超时时间，sylar采取的即是这种方案。</p>
<h4 id="8-3-定时器设计"><a href="#8-3-定时器设计" class="headerlink" title="8.3 定时器设计"></a>8.3 定时器设计</h4><p>sylar的定时器采用最小堆设计，<strong>所有定时器根据绝对的超时时间点进行排序</strong>，每次取出离当前时间最近的一个超时时间点，计算出超时需要等待的时间，然后等待超时。超时时间到后，获取当前的绝对时间点，然后把最小堆里超时时间点小于这个时间点的定时器都收集起来，执行它们的回调函数。</p>
<p>注意，在注册定时事件时，一般提供的是相对时间，比如相对当前时间3秒后执行。sylar会根据传入的相对时间和当前的绝对时间计算出定时器超时时的绝对时间点，然后根据这个绝对时间点对定时器进行最小堆排序。因为依赖的是系统绝对时间，所以需要考虑校时因素，这点会在后面讨论。</p>
<p>sylar定时器的超时等待基于epoll_wait，精度只支持毫秒级，因为epoll_wait的超时精度也只有毫秒级。</p>
<p>关于定时器和IO协程调度器的整合。IO协程调度器的idle协程会在调度器空闲时阻塞在epoll_wait上，等待IO事件发生。在之前的代码里，epoll_wait具有固定的超时时间，这个值是5秒钟。<strong>加入定时器功能后，epoll_wait的超时时间改用当前定时器的最小超时时间来代替。epoll_wait返回后，根据当前的绝对时间把已超时的所有定时器收集起来，执行它们的回调函数。</strong></p>
<p>由于epoll_wait的返回并不一定是超时引起的，也有可能是IO事件唤醒的，所以在epoll_wait返回后不能想当然地假设定时器已经超时了，而是要再判断一下定时器有没有超时，这时绝对时间的好处就体现出来了，通过比较当前的绝对时间和定时器的绝对超时时间，就可以确定一个定时器到底有没有超时。</p>
<h4 id="8-4-定时器实现"><a href="#8-4-定时器实现" class="headerlink" title="8.4 定时器实现"></a>8.4 定时器实现</h4><h5 id="8-4-1-Timer-类"><a href="#8-4-1-Timer-类" class="headerlink" title="8.4.1 Timer 类"></a>8.4.1 Timer 类</h5><p>sylar的定时器对应Timer类，这个类的成员变量包括定时器的绝对超时时间点，是否重复执行，回调函数，以及一个指向TimerManager的指针，提供cancel/reset/refresh方法用于操作定时器。构造Timer时可以传入超时时间，也可以直接传入一个绝对时间。<strong>Timer的构造函数被定义成私有方式，只能通过TimerManager类来创建Timer对象。</strong>除此外，Timer类还提供了一个仿函数Comparator，用于比较两个Timer对象，比较的依据是绝对超时时间。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerManager</span>;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Timer&gt; &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerManager</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 定时器的智能指针类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Timer&gt; ptr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 取消定时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 刷新设置定时器的执行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">refresh</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重置定时器时间</span></span><br><span class="line"><span class="comment">     * @param[in] ms 定时器执行间隔时间(毫秒)</span></span><br><span class="line"><span class="comment">     * @param[in] from_now 是否从当前时间开始计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">reset</span><span class="params">(<span class="keyword">uint64_t</span> ms, <span class="keyword">bool</span> from_now)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     * @param[in] ms 定时器执行间隔时间</span></span><br><span class="line"><span class="comment">     * @param[in] cb 回调函数</span></span><br><span class="line"><span class="comment">     * @param[in] recurring 是否循环</span></span><br><span class="line"><span class="comment">     * @param[in] manager 定时器管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Timer(<span class="keyword">uint64_t</span> ms, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb,</span><br><span class="line">          <span class="keyword">bool</span> recurring, TimerManager* manager);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     * @param[in] next 执行的时间戳(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Timer(<span class="keyword">uint64_t</span> next);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 是否循环定时器</span></span><br><span class="line">    <span class="keyword">bool</span> m_recurring = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/// 执行周期</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_ms = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// 精确的执行时间</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_next = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// 回调函数</span></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; m_cb;</span><br><span class="line">    <span class="comment">/// 定时器管理器</span></span><br><span class="line">    TimerManager* m_manager = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 定时器比较仿函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Comparator</span> &#123;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @brief 比较定时器的智能指针的大小(按执行时间排序)</span></span><br><span class="line"><span class="comment">         * @param[in] lhs 定时器智能指针</span></span><br><span class="line"><span class="comment">         * @param[in] rhs 定时器智能指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Timer::ptr&amp; lhs, <span class="keyword">const</span> Timer::ptr&amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="8-4-2-TimerManager类"><a href="#8-4-2-TimerManager类" class="headerlink" title="8.4.2 TimerManager类"></a>8.4.2 TimerManager类</h5><p>所有的Timer对象都由TimerManager类进行管理，TimerManager包含一个std::set类型的Timer集合，这个集合就是定时器的最小堆结构，因为set里的元素总是排序过的，所以总是可以很方便地获取到当前的最小定时器。TimerManager提供创建定时器，获取最近一个定时器的超时时间，以及获取全部已经超时的定时器回调函数的方法，并且提供了一个onTimerInsertedAtFront()方法，这是一个虚函数，由IOManager继承时实现，当新的定时器插入到Timer集合的首部时，TimerManager通过该方法来通知IOManager立刻更新当前的epoll_wait超时。TimerManager还负责检测是否发生了校时，由detectClockRollover方法实现。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerManager</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Timer</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 读写锁类型</span></span><br><span class="line">    <span class="keyword">typedef</span> RWMutex RWMutexType;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TimerManager();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~TimerManager();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加定时器</span></span><br><span class="line"><span class="comment">     * @param[in] ms 定时器执行间隔时间</span></span><br><span class="line"><span class="comment">     * @param[in] cb 定时器回调函数</span></span><br><span class="line"><span class="comment">     * @param[in] recurring 是否循环定时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timer::ptr <span class="title">addTimer</span><span class="params">(<span class="keyword">uint64_t</span> ms, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb</span></span></span><br><span class="line"><span class="function"><span class="params">                        ,<span class="keyword">bool</span> recurring = <span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加条件定时器</span></span><br><span class="line"><span class="comment">     * @param[in] ms 定时器执行间隔时间</span></span><br><span class="line"><span class="comment">     * @param[in] cb 定时器回调函数</span></span><br><span class="line"><span class="comment">     * @param[in] weak_cond 条件</span></span><br><span class="line"><span class="comment">     * @param[in] recurring 是否循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timer::ptr <span class="title">addConditionTimer</span><span class="params">(<span class="keyword">uint64_t</span> ms, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb</span></span></span><br><span class="line"><span class="function"><span class="params">                        ,<span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">void</span>&gt; weak_cond</span></span></span><br><span class="line"><span class="function"><span class="params">                        ,<span class="keyword">bool</span> recurring = <span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 到最近一个定时器执行的时间间隔(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">uint64_t</span> <span class="title">getNextTimer</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取需要执行的定时器的回调函数列表</span></span><br><span class="line"><span class="comment">     * @param[out] cbs 回调函数数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listExpiredCb</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; &gt;&amp; cbs)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 是否有定时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasTimer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 当有新的定时器插入到定时器的首部,执行该函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTimerInsertedAtFront</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 将定时器添加到管理器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTimer</span><span class="params">(Timer::ptr val, RWMutexType::WriteLock&amp; lock)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 检测服务器时间是否被调后了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectClockRollover</span><span class="params">(<span class="keyword">uint64_t</span> now_ms)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// Mutex</span></span><br><span class="line">    RWMutexType m_mutex;</span><br><span class="line">    <span class="comment">/// 定时器集合</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Timer::ptr, Timer::Comparator&gt; m_timers;</span><br><span class="line">    <span class="comment">/// 是否触发onTimerInsertedAtFront</span></span><br><span class="line">    <span class="keyword">bool</span> m_tickled = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/// 上次执行时间</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_previouseTime = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h5 id="8-4-3-IOManager类"><a href="#8-4-3-IOManager类" class="headerlink" title="8.4.3 IOManager类"></a>8.4.3 IOManager类</h5><p>IOManager通过继承的方式获得TimerManager类的所有方法，这种方式相当于给IOManager外挂了一个定时器管理模块。为支持定时器功能，需要重新改造idle协程的实现，epoll_wait应该根据下一个定时器的超时时间来设置超时参数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOManager</span> :</span> <span class="keyword">public</span> Scheduler, <span class="keyword">public</span> TimerManager &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IOManager::idle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;idle&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一次epoll_wait最多检测256个就绪事件，如果就绪事件超过了这个数，那么会在下轮epoll_wati继续处理</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> MAX_EVNETS = <span class="number">256</span>;</span><br><span class="line">    epoll_event *events       = <span class="keyword">new</span> epoll_event[MAX_EVNETS]();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;epoll_event&gt; <span class="title">shared_events</span><span class="params">(events, [](epoll_event *ptr) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">delete</span>[] ptr;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取下一个定时器的超时时间，顺便判断调度器是否停止</span></span><br><span class="line">        <span class="keyword">uint64_t</span> next_timeout = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( SYLAR_UNLIKELY(stopping(next_timeout))) &#123;</span><br><span class="line">            SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; getName() &lt;&lt; <span class="string">&quot;idle stopping exit&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 阻塞在epoll_wait上，等待事件发生或定时器超时</span></span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">// 默认超时时间5秒，如果下一个定时器的超时时间大于5秒，仍以5秒来计算超时，避免定时器超时时间太大时，epoll_wait一直阻塞</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line">            <span class="keyword">if</span>(next_timeout != ~<span class="number">0ull</span>) &#123;</span><br><span class="line">                next_timeout = <span class="built_in">std</span>::min((<span class="keyword">int</span>)next_timeout, MAX_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next_timeout = MAX_TIMEOUT;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = epoll_wait(m_epfd, events, MAX_EVNETS, (<span class="keyword">int</span>)next_timeout);</span><br><span class="line">            <span class="keyword">if</span>(rt &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 收集所有已超时的定时器，执行回调函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; cbs;</span><br><span class="line">        listExpiredCb(cbs);</span><br><span class="line">        <span class="keyword">if</span>(!cbs.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cb : cbs) &#123;</span><br><span class="line">                schedule(cb);</span><br><span class="line">            &#125;</span><br><span class="line">            cbs.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="8-5-注意事项"><a href="#8-5-注意事项" class="headerlink" title="8.5 注意事项"></a>8.5 注意事项</h4><ol>
<li><p>创建定时器时只传入了相对超时时间，内部要先进行转换，根据当前时间把相对时间转化成绝对时间。</p>
</li>
<li><p>sylar支持创建条件定时器，也就是在创建定时器时绑定一个变量，在定时器触发时判断一下该变量是否仍然有效，如果变量无效，那就取消触发。</p>
</li>
<li><p>关于onTimerInsertedAtFront()方法的作用。这个方法是IOManager提供给TimerManager使用的，当TimerManager检测到新添加的定时器的超时时间比当前最小的定时器还要小时，TimerManager通过这个方法来通知IOManager立刻更新当前的epoll_wait超时，否则新添加的定时器的执行时间将不准确。实际实现时，只需要在onTimerInsertedAtFront()方法内执行一次tickle就行了，tickle之后，epoll_wait会立即退出，并重新从TimerManager中获取最近的超时时间，这时拿到的超时时间就是新添加的最小定时器的超时时间了。</p>
</li>
<li><p>关于校时问题。sylar的定时器以gettimeofday()来获取绝对时间点并判断超时，所以依赖于系统时间，如果系统进行了校时，比如NTP时间同步，那这套定时机制就失效了。sylar的解决办法是设置一个较小的超时步长，比如3秒钟，也就是epoll_wait最多3秒超时，假设最近一个定时器的超时时间是10秒以后，那epoll_wait需要超时3次才会触发。每次超时之后除了要检查有没有要触发的定时器，还顺便检查一下系统时间有没有被往回调。如果系统时间往回调了1个小时以上，那就触发全部定时器。个人感觉这个办法有些粗糙，其实只需要换个时间源就可以解决校时问题，换成clock_gettime(CLOCK_MONOTONIC_RAW)的方式获取系统的单调时间，就可以解决这个问题了。</p>
</li>
</ol>
<h3 id="九-hook模块"><a href="#九-hook模块" class="headerlink" title="九 hook模块"></a>九 hook模块</h3><p>hook系统底层和socket相关的API，socket IO相关的API，以及sleep系列的API。hook的开启控制是线程粒度的，可以自由选择。通过hook模块，可以使一些不具异步功能的API，展现出异步的性能，如MySQL。</p>
<p>注意：本篇提到的系统调用接口实际是指C标准函数库提供的接口，而不是单指Linux提供的系统调用，比如malloc和free就不是系统调用，它们是C标准函数库提供的接口。</p>
<h4 id="9-1-hook概述"><a href="#9-1-hook概述" class="headerlink" title="9.1 hook概述"></a>9.1 hook概述</h4><h5 id="9-1-1-理解hook"><a href="#9-1-1-理解hook" class="headerlink" title="9.1.1 理解hook"></a>9.1.1 理解hook</h5><p>hook实际上就是对系统调用API进行一次封装，将其封装成一个与原始的系统调用API同名的接口，应用在调用这个接口时，会先执行封装中的操作，再执行原始的系统调用API。</p>
<p>hook技术可以使应用程序在执行系统调用之前进行一些隐藏的操作，比如可以对系统提供malloc()和free()进行hook，在真正进行内存分配和释放之前，统计内存的引用计数，以排查内存泄露问题。</p>
<p>还可以用C++的子类重载来理解hook。在C++中，子类在重载父类的同名方法时，一种常见的实现方式是子类先完成自己的操作，再调用父类的操作，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is Base&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 子类重载时先实现自己的操作，再调用父类的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is Child&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Base::Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在上面的代码实现中，调用子类的Print方法，会先执行子类的语句，然后再调用父类的Print方法，这就相当于子类hook了父类的Print方法。 </p>
<p>由于hook之后的系统调用与原始的系统系统调用同名，所以对于程序开发者来说也很方便，不需要重新学习新的接口，只需要按老的接口调用惯例直接写代码就行了。</p>
<h5 id="9-1-2-hook功能"><a href="#9-1-2-hook功能" class="headerlink" title="9.1.2 hook功能"></a>9.1.2 hook功能</h5><p>hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。hook和IO协程调度是密切相关的，如果不使用IO协程调度器，那hook没有任何意义。</p>
<blockquote>
<p>考虑IOManager要在一个线程上按顺序调度以下协程：</p>
<ol>
<li>协程1：sleep(2) 睡眠两秒后返回。</li>
<li>协程2：在scoket fd1 上send 100k数据。</li>
<li>协程3：在socket fd2 上recv直到数据接收成功。</li>
</ol>
<p>在未hook的情况下，IOManager要调度上面的协程，流程是下面这样的：</p>
<ol>
<li>调度协程1，协程阻塞在sleep上，等2秒后返回，这两秒内调度线程是被协程1占用的，其他协程无法在当前线程上调度。</li>
<li>调度协徎2，协程阻塞send 100k数据上，这个操作一般问题不大，因为send数据无论如何都要占用时间，但如果fd迟迟不可写，那send会阻塞直到套接字可写，同样，在阻塞期间，其他协程也无法在当前线程上调度。</li>
<li>调度协程3，协程阻塞在recv上，这个操作要直到recv超时或是有数据时才返回，期间调度器也无法调度其他协程。</li>
</ol>
<p>上面的调度流程最终总结起来就是，协程只能按顺序调度，一旦有一个协程阻塞住了，那整个调度线程也就阻塞住了，其他的协程都无法在当前线程上执行。</p>
</blockquote>
<p>像这种一条路走到黑的方式其实并不是完全不可避免，<strong>以sleep为例，调度器完全可以在检测到协程sleep后，将协程yield以让出执行权，同时设置一个定时器，2秒后再将协程重新resume。</strong>这样，调度器就可以在这2秒期间调度其他的任务，同时还可以顺利的实现sleep 2秒后再继续执行协程的效果，send/recv与此类似。</p>
<p>在完全实现hook后，IOManager的执行流程将变成下面的方式：</p>
<ol>
<li>调度协程1，检测到协程sleep，那么先添加一个2秒的定时器，定时器回调函数是在调度器上继续调度本协程，接着协程yield，等定时器超时。</li>
<li>因为上一步协程1已经yield了，所以协徎2并不需要等2秒后才可以执行，而是立刻可以执行。同样，调度器检测到协程send，由于不知道fd是不是马上可写，所以先在IOManager上给fd注册一个写事件，回调函数是让当前协程resume并执行实际的send操作，然后当前协程yield，等可写事件发生。</li>
<li>上一步协徎2也yield了，可以马上调度协程3。协程3与协程2类似，也是给fd注册一个读事件，回调函数是让当前协程resume并继续recv，然后本协程yield，等事件发生。</li>
<li>等2秒超时后，执行定时器回调函数，将协程1 resume以便继续执行。</li>
<li>等协程2的fd可写，一旦可写，调用写事件回调函数将协程2 resume以便继续执行send。</li>
<li>等协程3的fd可读，一旦可读，调用回调函数将协程3 resume以便继续执行recv。</li>
</ol>
<p>上面的4、5、6步都是异步的，调度线程并不会阻塞，IOManager仍然可以调度其他的任务，只在相关的事件发生后，再继续执行对应的任务即可。并且，由于hook的函数签名与原函数一样，所以对调用方也很方便，只需要<strong>以同步的方式编写代码，实现的效果却是异步执行的，效率很高。</strong></p>
<p><strong>总而言之，在IO协程调度中对相关的系统调用进行hook，可以让调度线程尽可能得把时间片都花在有意义的操作上，而不是浪费在阻塞等待中。</strong></p>
<p><strong>hook的重点是在替换API的底层实现的同时完全模拟其原本的行为</strong>，因为调用方是不知道hook的细节的，在调用被hook的API时，如果其行为与原本的行为不一致，就会给调用方造成困惑。比如，所有的socket fd在进行IO调度时都会被设置成NONBLOCK模式，如果用户未显式地对fd设置NONBLOCK，那就要处理好fcntl，不要对用户暴露fd已经是NONBLOCK的事实，这点也说明，除了IO相关的函数要进行hook外，对fcntl, setsockopt之类的功能函数也要进行hook，才能保证API的一致性。</p>
<h5 id="9-1-3-hook实现"><a href="#9-1-3-hook实现" class="headerlink" title="9.1.3 hook实现"></a>9.1.3 hook实现</h5><p>这里只讲解动态链接中的hook实现，静态链接以及基于内核模块的hook不在本章讨论范围。</p>
<p>在学习hook之前需要对Linux的动态链接有一定的了解，建议阅读《程序员的自我修养 —— 链接、装载与库》第7章。本站 <a target="_blank" rel="noopener" href="https://www.midlane.top/wiki/pages/viewpage.action?pageId=16418206">关于链接与装载的几个测试代码</a> 提供了一些示例，有助于理解动态链接的具体行为。</p>
<p><strong>hook的实现机制非常简单，就是通过动态库的全局符号介入功能，用自定义的接口来替换掉同名的系统调用接口。由于系统调用接口基本上是由C标准函数库libc提供的，所以这里要做的事情就是用自定义的动态库来覆盖掉libc中的同名符号。</strong></p>
<p>基于动态链接的hook有两种方式，<strong>第一种是外挂式hook</strong>，也称为非侵入式hook，通过优先加载自定义动态库来实现对后加载的动态库进行hook，这种hook方式不需要重新编译代码，考虑以下例子：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;hello world\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello world\n&quot;</span>)); <span class="comment">// 调用系统调用write写标准输出文件描述符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面在不重新编译代码的情况下，用自定义的动态库来替换掉可执行程序a.out中的write实现，新建hook.c，内容如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    syscall(SYS_write, STDOUT_FILENO, <span class="string">&quot;12345\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;12345\n&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里实现了一个write函数，这个函数的签名和libc提供的write函数完全一样，函数内容是用syscall的方式直接调用编号为SYS_write的系统调用，实现的效果也是往标准输出写内容，只不过这里我们将输出内容替换成了其他值。将hook.c编译成动态库：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared hook.c -o libhook.so</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过设置 LD_PRELOAD环境变量，将libhoook.so设置成优先加载，从面覆盖掉libc中的write函数，如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LD_PRELOAD=<span class="string">&quot;./libhook.so&quot;</span> ./a.out</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure>

<p>这里我们并没有重新编译可执行程序a.out，但是可以看到，write的实现已经替换成了我们自己的实现。究其原因，就是LD_PRELOAD环境变量，它指明了在运行a.out之前，系统会优先把libhook.so加载到了程序的进程空间，使得在a.out运行之前，其全局符号表中就已经有了一个write符号，这样在后续加载libc共享库时，由于全局符号介入机制，libc中的write符号不会再被加入全局符号表，所以全局符号表中的write就变成了我们自己的实现。</p>
<p><strong>第二种方式的hook是侵入式的，</strong>需要改造代码或是重新编译一次以指定动态库加载顺序。如果是以改造代码的方式来实现hook，那么可以像下面这样直接将write函数的实现放在main.c里，那么编译时全局符号表里先出现的必然是main.c中的write符号：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    syscall(SYS_write, STDOUT_FILENO, <span class="string">&quot;12345\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;12345\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;hello world\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello world\n&quot;</span>)); <span class="comment">// 这里调用的是上面的write实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不改造代码，那么可以重新编译一次，通过编译参数将自定义的动态库放在libc之前进行链接。由于默认情况下gcc总会链接一次libc，并且libc的位置也总在命令行所有参数后面，所以只需要像下面这样操作就可以了：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># gcc main.c -L. -lhook -Wl,-rpath=.</span></span><br><span class="line"># ./a.out</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里显式指定了链接libhook.so（<code>-Wl,-rpath=.</code>用于指定运行时的动态库搜索路径，避免找不到动态库的问题），由于libhook.so的链接位置比libc要靠前（可以通过gcc -v进行验证），所以运行时会先加载libhook.so，从而实现全局符号介入，这点也可以通过ldd命令来查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ldd a.out</span></span><br><span class="line">        linux-vdso.so.1 (0x00007ffe615f9000)</span><br><span class="line">        libhook.so =&gt; ./libhook.so (0x00007fab4bae3000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fab4b8e9000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fab4baef000)</span><br></pre></td></tr></table></figure>
</blockquote>
<p>于hook的另一个讨论点是<strong>如何找回已经被全局符号介入机制覆盖的系统调用接口</strong>，这个功能非常实用，因为大部分情况下，系统调用提供的功能都是无可替代的，我们虽然可以用hook的方式将其替换成自己的实现，但是最终要实现的功能，还是得由原始的系统调用接口来完成。</p>
<blockquote>
<p>以malloc和free为例，假如我们要hook标准库提供的malloc和free接口，以跟踪每次分配和释放的内存地址，判断有无内存泄漏问题，那么具体的实现方式应该是，先调用自定义的malloc和free实现，在分配和释放内存之前，记录下内存地址，然后再调用标准库里的malloc和free，以真正实现内存申请和释放。</p>
</blockquote>
<p>上面的过程涉及到了查找后加载的动态库里被覆盖的符号地址问题。首先，这个操作本身就具有合理性，因为程序运行时，依赖的动态库无论是先加载还是后加载，最终都会被加载到程序的进程空间中，也就是说，那些因为<strong>加载顺序靠后而被覆盖的符号，它们只是被“雪藏”了而已，实际还是存在于程序的进程空间中的，通过一定的办法，可以把它们再找回来。</strong>在Linux中，这个方法就是<code>dslym</code>，它的函数原型如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;</span><br></pre></td></tr></table></figure>

<p>关于dlsym的使用可参考<code>man 3 dlsym</code>，在<strong>链接时需要指定 <code>-ldl</code> 参数</strong>。<strong>使用dlsym找回被覆盖的符号时，第一个参数固定为 <code>RTLD_NEXT</code>，第二个参数为符号的名称，下面通过dlsym来实现上面的内存跟踪功能：</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* (*<span class="keyword">malloc_func_t</span>)(<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">free_func_t</span>)</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这两个指针用于保存libc中的malloc和free的地址</span></span><br><span class="line"><span class="keyword">malloc_func_t</span> sys_malloc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">free_func_t</span> sys_free = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 重定义malloc和free，在这里重定义会导致libc中的同名符号被覆盖</span></span><br><span class="line"><span class="comment">// 这里不能调用带缓冲的printf接口，否则会出段错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先调用标准库里的malloc申请内存，再记录内存分配信息，这里只是简单地将内存地址和长度打印出来</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = sys_malloc(size);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc: ptr=%p, length=%ld\n&quot;</span>, ptr, size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印内存释放信息，再调用标准库里的free释放内存</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free: ptr=%p\n&quot;</span>, ptr);</span><br><span class="line">    sys_free(ptr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过dlsym找到标准库中的malloc和free的符号地址</span></span><br><span class="line">    sys_malloc = dlsym(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    assert(dlerror() == <span class="literal">NULL</span>);</span><br><span class="line">    sys_free = dlsym(RTLD_NEXT, <span class="string">&quot;free&quot;</span>);</span><br><span class="line">    assert(dlerror() == <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> *ptrs[<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = <span class="built_in">malloc</span>(<span class="number">100</span> + i);</span><br><span class="line">        <span class="built_in">memset</span>(ptrs[i], <span class="number">0</span>, <span class="number">100</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译运行以上代码，效果如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc hook_malloc.c -ldl</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./a.out</span></span><br></pre></td></tr></table></figure>

<img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230322170118458.png" class="" title="image-20230322170118458">



<h4 id="9-2-hook-模块设计"><a href="#9-2-hook-模块设计" class="headerlink" title="9.2 hook 模块设计"></a>9.2 hook 模块设计</h4><p>sylar的hook功能以线程为单位，可自由设置当前线程是否使用hook。默认情况下，协程调度器的调度线程会开启hook，而其他线程则不会开启。</p>
<p>sylar对以下函数进行了hook，并且只对socket fd进行了hook，如果操作的不是socket fd，那会直接调用系统原本的API，而不是hook之后的API：</p>
<figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sleep</span><br><span class="line">usleep</span><br><span class="line">nanosleep</span><br><span class="line">socket</span><br><span class="line">connect</span><br><span class="line">accept</span><br><span class="line">read</span><br><span class="line">readv</span><br><span class="line">recv</span><br><span class="line">recvfrom</span><br><span class="line">recvmsg</span><br><span class="line">write</span><br><span class="line">writev</span><br><span class="line">send</span><br><span class="line">sendto</span><br><span class="line">sendmsg</span><br><span class="line">close</span><br><span class="line">fcntl</span><br><span class="line">ioctl</span><br><span class="line">getsockopt</span><br><span class="line">setsockopt</span><br></pre></td></tr></table></figure>

<p>除此外，sylar还增加了一个 <code>connect_with_timeout</code> 接口用于实现带超时的connect。</p>
<p><strong>为了管理所有的socket fd，sylar设计了一个FdManager类来记录所有分配过的fd的上下文，这是一个单例类，每个socket fd上下文记录了当前fd的读写超时，是否设置非阻塞等信息。</strong></p>
<p>关于hook模块和IO协程调度的整合。一共有三类接口需要hook，如下：</p>
<ol>
<li><p>sleep延时系列接口，包括sleep/usleep/nanosleep。对于这些接口的hook，只需要给IO协程调度器注册一个定时事件，在定时事件触发后再继续执行当前协程即可。当前协程在注册完定时事件后即可yield让出执行权。</p>
</li>
<li><p>socket IO系列接口，包括read/write/recv/send…等，connect及accept也可以归到这类接口中。这类接口的hook首先需要判断操作的fd是否是socket fd，以及用户是否显式地对该fd设置过非阻塞模式，如果不是socket fd或是用户显式设置过非阻塞模式，那么就不需要hook了，直接调用操作系统的IO接口即可。如果需要hook，那么首先在IO协程调度器上注册对应的读写事件，等事件发生后再继续执行当前协程。当前协程在注册完IO事件即可yield让出执行权。</p>
</li>
<li><p>socket/fcntl/ioctl/close等接口，这类接口主要处理的是边缘情况，比如分配fd上下文，处理超时及用户显式设置非阻塞问题。</p>
</li>
</ol>
<h4 id="9-3-hook模块实现"><a href="#9-3-hook模块实现" class="headerlink" title="9.3 hook模块实现"></a>9.3 hook模块实现</h4><h5 id="9-3-1-关于fd上下文的类"><a href="#9-3-1-关于fd上下文的类" class="headerlink" title="9.3.1 关于fd上下文的类"></a>9.3.1 关于fd上下文的类</h5><p>首先是socket fd上下文和FdManager的实现，这两个类用于记录fd上下文和保存全部的fd上下文，它们的关键实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 文件句柄上下文类</span></span><br><span class="line"><span class="comment"> * @details 管理文件句柄类型(是否socket)</span></span><br><span class="line"><span class="comment"> *          是否阻塞,是否关闭,读/写超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FdCtx</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;FdCtx&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FdCtx&gt; ptr;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 通过文件句柄构造FdCtx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FdCtx(<span class="keyword">int</span> fd);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~FdCtx();</span><br><span class="line">    ....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 是否初始化</span></span><br><span class="line">    <span class="keyword">bool</span> m_isInit: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 是否socket</span></span><br><span class="line">    <span class="keyword">bool</span> m_isSocket: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 是否hook非阻塞</span></span><br><span class="line">    <span class="keyword">bool</span> m_sysNonblock: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 是否用户主动设置非阻塞</span></span><br><span class="line">    <span class="keyword">bool</span> m_userNonblock: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 是否关闭</span></span><br><span class="line">    <span class="keyword">bool</span> m_isClosed: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 文件句柄</span></span><br><span class="line">    <span class="keyword">int</span> m_fd;</span><br><span class="line">    <span class="comment">/// 读超时时间毫秒</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_recvTimeout;</span><br><span class="line">    <span class="comment">/// 写超时时间毫秒</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_sendTimeout;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 文件句柄管理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FdManager</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> RWMutex RWMutexType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FdManager();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取/创建文件句柄类FdCtx</span></span><br><span class="line"><span class="comment">     * @param[in] fd 文件句柄</span></span><br><span class="line"><span class="comment">     * @param[in] auto_create 是否自动创建</span></span><br><span class="line"><span class="comment">     * @return 返回对应文件句柄类FdCtx::ptr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">FdCtx::ptr <span class="title">get</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">bool</span> auto_create = <span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 删除文件句柄类</span></span><br><span class="line"><span class="comment">     * @param[in] fd 文件句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 读写锁</span></span><br><span class="line">    RWMutexType m_mutex;</span><br><span class="line">    <span class="comment">/// 文件句柄集合</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FdCtx::ptr&gt; m_datas;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 文件句柄单例</span></span><br><span class="line"><span class="keyword">typedef</span> Singleton&lt;FdManager&gt; FdMgr;</span><br></pre></td></tr></table></figure>

<p>FdCtx类在用户态记录了fd的读写超时和非阻塞信息，其中非阻塞包括用户显式设置的非阻塞和hook内部设置的非阻塞，区分这两种非阻塞可以有效应对用户对fd设置/获取NONBLOCK模式的情形。</p>
<p>另外注意一点，FdManager类对FdCtx的寻址采用了和IOManager中对FdContext的寻址一样的寻址方式，直接用fd作为数组下标进行寻址。</p>
<h5 id="9-3-2-整体实现"><a href="#9-3-2-整体实现" class="headerlink" title="9.3.2 整体实现"></a>9.3.2 整体实现</h5><p>接下来是hook的整体实现。首先定义线程局部变量t_hook_enable，用于表示当前线程是否启用hook，使用线程局部变量表示hook模块是线程粒度的，各个线程可单独启用或关闭hook。然后是获取各个被hook的接口的原始地址， 这里要借助dlsym来获取。sylar使用了一套宏来简化编码，这套宏的实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOOK_FUN(XX) \</span></span><br><span class="line">    XX(sleep) \</span><br><span class="line">    XX(usleep) \</span><br><span class="line">    XX(nanosleep) \</span><br><span class="line">    XX(socket) \</span><br><span class="line">    XX(connect) \</span><br><span class="line">    XX(accept) \</span><br><span class="line">    XX(read) \</span><br><span class="line">    XX(readv) \</span><br><span class="line">    XX(recv) \</span><br><span class="line">    XX(recvfrom) \</span><br><span class="line">    XX(recvmsg) \</span><br><span class="line">    XX(write) \</span><br><span class="line">    XX(writev) \</span><br><span class="line">    XX(send) \</span><br><span class="line">    XX(sendto) \</span><br><span class="line">    XX(sendmsg) \</span><br><span class="line">    XX(close) \</span><br><span class="line">    XX(fcntl) \</span><br><span class="line">    XX(ioctl) \</span><br><span class="line">    XX(getsockopt) \</span><br><span class="line">    XX(setsockopt)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(name) name ## _fun name ## _f = nullptr;</span></span><br><span class="line">    HOOK_FUN(XX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> is_inited = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(is_inited) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(name) name ## _f = (name ## _fun)dlsym(RTLD_NEXT, #name);</span></span><br><span class="line">    HOOK_FUN(XX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的宏展开之后的效果如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    sleep_fun sleep_f = <span class="literal">nullptr</span>; \</span><br><span class="line">    usleep_fun usleep_f = <span class="literal">nullptr</span>; \</span><br><span class="line">    ....</span><br><span class="line">    setsocketopt_fun setsocket_f = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">hook_init() &#123;</span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    sleep_f = (sleep_fun)dlsym(RTLD_NEXT, <span class="string">&quot;sleep&quot;</span>); \</span><br><span class="line">    usleep_f = (usleep_fun)dlsym(RTLD_NEXT, <span class="string">&quot;usleep&quot;</span>); \</span><br><span class="line">    ...</span><br><span class="line">    setsocketopt_f = (setsocketopt_fun)dlsym(RTLD_NEXT, <span class="string">&quot;setsocketopt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>hook_init() 放在一个静态对象的构造函数中调用，这表示在main函数运行之前就会获取各个符号的地址并保存在全局变量中。</p>
<h5 id="9-3-3-各个接口实现"><a href="#9-3-3-各个接口实现" class="headerlink" title="9.3.3 各个接口实现"></a>9.3.3 各个接口实现</h5><p>最后是各个接口的hook实现，这部分和上面的全局变量定义要放在extern “C”中，以防止C++编译器对符号名称添加修饰。由于被hook的接口要完全模拟原接口的行为，所以这里要小心处理好各种边界情况以及返回值和errno问题。</p>
<p>首先是sleep/usleep/nanosleep的hook实现，它们的实现思路完全一样，即先添加定时器再yield，比如sleep函数的hook代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sylar::t_hook_enable) &#123;</span><br><span class="line">        <span class="keyword">return</span> sleep_f(seconds);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sylar::Fiber::ptr fiber = sylar::Fiber::GetThis();</span><br><span class="line">    sylar::IOManager* iom = sylar::IOManager::GetThis();</span><br><span class="line">    iom-&gt;addTimer(seconds * <span class="number">1000</span>, <span class="built_in">std</span>::bind((<span class="keyword">void</span>(sylar::Scheduler::*)</span><br><span class="line">            (sylar::Fiber::ptr, <span class="keyword">int</span> thread))&amp;sylar::IOManager::schedule</span><br><span class="line">            ,iom, fiber, <span class="number">-1</span>));</span><br><span class="line">    sylar::Fiber::GetThis()-&gt;yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来是socket接口的hook实现，socket用于创建套接字，需要在拿到fd后将其添加到FdManager中，代码实现如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sylar::t_hook_enable) &#123;</span><br><span class="line">        <span class="keyword">return</span> socket_f(domain, type, protocol);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = socket_f(domain, type, protocol);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    sylar::FdMgr::GetInstance()-&gt;get(fd, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>接下来是connect和connect_with_timeout的实现，由于connect有默认的超时，所以这里只需要实现connect_with_timeout即可：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect_with_timeout</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen, <span class="keyword">uint64_t</span> timeout_ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sylar::t_hook_enable) &#123;</span><br><span class="line">        <span class="keyword">return</span> connect_f(fd, addr, addrlen);</span><br><span class="line">    &#125;</span><br><span class="line">    sylar::FdCtx::ptr ctx = sylar::FdMgr::GetInstance()-&gt;get(fd);</span><br><span class="line">    <span class="keyword">if</span>(!ctx || ctx-&gt;isClose()) &#123;</span><br><span class="line">        errno = EBADF;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!ctx-&gt;isSocket()) &#123;</span><br><span class="line">        <span class="keyword">return</span> connect_f(fd, addr, addrlen);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(ctx-&gt;getUserNonblock()) &#123;</span><br><span class="line">        <span class="keyword">return</span> connect_f(fd, addr, addrlen);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = connect_f(fd, addr, addrlen);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n != <span class="number">-1</span> || errno != EINPROGRESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sylar::IOManager* iom = sylar::IOManager::GetThis();</span><br><span class="line">    sylar::Timer::ptr timer;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;timer_info&gt; <span class="title">tinfo</span><span class="params">(<span class="keyword">new</span> timer_info)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::weak_ptr&lt;timer_info&gt; <span class="title">winfo</span><span class="params">(tinfo)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(timeout_ms != (<span class="keyword">uint64_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">        timer = iom-&gt;addConditionTimer(timeout_ms, [winfo, fd, iom]() &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = winfo.lock();</span><br><span class="line">                <span class="keyword">if</span>(!t || t-&gt;cancelled) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                t-&gt;cancelled = ETIMEDOUT;</span><br><span class="line">                iom-&gt;cancelEvent(fd, sylar::IOManager::WRITE);</span><br><span class="line">        &#125;, winfo);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = iom-&gt;addEvent(fd, sylar::IOManager::WRITE);</span><br><span class="line">    <span class="keyword">if</span>(rt == <span class="number">0</span>) &#123;</span><br><span class="line">        sylar::Fiber::GetThis()-&gt;yield();</span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            timer-&gt;cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tinfo-&gt;cancelled) &#123;</span><br><span class="line">            errno = tinfo-&gt;cancelled;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            timer-&gt;cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;connect addEvent(&quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, WRITE) error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = error;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的实现重点如下：</p>
<ol>
<li>判断传入的fd是否为套接字，如果不为套接字，则调用系统的connect函数并返回。</li>
<li>判断fd是否被显式设置为了非阻塞模式，如果是则调用系统的connect函数并返回。</li>
<li>调用系统的connect函数，由于套接字是非阻塞的，这里会直接返回EINPROGRESS错误。</li>
<li>如果超时参数有效，则添加一个条件定时器，在定时时间到后通过t-&gt;cancelled设置超时标志并触发一次WRITE事件。</li>
<li>添加WRITE事件并yield，等待WRITE事件触发再往下执行。</li>
<li>等待超时或套接字可写，如果先超时，则条件变量winfo仍然有效，通过winfo来设置超时标志并触发WRITE事件，协程从yield点返回，返回之后通过超时标志设置errno并返回-1；如果在未超时之前套接字就可写了，那么直接取消定时器并返回成功。取消定时器会导致定时器回调被强制执行一次，但这并不会导致问题，因为只有当前协程结束后，定时器回调才会在接下来被调度，由于定时器回调被执行时connect_with_timeout协程已经执行完了，所以理所当然地条件变量也被释放了，所以实际上定时器回调函数什么也没做。这里是sylar条件定时器的巧妙应用，自行体会，感觉说得不是很清楚。</li>
</ol>
<p>接下来是accept和read/write/recv/send等IO接口的hook实现，这里sylar又一次充分发挥了懒得写代码的本事，用一个do_io模板函数将全部情况都囊括了进来。do_io模板函数的实现与上面的connect_with_timout实现基本一致，都借助了条件定时器和READ/WRITE事件，这里我也懒得写了，自行看代码。</p>
<p>最后是一些边边角角的情况，有以下几个要注意：</p>
<ol>
<li>close，这里除了要删除fd的上下文，还要取消掉fd上的全部事件，这会让fd的读写事件回调都执行一次。</li>
<li>fcntl，这里的O_NONBLOCK标志要特殊处理，因为所有参与协程调度的fd都会被设置成非阻塞模式，所以要在应用层维护好用户设置的非阻塞标志。</li>
<li>ioctl，同样要特殊处理FIONBIO命令，这个命令用于设置非阻塞，处理方式和上面的fcntl一样。</li>
<li>setsocketopt，这里要特殊处理SO_RECVTIMEO和SO_SNDTIMEO，在应用层记录套接字的读写超时，方便协程调度器获取。</li>
</ol>
<h4 id="9-4-注意事项"><a href="#9-4-注意事项" class="headerlink" title="9.4 注意事项"></a>9.4 注意事项</h4><ol>
<li>由于定时器模块只支持毫秒级定时，所以被hook后的nanosleep()实际精度只能达到毫秒级，而不是纳秒级。</li>
<li>按照 <code>man 2 socket</code> 的描述，自2.6.27版本的内核开始socket函数支持直接在type中位或SOCK_NONBLOCK标志位以创建非阻塞套接字，sylar的hook模块未处理这种情况。</li>
<li>按sylar hook模块的实现，非调度线程不支持启用hook。</li>
</ol>
<h3 id="十-Address-模块"><a href="#十-Address-模块" class="headerlink" title="十 Address 模块"></a>十 Address 模块</h3><hr>
<h4 id="10-1-Address模块概述"><a href="#10-1-Address模块概述" class="headerlink" title="10.1 Address模块概述"></a>10.1 Address模块概述</h4><p>提供网络地址相关的类，支持与网络地址相关的操作，一共有以下几个类：</p>
<ul>
<li><code>Address</code>：所有网络地址的基类，抽象类，对应sockaddr类型，但只包含抽象方法，不包含具体的成员。除此外，Address作为地址类还提供了网络地址查询及网卡地址查询功能。</li>
<li><code>IPAddress</code>：IP地址的基类，抽象类，在Address基础上，增加了IP地址相关的端口以及子网掩码、广播地址、网段地址操作，同样是只包含抽象方法，不包含具体的成员。</li>
<li><code>IPv4Address</code>：IPv4地址类，实体类，表示一个IPv4地址，对应sockaddr_in类型，包含一个sockaddr_in成员，可以操作该成员的网络地址和端口，以及获取子码掩码等操作。</li>
<li><code>IPv6Address</code>：IPv6地址类，实体类，与IPv4Address类似，表示一个IPv6地址，对应sockaddr_in6类型，包含一个sockaddr_in6成员。</li>
<li><code>UnixAddreess</code>：Unix域套接字类，对应sockaddr_un类型，同上。</li>
<li><code>UnknownAddress</code>：表示一个未知类型的套接字地址，实体类，对应sockaddr类型，这个类型与Address类型的区别是它包含一个sockaddr成员，并且是一个实体类。</li>
</ul>
<p>整个网络地址模块的类继承关系图如下：</p>
<img src="sylar服务器开发/image-20230323212942172.png" alt="image-20230323212942172" style="zoom:67%;" />



<h4 id="10-2-关于套接字地址"><a href="#10-2-关于套接字地址" class="headerlink" title="10.2 关于套接字地址"></a>10.2 关于套接字地址</h4><p>Linux使用<strong>Berkeley套接字接口</strong>进行网络编程，这套接口是事实上的标准网络套接字编程接口，在基本所有的系统上都支持。Berkeley套接字接口提供了一系列用于网络编程的通用API，通过这些API可以实现跨主机之间网络通信，或是在本机上通过Unix域套接字进行进程间通信。</p>
<p>Berkeley套接字接口拟定了一个<strong>通用套接字地址结构sockaddr</strong>，用于表示任意类型的地址，所有的套接字API在传入地址参数时都只需要传入sockaddr类型，以保证接口的通用性。除通用地址结构sockaddr外，还有一系列表示具体的网络地址的结构，<strong>这些具体的网络地址结构用于用户赋值，但在使用时，都要转化成sockaddr的形式。</strong></p>
<p>sockaddr表示通用套接字地址结构，其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family; <span class="comment">// 地址族，也就是地址类型</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];         <span class="comment">// 地址内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>所有的套接字API都是以指针形式接收sockaddr参数</strong>，并且额外需要一个地址长度参数，这可以保证当sockaddr本身不足以容纳一个具体的地址时，可以通过指针取到全部的内容。比如上面的地址内容占14字节，这并不足以容纳一个128位16字节的IPv6地址。但当以指针形式传入时，完全可以通过指针取到适合IPv6的长度。</p>
</blockquote>
<p><strong>除sockaddr外，套接字接口还定义了一系列具体的网络地址结构，比如sockaddr_in表示IPv4地址</strong>，sockaddr_in6表示IPv6地址，sockaddr_un表示Unix域套接字地址，它们的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_family; <span class="comment">// 地址族，IPv4的地址族为AF_INET</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;   <span class="comment">// 端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// IP地址，IPv4的地址用一个32位整数来表示</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];          <span class="comment">// 填充位，填零即可</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin6_family; <span class="comment">// 地址族，IPv6的地址族为AF_INET6</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port;        <span class="comment">// 端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo;     <span class="comment">// IPv6流控信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>  <span class="comment">// IPv6地址，实际为一个128位的结构体</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;     <span class="comment">// IPv6 scope-id</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sun_family;  <span class="comment">// 地址族，Unix域套字地址族为AF_UNIX</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];         <span class="comment">// 路径字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>通过上面的定义也可以发现，除sockaddr_in可以无缝转换为sockaddr外，sockaddr_in6和sockaddr_un都不能转换为sockaddr，因为<strong>大小不一样。但这并不影响套接字接口的通用性，因为在使用时，所有类型的地址都会转换成sockaddr指针形式，又由于以上所有的地址结构的前两个字节都表示地址族，所以通过sockaddr指针总能拿到传入地址的地址类型，通过地址类型判断出地址长度后，再通过sockaddr指针取适合该地址的长度即可拿到地址内容。</strong></p>
<h4 id="10-3-其他的类"><a href="#10-3-其他的类" class="headerlink" title="10.3 其他的类"></a>10.3 其他的类</h4><h5 id="10-3-1-Address类"><a href="#10-3-1-Address类" class="headerlink" title="10.3.1 Address类"></a>10.3.1 Address类</h5><p>这个类是所有网络地址类的基类，并且是一个抽象类，对应的是sockaddr，表示通用网络地址。对于一个通用的网络地址，需要关注它的地址类型，sockaddr指针，地址长度这几项内容。</p>
<p>除此外，Address类还提供了地址解析与本机网卡地址查询的功能，地址解析功能可以实现域名解析，网卡地址查询可以获取本机指定网卡的IP地址。</p>
<h5 id="10-3-2-IPAddress类"><a href="#10-3-2-IPAddress类" class="headerlink" title="10.3.2 IPAddress类"></a>10.3.2 IPAddress类</h5><p>继承自Address类，表示一个IP地址，同样是一个抽象类，因为IP地址包含IPv4地址和IPv6地址。IPAddress类提供了IP地址相关的端口和掩码、网段地址、网络地址操作，无论是IPv4还是IPv6都支持这些操作，但这些方法都是抽象方法，需要由继承类来实现。</p>
<h5 id="10-3-3-IPv4Address类"><a href="#10-3-3-IPv4Address类" class="headerlink" title="10.3.3 IPv4Address类"></a>10.3.3 IPv4Address类</h5><p>继承自IPAddress类，表示一个IPv4地址，到这一步，IPv4Address就是一个实体类了，它包含一个sockaddr_in类型的成员，并且提供具体的端口设置/获取，掩码、网段、网络地址设置/获取操作。</p>
<h5 id="10-3-4-IPv6Address类"><a href="#10-3-4-IPv6Address类" class="headerlink" title="10.3.4 IPv6Address类"></a>10.3.4 IPv6Address类</h5><p>继承自IPAddress类，表示一个IPv6地址，也是一个实体类，实现思路和IPv4Address一致。</p>
<h5 id="10-3-5-UnixAddress类"><a href="#10-3-5-UnixAddress类" class="headerlink" title="10.3.5 UnixAddress类"></a>10.3.5 UnixAddress类</h5><p>继承自Address类，表示一个Unix域套接字地址，是一个实体类，可以用于实例化对象。UnixAddress类包含一个sockaddr_un对象以及一个路径字符串长度。</p>
<h5 id="10-3-6-UnknownAddress类"><a href="#10-3-6-UnknownAddress类" class="headerlink" title="10.3.6 UnknownAddress类"></a>10.3.6 UnknownAddress类</h5><p>继承自Address类，包含一个sockaddr成员，表示未知的地址类型。</p>
<h3 id="11-Socket模块"><a href="#11-Socket模块" class="headerlink" title="11 Socket模块"></a>11 Socket模块</h3><p>套接字类，表示一个套接字对象。</p>
<p>对于套接字类，需要关注以下属性：</p>
<ol>
<li>文件描述符</li>
<li>地址类型（AF_INET, AF_INET6等）</li>
<li>套接字类型（SOCK_STREAM, SOCK_DGRAM等）</li>
<li>协议类型（这项其实可以忽略）</li>
<li>是否连接（针对TCP套接字，如果是UDP套接字，则默认已连接）</li>
<li>本地地址和对端的地址</li>
</ol>
<p>套接字类应提供以下方法：</p>
<ol>
<li>创建各种类型的套接字对象的方法（TCP套接字，UDP套接字，Unix域套接字）</li>
<li>设置套接字选项，比如超时参数</li>
<li>bind/connect/listen方法，实现绑定地址、发起连接、发起监听功能 </li>
<li>accept方法，返回连入的套接字对象</li>
<li>发送、接收数据的方法</li>
<li>获取本地地址、远端地址的方法</li>
<li>获取套接字类型、地址类型、协议类型的方法</li>
<li>取消套接字读、写的方法</li>
</ol>
<p>以下是Socket类的继承关系图：</p>
<img src="sylar服务器开发/image-20230324115003541.png" alt="image-20230324115003541" style="zoom:50%;" />



<h3 id="12-ByteArray类"><a href="#12-ByteArray类" class="headerlink" title="12 ByteArray类"></a>12 ByteArray类</h3><p>字节数组容器，提供基础类型的序列化与反序列化功能。</p>
<p>ByteArray的底层存储是固定大小的块，以链表形式组织。每次写入数据时，将数据写入到链表最后一个块中，如果最后一个块不足以容纳数据，则分配一个新的块并添加到链表结尾，再写入数据。<strong>ByteArray会记录当前的操作位置，每次写入数据时，该操作位置按写入大小往后偏移，如果要读取数据，则必须调用setPosition重新设置当前的操作位置。</strong></p>
<p>ByteArray支持基础类型的序列化与反序列化功能，并且支持将序列化的结果写入文件，以及从文件中读取内容进行反序列化。ByteArray支持以下类型的序列化与反序列化：</p>
<ol>
<li>固定长度的有符号/无符号8位、16位、32位、64位整数</li>
<li>不固定长度的有符号/无符号32位、64位整数</li>
<li>float、double类型</li>
<li>字符串，包含字符串长度，长度范围支持16位、32位、64位。</li>
<li>字符串，不包含长度。</li>
</ol>
<p>以上所有的类型都支持读写。</p>
<p>ByteArray还支持设置序列化时的大小端顺序。</p>
<p>私有属性： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 内存块的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> m_baseSize;</span><br><span class="line">    <span class="comment">/// 当前操作位置</span></span><br><span class="line">    <span class="keyword">size_t</span> m_position;</span><br><span class="line">    <span class="comment">/// 当前的总容量</span></span><br><span class="line">    <span class="keyword">size_t</span> m_capacity;</span><br><span class="line">    <span class="comment">/// 当前数据的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> m_size;</span><br><span class="line">    <span class="comment">/// 字节序,默认大端</span></span><br><span class="line">    <span class="keyword">int8_t</span> m_endian;</span><br><span class="line">    <span class="comment">/// 第一个内存块指针</span></span><br><span class="line">    Node* m_root;</span><br><span class="line">    <span class="comment">/// 当前操作的内存块指针</span></span><br><span class="line">    Node* m_cur;</span><br></pre></td></tr></table></figure>



<p>浅谈序列化</p>
<p><strong>zigzag算法</strong></p>
<p>用于压缩较小的整数，参考：<a target="_blank" rel="noopener" href="https://blog.csdn.net/zgwangbo/article/details/51590186">小而巧的数字压缩算法：zigzag_简单的老王-CSDN博客_zigzag编码</a>。</p>
<p>ByteArray在序列化不固定长度的有符号/无符号32位、64位整数时使用了zigzag算法。</p>
<p><strong>TLV编码结构</strong></p>
<p>用于序列化和消息传递，指Tag（类型），Length（长度），Value（值），参考：<a target="_blank" rel="noopener" href="https://www.wtango.com/tlv%E7%BC%96%E7%A0%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/">TLV编码通信协议设计 - Tango 博客 | Tango Blog</a>。</p>
<p>ByteArray在序列化字符串时使用TLV中的Length和Value。</p>
<h3 id="13-Stream-模块"><a href="#13-Stream-模块" class="headerlink" title="13 Stream 模块"></a>13 Stream 模块</h3><p>流结构，提供字节流读写接口。</p>
<p>所有的流结构都继承自抽象类Stream，Stream类规定了一个流必须具备read/write接口和readFixSize/writeFixSize接口，继承自Stream的类必须实现这些接口。</p>
<p>以下是Stream模块的继承关系图：</p>
<img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230324222943834.png" class="" title="image-20230324222943834">





<p><strong>SocketStream类</strong></p>
<p>套接字流结构，将套接字封装成流结构，以支持Stream接口规范，除此外，SocketStream还支持套接字关闭操作以及获取本地/远端地址的操作。</p>
<h3 id="14-TcpServer类"><a href="#14-TcpServer类" class="headerlink" title="14 TcpServer类"></a>14 TcpServer类</h3><p>TCP服务器封装。</p>
<p>TcpServer类支持同时绑定多个地址进行监听，只需要在绑定时传入地址数组即可。TcpServer还可以分别指定接收客户端和处理客户端的协程调度器。</p>
<p>以下是TcpServer的继承关系图：</p>
<img src="sylar服务器开发/image-20230324223242442.png" alt="image-20230324223242442" style="zoom:67%;" />

<p>TcpServer类采用了Template Pattern设计模式，它的HandleClient是交由继承类来实现的。使用TcpServer时，必须从TcpServer派生一个新类，并重新实现子类的handleClient操作，这点可以参考test_tcp_server.cc。</p>
<h3 id="15-HTTP模块"><a href="#15-HTTP模块" class="headerlink" title="15 HTTP模块"></a>15 HTTP模块</h3><p>提供HTTP服务，主要包含以下几个模块：</p>
<ol>
<li>HTTP常量定义，包括HTTP方法<code>HttpMethod</code>与HTTP状态<code>HttpStatus</code>。</li>
<li>HTTP请求与响应结构，对应<code>HttpRequest</code>和<code>HttpResponse</code>。</li>
<li>HTTP解析器，包含HTTP请求解析器与HTTP响应解析器，对应<code>HttpRequestParser</code>和<code>HttpResponseParser</code>。</li>
<li>HTTP会话结构，对应<code>HttpSession</code>。</li>
<li>HTTP服务器。</li>
<li>HTTP Servlet。</li>
<li>HTTP客户端<code>HttpConnection</code>，用于发起GET/POST等请求，支持连接池。</li>
</ol>
<p>HTTP模块依赖<a target="_blank" rel="noopener" href="https://github.com/nodejs/http-parser">nodejs/http-parser</a>提供的HTTP解析器，并且直接复用了nodejs/http-parser中定义的HTTP方法与状态枚举。</p>
<h4 id="15-1-HTTP常量定义"><a href="#15-1-HTTP常量定义" class="headerlink" title="15.1 HTTP常量定义"></a>15.1 HTTP常量定义</h4><p><strong>http_parser/http_parser.h</strong> 包括HttpMethod和HttpStatus两个定义，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Request Methods */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HTTP_METHOD_MAP(XX)         \</span></span><br><span class="line">  XX(<span class="number">0</span>,  DELETE,      DELETE)       \</span><br><span class="line">  XX(<span class="number">1</span>,  GET,         GET)          \</span><br><span class="line">  XX(<span class="number">2</span>,  HEAD,        HEAD)         \</span><br><span class="line">  XX(<span class="number">3</span>,  POST,        POST)         \</span><br><span class="line">  XX(<span class="number">4</span>,  PUT,         PUT)          \</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Status Codes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HTTP_STATUS_MAP(XX)                                                 \</span></span><br><span class="line">  XX(<span class="number">100</span>, CONTINUE,                        Continue)                        \</span><br><span class="line">  XX(<span class="number">101</span>, SWITCHING_PROTOCOLS,             Switching Protocols)             \</span><br><span class="line">  XX(<span class="number">102</span>, PROCESSING,                      Processing)                      \</span><br><span class="line">  XX(<span class="number">200</span>, OK,                              OK)                              \</span><br><span class="line">  XX(<span class="number">201</span>, CREATED,                         Created)                         \</span><br><span class="line">  XX(<span class="number">202</span>, ACCEPTED,                        Accepted)                        \</span><br><span class="line">  XX(<span class="number">203</span>, NON_AUTHORITATIVE_INFORMATION,   Non-Authoritative Information)   \</span><br><span class="line">...</span><br></pre></td></tr></table></figure>



<p>http.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief HTTP方法枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">HttpMethod</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(num, name, string) name = num,</span></span><br><span class="line">    HTTP_METHOD_MAP(XX)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">    INVALID_METHOD</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief HTTP状态枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">HttpStatus</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(code, name, desc) name = code,</span></span><br><span class="line">    HTTP_STATUS_MAP(XX)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="15-2-HTTP-请求与相应结构"><a href="#15-2-HTTP-请求与相应结构" class="headerlink" title="15.2 HTTP 请求与相应结构"></a>15.2 HTTP 请求与相应结构</h4><p>包括HttpRequest和HttpResponse两个结构，用于封装HTTP请求与响应。</p>
<p>关于HTTP请求和响应的格式可参考<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages">HTTP消息 - HTTP | MDN</a>，以下是一个HTTP请求与响应的示例：</p>
<img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/Clip_20230325_202242.png" class="" title="Clip_20230325_202242">

<p>对于HTTP请求，需要关注HTTP方法，请求路径和参数，HTTP版本，HTTP头部的key-value结构，Cookies，以及HTTP Body内容。</p>
<p>对于HTTP响应，需要关注HTTP版本，响应状态码，响应字符串，响应头部的key-value结构，以及响应的Body内容。</p>
<h4 id="15-3-HTTP解析器"><a href="#15-3-HTTP解析器" class="headerlink" title="15.3 HTTP解析器"></a>15.3 HTTP解析器</h4><p>输入字节流，解析HTTP消息，包括HttpRequestParser和HttpResponseParser两个结构。</p>
<p>HTTP解析器基于<a target="_blank" rel="noopener" href="https://github.com/nodejs/http-parser">nodejs/http-parser</a>实现，通过套接字读到HTTP消息后将消息内容传递给解析器，解析器通过回调的形式通知调用方HTTP解析的内容。</p>
<p>以下是HTTP解析器的类协作图：</p>
<img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230325204529999.png" class="" title="image-20230325204529999">

<img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230325204548232.png" class="" title="image-20230325204548232">

<h4 id="15-4-HTTP-会话结构httpsession"><a href="#15-4-HTTP-会话结构httpsession" class="headerlink" title="15.4 HTTP 会话结构httpsession"></a>15.4 HTTP 会话结构httpsession</h4><p>继承自SocketStream，实现了在套接字流上读取HTTP请求与发送HTTP响应的功能，在读取HTTP请求时需要借助HTTP解析器，以便于将套接字流上的内容解析成HTTP请求。以下是HttpSession的继承关系图：</p>
<img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230325210116271.png" class="" title="image-20230325210116271">



<h4 id="15-5-HTTP服务器"><a href="#15-5-HTTP服务器" class="headerlink" title="15.5 HTTP服务器"></a>15.5 HTTP服务器</h4><p>继承自TcpServer，重载handleClient方法，将accept后得到的客户端套接字封装成HttpSession结构，以便于接收和发送HTTP消息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HttpServer::handleClient</span><span class="params">(Socket::ptr client)</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;handleClient &quot;</span> &lt;&lt; *client;</span><br><span class="line">    <span class="function">HttpSession::ptr <span class="title">session</span><span class="params">(<span class="keyword">new</span> HttpSession(client))</span></span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> req = session-&gt;recvRequest();</span><br><span class="line">        <span class="keyword">if</span>(!req) &#123;</span><br><span class="line">            SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;recv http request fail, errno=&quot;</span></span><br><span class="line">                &lt;&lt; errno &lt;&lt; <span class="string">&quot; errstr=&quot;</span> &lt;&lt; strerror(errno)</span><br><span class="line">                &lt;&lt; <span class="string">&quot; cliet:&quot;</span> &lt;&lt; *client &lt;&lt; <span class="string">&quot; keep_alive=&quot;</span> &lt;&lt; m_isKeepalive;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">HttpResponse::ptr <span class="title">rsp</span><span class="params">(<span class="keyword">new</span> HttpResponse(req-&gt;getVersion()</span></span></span><br><span class="line"><span class="function"><span class="params">                            ,req-&gt;isClose() || !m_isKeepalive))</span></span>;</span><br><span class="line">        rsp-&gt;setHeader(<span class="string">&quot;Server&quot;</span>, getName());</span><br><span class="line">        m_dispatch-&gt;handle(req, rsp, session);</span><br><span class="line">        session-&gt;sendResponse(rsp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!m_isKeepalive || req-&gt;isClose()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    session-&gt;close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-6-HTTP-Servlet"><a href="#15-6-HTTP-Servlet" class="headerlink" title="15.6 HTTP Servlet"></a>15.6 HTTP Servlet</h4><p>提供HTTP请求路径到处理类的映射，用于规范化的HTTP消息处理流程。</p>
<p>HTTP Servlet包括两部分，第一部分是Servlet对象，每个Servlet对象表示一种处理HTTP消息的方法，第二部分是ServletDispatch，它包含一个请求路径到Servlet对象的映射，用于指定一个请求路径该用哪个Servlet来处理。</p>
<p>以下是Servlet对象用于处理请求的声明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">     * @brief 处理请求</span><br><span class="line">     * @param[in] request HTTP请求</span><br><span class="line">     * @param[in] response HTTP响应</span><br><span class="line">     * @param[in] session HTTP连接</span><br><span class="line">     * @<span class="keyword">return</span> 是否处理成功</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">int32_t</span> handle(sylar::http::HttpRequest::ptr request</span><br><span class="line">                   , sylar::http::HttpResponse::ptr response</span><br><span class="line">                   , sylar::http::HttpSession::ptr session) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>



<h4 id="15-7-HTTP-客户端HttpConnection"><a href="#15-7-HTTP-客户端HttpConnection" class="headerlink" title="15.7 HTTP 客户端HttpConnection"></a>15.7 HTTP 客户端HttpConnection</h4><p>用于发起GET/POST等请求并获取响应，支持设置超时，keep-alive，支持连接池。</p>
<p>HTTP服务端的业务模型是接收请求→ 发送响应，而HTTP客户端的业务模型是发送请求→ 接收响应。</p>
<p>关于连接池，是指提前预备好一系列已接建立连接的socket，这样，在发起请求时，可以直接从中选择一个进行通信，而不用重复创建套接字→ 发起connect→ 发起请求 的流程。</p>
<p>连接池与发起请求时的keep-alive参数有关，如果使用连接池来发起GET/POST请求，在未设置keep-alive时，连接池并没有什么卵用。</p>
<h3 id="16-守护进程"><a href="#16-守护进程" class="headerlink" title="16 守护进程"></a>16 守护进程</h3><p>将进程与终端解绑，转到后台运行，除此外，sylar还实现了双进程唤醒功能，父进程作为守护进程的同时会检测子进程是否退出，如果子进程退出，则会定时重新拉起子进程。</p>
<p>以下是守护进程的实现步骤：</p>
<ol>
<li>调用daemon(1, 0)将当前进程以守护进程的形式运行；</li>
<li>守护进程fork子进程，在子进程运行主业务；</li>
<li>父进程通过waitpid()检测子进程是否退出，如果子进程退出，则重新拉起子进程；</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">real_daemon</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)&gt; main_cb)</span> </span>&#123;</span><br><span class="line">    daemon(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ProcessInfoMgr::GetInstance()-&gt;parent_id = getpid();</span><br><span class="line">    ProcessInfoMgr::GetInstance()-&gt;parent_start_time = time(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//子进程返回</span></span><br><span class="line">            ProcessInfoMgr::GetInstance()-&gt;main_id = getpid();</span><br><span class="line">            ProcessInfoMgr::GetInstance()-&gt;main_start_time  = time(<span class="number">0</span>);</span><br><span class="line">            SYLAR_LOG_INFO(g_logger) &lt;&lt; <span class="string">&quot;process start pid=&quot;</span> &lt;&lt; getpid();</span><br><span class="line">            <span class="keyword">return</span> real_start(argc, argv, main_cb);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;fork fail return=&quot;</span> &lt;&lt; pid</span><br><span class="line">                &lt;&lt; <span class="string">&quot; errno=&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; errstr=&quot;</span> &lt;&lt; strerror(errno);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//父进程返回</span></span><br><span class="line">            <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">            waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(status) &#123;</span><br><span class="line">                SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;child crash pid=&quot;</span> &lt;&lt; pid</span><br><span class="line">                    &lt;&lt; <span class="string">&quot; status=&quot;</span> &lt;&lt; status;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                SYLAR_LOG_INFO(g_logger) &lt;&lt; <span class="string">&quot;child finished pid=&quot;</span> &lt;&lt; pid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ProcessInfoMgr::GetInstance()-&gt;restart_count += <span class="number">1</span>;</span><br><span class="line">            sleep(g_daemon_restart_interval-&gt;getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">okeyia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://okeyia.github.io/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">http://okeyia.github.io/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://okeyia.github.io" target="_blank">okeyia</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/">服务器开发</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/11/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E4%B8%8E%E6%A3%80%E6%B5%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303101636855.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">四 性能检测和优化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/" title="OpenMP并行编程"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202205130900987.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-05-13</div><div class="title">OpenMP并行编程</div></div></a></div><div><a href="/2022/11/06/Modern_CMake/" title="现代化Cmake"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202211061428166.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-06</div><div class="title">现代化Cmake</div></div></a></div><div><a href="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" title="QT学习笔记"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202211061303026.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-08-16</div><div class="title">QT学习笔记</div></div></a></div><div><a href="/2021/10/24/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/" title="关于C++中指针的理解及其应用"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202203291949101.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2021-10-24</div><div class="title">关于C++中指针的理解及其应用</div></div></a></div><div><a href="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/" title="求职算法总结"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202210241553988.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-24</div><div class="title">求职算法总结</div></div></a></div><div><a href="/2022/09/17/C_C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/" title="C/C++常用刷题技巧"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202211132305808.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-09-17</div><div class="title">C/C++常用刷题技巧</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91"><span class="toc-text">sylar服务器开发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E3%80%87-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83"><span class="toc-text">〇 开发环境</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%80-%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F"><span class="toc-text">一 日志系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-text">1.1 日志模块设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text">1.2 日志模块工作流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-%E6%97%A5%E5%BF%97%E5%85%B3%E9%94%AE%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">1.3 日志关键模块实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-1-LogEvent"><span class="toc-text">1.3.1 LogEvent</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-2-LogFormatter"><span class="toc-text">1.3.2 LogFormatter</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-3-LogAppender"><span class="toc-text">1.3.3 LogAppender</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-4-Logger"><span class="toc-text">1.3.4 Logger</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-5-LogEventWrap"><span class="toc-text">1.3.5 LogEventWrap</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#1-3-6-LogManager"><span class="toc-text">1.3.6 LogManager</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-4-%E5%B7%A5%E5%85%B7%E5%AE%8F"><span class="toc-text">1.4 工具宏</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C-%E9%85%8D%E7%BD%AE%E7%B3%BB%E7%BB%9F"><span class="toc-text">二 配置系统</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">2.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-2-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-text">2.2 环境变量模块设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">2.3 环境变量模块实现</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%89-%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97"><span class="toc-text">三 配置模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-%E6%A6%82%E8%BF%B0"><span class="toc-text">3.1 概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-2-%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-text">3.2 配置模块设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-3-%E9%85%8D%E7%BD%AE%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">3.3 配置模块实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-1-%E8%BD%AC%E6%8D%A2%E7%AE%80%E5%8D%95%E7%B1%BB"><span class="toc-text">3.3.1 转换简单类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-3-2-%E5%A4%8D%E6%9D%82%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-text">3.3.2 复杂类型转换</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%9B-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97"><span class="toc-text">四 线程模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%94-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9D%97"><span class="toc-text">五 线程模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-1-%E5%8D%8F%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">5.1 协程概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-2-ucontext-t-%E6%8E%A5%E5%8F%A3"><span class="toc-text">5.2 ucontext_t 接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-text">5.3 协程模块设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.4 协程模块实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-1-%E5%8D%8F%E7%A8%8B%E7%8A%B6%E6%80%81"><span class="toc-text">5.4.1 协程状态</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-2-%E5%8D%8F%E7%A8%8B%E5%8E%9F%E8%AF%AD"><span class="toc-text">5.4.2 协程原语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-3-%E5%8D%8F%E7%A8%8B%E7%B1%BB%E5%AE%9E%E7%8E%B0"><span class="toc-text">5.4.3 协程类实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-4-4-%E5%85%B6%E4%BB%96%E5%AE%9E%E7%8E%B0%E7%BB%86%E8%8A%82"><span class="toc-text">5.4.4 其他实现细节</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-shared-from-this"><span class="toc-text">5.5 shared_from_this()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AD-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97"><span class="toc-text">六 协程调度模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0"><span class="toc-text">6.1 协程调度概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-text">6.2 协程调度模块设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-3-%E8%B0%83%E5%BA%A6%E5%8D%8F%E7%A8%8B%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98"><span class="toc-text">6.3 调度协程切换问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-4-%E5%85%B6%E4%BB%96%E6%83%85%E5%86%B5%E7%9A%84%E8%AE%A8%E8%AE%BA"><span class="toc-text">6.4 其他情况的讨论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-5-%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">6.5 调度模块实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-1-%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97%E6%94%B9%E9%80%A0"><span class="toc-text">6.5.1 协程模块改造</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-2-%E8%B0%83%E5%BA%A6%E4%BB%BB%E5%8A%A1"><span class="toc-text">6.5.2 调度任务</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-3-%E4%B8%89%E4%B8%AA%E5%8D%8F%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E4%BF%A1%E6%81%AF"><span class="toc-text">6.5.3 三个协程上下文信息</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-5-4-%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="toc-text">6.5.4 调度器的构造方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-6-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">6.6 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%83-IO%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97"><span class="toc-text">七 IO协程调度模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-IO%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A6%82%E8%BF%B0"><span class="toc-text">7.1 IO协程调度概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-IO%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-text">7.2 IO协程调度模块设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-3-IO%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">7.3 IO协程调度器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-1-IOManger%E7%B1%BB"><span class="toc-text">7.3.1 IOManger类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-2-fd%E4%B8%8A%E4%B8%8B%E6%96%87"><span class="toc-text">7.3.2 fd上下文</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-3-%E6%94%B9%E9%80%A0%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8"><span class="toc-text">7.3.3 改造协程调度器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-4-%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0"><span class="toc-text">7.3.4 事件回调函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-3-5-IOManager%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="toc-text">7.3.5 IOManager析构函数</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-IO%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E5%87%A0%E7%82%B9%E6%80%BB%E7%BB%93"><span class="toc-text">7.4 IO协程调度的几点总结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%AB-%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="toc-text">八 定时器模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-%E5%AE%9A%E6%97%B6%E5%99%A8%E6%A6%82%E8%BF%B0"><span class="toc-text">8.1 定时器概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-%E5%87%A0%E7%A7%8D%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">8.2 几种定时器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-1-%E5%9F%BA%E4%BA%8E%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8%E7%9A%84%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-text">8.2.1 基于升序链表的定时器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-2-%E6%97%B6%E9%97%B4%E8%BD%AE"><span class="toc-text">8.2.2 时间轮</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-2-3-%E6%97%B6%E9%97%B4%E5%A0%86"><span class="toc-text">8.2.3 时间堆</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-%E5%AE%9A%E6%97%B6%E5%99%A8%E8%AE%BE%E8%AE%A1"><span class="toc-text">8.3 定时器设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-4-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9E%E7%8E%B0"><span class="toc-text">8.4 定时器实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-1-Timer-%E7%B1%BB"><span class="toc-text">8.4.1 Timer 类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-2-TimerManager%E7%B1%BB"><span class="toc-text">8.4.2 TimerManager类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#8-4-3-IOManager%E7%B1%BB"><span class="toc-text">8.4.3 IOManager类</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-5-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">8.5 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B9%9D-hook%E6%A8%A1%E5%9D%97"><span class="toc-text">九 hook模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-hook%E6%A6%82%E8%BF%B0"><span class="toc-text">9.1 hook概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-1-%E7%90%86%E8%A7%A3hook"><span class="toc-text">9.1.1 理解hook</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-2-hook%E5%8A%9F%E8%83%BD"><span class="toc-text">9.1.2 hook功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-1-3-hook%E5%AE%9E%E7%8E%B0"><span class="toc-text">9.1.3 hook实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-hook-%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1"><span class="toc-text">9.2 hook 模块设计</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-hook%E6%A8%A1%E5%9D%97%E5%AE%9E%E7%8E%B0"><span class="toc-text">9.3 hook模块实现</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-1-%E5%85%B3%E4%BA%8Efd%E4%B8%8A%E4%B8%8B%E6%96%87%E7%9A%84%E7%B1%BB"><span class="toc-text">9.3.1 关于fd上下文的类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-2-%E6%95%B4%E4%BD%93%E5%AE%9E%E7%8E%B0"><span class="toc-text">9.3.2 整体实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#9-3-3-%E5%90%84%E4%B8%AA%E6%8E%A5%E5%8F%A3%E5%AE%9E%E7%8E%B0"><span class="toc-text">9.3.3 各个接口实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-4-%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9"><span class="toc-text">9.4 注意事项</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%81-Address-%E6%A8%A1%E5%9D%97"><span class="toc-text">十 Address 模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-Address%E6%A8%A1%E5%9D%97%E6%A6%82%E8%BF%B0"><span class="toc-text">10.1 Address模块概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-%E5%85%B3%E4%BA%8E%E5%A5%97%E6%8E%A5%E5%AD%97%E5%9C%B0%E5%9D%80"><span class="toc-text">10.2 关于套接字地址</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-%E5%85%B6%E4%BB%96%E7%9A%84%E7%B1%BB"><span class="toc-text">10.3 其他的类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-1-Address%E7%B1%BB"><span class="toc-text">10.3.1 Address类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-2-IPAddress%E7%B1%BB"><span class="toc-text">10.3.2 IPAddress类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-3-IPv4Address%E7%B1%BB"><span class="toc-text">10.3.3 IPv4Address类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-4-IPv6Address%E7%B1%BB"><span class="toc-text">10.3.4 IPv6Address类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-5-UnixAddress%E7%B1%BB"><span class="toc-text">10.3.5 UnixAddress类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#10-3-6-UnknownAddress%E7%B1%BB"><span class="toc-text">10.3.6 UnknownAddress类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-Socket%E6%A8%A1%E5%9D%97"><span class="toc-text">11 Socket模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-ByteArray%E7%B1%BB"><span class="toc-text">12 ByteArray类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-Stream-%E6%A8%A1%E5%9D%97"><span class="toc-text">13 Stream 模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-TcpServer%E7%B1%BB"><span class="toc-text">14 TcpServer类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-HTTP%E6%A8%A1%E5%9D%97"><span class="toc-text">15 HTTP模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-HTTP%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89"><span class="toc-text">15.1 HTTP常量定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-HTTP-%E8%AF%B7%E6%B1%82%E4%B8%8E%E7%9B%B8%E5%BA%94%E7%BB%93%E6%9E%84"><span class="toc-text">15.2 HTTP 请求与相应结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-HTTP%E8%A7%A3%E6%9E%90%E5%99%A8"><span class="toc-text">15.3 HTTP解析器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-HTTP-%E4%BC%9A%E8%AF%9D%E7%BB%93%E6%9E%84httpsession"><span class="toc-text">15.4 HTTP 会话结构httpsession</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-5-HTTP%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">15.5 HTTP服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-6-HTTP-Servlet"><span class="toc-text">15.6 HTTP Servlet</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-7-HTTP-%E5%AE%A2%E6%88%B7%E7%AB%AFHttpConnection"><span class="toc-text">15.7 HTTP 客户端HttpConnection</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B"><span class="toc-text">16 守护进程</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By okeyia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>