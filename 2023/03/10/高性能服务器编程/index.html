<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>三 高性能服务器编程 | okeyia</title><meta name="keywords" content="服务器编程"><meta name="author" content="okeyia"><meta name="copyright" content="okeyia"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="第三篇 高性能服务器编程第12章 高性能I&#x2F;O框架库Libevent前面我们利用三章的篇幅较为细致地讨论了Linux服务器程序必须 处理的三类事件：I&#x2F;O事件、信号和定时事件。 在处理这三类事件时我 们通常需要考虑如下三个问题：  统一事件源。统一处理这三类事件既能使代码简单易 懂，又能避免一些潜在的逻辑错误。前面我们已经讨论了实现统一事 件源的一般方法——利用I&#x2F;O复用系统调">
<meta property="og:type" content="article">
<meta property="og:title" content="三 高性能服务器编程">
<meta property="og:url" content="http://okeyia.github.io/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/index.html">
<meta property="og:site_name" content="okeyia">
<meta property="og:description" content="第三篇 高性能服务器编程第12章 高性能I&#x2F;O框架库Libevent前面我们利用三章的篇幅较为细致地讨论了Linux服务器程序必须 处理的三类事件：I&#x2F;O事件、信号和定时事件。 在处理这三类事件时我 们通常需要考虑如下三个问题：  统一事件源。统一处理这三类事件既能使代码简单易 懂，又能避免一些潜在的逻辑错误。前面我们已经讨论了实现统一事 件源的一般方法——利用I&#x2F;O复用系统调">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091408284.png">
<meta property="article:published_time" content="2023-03-10T08:31:21.000Z">
<meta property="article:modified_time" content="2023-03-11T11:09:31.392Z">
<meta property="article:author" content="okeyia">
<meta property="article:tag" content="服务器编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091408284.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://okeyia.github.io/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    jQuery: 'https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js',
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
    },
    fancybox: {
      js: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js',
      css: 'https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isanchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '三 高性能服务器编程',
  isPost: true,
  isHome: false,
  isHighlightShrink: undefined,
  isToc: true,
  postUpdate: '2023-03-11 19:09:31'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if (GLOBAL_CONFIG_SITE.isHome && /iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="okeyia" type="application/atom+xml">
</head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202204171749626.png" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data"><div class="data-item is-center"><div class="data-item-link"><a href="/archives/"><div class="headline">文章</div><div class="length-num">31</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/tags/"><div class="headline">标签</div><div class="length-num">21</div></a></div></div><div class="data-item is-center"><div class="data-item-link"><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091408284.png')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">okeyia</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/books/"><i class="fa-fw fas fa-book-open"></i><span> Books</span></a></div><div class="menus_item"><a class="site-page" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">三 高性能服务器编程</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-03-10T08:31:21.000Z" title="发表于 2023-03-10 16:31:21">2023-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-03-11T11:09:31.392Z" title="更新于 2023-03-11 19:09:31">2023-03-11</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Linux/">Linux</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="三 高性能服务器编程"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20220908201643320.png" class="" title="image-20220908201643320">









<h2 id="第三篇-高性能服务器编程"><a href="#第三篇-高性能服务器编程" class="headerlink" title="第三篇 高性能服务器编程"></a>第三篇 高性能服务器编程</h2><h3 id="第12章-高性能I-O框架库Libevent"><a href="#第12章-高性能I-O框架库Libevent" class="headerlink" title="第12章 高性能I/O框架库Libevent"></a>第12章 高性能I/O框架库Libevent</h3><p>前面我们利用三章的篇幅较为细致地讨论了Linux服务器程序必须 处理的三类事件：<strong>I/O事件、信号和定时事件。</strong></p>
<p>在处理这三类事件时我 们通常需要考虑如下三个问题：</p>
<ul>
<li>统一事件源。统一处理这三类事件既能使代码简单易 懂，又能避免一些潜在的逻辑错误。前面我们已经讨论了实现统一事 件源的一般方法——利用I/O复用系统调用来管理所有事件。</li>
<li>可移植性。不同的操作系统具有不同的I/O复用方式，比如 Solaris的dev/poll文件，FreeBSD的kqueue机制，Linux的epoll系列系统 调用。</li>
<li>对并发编程的支持。在多进程和多线程环境下，我们需要考虑 各执行实体如何协同处理客户连接、信号和定时器，以避免竞态条 件。</li>
</ul>
<p>本章将 介绍其中相对轻量级的Libevent框架库</p>
<h4 id="12-1-I-O框架库概述"><a href="#12-1-I-O框架库概述" class="headerlink" title="12.1  I/O框架库概述"></a>12.1  I/O框架库概述</h4><p>I/O框架库以库函数的形式，封装了较为底层的系统调用，给应用 程序提供了一组更便于使用的接口。</p>
<p>各种I/O框架库的实现原理基本相似，要么以Reactor模式实现，要 么以Proactor模式实现，要么同时以这两种模式实现。举例来说，基于 Reactor模式的I/O框架库包含如下几个组件：句柄（Handle）、事件多 路分发器（EventDemultiplexer）、事件处理器（EventHandler）和具体 的事件处理器（ConcreteEventHandler）、Reactor。这些组件的关系如 图12-1所示[6]。</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230305225701977.png" class="" title="image-20230305225701977">

<ul>
<li><strong>句柄:</strong> I/O框架库要处理的对象，即I/O事件、信号和定时事件，统一称为事件源。一个事件源通常和一个句柄绑定在一起。<strong>句柄的作用是，当内核检测到就绪事件时，它将通过句柄来通知应用程序这一事件。</strong>在 Linux环境下，I/O事件对应的句柄是文件描述符，信号事件对应的句柄就是信号值。</li>
<li><strong>事件多路分发器:</strong> 事件的到来是随机的、异步的。我们无法预知程序何时收到一个客户连接请求，又亦或收到一个暂停信号。所以程序需要循环地等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O 复用技术来实现。<strong>I/O框架库一般将系统支持的各种I/O复用系统调用封装成统一的接口，称为事件多路分发器。</strong>事件多路分发器的demultiplex 方法是等待事件的核心函数，其内部调用的是select、poll、epoll_wait 等函数。</li>
<li><strong>事件处理器和具体事件处理器:</strong>  事件处理器执行事件对应的业务逻辑。它通常包含一个或多个 handle_event回调函数，这些回调函数在事件循环中被执行。<strong>I/O框架库 提供的事件处理器通常是一个接口，用户需要继承它来实现自己的事 件处理器，即具体事件处理器。</strong>因此，事件处理器中的回调函数一般 被声明为虚函数，以支持用户的扩展。</li>
<li><strong>Reactor:</strong>  Reactor是I/O框架库的核心。<ul>
<li>handle_events。该方法执行事件循环。它重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器。</li>
<li>register_handler。该方法调用事件多路分发器的register_event方法来往事件多路分发器中注册一个事件。</li>
<li>remove_handler。该方法调用事件多路分发器的remove_event方 法来删除事件多路分发器中的一个事件。</li>
</ul>
</li>
</ul>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230305230319003.png" class="" title="image-20230305230319003">



<h4 id="12-2-Libevent源码分析"><a href="#12-2-Libevent源码分析" class="headerlink" title="12.2 Libevent源码分析"></a>12.2 Libevent源码分析</h4><p>作为一个I/O 框架库，Libevent具有如下特点：</p>
<ul>
<li>跨平台支持。Libevent支持Linux、UNIX和Windows。</li>
<li>统一事件源。Libevent对I/O事件、信号和定时事件提供统一的处理。</li>
<li>线程安全。Libevent使用libevent_pthreads库来提供线程安全支 持。</li>
<li>基于Reactor模式的实现。</li>
</ul>
<h5 id="12-2-1-一个实例"><a href="#12-2-1-一个实例" class="headerlink" title="12.2.1 一个实例"></a>12.2.1 一个实例</h5><p>分析一款软件的源代码，最简单有效的方式是从使用入手，这样 才能从整体上把握该软件的逻辑结构。</p>
<p>使用Libevent库 实现的一个“Hello World”程序, 代码清单12-1虽然简单，但却基本上描述了Libevent库的主要逻辑：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_cb</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">short</span> event,<span class="keyword">void</span>*argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>*<span class="title">base</span>=</span>(event_base*)argc;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span>=</span>&#123;<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;Caught an interrupt signal;exiting cleanly in two seconds...\n&quot;</span>);</span><br><span class="line">	event_base_loopexit(base,&amp;delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeout_cb</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">short</span> event,<span class="keyword">void</span>*argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span>=</span>event_init();</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">signal_event</span>=</span>evsignal_new(base,SIGINT,signal_cb,base);</span><br><span class="line">	event_add(signal_event,<span class="literal">NULL</span>);</span><br><span class="line">	timeval tv =&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">timeout_event</span>=</span>evtimer_new(base,timeout_cb,<span class="literal">NULL</span>);</span><br><span class="line">	event_add(timeout_event,&amp;tv);</span><br><span class="line">	event_base_dispatch(base);</span><br><span class="line">	event_free(timeout_event);</span><br><span class="line">	event_free(signal_event);</span><br><span class="line">	event_base_free(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol>
<li><p>调用event_init函数创建event_base对象。一个event_base相当于 一个Reactor实例。</p>
</li>
<li><p>创建具体的事件处理器，并设置它们所从属的Reactor实例。 evsignal_new和evtimer_new分别用于创建信号事件处理器和定时事件处理器，它们是定义在include/event2/event.h文件中的宏：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(b,x,cb,arg)\</span></span><br><span class="line">event_new((b),(x),EV_SIGNAL|EV_PERSIST,(cb),(arg))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(b,cb,arg)event_new((b),-1,0,(cb),(arg))</span></span><br></pre></td></tr></table></figure>

<p>可见，它们的统一入口是event_new函数，<strong>即用于创建通用事件处 理器</strong>（图12-1中的EventHandler）的函数。其定义是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event* <span class="title">event_new</span><span class="params">(struct event_base* base,<span class="keyword">evutil_socket_t</span></span></span></span><br><span class="line"><span class="function"><span class="params">fd, <span class="keyword">short</span> events, <span class="keyword">void</span>(*cb)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span>*), <span class="keyword">void</span>*arg)</span></span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>base参数指定新创建的事件处理器从属的Reactor。</p>
</li>
<li><p>fd参数指定与该事件处理器关联的句柄。<strong>创建I/O事件处理器时，应该给fd参 数传递文件描述符值；创建信号事件处理器时，应该给fd参数传递信 号值，比如代码清单12-1中的SIGINT；创建定时事件处理器时，则应该给fd参数传递-1。</strong></p>
</li>
<li><p>events参数指定事件类型，其可选值都定义在 include/event2/event.h文件中，如代码清单12-2所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_TIMEOUT 0x01		<span class="comment">/*定时事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_READ 0x02		<span class="comment">/*可读事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WRITE 0x04		<span class="comment">/*可写事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SIGNAL 0x08		<span class="comment">/*信号事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_PERSIST 0x10		<span class="comment">/*永久事件*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EV_PERSIST的作用是：事件被触发后，自动重新对这个event调用event_add函数</span></span><br><span class="line"><span class="comment">/*边沿触发事件，需要I/O复用系统调用支持，比如epoll*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ET 0x20</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>cb参数指定目标事件对应的回调函数，相当于图12-1中事件处理 器的handle_event方法。</p>
</li>
<li><p>arg参数则是Reactor传递给回调函数的参数。</p>
</li>
</ul>
<p>event_new函数成功时返回一个event类型的对象，也就是Libevent 的事件处理器。</p>
<blockquote>
<p>约定:  </p>
<p><strong>事件</strong>指的是一个句柄上绑定的事件，比如文件描述符0上的可读 事件。</p>
<p>事件处理器，也就是event结构体类型的对象，除了包含事件必 须具备的两个要素（句柄和事件类型）外，还有很多其他成员，比如 回调函数。</p>
<p>事件由事件多路分发器管理，事件处理器则由事件队列管理。 事件队列包括多种，比如event_base中的注册事件队列、活动事件队列 和通用定时器队列，以及evmap中的I/O事件队列、信号事件队列。</p>
<p>事件循环对一个被激活事件（就绪事件）的处理，指的是执行 该事件对应的事件处理器中的回调函数。</p>
</blockquote>
</li>
<li><p>调用event_add函数，将事件处理器添加到注册事件队列中， 并将该事件处理器对应的事件添加到事件多路分发器中。event_add函 数相当于Reactor中的register_handler方法。</p>
</li>
<li><p>调用event_base_dispatch函数来执行事件循环。</p>
</li>
<li><p>事件循环结束后，使用*_free系列函数来释放系统资源。</p>
</li>
</ol>
<h5 id="12-2-2-源代码组织结构"><a href="#12-2-2-源代码组织结构" class="headerlink" title="12.2.2 源代码组织结构"></a>12.2.2 源代码组织结构</h5><p>Libevent源代码中的目录和文件按照功能可划分为如下部分：</p>
<ul>
<li>头文件目录include/event2。该目录中的头文件 是Libevent提供给应用程序使用的，比如，event.h头文件提供核心函 数，http.h头文件提供HTTP协议相关服务，rpc.h头文件提供远程过程 调用支持。</li>
<li>源码根目录下的头文件。这些头文件分为两类：一类是对 include/event2目录下的部分头文件的包装，另外一类是供Libevent内部 使用的辅助性头文件，它们的文件名都具有*-internal.h的形式。<ul>
<li>event-internal.h， 比较重要</li>
</ul>
</li>
<li>通用数据结构目录compat/sys。该目录下仅有一个文件—— queue.h。它封装了跨平台的基础数据结构，包括单向链表、双向链 表、队列、尾队列和循环队列</li>
<li><strong>event.c文件。</strong> <strong>该文件实现Libevent的整体框架，主要是event和 event_base两个结构体的相关操作。</strong></li>
<li>devpoll.c、kqueue.c、evport.c、select.c、win32select.c、poll.c和 epoll.c文件。它们分别封装了如下I/O复用机制：/dev/poll、kqueue、 event ports、POSIX select、Windows select、poll和epoll。</li>
<li><strong>evmap.c文件</strong>。它维护句柄（文件描述符或信号）与事件处理器的映射关系。</li>
</ul>
<p>在整个源码中，event-internal.h、include/event2/event_struct.h、 event.c和evmap.c等4个文件最为重要。它们定义了event和event_base结 构体，并实现了这两个结构体的相关操作。</p>
<h5 id="12-2-3-event-结构体"><a href="#12-2-3-event-结构体" class="headerlink" title="12.2.3 event 结构体"></a>12.2.3 event 结构体</h5><p>Libevent中的事件处理器是event结构类型。<strong>event结构 体封装了句柄、事件类型、回调函数，以及其他必要的标志和数据。</strong> </p>
<p>该结构体在include/event2/event_struct.h文件中定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	TAILQ_ENTRY(event) ev_active_next;</span><br><span class="line">	TAILQ_ENTRY(event) ev_next;</span><br><span class="line">	</span><br><span class="line">	<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">		TAILQ_ENTRY(event)ev_next_with_common_timeout;</span><br><span class="line">		<span class="keyword">int</span> min_heap_idx;</span><br><span class="line">	&#125;ev_timeout_pos;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">evutil_socket_t</span> ev_fd;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">ev_base</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">			TAILQ_ENTRY(event) ev_io_next;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line">		&#125;ev_io;</span><br><span class="line">		</span><br><span class="line">		<span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">			TAILQ_ENTRY(event) ev_signal_next;</span><br><span class="line">			<span class="keyword">short</span> ev_ncalls;</span><br><span class="line">			<span class="keyword">short</span>* ev_pncalls;</span><br><span class="line">		&#125;ev_signal;</span><br><span class="line">	&#125;_ev;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">short</span> ev_events;</span><br><span class="line">	<span class="keyword">short</span> ev_res;</span><br><span class="line">	<span class="keyword">short</span> ev_flags;</span><br><span class="line">	<span class="keyword">ev_uint8_t</span> ev_pri;</span><br><span class="line">	<span class="keyword">ev_uint8_t</span> ev_closure;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line">	<span class="keyword">void</span>(*ev_callback)(<span class="keyword">evutil_socket_t</span>,<span class="keyword">short</span>,<span class="keyword">void</span>*arg);</span><br><span class="line">	<span class="keyword">void</span>*ev_arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>ev_active_next。所有被激活的事件处理器通过该成员串联成一 个尾队列，我们称之为活动事件队列。活动事件队列不止一个，不同 优先级的事件处理器被激活后将被插入不同的活动事件队列中。在事 件循环中，Reactor将按优先级从高到低遍历所有活动事件队列，并依 次处理其中的事件处理器。</p>
</li>
<li><p>ev_next。<strong>所有已经注册的事件处理器（包括I/O事件处理器和信 号事件处理器）通过该成员串联成一个尾队列，我们称之为注册事件队列。</strong>宏TAILQ_ENTRY是尾队列中的节点类型，它定义在 compat/sys/queue.h文件中：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_ENTRY(type)\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span>* <span class="title">tqe_next</span>;</span>\<span class="comment">/*下一个元素*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span>** <span class="title">tqe_prev</span>;</span>\<span class="comment">/*前一个元素的地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<p>内容暂时忽略。</p>
<h3 id="第13章-多进程编程"><a href="#第13章-多进程编程" class="headerlink" title="第13章 多进程编程"></a>第13章 多进程编程</h3><p>进程是Linux操作系统环境的基础，它控制着系统上几乎所有的活动。</p>
<ul>
<li>复制进程映像的fork系统调用和替换进程映像的exec系列系统调 用。</li>
<li>僵尸进程以及如何避免僵尸进程。</li>
<li>进程间通信（Inter-Process Communication，IPC）最简单的方 式：管道。</li>
<li>3种System V进程间通信方式：信号量、消息队列和共享内存。 它们都是由AT＆T System V2版本的UNIX引入的，所以统称为System V IPC。</li>
<li>在进程间传递文件描述符的通用方法：通过UNIX本地域socket 传递特殊的辅助数据（关于辅助数据，参考5.8.3小节）。</li>
</ul>
<h4 id="13-1-fork系统"><a href="#13-1-fork系统" class="headerlink" title="13.1 fork系统"></a>13.1 fork系统</h4><p>Linux下创建新进程的系统调用是fork。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数的每次调用都返回两次，在父进程中返回的是子进程的 PID，在子进程中则返回0。</p>
<p>该返回值是后续代码判断当前进程是父进 程还是子进程的依据。fork调用失败时返回-1，并设置errno。</p>
<blockquote>
<p><strong>Fork函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和 标志寄存器的值。</strong></p>
<p>但也有许多属性被赋予了新的值，比如该进程的 PPID被设置成原进程的PID，信号位图被清除（原进程设置的信号处 理函数不再对新进程起作用）。</p>
<p>复制父进程的数据 （堆数据、栈数据和静态数据）。数据的复制采用的是所谓的写时复制（copy on writte），即只有在任一进程（父进程或子进程）对数据 执行了写操作时，复制才会发生</p>
<p>创建子进程后，父进程中打开的文件描述符默认在子进程 中也是打开的，且文件描述符的引用计数加1。不仅如此，父进程的用 户根目录、当前工作目录等变量的引用计数均会加1。</p>
</blockquote>
<h4 id="13-2-exec系列系统调用"><a href="#13-2-exec系列系统调用" class="headerlink" title="13.2 exec系列系统调用"></a>13.2 exec系列系统调用</h4><p>有时我们需要在子进程中执行其他程序，即替换当前进程映像， 这就需要使用如下exec系列函数之一：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>**environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*file,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...,<span class="keyword">char</span>*<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">char</span>*<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*file,<span class="keyword">char</span>*<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">char</span>*<span class="keyword">const</span> argv[],<span class="keyword">char</span>*<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>path参数指定可执行文件的完整路径，</li>
<li>file参数可以接受文件名， 该文件的具体位置则在环境变量PATH中搜寻。</li>
<li>arg接受可变参数，argv 则接受参数数组，它们都会被传递给新程序（path或file指定的程序） 的main函数。</li>
<li>envp参数用于设置新程序的环境变量。如果未设置它， 则新程序将使用由全局变量environ指定的环境变量。</li>
</ul>
<p>一般情况下，exec函数是不返回的，除非出错。它出错时返 回-1，并设置errno。如果没出错，则<strong>原程序中exec调用之后的代码都不会执行，因为此时原程序已经被exec的参数指定的程序完全替换</strong> （包括代码和数据）。</p>
<h4 id="13-3-处理僵尸进程"><a href="#13-3-处理僵尸进程" class="headerlink" title="13.3 处理僵尸进程"></a>13.3 处理僵尸进程</h4><p>对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。 因此，<strong>当子进程结束运行时，内核不会立即释放该进程的进程表表 项，以满足父进程后续对该子进程退出信息的查询（如果父进程还在 运行）。在子进程结束运行之后，父进程读取其退出状态之前，我们 称该子进程处于僵尸态。</strong></p>
<p>另外一种使子进程进入僵尸态的情况是：<strong>父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被 操作系统设置为1，即init进程。init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态。</strong></p>
<p>下面这对函数在父进程中调用，以 等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程 的产生，或者使子进程的僵尸态立即结束：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/wait.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* stat_loc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* stat_loc, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>wait函数将阻塞进程，直到该进程的某个子进程结束运行为止。</strong>它返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于 stat_loc参数指向的内存中。sys/wait.h头文件中定义了几个宏来帮助解 释子进程的退出状态信息，</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306210917536.png" class="" title="image-20230306210917536">
</li>
<li><p>wait函数的阻塞特性显然不是服务器程序期望的，而waitpid函数解 决了这个问题。<strong>waitpid只等待由pid参数指定的子进程。</strong>如果pid取值 为-1，那么它就和wait函数相同，即等待任意一个子进程结束。</p>
<ul>
<li>stat_loc 参数的含义和wait函数的stat_loc参数相同。</li>
<li>options参数可以控制waitpid 函数的行为。该参数最常用的取值是WNOHANG。当options的取值是 WNOHANG时，waitpid调用将是非阻塞的：<strong>如果pid指定的目标子进程还没有结束或意外终止，则waitpid立即返回0；</strong>如果目标子进程确实正常退出了，则waitpid返回该子进程的PID。waitpid调用失败时返回-1并 设置errno。</li>
</ul>
</li>
</ul>
<p><strong>要在事件已经发生的情况下执行非阻塞调用才能提高程序的效率。</strong>对waitpid函数而言，我们最好在某个子进程退出之后 再调用它。</p>
<p>那么父进程从何得知某个子进程已经退出了呢？这正是 SIGCHLD信号的用途。当一个进程结束时，它将给其父进程发送一个 SIGCHLD信号。因此，我们可以在父进程中捕获SIGCHLD信号，并在 信号处理函数中调用waitpid函数以“彻底结束”一个子进程, 信号处理函数如下: </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">pid_t</span> pid;</span><br><span class="line">	<span class="keyword">int</span> stat;</span><br><span class="line">	<span class="keyword">while</span>((pid=waitpid(<span class="number">-1</span>,&amp;stat,WNOHANG))＞<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="comment">/*对结束的子进程进行善后处理*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-4-管道"><a href="#13-4-管道" class="headerlink" title="13.4 管道"></a>13.4 管道</h4><p>管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0]和fd[1]）都保持打开。一对这样的文件描述符只能 保证父、子进程间一个方向的数据传输，<strong>父进程和子进程必须有一个关闭fd[0]，另一个关闭fd[1]。</strong></p>
<p>比如，我们要使用管道实现从父进程向 子进程写数据，就应该按照图13-1所示来操作。</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306211713409.png" class="" title="image-20230306211713409">



<p>如果要实现父、子进程之间的双向数据传输，就必须使用两个管道。第6章中我们还介绍过，<strong>socket编程接口提供了一个创建全双工管道的系统调用：socketpair。</strong></p>
<p><strong>管道只能用于有关联的两个进程（比如父、子进程）间的 通信。</strong></p>
<p>而下面要讨论的3种System V IPC能用于无关联的多个进程之间 的通信，因为它们都使用一个全局唯一的键值来标识一条信道。</p>
<h4 id="13-5-信号量"><a href="#13-5-信号量" class="headerlink" title="13.5 信号量"></a>13.5 信号量</h4><h5 id="13-5-1-信号量原语"><a href="#13-5-1-信号量原语" class="headerlink" title="13.5.1 信号量原语"></a>13.5.1 信号量原语</h5><p>通常，程序对共享资源的访问的代码只是很短的一段，但就是这一段 代码引发了进程之间的竞态条件。我们称这段代码为关键代码段，或 者临界区。对进程同步，也就是确保任一时刻只有一个进程能进入关 键代码段。</p>
<p>对信号量的这两种操作更常 用的称呼是P、V操作。这两个字母来自于荷兰语单词passeren（传递， 就好像进入临界区）和vrijgeven（释放，就好像退出临界区）。</p>
<p>假设有 信号量SV，则对它的P、V操作含义如下：</p>
<ul>
<li>P(SV)，如果SV的值大于0，就将它减1；如果SV的值为0，则挂 起进程的执行。 </li>
<li>V(SV)，如果有其他进程因为等待SV而挂起，则唤醒之；如果没 有，则将SV加1。</li>
</ul>
<p>本书仅讨论二进制信号 量。使用二进制信号量同步两个进程，以确保关键代码段的独占式访 问的一个典型例子如图13-2所示。</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306212542683.png" class="" title="image-20230306212542683">

<p>Linux信号量的API都定义在sys/sem.h头文件中，主要包含3个系统调用：<strong>semget、semop和semctl</strong>。它们都被设计为操作一组信号量，即 信号量集，而不是单个信号量</p>
<h5 id="13-5-2-semget"><a href="#13-5-2-semget" class="headerlink" title="13.5.2 semget"></a>13.5.2 semget</h5><p>semget系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sem.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> num_sems,<span class="keyword">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>key参数是一个键值，用来标识一个全局唯一的信号量集，就像文 件名全局唯一地标识一个文件一样。要通过信号量通信的进程需要使 用相同的键值来创建/获取该信号量。</li>
<li>num_sems参数指定要创建/获取的信号量集中信号量的数目。如果 是创建信号量，则该值必须被指定；如果是获取已经存在的信号量， 则可以把它设置为0。</li>
<li>sem_flags参数指定一组标志。它低端的9个比特是该信号量的权 限，其格式和含义都与系统调用open的mode参数相同。</li>
</ul>
<p><strong>semget成功时返回一个正整数值，它是信号量集的标识符</strong>；semget 失败时返回-1，并设置errno。</p>
<h5 id="13-5-3-semop系统调用"><a href="#13-5-3-semop系统调用" class="headerlink" title="13.5.3 semop系统调用"></a>13.5.3 semop系统调用</h5><p>semop系统调用改变信号量的值，即执行P、V操作。在讨论semop 之前，我们需要先介绍与每个信号量关联的一些重要的内核变量：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semval;   	<span class="comment">/*信号量的值*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semzcnt;		<span class="comment">/*等待信号量值变为0的进程数量*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt;		<span class="comment">/*等待信号量值增加的进程数量*/</span></span><br><span class="line"><span class="keyword">pid_t</span> sempid;				<span class="comment">/*最后一次执行semop操作的进程ID*/</span></span><br></pre></td></tr></table></figure>

<p>semop对信号量的操作实际上就是对这些内核变量的操作。</p>
<p>semop 的定义如下：#include＜sys/sem.h＞</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf* sem_ops, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sem_id参数是由semget调用返回的信号量集标识符，用以指定被操作的目标信号量集。</p>
</li>
<li><p>sem_ops参数指向一个sembuf结构体类型的数组， sembuf结构体的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sem_num;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sem_op;</span><br><span class="line">	<span class="keyword">short</span> <span class="keyword">int</span> sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>sem_num成员是<code>信号量集</code>中信号量的编号，0表示信号量集 中的第一个信号量。</li>
<li>sem_op成员指定操作类型，其可选值为正整数、0 和负整数。每种类型的操作的行为又受到sem_flg成员的影响。</li>
<li>sem_flg 的可选值是IPC_NOWAIT和SEM_UNDO。IPC_NOWAIT的含义是，无论信号量操作是否成功，semop调用都将立即返回，这类似于非阻塞 I/O操作。<strong>SEM_UNDO的含义是，当进程退出时取消正在进行的semop 操作。</strong></li>
</ul>
</blockquote>
</li>
<li><p><strong>semop系统调用的第3个参数num_sem_ops指定要执行的操作个数，即sem_ops数组中元素的个数。</strong>semop对数组sem_ops中的每个成员按照数组顺序依次执行操作，并且该过程是原子操作，以避免别的进 程在同一时刻按照不同的顺序对该信号集中的信号量执行semop操作导 致的竞态条件。</p>
</li>
</ul>
<p>semop成功时返回0，失败则返回-1并设置errno。失败的时候， sem_ops数组中指定的所有操作都不被执行。</p>
<h5 id="13-5-4-semctl系统调用"><a href="#13-5-4-semctl系统调用" class="headerlink" title="13.5.4 semctl系统调用"></a>13.5.4 semctl系统调用</h5><p>semctl系统调用允许调用者对信号量进行直接控制。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sem.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> sem_num,<span class="keyword">int</span> command,...)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>sem_id参数是由semget调用返回的信号量集标识符，用以指定被操 作的信号量集。</p>
</li>
<li><p>sem_num参数指定被操作的信号量在信号量集中的编 号。</p>
</li>
<li><p>command参数指定要执行的命令。有的命令需要调用者传递第4个 参数。</p>
</li>
<li><p>第4个参数的类型由用户自己定义，但sys/sem.h头文件给出了它 的推荐格式，具体如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;<span class="comment">/*用于SETVAL命令*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>*<span class="title">buf</span>;</span><span class="comment">/*用于IPC_STAT和IPC_SET命令*/</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span>*<span class="built_in">array</span>;<span class="comment">/*用于GETALL和SETALL命令*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>*__<span class="title">buf</span>;</span><span class="comment">/*用于IPC_INFO命令*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> semmap;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line">	<span class="keyword">int</span> semmni;<span class="comment">/*系统最多可以拥有的信号量集数目*/</span></span><br><span class="line">	<span class="keyword">int</span> semmns;<span class="comment">/*系统最多可以拥有的信号量数目*/</span></span><br><span class="line">	<span class="keyword">int</span> semmnu;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line">	<span class="keyword">int</span> semmsl;<span class="comment">/*一个信号量集最多允许包含的信号量数目*/</span></span><br><span class="line">	<span class="keyword">int</span> semopm;<span class="comment">/*semop一次最多能执行的sem_op操作数目*/</span></span><br><span class="line">	<span class="keyword">int</span> semume;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line">	<span class="keyword">int</span> semusz;<span class="comment">/*sem_undo结构体的大小*/</span></span><br><span class="line">	<span class="keyword">int</span> semvmx;<span class="comment">/*最大允许的信号量值*/</span></span><br><span class="line">	<span class="comment">/*最多允许的UNDO次数（带SEM_UNDO标志的semop操作的次数）*/</span></span><br><span class="line">	<span class="keyword">int</span> semaem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306215726484.png" class="" title="image-20230306215726484">



</li>
</ul>
<p>semctl成功时的返回值取决于command参数，如表13-2所示。 semctl失败时返回-1，并设置errno。</p>
<h5 id="13-5-5-特殊键值IPC-PRIVATE"><a href="#13-5-5-特殊键值IPC-PRIVATE" class="headerlink" title="13.5.5 特殊键值IPC_PRIVATE"></a>13.5.5 特殊键值IPC_PRIVATE</h5><p>semget的调用者可以给其key参数传递一个特殊的键值 IPC_PRIVATE（其值为0），这样无论该信号量是否已经存在，semget 都将创建一个新的信号量。  使用该键值创建的信号量并非像它的名字 声称的那样是进程私有的。其他进程，尤其是子进程，也有方法来访 问这个信号量。</p>
<p>比如下面 的代码清单13-3就在父、子进程间使用一个IPC_PRIVATE信号量来同 步。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/6.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">int</span> val;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>*<span class="title">buf</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>*<span class="built_in">array</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>*__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*op为-1时执行P操作，op为1时执行V操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pv</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>&#123;</span>&#125;;</span><br><span class="line">	sem_b.sem_num=<span class="number">0</span>;</span><br><span class="line">	sem_b.sem_op=op;</span><br><span class="line">	sem_b.sem_flg=SEM_UNDO;</span><br><span class="line">	semop(sem_id, &amp;sem_b ,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> sem_id=semget(IPC_PRIVATE,<span class="number">1</span>,<span class="number">0666</span>);</span><br><span class="line">	<span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_un</span>&#123;</span>&#125;;</span><br><span class="line">	sem_un.val=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0是被操作的信号量在信号集中的编号, SETVAl 是被执行的命令</span></span><br><span class="line">	semctl(sem_id,<span class="number">0</span>,SETVAL,sem_un);</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">pid_t</span> id=fork();</span><br><span class="line">	<span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span>(id==<span class="number">0</span>)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child try to get binary sem\n&quot;</span>);</span><br><span class="line">		<span class="comment">/*在父、子进程间共享IPC_PRIVATE信号量的关键就在于二者都可以操作该信号量的标识符sem_id*/</span></span><br><span class="line">		pv(sem_id,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;child get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		pv(sem_id,<span class="number">1</span>);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent try to get binary sem\n&quot;</span>);</span><br><span class="line">		pv(sem_id,<span class="number">-1</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;parent get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">		sleep(<span class="number">5</span>);</span><br><span class="line">		pv(sem_id,<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	waitpid(id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">	semctl(sem_id,<span class="number">0</span>,IPC_RMID,sem_un);<span class="comment">/*删除信号量*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-6-共享内存"><a href="#13-6-共享内存" class="headerlink" title="13.6 共享内存"></a>13.6 共享内存</h4><p>共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据 传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进 程对共享内存的访问，否则会产生竞态条件。</p>
<p>Linux共享内存的API都定义在sys/shm.h头文件中，包括4个系统调 用：shmget、shmat、shmdt和shmctl。</p>
<h5 id="13-6-1-shmget系统调用"><a href="#13-6-1-shmget系统调用" class="headerlink" title="13.6.1 shmget系统调用"></a>13.6.1 shmget系统调用</h5><p>shmget系统调用创建一段新的共享内存，或者获取一段已经存在 的共享内存。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">size_t</span> size,<span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>和semget系统调用一样，key参数是一个键值，用来标识一段全局 唯一的共享内存。</li>
<li>size参数指定共享内存的大小，单位是字节。如果是 创建新的共享内存，则size值必须被指定。如果是获取已经存在的共享 内存，则可以把size设置为0。</li>
<li>shmflg参数的使用和含义与semget系统调用的sem_flags参数相同。 不过shmget支持两个额外的标志——SHM_HUGETLB和 SHM_NORESERVE。它们的含义如下：<ul>
<li>SHM_HUGETLB，类似于mmap的MAP_HUGETLB标志，系统 将使用“大页面”来为共享内存分配空间。</li>
<li>SHM_NORESERVE，类似于mmap的MAP_NORESERVE标志， 不为共享内存保留交换分区（swap空间）。这样，当物理内存不足的 时候，对该共享内存执行写操作将触发SIGSEGV信号。</li>
</ul>
</li>
</ul>
<p>shmget成功时返回一个正整数值，它是共享内存的标识符。shmget 失败时返回-1，并设置errno。</p>
<h5 id="13-6-2-shmat和shmdt系统调用"><a href="#13-6-2-shmat和shmdt系统调用" class="headerlink" title="13.6.2 shmat和shmdt系统调用"></a>13.6.2 shmat和shmdt系统调用</h5><p>共享内存被创建/获取之后，我们不能立即访问它，而是需要先将 它关联到进程的地址空间中。使用完共享内存之后，我们也需要将它 从进程地址空间中分离。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">const</span> <span class="keyword">void</span>*shm_addr,<span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*shm_addr)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>shm_id参数是由shmget调用返回的共享内存标识符。 </li>
<li>shm_addr参数指定将共享内存关联到进程的哪块地址空间，最终的效果还受到shmflg参数的可选标志SHM_RND的影响：<ul>
<li>如果shm_addr为NULL，则被关联的地址由操作系统选择。这是 推荐的做法，以确保代码的可移植性.</li>
<li>如果shm_addr非空，并且SHM_RND标志未被设置，则共享内存 被关联到addr指定的地址处。</li>
</ul>
</li>
</ul>
<h5 id="13-6-3-shmctl系统调用"><a href="#13-6-3-shmctl系统调用" class="headerlink" title="13.6.3 shmctl系统调用"></a>13.6.3 shmctl系统调用</h5><p>shmctl系统调用控制共享内存的某些属性。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">int</span> command, struct shmid_ds* buf)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>shm_id参数是由shmget调用返回的共享内存标识符。 </p>
</li>
<li><p>command参数指定要执行的命令。</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306224911405.png" class="" title="image-20230306224911405">

</li>
</ul>
<p>shmctl成功时的返回值取决于command参数，如表13-3所示。 shmctl失败时返回-1，并设置errno。</p>
<h5 id="13-6-5-共享内存实例"><a href="#13-6-5-共享内存实例" class="headerlink" title="13.6.5 共享内存实例"></a>13.6.5 共享内存实例</h5><p>在9.6.2小节中，我们介绍过一个聊天室服务器程序。下面我们将 它修改为一个多进程服务器：一个子进程处理一个客户连接。同时， 我们将所有客户socket连接的读缓冲设计为一块共享内存，如代码清单 13-4所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/6.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_LIMIT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_LIMIT 65536</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理一个客户连接必要的数据*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line"></span><br><span class="line">	sockaddr_in address;<span class="comment">/*客户端的socket地址*/</span></span><br><span class="line">	<span class="keyword">int</span> connfd;<span class="comment">/*socket文件描述符*/</span></span><br><span class="line">	<span class="keyword">pid_t</span> pid;<span class="comment">/*处理这个连接的子进程的PID*/</span></span><br><span class="line">	<span class="keyword">int</span> pipefd[<span class="number">2</span>];<span class="comment">/*和父进程通信用的管道*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *shm_name = <span class="string">&quot;/my_shm&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> sig_pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"><span class="keyword">int</span> shmfd;</span><br><span class="line"><span class="keyword">char</span> *share_mem = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户连接数组。进程用客户连接的编号来索引这个数组，即可取得相关的客户连接数据*/</span></span><br><span class="line">client_data *users = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程和客户连接的映射关系表。用进程的PID来索引这个数组，即可取得该进程所处理的客户连接的编号*/</span></span><br><span class="line"><span class="keyword">int</span> *sub_process = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当前客户数量*/</span></span><br><span class="line"><span class="keyword">int</span> user_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> stop_child = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	epoll_event event&#123;&#125;;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN | EPOLLET;</span><br><span class="line">	epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">	setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> save_errno = errno;</span><br><span class="line">	<span class="keyword">int</span> msg = sig;</span><br><span class="line">	send(sig_pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(*handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">	sa.sa_handler = handler;</span><br><span class="line">	<span class="keyword">if</span> (restart) &#123;</span><br><span class="line">		sa.sa_flags |= SA_RESTART;</span><br><span class="line">	&#125;</span><br><span class="line">	sigfillset(&amp;sa.sa_mask);</span><br><span class="line">	assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	close(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">	close(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">	close(listenfd);</span><br><span class="line">	close(epollfd);</span><br><span class="line">	shm_unlink(shm_name);</span><br><span class="line">	<span class="keyword">delete</span>[]users;</span><br><span class="line">	<span class="keyword">delete</span>[]sub_process;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*停止一个子进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_term_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程运行的函数。参数idx指出该子进程处理的客户连接的编号，</span></span><br><span class="line"><span class="comment"> * users是保存所有客户连接数据的数组，参数share_mem指出共享内存的起始地址*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_child</span><span class="params">(<span class="keyword">int</span> idx, client_data *users, <span class="keyword">char</span> *share_mem)</span> </span>&#123;</span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">	<span class="comment">/*子进程使用I/O复用技术来同时监听两个文件描述符：</span></span><br><span class="line"><span class="comment">	 * 客户连接socket、与父进程通信的管道文件描述符*/</span></span><br><span class="line">	<span class="keyword">int</span> child_epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">	assert(child_epollfd != <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">int</span> connfd = users[idx].connfd;</span><br><span class="line">	addfd(child_epollfd, connfd);</span><br><span class="line">	<span class="keyword">int</span> pipefd = users[idx].pipefd[<span class="number">1</span>];</span><br><span class="line">	addfd(child_epollfd, pipefd);</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*子进程需要设置自己的信号处理函数*/</span></span><br><span class="line">	addsig(SIGTERM, child_term_handler, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">while</span> (!stop_child) &#123;</span><br><span class="line">		<span class="keyword">int</span> number = epoll_wait(child_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*本子进程负责的客户连接有数据到达*/</span></span><br><span class="line">			<span class="keyword">if</span> ((sockfd == connfd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">				<span class="built_in">memset</span>(share_mem + idx * BUFFER_SIZE, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*将客户数据读取到对应的读缓存中。该读缓存是共享内存的一段，</span></span><br><span class="line"><span class="comment">				 * 它开始于idx*BUFFER_SIZE处，长度为BUFFER_SIZE字节。</span></span><br><span class="line"><span class="comment">				 * 因此，各个客户连接的读缓存是共享的</span></span><br><span class="line"><span class="comment">				 * */</span></span><br><span class="line">				ret = recv(connfd, share_mem + idx * BUFFER_SIZE, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">						stop_child = <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">					stop_child = <span class="literal">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/*成功读取客户数据后就通知主进程（通过管道）来处理*/</span></span><br><span class="line">					send(pipefd, (<span class="keyword">char</span> *) &amp;idx, <span class="keyword">sizeof</span>(idx), <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">				<span class="comment">/*主进程通知本进程（通过管道）将第client个客户的数据发送到本进程负责的客户端*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">				<span class="keyword">int</span> client = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">/*接收主进程发送来的数据，即有客户数据到达的连接的编号*/</span></span><br><span class="line">				ret = recv(sockfd, (<span class="keyword">char</span> *) &amp;client, <span class="keyword">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">						stop_child = <span class="literal">true</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">					stop_child = <span class="literal">true</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					send(connfd, share_mem + client * BUFFER_SIZE,</span><br><span class="line">					     BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(connfd);</span><br><span class="line">	close(pipefd);</span><br><span class="line">	close(child_epollfd);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	&#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">		bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		address.sin_family = AF_INET;</span><br><span class="line">		inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">		address.sin_port = htons(port);</span><br><span class="line">		listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">		assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">		ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">		assert(ret != <span class="number">-1</span>);</span><br><span class="line">		ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">		assert(ret != <span class="number">-1</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	user_count = <span class="number">0</span>;</span><br><span class="line">	users = <span class="keyword">new</span> client_data[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line">	sub_process = <span class="keyword">new</span> <span class="keyword">int</span>[PROCESS_LIMIT];</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS_LIMIT; ++i) &#123;</span><br><span class="line">		sub_process[i] = <span class="number">-1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">	epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">	assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">	addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line">	ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, sig_pipefd);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	setnonblocking(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">	addfd(epollfd, sig_pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	addsig(SIGCHLD, sig_handler);  <span class="comment">/*子进程状态发生变化（退出或者暂停）*/</span></span><br><span class="line">	addsig(SIGTERM, sig_handler);   <span class="comment">/*主进程发给子进程的中断信号*/</span></span><br><span class="line">	addsig(SIGINT, sig_handler);</span><br><span class="line">	addsig(SIGPIPE, SIG_IGN);       <span class="comment">/*往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号*/</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">bool</span> <span class="built_in">terminate</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建共享内存，作为所有客户socket连接的读缓存*/</span></span><br><span class="line">	shmfd = shm_open(shm_name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">	assert(shmfd != <span class="number">-1</span>);</span><br><span class="line">	ret = ftruncate(shmfd, USER_LIMIT * BUFFER_SIZE);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	share_mem = (<span class="keyword">char</span> *) mmap(<span class="literal">nullptr</span>, USER_LIMIT * BUFFER_SIZE, PROT_READ | PROT_WRITE,</span><br><span class="line">	                          MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line">	assert(share_mem != MAP_FAILED);</span><br><span class="line">	close(shmfd);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line">		<span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line">			<span class="comment">// 判断是哪个描述符发生了变化</span></span><br><span class="line">			<span class="comment">/*新的客户连接到来*/</span></span><br><span class="line">			<span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">				<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">				<span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">				<span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (user_count &gt;= USER_LIMIT) &#123;</span><br><span class="line">					<span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">					send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">					close(connfd);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*保存第user_count个客户连接的相关数据*/</span></span><br><span class="line">				users[user_count].address = client_address;</span><br><span class="line">				users[user_count].connfd = connfd;</span><br><span class="line"></span><br><span class="line">				<span class="comment">/*在主进程和子进程间建立管道，以传递必要的数据*/</span></span><br><span class="line">				ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, users[user_count].pipefd);</span><br><span class="line">				assert(ret != <span class="number">-1</span>);</span><br><span class="line">				<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">				<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					close(connfd);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">					close(epollfd);</span><br><span class="line">					close(listenfd);</span><br><span class="line">					close(users[user_count].pipefd[<span class="number">0</span>]);</span><br><span class="line">					close(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">					close(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">					run_child(user_count, users, share_mem);</span><br><span class="line">					munmap((<span class="keyword">void</span> *) share_mem, USER_LIMIT * BUFFER_SIZE);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					close(connfd);</span><br><span class="line">					close(users[user_count].pipefd[<span class="number">1</span>]);</span><br><span class="line">					addfd(epollfd, users[user_count].pipefd[<span class="number">0</span>]);</span><br><span class="line">					users[user_count].pid = pid;</span><br><span class="line">					<span class="comment">/*记录新的客户连接在数组users中的索引值，建立进程pid和该索引值之间的映射关系*/</span></span><br><span class="line">					sub_process[pid] = user_count;</span><br><span class="line">					user_count++;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">				<span class="comment">/*处理信号事件*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">				<span class="keyword">int</span> sig;</span><br><span class="line">				<span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">				ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">						<span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line">							<span class="comment">/*子进程退出，表示有某个客户端关闭了连接*/</span></span><br><span class="line">							<span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line">								<span class="keyword">pid_t</span> pid;</span><br><span class="line">								<span class="keyword">int</span> stat;</span><br><span class="line">								<span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">									<span class="comment">/*用子进程的pid取得被关闭的客户连接的编号*/</span></span><br><span class="line">									<span class="keyword">int</span> del_user = sub_process[pid];</span><br><span class="line">									sub_process[pid] = <span class="number">-1</span>;</span><br><span class="line">									<span class="keyword">if</span> ((del_user &lt; <span class="number">0</span>) || (del_user &gt; USER_LIMIT)) &#123;</span><br><span class="line">										<span class="keyword">continue</span>;</span><br><span class="line">									&#125;</span><br><span class="line">									<span class="comment">/*清除第del_user个客户连接使用的相关数据*/</span></span><br><span class="line">									epoll_ctl(epollfd, EPOLL_CTL_DEL, users[del_user].pipefd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">									close(users[del_user].pipefd[<span class="number">0</span>]);</span><br><span class="line">									users[del_user] = users[--user_count];</span><br><span class="line">									sub_process[users[del_user].pid] = del_user;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">if</span> (<span class="built_in">terminate</span> &amp;&amp; user_count == <span class="number">0</span>) &#123;</span><br><span class="line">									stop_server = <span class="literal">true</span>;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">case</span> SIGTERM:</span><br><span class="line">							<span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">								<span class="comment">/*结束服务器程序*/</span></span><br><span class="line">								<span class="built_in">printf</span>(<span class="string">&quot;kill all the clild now\n&quot;</span>);</span><br><span class="line">								<span class="keyword">if</span> (user_count == <span class="number">0</span>) &#123;</span><br><span class="line">									stop_server = <span class="literal">true</span>;</span><br><span class="line">									<span class="keyword">break</span>;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; user_count; ++i) &#123;</span><br><span class="line">									<span class="keyword">int</span> pid = users[i].pid;</span><br><span class="line">									kill(pid, SIGTERM);</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="built_in">terminate</span> = <span class="literal">true</span>;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">default</span>: &#123;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">				<span class="comment">/*某个子进程向父进程写入了数据*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">				<span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">/*读取管道数据，child变量记录了是哪个客户连接有数据到达*/</span></span><br><span class="line">				ret = recv(sockfd, (<span class="keyword">char</span> *) &amp;child, <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;read data from child accross pipe\n&quot;</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/*向除负责处理第child个客户连接的子进程之外的其他子进程发送消息，通知它们有客户数据要写*/</span></span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; user_count; ++j) &#123;</span><br><span class="line">						<span class="keyword">if</span> (users[j].pipefd[<span class="number">0</span>] != sockfd) &#123;</span><br><span class="line">							<span class="built_in">printf</span>(<span class="string">&quot;send data to child accross pipe\n&quot;</span>);</span><br><span class="line">							send(users[j].pipefd[<span class="number">0</span>], (<span class="keyword">char</span> *) &amp;child,</span><br><span class="line">							     <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	del_resource();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="13-7-消息队列"><a href="#13-7-消息队列" class="headerlink" title="13.7 消息队列"></a>13.7 消息队列</h4><p>消息队列是在两个进程之间传递二进制块数据的一种简单有效的 方式。<strong>每个数据块都有一个特定的类型，接收方可以根据类型来有选 择地接收数据</strong>，而不一定像管道和命名管道那样必须以先进先出的方式接收数据。</p>
<p>Linux消息队列的API都定义在sys/msg.h头文件中，包括4个系统调 用：msgget、msgsnd、msgrcv和msgctl。</p>
<h5 id="13-7-1-msgget系统调用"><a href="#13-7-1-msgget系统调用" class="headerlink" title="13.7.1 msgget系统调用"></a>13.7.1 msgget系统调用</h5><p>msgget系统调用创建一个消息队列，或者获取一个已有的消息队列。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>和semget系统调用一样，key参数是一个键值，用来标识一个全局 唯一的消息队列。</li>
<li>msgflg参数的使用和含义与semget系统调用的sem_flags参数相同。</li>
</ul>
<p>msgget成功时返回一个正整数值，它是消息队列的标识符。msgget 失败时返回-1，并设置errno。</p>
<h5 id="13-7-2-msgsnd系统调用"><a href="#13-7-2-msgsnd系统调用" class="headerlink" title="13.7.2 msgsnd系统调用"></a>13.7.2 msgsnd系统调用</h5><p>msgsnd系统调用把一条消息添加到消息队列中。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span>* msg_ptr, <span class="keyword">size_t</span> msg_sz,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>msqid参数是由msgget调用返回的消息队列标识符。</p>
</li>
<li><p>msg_ptr参数指向一个准备发送的消息，消息必须被定义为如下类 型： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span> </span><br><span class="line">    <span class="keyword">long</span> mtype;<span class="comment">/*消息类型*/</span> </span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>];<span class="comment">/*消息数据*/</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<ul>
<li>其中，mtype成员指定消息的类型，它必须是一个正整数。</li>
<li>mtext是 消息数据。</li>
</ul>
</li>
<li><p>msg_sz参数是消息的数据部分（mtext）的长度。这个长度 可以为0，表示没有消息数据。</p>
</li>
<li><p><strong>msgflg参数控制msgsnd的行为。它通常仅支持IPC_NOWAIT标志， 即以非阻塞的方式发送消息。</strong>默认情况下，发送消息时如果消息队列 满了，则msgsnd将阻塞。若IPC_NOWAIT标志被指定，则msgsnd将立 即返回并设置errno为EAGAIN。</p>
</li>
</ul>
<p>msgsnd成功时返回0，失败则返回-1并设置errno。msgsnd成功时将 修改内核数据结构msqid_ds的部分字段，如下所示：</p>
<ul>
<li>将msg_qnum加1。</li>
<li>将msg_lspid设置为调用进程的PID。</li>
<li>将msg_stime设置为当前的时间。</li>
</ul>
<h5 id="13-7-3-msgrcv系统调用"><a href="#13-7-3-msgrcv系统调用" class="headerlink" title="13.7.3 msgrcv系统调用"></a>13.7.3 msgrcv系统调用</h5><p>msgrcv系统调用从消息队列中获取消息。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg·h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span>*msg_ptr,<span class="keyword">size_t</span> msg_sz,<span class="keyword">long</span> <span class="keyword">int</span> msgtype,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>msqid参数是由msgget调用返回的消息队列标识符。</li>
<li>msg_ptr参数用于存储接收的消息，msg_sz参数指的是消息数据部 分的长度。</li>
<li>msgtype参数指定接收何种类型的消息。我们可以使用如下几种方 式来指定消息类型： <ul>
<li>msgtype等于0。读取消息队列中的第一个消息。 </li>
<li>msgtype大于0。读取消息队列中第一个类型为msgtype的消息 （除非指定了标志MSG_EXCEPT，见后文）。 </li>
<li>msgtype小于0。读取消息队列中第一个类型值比msgtype的绝对 值小的消息。</li>
</ul>
</li>
<li>参数msgflg控制msgrcv函数的行为。它可以是如下一些标志的按位 或： <ul>
<li>IPC_NOWAIT。如果消息队列中没有消息，则msgrcv调用立即返 回并设置errno为ENOMSG。</li>
<li>MSG_EXCEPT。如果msgtype大于0，则接收消息队列中第一个 非msgtype类型的消息。 </li>
<li>MSG_NOERROR。如果消息数据部分的长度超过了msg_sz，就 将它截断。</li>
</ul>
</li>
</ul>
<p>msgrcv成功时返回0，失败则返回-1并设置errno。msgrcv成功时将 修改内核数据结构msqid_ds的部分字段，如下所示： </p>
<ul>
<li>将msg_qnum减1。 </li>
<li>将msg_lrpid设置为调用进程的PID。 </li>
<li>将msg_rtime设置为当前的时间。</li>
</ul>
<h5 id="13-7-4-msgctl系统调用"><a href="#13-7-4-msgctl系统调用" class="headerlink" title="13.7.4 msgctl系统调用"></a>13.7.4 msgctl系统调用</h5><p>msgctl系统调用控制消息队列的某些属性。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">int</span> command,struct msqid_ds*buf)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>msqid参数是由msgget调用返回的共享内存标识符。</p>
</li>
<li><p>command参数 指定要执行的命令。</p>
</li>
<li><p>msgctl支持的所有命令如表13-4所示</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230307112918598.png" class="" title="image-20230307112918598">

</li>
</ul>
<p>msgctl成功时的返回值取决于command参数，如表13-4所示。 msgctl函数失败时返回-1并设置errno。</p>
<h4 id="13-8-IPC命令"><a href="#13-8-IPC命令" class="headerlink" title="13.8 IPC命令"></a>13.8 IPC命令</h4><p>上述3种System V IPC进程间通信方式都使用一个全局唯一的键值 （key）来描述一个共享资源。当程序调用semget、shmget或者msgget 时，就创建了这些共享资源的一个实例。</p>
<p>Linux提供了ipcs命令，以观 察当前系统上拥有哪些共享资源实例。</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230307113151814.png" class="" title="image-20230307113151814">



<p>此外，我们可以使用ipcrm命令来删除遗留在系统中的共享资源。</p>
<h4 id="13-9-在进程间传递文件描述符"><a href="#13-9-在进程间传递文件描述符" class="headerlink" title="13.9 在进程间传递文件描述符"></a>13.9 在进程间传递文件描述符</h4><p>由于fork调用之后，父进程中打开的文件描述符在子进程中仍然 保持打开，所以文件描述符可以很方便地从父进程传递到子进程。</p>
<p>需要注意的是，<strong>传递一个文件描述符并不是传递一个文件描述符的值， 而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和 发送进程中被传递的文件描述符指向内核中相同的文件表项。</strong></p>
<p>那么如何把子进程中打开的文件描述符传递给父进程呢？或者更通俗地说，如何在两个不相干的进程之间传递文件描述符呢？</p>
<p>在Linux 下，我们可以利用UNIX域socket在进程间传递特殊的辅助数据，以实 现文件描述符的传递。</p>
<p>它在子进程 中打开一个文件描述符，然后将它传递给父进程，父进程则通过读取 该文件描述符来获得文件的内容。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CONTROL_LEN = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送文件描述符，fd参数是用来传递信息的UNIX域socket，fd_to_send参数是待发送的文件描述符*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_fd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd_to_send)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line">	iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">	iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">	msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">	msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">	msg.msg_iov = iov;</span><br><span class="line">	msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">	cmsghdr cm&#123;&#125;;</span><br><span class="line">	cm.cmsg_len = CONTROL_LEN;</span><br><span class="line">	cm.cmsg_level = SOL_SOCKET;</span><br><span class="line">	cm.cmsg_type = SCM_RIGHTS;</span><br><span class="line">	*(<span class="keyword">int</span> *) CMSG_DATA(&amp;cm) = fd_to_send;</span><br><span class="line">	msg.msg_control = &amp;cm;<span class="comment">/*设置辅助数据*/</span></span><br><span class="line">	msg.msg_controllen = CONTROL_LEN;</span><br><span class="line">	sendmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*接收目标文件描述符*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_fd</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line">	iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">	iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">	msg.msg_name = <span class="literal">nullptr</span>;</span><br><span class="line">	msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">	msg.msg_iov = iov;</span><br><span class="line">	msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">	cmsghdr cm&#123;&#125;;</span><br><span class="line">	msg.msg_control = &amp;cm;</span><br><span class="line">	msg.msg_controllen = CONTROL_LEN;</span><br><span class="line">	recvmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> fd_to_read = *(<span class="keyword">int</span> *) CMSG_DATA(&amp;cm);</span><br><span class="line">	<span class="keyword">return</span> fd_to_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> fd_to_pass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建父、子进程间的管道，文件描述符pipefd[0]和pipefd[1]都是UNIX域socket*/</span></span><br><span class="line">	<span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_DGRAM, <span class="number">0</span>, pipefd);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">	assert(pid &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		close(pipefd[<span class="number">0</span>]);</span><br><span class="line">		fd_to_pass = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR, <span class="number">0666</span>);</span><br><span class="line">		<span class="comment">/* 子进程通过管道将文件描述符发送到父进程。如果文件test.txt打开失败，</span></span><br><span class="line"><span class="comment">        * 则子进程将标准输入文件描述符发送到父进程*/</span></span><br><span class="line">		send_fd(pipefd[<span class="number">1</span>], (fd_to_pass &gt; <span class="number">0</span>) ? fd_to_pass : <span class="number">0</span>);</span><br><span class="line">		close(fd_to_pass);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	close(pipefd[<span class="number">1</span>]);</span><br><span class="line">	fd_to_pass = recv_fd(pipefd[<span class="number">0</span>]);<span class="comment">/*父进程从管道接收目标文件描述符*/</span></span><br><span class="line">	<span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">	<span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">1024</span>);</span><br><span class="line">	read(fd_to_pass, buf, <span class="number">1024</span>);<span class="comment">/*读目标文件描述符，以验证其有效性*/</span></span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;I got fd%d and data%s\n&quot;</span>, fd_to_pass, buf);</span><br><span class="line">	close(fd_to_pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="第14章-多线程编程"><a href="#第14章-多线程编程" class="headerlink" title="第14章 多线程编程"></a>第14章 多线程编程</h3><p>Native POSIX Thread Library， 本章要讨论的线程相关的内容都属于POSIX线程（简称pthread） 标准，而不局限于NPTL实现，具体包括：</p>
<ul>
<li>创建线程和结束线程。</li>
<li>读取和设置线程属性。</li>
<li>POSIX线程同步方式：POSIX信号量、互斥锁和条件变量。</li>
</ul>
<h4 id="14-1-Linux-线程概述"><a href="#14-1-Linux-线程概述" class="headerlink" title="14.1 Linux 线程概述"></a>14.1 Linux 线程概述</h4><h5 id="14-1-1-线程模型"><a href="#14-1-1-线程模型" class="headerlink" title="14.1.1 线程模型"></a>14.1.1 线程模型</h5><p>线程是程序中完成一个独立任务的完整执行序列，即一个可调度 的实体。</p>
<p>根据运行环境和调度者的身份，线程可分为内核线程和用户线程。<strong>内核线程，在有的系统上也称为LWP（Light Weight Process， 轻量级进程），运行在内核空间，由内核来调度</strong>；<strong>用户线程运行在用 户空间，由线程库来调度。</strong></p>
<p>当进程的一个内核线程获得CPU的使用权 时，它就加载并运行一个用户线程。可见，内核线程相当于用户线程 运行的“容器”。一个进程可以拥有M个内核线程和N个用户线程，其中 M≤N。并且在一个系统的所有进程中，M和N的比值都是固定的。</p>
<p><strong>按照M:N的取值，线程的实现方式可分为三种模式：完全在用户空间实现、完全由内核调度和双层调度（two level scheduler）。</strong></p>
<ol>
<li><strong>完全在用户空间实现的线程</strong>无须内核的支持，内核甚至根本不知 道这些线程的存在。线程库负责管理所有执行线程，比如线程的优先 级、时间片等。线程库利用longjmp来切换线程的执行，使它们看起来 像是“并发”执行的。<strong>但实际上内核仍然是把整个进程作为最小单位来调度的。</strong> 换句话说，一个进程的所有执行线程共享该进程的时间片， 它们对外表现出相同的优先级。因此，对这种实现方式而言，N=1， 即M个用户空间线程对应1个内核线程，而该内核线程实际上就是进程 本身。<ul>
<li><strong>优点：</strong> 创建和调度线程都无须 内核的干预，因此速度相当快。并且由于它不占用额外的内核资源， 所以即使一个进程创建了很多线程，也不会对系统性能造成明显的影 响。</li>
<li><strong>其缺点是</strong>：对于多处理器系统，一个进程的多个线程无法运行在不同的CPU上，因为内核是按照其最小调度单位来分配CPU的。此外，线程的优先级只对同一个进程中的线程有效，比较不同进程中的 线程的优先级没有意义。早期的伯克利UNIX线程就是采用这种方式实现的。</li>
</ul>
</li>
<li><strong>完全由内核调度的模式</strong>将创建、调度线程的任务都交给了内核， 运行在用户空间的线程库无须执行管理任务，这与完全在用户空间实 现的线程恰恰相反。<ul>
<li><strong>二者的优缺点也正好互换</strong>。较早的Linux内核对内 核线程的控制能力有限，线程库通常还要提供额外的控制能力，尤其 是线程同步机制，不过现代Linux内核已经大大增强了对线程的支持。 完全由内核调度的这种线程实现方式满足M:N=1:1，即1个用户空间线 程被映射为1个内核线程。</li>
</ul>
</li>
<li>双层调度模式是前两种实现模式的混合体：<strong>内核调度M个内核线 程，线程库调度N个用户线程。</strong>这种线程实现方式结合了前两种方式 的优点：不但不会消耗过多的内核资源，而且线程切换速度也较快， 同时它可以充分利用多处理器的优势。</li>
</ol>
<h5 id="14-1-2-Linux-线程库"><a href="#14-1-2-Linux-线程库" class="headerlink" title="14.1.2 Linux 线程库"></a>14.1.2 Linux 线程库</h5><p>Linux内核从 2.6版本开始，提供了真正的内核线程。新的NPTL线程库也应运而 生。相比LinuxThreads，NPTL的主要优势在于：</p>
<ul>
<li>内核线程不再是一个进程，因此避免了很多用进程模拟内核线 程导致的语义问题。</li>
<li>摒弃了管理线程，终止线程、回收线程堆栈等工作都可以由内核来完成。</li>
<li>由于不存在管理线程，所以一个进程的线程可以运行在不同的 CPU上，从而充分利用了多处理器系统的优势。</li>
<li>线程的同步由内核来完成。隶属于不同进程的线程之间也能共 享互斥锁，因此可实现跨进程的线程同步。</li>
</ul>
<h4 id="14-2-创建线程和结束线程"><a href="#14-2-创建线程和结束线程" class="headerlink" title="14.2 创建线程和结束线程"></a>14.2 创建线程和结束线程</h4><p>下面我们讨论创建和结束线程的基础API。Linux系统上，它们都 定义在pthread.h头文件中。</p>
<h5 id="14-2-1-pthread-create"><a href="#14-2-1-pthread-create" class="headerlink" title="14.2.1 pthread_create"></a>14.2.1 pthread_create</h5><p>创建一个线程的函数是pthread_create。其定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>*attr,<span class="keyword">void</span>*(*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span>*arg)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>thread参数是新线程的标识符，后续pthread_*函数通过它来引用新 线程。其类型pthread_t的定义如下：  可见，pthread_t是一个整型类型。实际上，Linux上几乎所有的资 源标识符都是一个整型数，比如socket、各种System V IPC标识符等。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/pthreadtypes.h＞</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>attr参数用于设置新线程的属性。给它传递NULL表示使用默认线 程属性。</p>
</li>
<li><p>start_routine 和arg参数分别指定新线程将运行的函数及其参数。</p>
</li>
</ul>
<p>pthread_create成功时返回0，失败时返回错误码。</p>
<h5 id="14-2-3-pthread-exit"><a href="#14-2-3-pthread-exit" class="headerlink" title="14.2.3 pthread_exit"></a>14.2.3 pthread_exit</h5><p>线程一旦被创建好，内核就可以调度内核线程来执行start_routine 函数指针所指向的函数了。线程函数在结束时最好调用如下函数，以 确保安全、干净地退出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span>;</span><br></pre></td></tr></table></figure>

<p>pthread_exit函数通过retval参数向线程的回收者传递其退出信息。 它执行完之后不会返回到调用者，而且永远不会失败。</p>
<h5 id="14-2-4-pthread-join"><a href="#14-2-4-pthread-join" class="headerlink" title="14.2.4 pthread_join"></a>14.2.4 pthread_join</h5><p>一个进程中的所有线程都可以调用pthread_join函数来回收其他线 程（前提是目标线程是可回收的，见后文），即等待其他线程结束， 这类似于回收进程的wait和waitpid系统调用。</p>
<p>pthread_join的定义如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span>** retval)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>hread参数是目标线程的标识符，</li>
<li>retval参数则是目标线程返回的退 出信息。该函数会一直阻塞，直到被回收的线程结束为止。</li>
</ul>
<p>该函数成 功时返回0，失败则返回错误码。</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230307172622769.png" class="" title="image-20230307172622769">



<h5 id="14-2-5-pthread-cancel"><a href="#14-2-5-pthread-cancel" class="headerlink" title="14.2.5 pthread_cancel"></a>14.2.5 pthread_cancel</h5><p>有时候我们希望异常终止一个线程，即取消线程，它是通过如下 函数实现的：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>thread参数是目标线程的标识符。</li>
</ul>
<p>该函数成功时返回0，失败则返 回错误码。</p>
<h4 id="14-3-线程属性"><a href="#14-3-线程属性" class="headerlink" title="14.3 线程属性"></a>14.3 线程属性</h4><p>pthread_attr_t结构体定义了一套完整的线程属性，如下所示：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/pthreadtypes.h＞</span></span><br><span class="line">#define__SIZEOF_PTHREAD_ATTR_T <span class="number">36</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line">	<span class="keyword">long</span> int__align;</span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h4 id="14-4-POSIX信号量"><a href="#14-4-POSIX信号量" class="headerlink" title="14.4 POSIX信号量"></a>14.4 POSIX信号量</h4><p>和多进程程序一样，多线程程序也必须考虑同步问题。 pthread_join可以看作一种简单的线程同步方式，不过很显然，它无法 高效地实现复杂的同步需求，比如控制对共享资源的独占式访问，又抑或是在某个条件满足之后唤醒一个线程。</p>
<p>接下来我们讨论3种专门用 于线程同步的机制：POSIX信号量、互斥量和条件变量。</p>
<blockquote>
<p>在Linux上，信号量API有两组。一组是第13章讨论过的System V IPC信号量，另外一组是我们现在要讨论的POSIX信号量。这两组接口 很相似，但不保证能互换。由于这两种信号量的语义完全相同，因此 我们不再赘述信号量的原理。</p>
</blockquote>
<p><code>POSIX信号量函数的名字都以sem_开头，并不像大多数线程函数 那样以pthread_开头。</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜semaphore.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>*sem,<span class="keyword">int</span> pshared,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>这些函数的第一个参数sem指向被操作的信号量。</li>
<li>sem_init函数用于初始化一个未命名的信号量,  pshared参数指定信号量的类 型。如果其值为0，就表示这个信号量是当前进程的局部信号量，否则 该信号量就可以在多个进程之间共享。value参数指定信号量的初始 值。此外，初始化一个已经被初始化的信号量将导致不可预期的结 果。</li>
<li>sem_destroy函数用于销毁信号量，以释放其占用的内核资源。如 果销毁一个正被其他线程等待的信号量，则将导致不可预期的结果。</li>
<li>sem_wait函数以原子操作的方式将信号量的值减1。如果信号量的 值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</li>
<li>sem_trywait与sem_wait函数相似，不过它始终立即返回，而不论 被操作的信号量是否具有非0值，相当于sem_wait的非阻塞版本。当信 号量的值非0时，sem_trywait对信号量执行减1操作。当信号量的值为0 时，它将返回-1并设置errno为EAGAIN。</li>
<li>sem_post函数以原子操作的方式将信号量的值加1。当信号量的值 大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</li>
</ul>
<p>上面这些函数成功时返回0，失败则返回-1并设置errno。</p>
<h4 id="14-5-互斥锁"><a href="#14-5-互斥锁" class="headerlink" title="14.5 互斥锁"></a>14.5 互斥锁</h4><p>互斥锁（也称互斥量）可以用于保护关键代码段，以确保其独占 式的访问，这有点像一个二进制信号量（见13.5.1小节）。</p>
<h5 id="14-5-1-互斥锁基础API"><a href="#14-5-1-互斥锁基础API" class="headerlink" title="14.5.1 互斥锁基础API"></a>14.5.1 互斥锁基础API</h5><p>POSIX互斥锁的相关函数主要有如下5个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span>*mutexattr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这些函数的第一个参数mutex指向要操作的目标互斥锁，互斥锁的 类型是pthread_mutex_t结构体。</p>
</li>
<li><p>pthread_mutex_init函数用于初始化互斥锁。mutexattr参数指定互 斥锁的属性。如果将它设置为NULL，则表示使用默认属性。除了这个函数外，我们<strong>还可以使用如 下方式来初始化一个互斥锁</strong>：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER; </span><br></pre></td></tr></table></figure>

<p>宏PTHREAD_MUTEX_INITIALIZER实际上只是把互斥锁的各个 字段都初始化为0。</p>
</li>
<li><p>pthread_mutex_destroy函数用于销毁互斥锁，以释放其占用的内核 资源。销毁一个已经加锁的互斥锁将导致不可预期的后果。</p>
</li>
<li><p>pthread_mutex_lock函数以原子操作的方式给一个互斥锁加锁。如 果目标互斥锁已经被锁上，则pthread_mutex_lock调用将阻塞，直到该 互斥锁的占有者将其解锁。</p>
</li>
<li><p>pthread_mutex_trylock与pthread_mutex_lock函数类似，不过它始 终立即返回，而不论被操作的互斥锁是否已经被加锁，相当于 pthread_mutex_lock的非阻塞版本。当目标互斥锁未被加锁时， pthread_mutex_trylock对互斥锁执行加锁操作。当互斥锁已经被加锁 时，pthread_mutex_trylock将返回错误码EBUSY。</p>
</li>
<li><p>pthread_mutex_unlock函数以原子操作的方式给一个互斥锁解锁。 如果此时有其他线程正在等待这个互斥锁，则这些线程中的某一个将 获得它。</p>
</li>
</ul>
<p>上面这些函数成功时返回0，失败则返回错误码。</p>
<h5 id="14-5-2-互斥锁属性"><a href="#14-5-2-互斥锁属性" class="headerlink" title="14.5.2 互斥锁属性"></a>14.5.2 互斥锁属性</h5><p>pthread_mutexattr_t结构体定义了一套完整的互斥锁属性。线程库 提供了一系列函数来操作pthread_mutexattr_t类型的变量，以方便我们 获取和设置互斥锁属性。</p>
<p>本书只讨论互斥锁的两种常用属性：pshared和type。</p>
<ol>
<li>互斥锁属性 pshared指定是否允许跨进程共享互斥锁，其可选值有两个：<ul>
<li>PTHREAD_PROCESS_SHARED。互斥锁可以被跨进程共享。</li>
<li>PTHREAD_PROCESS_PRIVATE。互斥锁只能被和锁的初始化 线程隶属于同一个进程的线程共享。</li>
</ul>
</li>
<li>互斥锁属性type指定互斥锁的类型。Linux支持如下4种类型的互 斥锁：<ul>
<li>PTHREAD_MUTEX_NORMAL，普通锁。这是互斥锁默认的类 型。当一个线程对一个普通锁加锁以后，其余请求该锁的线程将形成 一个等待队列，并在该锁解锁后按优先级获得它。这种锁类型保证了 资源分配的公平性。但这种锁也很容易引发问题：一个线程如果对一 个已经加锁的普通锁再次加锁，将引发死锁；对一个已经被其他线程 加锁的普通锁解锁，或者对一个已经解锁的普通锁再次解锁，将导致 不可预期的后果。</li>
<li>PTHREAD_MUTEX_ERRORCHECK，检错锁。一个线程如果 对一个已经加锁的检错锁再次加锁，则加锁操作返回EDEADLK。对 一个已经被其他线程加锁的检错锁解锁，或者对一个已经解锁的检错 锁再次解锁，则解锁操作返回EPERM</li>
<li>PTHREAD_MUTEX_RECURSIVE，嵌套锁。这种锁允许一个 线程在释放锁之前多次对它加锁而不发生死锁。不过其他线程如果要 获得这个锁，则当前锁的拥有者必须执行相应次数的解锁操作。对一 个已经被其他线程加锁的嵌套锁解锁，或者对一个已经解锁的嵌套锁 再次解锁，则解锁操作返回EPERM。</li>
<li>PTHREAD_MUTEX_DEFAULT，默认锁。一个线程如果对一个 已经加锁的默认锁再次加锁，或者对一个已经被其他线程加锁的默认 锁解锁，或者对一个已经解锁的默认锁再次解锁，将导致不可预期的 后果。这种锁在实现的时候可能被映射为上面三种锁之一。</li>
</ul>
</li>
</ol>
<h5 id="14-5-3-死锁举例"><a href="#14-5-3-死锁举例" class="headerlink" title="14.5.3 死锁举例"></a>14.5.3 死锁举例</h5><p>前文提到，在一个 线程中对一个已经加锁的普通锁再次加锁，将导致死锁。这种情况可 能出现在设计得不够仔细的递归函数中。另外，如果两个线程按照不 同的顺序来申请两个互斥锁，也容易产生死锁，如代码清单14-1所 示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">another</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in child thread,got mutex b,waiting for mutex a\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	++b;</span><br><span class="line">	pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line">	b += a++;</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">	pthread_exit(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> id;</span><br><span class="line">	pthread_mutex_init(&amp;mutex_a, <span class="literal">nullptr</span>);</span><br><span class="line">	pthread_mutex_init(&amp;mutex_b, <span class="literal">nullptr</span>);</span><br><span class="line">	pthread_create(&amp;id, <span class="literal">nullptr</span>, another, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">	pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in parent thread,got mutex a,waiting for mutex b\n&quot;</span>);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	++a;</span><br><span class="line">	pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line">	a += b++;</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">	pthread_join(id, <span class="literal">nullptr</span>);</span><br><span class="line">	pthread_mutex_destroy(&amp;mutex_a);</span><br><span class="line">	pthread_mutex_destroy(&amp;mutex_b);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主线程试图先占有互斥锁mutex_a，然后操作被 该锁保护的变量a，但操作完毕之后，主线程并没有立即释放互斥锁 mutex_a，而是又申请互斥锁mutex_b，并在两个互斥锁的保护下，操 作变量a和b，最后才一起释放这两个互斥锁；与此同时，子线程则按 照相反的顺序来申请互斥锁mutex_a和mutex_b，并在两个锁的保护下 操作变量a和b。</p>
<h4 id="14-6-条件变量"><a href="#14-6-条件变量" class="headerlink" title="14.6 条件变量"></a>14.6 条件变量</h4><p>如果说互斥锁是用于同步线程对共享数据的访问的话，那么条件变量则是用于在线程之间同步共享数据的值。条件变量提供了一种线 程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个 共享数据的线程。</p>
<p>条件变量的相关函数主要有如下5个：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span>*cond_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond,<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>这些函数的第一个参数cond指向要操作的目标条件变量，条件变 量的类型是pthread_cond_t结构体。</p>
</li>
<li><p>pthread_cond_init函数用于初始化条件变量。cond_attr参数指定条 件变量的属性。如果将它设置为NULL，则表示使用默认属性。除了pthread_cond_init函数外，我们还可以使用如下方式来初始化 一个条件变量： 宏PTHREAD_COND_INITIALIZER实际上只是把条件变量的各个 字段都初始化为0。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> cond=PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure>
</li>
<li><p>pthread_cond_destroy函数用于销毁条件变量，以释放其占用的内 核资源。销毁一个正在被等待的条件变量将失败并返回EBUSY。</p>
</li>
<li><p>pthread_cond_broadcast函数以广播的方式唤醒所有等待目标条件 变量的线程。</p>
</li>
<li><p>pthread_cond_signal函数用于唤醒一个等待目标条件变量 的线程。至于哪个线程将被唤醒，则取决于线程的优先级和调度策 略。有时候我们可能想唤醒一个指定的线程，但pthread没有对该需求 提供解决方法。</p>
<blockquote>
<p>不过我们可以间接地实现该需求：定义一个能够唯一 表示目标线程的全局变量，在唤醒等待条件变量的线程前先设置该变 量为目标线程，然后采用广播方式唤醒所有等待条件变量的线程，这 些线程被唤醒后都检查该变量以判断被唤醒的是否是自己，如果是就 开始执行后续代码，如果不是则返回继续等待。</p>
</blockquote>
</li>
<li><p>pthread_cond_wait函数用于等待目标条件变量。mutex参数是用于 保护条件变量的互斥锁，以确保pthread_cond_wait操作的原子性。在 调用pthread_cond_wait前，必须确保互斥锁mutex已经加锁，否则将导 致不可预期的结果。pthread_cond_wait函数执行时，首先把调用线程 放入条件变量的等待队列中，然后将互斥锁mutex解锁。</p>
</li>
</ul>
<p>上面这些函数成功时返回0，失败则返回错误码。</p>
<h4 id="14-7-线程同步机制"><a href="#14-7-线程同步机制" class="headerlink" title="14.7 线程同步机制"></a>14.7 线程同步机制</h4><p>为了充分复用代码，同时由于后文的需要，我们将前面讨论的3种 线程同步机制分别封装成3个类，实现在locker.h文件中</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装信号量的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*创建并初始化信号量*/</span></span><br><span class="line">	sem() &#123;</span><br><span class="line">		<span class="keyword">if</span> (sem_init(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="comment">/*构造函数没有返回值，可以通过抛出异常来报告错误*/</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*销毁信号量*/</span></span><br><span class="line">	~sem() &#123;</span><br><span class="line">		sem_destroy(&amp;m_sem);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*等待信号量*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sem_wait(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*增加信号量*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> sem_post(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装互斥锁的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*创建并初始化互斥锁*/</span></span><br><span class="line">	locker() &#123;</span><br><span class="line">		<span class="keyword">if</span> (pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*销毁互斥锁*/</span></span><br><span class="line">	~locker() &#123;</span><br><span class="line">		pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*获取互斥锁*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pthread_mutex_lock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*释放互斥锁*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pthread_mutex_unlock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装条件变量的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*创建并初始化条件变量*/</span></span><br><span class="line">	cond() &#123;</span><br><span class="line">		<span class="keyword">if</span> (pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (pthread_cond_init(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">/*构造函数中一旦出现问题，就应该立即释放已经成功分配了的资源*/</span></span><br><span class="line">			pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*销毁条件变量*/</span></span><br><span class="line">	~cond() &#123;</span><br><span class="line">		pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">		pthread_cond_destroy(&amp;m_cond);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*等待条件变量*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">		pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line">		ret = pthread_cond_wait(&amp;m_cond, &amp;m_mutex);</span><br><span class="line">		pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line">		<span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*唤醒等待条件变量的线程*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> pthread_cond_signal(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">	<span class="keyword">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>



<h4 id="14-8-多线程环境"><a href="#14-8-多线程环境" class="headerlink" title="14.8 多线程环境"></a>14.8 多线程环境</h4><h5 id="14-8-1-可重入函数"><a href="#14-8-1-可重入函数" class="headerlink" title="14.8.1 可重入函数"></a>14.8.1 可重入函数</h5><p>如果一个函数能被多个线程同时调用且不发生竞态条件，则我们 称它是线程安全的（thread safe），或者说它是可重入函数。</p>
<p>关于 Linux上不可重入的库函数的完整列表，请读者参考相关书籍，这里不 再赘述。这些库函数之所以不可重入，主要是因为其内部使用了静态变量。</p>
<p>不过Linux对很多不可重入的库函数提供了对应的可重入版本， 这些可重入版本的函数名是在原函数名尾部加上_r。比如，函数 localtime对应的可重入函数是localtime_r。在多线程程序中调用库函 数，一定要使用其可重入版本，否则可能导致预想不到的结果。</p>
<h5 id="14-8-2-线程和进程"><a href="#14-8-2-线程和进程" class="headerlink" title="14.8.2 线程和进程"></a>14.8.2 线程和进程</h5><p>思考这样一个问题：<strong>如果一个多线程程序的某个线程调用了fork 函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢？ **答案是“否”，正如我们期望的那样。</strong>子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父 进程中互斥锁（条件变量与之类似）的状态。也就是说，父进程中已 经被加锁的互斥锁在子进程中也是被锁住的。**</p>
<p>这就引起了一个问题： 子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状 态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork 函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况， 则子进程若再次对该互斥锁执行加锁操作就会导致死锁，如代码清单</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子线程运行的函数。它首先获得互斥锁mutex，然后暂停5 s，再释放该互斥锁*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">another</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;in child thread,lock the mutex\n&quot;</span>);</span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line">	sleep(<span class="number">5</span>);</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	pthread_mutex_init(&amp;mutex, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">pthread_t</span> id;</span><br><span class="line">	pthread_create(&amp;id, <span class="literal">nullptr</span>, another, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="comment">/*父进程中的主线程暂停1 s，以确保在执行fork操作之前，子线程已经开始运行并获得了互斥变量mutex*/</span></span><br><span class="line">	sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> pid = fork();</span><br><span class="line">	<span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		pthread_join(id, <span class="literal">nullptr</span>);</span><br><span class="line">		pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I am in the child,want to get the lock\n&quot;</span>);</span><br><span class="line">		<span class="comment">/* 子进程从父进程继承了互斥锁mutex的状态，该互斥锁处于锁住的状态，</span></span><br><span class="line"><span class="comment">		 * 这是由父进程中的子线程执行pthread_mutex_lock引起的，</span></span><br><span class="line"><span class="comment">		 * 因此，下面这句加锁操作会一直阻塞，尽管从逻辑上来说它是不应该阻塞的*/</span></span><br><span class="line">		pthread_mutex_lock(&amp;mutex);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;I can not run to here,oop...\n&quot;</span>);</span><br><span class="line">		pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">		<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// wait 函数将阻塞进程, 直到该进程的某个子进程结束运行为止</span></span><br><span class="line">		wait(<span class="literal">nullptr</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	pthread_join(id, <span class="literal">nullptr</span>);</span><br><span class="line">	pthread_mutex_destroy(&amp;mutex);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>pthread提供了一个专门的函数pthread_atfork，以确保fork 调用后父进程和子进程都拥有一个清楚的锁状态。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_atfork</span><span class="params">(<span class="keyword">void</span>(*prepare)(<span class="keyword">void</span>), <span class="keyword">void</span>(*parent)(<span class="keyword">void</span>), <span class="keyword">void</span>(*child)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数将建立3个fork句柄来帮助我们清理互斥锁的状态。</p>
<ul>
<li>prepare 句柄将在fork调用创建出子进程之前被执行。它可以用来锁住所有父进程中的互斥锁。</li>
<li>parent句柄则是fork调用创建出子进程之后，而fork 返回之前，在父进程中被执行。它的作用是释放所有在prepare句柄中 被锁住的互斥锁。</li>
<li>child句柄是fork返回之前，在子进程中被执行。和 parent句柄一样，child句柄也是用于释放所有在prepare句柄中被锁住的 互斥锁。</li>
</ul>
<p>该函数成功时返回0，失败则返回错误码。</p>
<p>如果要让代码清单14-3正常工作，就应该在其中的fork调用 前加入代码清单14-4所示的代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pthread_mutex_lock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">infork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">	pthread_atfork(prepare,infork,infork);</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="14-8-3-线程和信号"><a href="#14-8-3-线程和信号" class="headerlink" title="14.8.3 线程和信号"></a>14.8.3 线程和信号</h5><p>每个线程都可以独立地设置信号掩码。我们在10.3.2小节讨论过设 置进程信号掩码的函数sigprocmask，但在多线程环境下我们应该使用 如下所示的pthread版本的sigprocmask函数来设置线程信号掩码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span>* newmask, <span class="keyword">sigset_t</span>* oldmask)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><code>_set</code>参数指定新的信号掩码，</p>
</li>
<li><p>_oset参数则输出原来的信号掩码（如 果不为NULL的话）。</p>
</li>
<li><p>如果_set参数不为NULL，则_how参数指定设置 进程信号掩码的方式，其可选值如表10-5所示。</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230304143250709.png" class="" title="image-20230304143250709">

</li>
</ul>
<p>sigprocmask成功时返回0，失败则返回-1并设置errno。</p>
<p>由于进程中的所有线程共享该进程的信号，所以线程库将根据线程掩码决定把信号发送给哪个具体的线程。这两点都说明，我们应该定义一个专门的线程来处理所有的 信号。这可以通过如下两个步骤来实现：</p>
<ol>
<li><p>在主线程创建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码。这样 做之后，实际上所有线程都不会响应被屏蔽的信号了。</p>
</li>
<li><p>在某个线程中调用如下函数来等待信号并处理之：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">int</span>* sig)</span></span>;</span><br></pre></td></tr></table></figure>

<ul>
<li>set参数指定需要等待的信号的集合。我们可以简单地将其指定为 在第1步中创建的信号掩码，表示在该线程中等待所有被屏蔽的信号。</li>
<li>参数sig指向的整数用于存储该函数返回的信号值。</li>
</ul>
</li>
</ol>
<p>sigwait成功时返回 0，失败则返回错误码。一旦sigwait正确返回，我们就可以对接收到的 信号做处理了。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> handle_error_en(en, msg)\</span></span><br><span class="line"><span class="keyword">do</span>&#123;errno=en;perror(msg);<span class="built_in">exit</span>(EXIT_FAILURE);&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">sig_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">auto</span> *<span class="built_in">set</span> = (<span class="keyword">sigset_t</span> *) arg;</span><br><span class="line">	<span class="keyword">int</span> s, sig;</span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="comment">/*第二个步骤，调用sigwait等待信号*/</span></span><br><span class="line">		s = sigwait(<span class="built_in">set</span>, &amp;sig);</span><br><span class="line">		<span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">			handle_error_en(s, <span class="string">&quot;sigwait&quot;</span>);</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;Signal handling thread got signal%d\n&quot;</span>, sig);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">pthread_t</span> thread;</span><br><span class="line">	<span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line">	<span class="keyword">int</span> s;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/*第一个步骤，在主线程中设置信号掩码*/</span></span><br><span class="line">	sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">	sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">	sigaddset(&amp;<span class="built_in">set</span>, SIGUSR1);</span><br><span class="line">	</span><br><span class="line">	s = pthread_sigmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">nullptr</span>);</span><br><span class="line">	<span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">		handle_error_en(s, <span class="string">&quot;pthread_sigmask&quot;</span>);</span><br><span class="line">	</span><br><span class="line">	s = pthread_create(&amp;thread, <span class="literal">nullptr</span>, &amp;sig_thread, (<span class="keyword">void</span> *) &amp;<span class="built_in">set</span>);</span><br><span class="line">	<span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">		handle_error_en(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">	pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，pthread还提供了下面的方法，使得我们可以明确地将一个 信号发送给指定的线程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure>

<p>其中，thread参数指定目标线程，sig参数指定待发送的信号。</p>
<h3 id="第15章-进程池和线程池"><a href="#第15章-进程池和线程池" class="headerlink" title="第15章 进程池和线程池"></a>第15章 进程池和线程池</h3><p>在前面的章节中，我们是通过动态创建子进程（或子线程）来实 现并发服务器的。这样做有如下缺点：</p>
<ul>
<li>动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户响应。</li>
<li>动态创建的子进程（或子线程）通常只用来为一个客户服务 （除非我们做特殊的处理），这将导致系统上产生大量的细微进程 （或线程）。进程（或线程）间的切换将消耗大量CPU时间。</li>
<li>动态创建的子进程是当前进程的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复 制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性 能。</li>
</ul>
<h4 id="15-1-线程池和进程池概述"><a href="#15-1-线程池和进程池概述" class="headerlink" title="15.1 线程池和进程池概述"></a>15.1 线程池和进程池概述</h4><p>进程池和线程池相似，所以这里我们只以进程池为例进行介绍。 如没有特殊声明，下面对进程池的讨论完全适用于线程池。</p>
<p>进程池是由服务器预先创建的一组子进程，这些子进程的数目在3 ～10个之间（当然，这只是典型情况）。比如13.5.5小节所描述的， httpd守护进程就是使用包含7个子进程的进程池来实现并发的。<strong>线程池 中的线程数量应该和CPU数量差不多。</strong></p>
<p>进程池中的所有子进程都运行着相同的代码，并具有相同的属 性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好 了，所以<strong>每个子进程都相对“干净”，即它们没有打开不必要的文件描 述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父 进程复制得到）。</strong></p>
<p>当有新的任务到来时，主进程将通过某种方式选择进程池中的某 一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在 的子进程的代价显然要小得多。至于主进程选择哪个子进程来为新任 务服务，则有两种方式：</p>
<ul>
<li>主进程使用某种算法来主动选择子进程。最简单、最常用的算 法是随机算法和Round Robin（轮流选取）算法，但更优秀、更智能的 算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整 体压力。</li>
<li>主进程和所有子进程通过一个共享的工作队列来同步，子进程 都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到 工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程 将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之， 而其他子进程将继续睡眠在工作队列上。</li>
</ul>
<p><strong>当选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。</strong>最简单的方法是，在 父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的进程间通信（当然，要预先定义好一套协议来规范管道的使 用）。在父线程和子线程之间传递数据就要简单得多，因为我们可以 把这些数据定义为全局的，那么它们本身就是被所有线程共享的。</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230308112500214.png" class="" title="image-20230308112500214">



<h4 id="15-2-处理多客户"><a href="#15-2-处理多客户" class="headerlink" title="15.2 处理多客户"></a>15.2 处理多客户</h4><p>在使用进程池处理多客户任务时，首先要考虑的一个问题是：<strong>监听socket和连接socket是否都由主进程来统一管理。</strong></p>
<blockquote>
<p>回忆第8章中我们介 绍过的几种并发模式，其中半同步/半反应堆模式是由主进程统一管理这两种socket的；而图8-11所示的高效的半同步/半异步模式，以及领导者/追随者模式，则是由主进程管理所有监听socket，而各个子进程分别 管理属于自己的连接socket的。</p>
<p>对于前一种情况，主进程接受新的连接 以得到连接socket，然后它需要将该socket传递给子进程（对于线程池 而言，父线程将socket传递给子线程是很简单的，因为它们可以很容易 地共享该socket。但对于进程池而言，我们必须使用13.9节介绍的方法 来传递该socket）。</p>
<p>后一种情况的灵活性更大一些，因为子进程可以自 己调用accept来接受新的连接，这样父进程就无须向子进程传递 socket，而只需要简单地通知一声：“我检测到新的连接，你来接受它。</p>
</blockquote>
<p>在4.6.1小节中我们曾讨论过常连接，即一个客户的多次请求可以 复用一个TCP连接。这里是指长链接和短连接. 那么，在设计进程池时还需要考虑：一个客户连接 上的所有任务是否始终由一个子进程来处理。</p>
<ul>
<li><p>如果说客户任务是无状 态的，那么我们可以考虑使用不同的子进程来为该客户的不同请求服 务，如图15-2所示:</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230308113352813.png" class="" title="image-20230308113352813">
</li>
<li><p>但如果客户任务是存在上下文关系的，则最好一直用同一个子进 程来为之服务，否则实现起来将比较麻烦，因为我们不得不在各子进 程之间传递上下文数据。<strong>在9.3.4小节中，我们讨论了epoll的 EPOLLONESHOT事件，这一事件能够确保一个客户连接在整个生命周 期中仅被一个线程处理。</strong></p>
</li>
</ul>
<h4 id="15-3-半同步-半异步进程池实现"><a href="#15-3-半同步-半异步进程池实现" class="headerlink" title="15.3 半同步/半异步进程池实现"></a>15.3 半同步/半异步进程池实现</h4><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230228212643003.png" class="" title="image-20230228212643003">

<p>本节我们实现一个基于图8-11所示的半同步/半 异步并发模式的进程池，如代码清单15-1所示。</p>
<p>为了避免在父、子进 程之间传递文件描述符，我们将接受新连接的操作放到子进程中。很 显然，对于这种模式而言，一个客户连接上的所有任务始终是由一个子进程来处理的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filename:processpool.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROCESSPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESSPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*描述一个子进程的类，m_pid是目标子进程的PID，m_pipefd是父进程和子进程通</span></span><br><span class="line"><span class="comment">信用的管道*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">process</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	process() : m_pid(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">pid_t</span> m_pid;</span><br><span class="line">	<span class="keyword">int</span> m_pipefd[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池类，将它定义为模板类是为了代码复用。其模板参数是处理逻辑任务的类*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">processpool</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*将构造函数定义为私有的，因此我们只能通过后面的create静态函数来创建processpool实例*/</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">processpool</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number = <span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*单体模式，以保证程序最多创建一个processpool实例，这是程序正确处理信号的必要条件*/</span></span><br><span class="line">	<span class="keyword">static</span> processpool&lt;T&gt; *</span><br><span class="line"></span><br><span class="line">	create(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number = <span class="number">8</span>) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!m_instance) &#123;</span><br><span class="line">			m_instance = <span class="keyword">new</span> processpool&lt;T&gt;(listenfd, process_number);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> m_instance;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~processpool() &#123; <span class="keyword">delete</span>[] m_sub_process; &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*启动进程池*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">setup_sig_pipe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run_parent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run_child</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*进程池允许的最大子进程数量*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_PROCESS_NUMBER = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*每个子进程最多能处理的客户数量*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> USER_PER_PROCESS = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*epoll最多能处理的事件数*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENT_NUMBER = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*进程池中的进程总数*/</span></span><br><span class="line">	<span class="keyword">int</span> m_process_number;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*子进程在池中的序号，从0开始*/</span></span><br><span class="line">	<span class="keyword">int</span> m_idx;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*每个进程都有一个epoll内核事件表，用m_epollfd标识*/</span></span><br><span class="line">	<span class="keyword">int</span> m_epollfd&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*监听socket*/</span></span><br><span class="line">	<span class="keyword">int</span> m_listenfd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*子进程通过m_stop来决定是否停止运行*/</span></span><br><span class="line">	<span class="keyword">int</span> m_stop;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*保存所有子进程的描述信息*/</span></span><br><span class="line">	process *m_sub_process;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*进程池静态实例*/</span></span><br><span class="line">	<span class="keyword">static</span> processpool&lt;T&gt; *m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">processpool&lt;T&gt; *processpool&lt;T&gt;::m_instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于处理信号的管道，以实现统一事件源。后面称之为信号管道*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sig_pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	epoll_event event&#123;&#125;;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN | EPOLLET;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">	setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从epollfd标识的epoll内核事件表中删除fd上的所有注册事件*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> save_errno = errno;</span><br><span class="line">	<span class="keyword">int</span> msg = sig;</span><br><span class="line">	send(sig_pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">	errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span> &#123;</span>&#125;;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">	sa.sa_handler = handler;</span><br><span class="line">	<span class="keyword">if</span> (restart) &#123;</span><br><span class="line">		sa.sa_flags |= SA_RESTART;</span><br><span class="line">	&#125;</span><br><span class="line">	sigfillset(&amp;sa.sa_mask);</span><br><span class="line">	assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池构造函数。参数listenfd是监听socket，它必须在创建进程池之前被创建，</span></span><br><span class="line"><span class="comment">否则子进程无法直接引用它。参数process_number指定进程池中子进程的数量*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">processpool&lt;T&gt;::processpool(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number)</span><br><span class="line">    : m_listenfd(listenfd), m_process_number(process_number), m_idx(<span class="number">-1</span>),</span><br><span class="line">      m_stop(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">	assert((process_number &gt; <span class="number">0</span>) &amp;&amp; (process_number &lt;= MAX_PROCESS_NUMBER));</span><br><span class="line"></span><br><span class="line">	m_sub_process = <span class="keyword">new</span> process[process_number];</span><br><span class="line">	assert(m_sub_process);</span><br><span class="line">	<span class="comment">/*创建process_number个子进程，并建立它们和父进程之间的管道*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_number; ++i) &#123;</span><br><span class="line">		<span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_sub_process[i].m_pipefd);</span><br><span class="line">		assert(ret == <span class="number">0</span>);</span><br><span class="line">		m_sub_process[i].m_pid = fork();</span><br><span class="line">		assert(m_sub_process[i].m_pid &gt;= <span class="number">0</span>);</span><br><span class="line">		<span class="keyword">if</span> (m_sub_process[i].m_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			close(m_sub_process[i].m_pipefd[<span class="number">1</span>]);</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			close(m_sub_process[i].m_pipefd[<span class="number">0</span>]);</span><br><span class="line">			m_idx = i;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*统一事件源*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::setup_sig_pipe() &#123;</span><br><span class="line">	<span class="comment">/*创建epoll事件监听表和信号管道*/</span></span><br><span class="line">	m_epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">	assert(m_epollfd != <span class="number">-1</span>);</span><br><span class="line">	<span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, sig_pipefd);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	setnonblocking(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">	addfd(m_epollfd, sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">	<span class="comment">/*设置信号处理函数*/</span></span><br><span class="line">	addsig(SIGCHLD, sig_handler);</span><br><span class="line">	addsig(SIGTERM, sig_handler);</span><br><span class="line">	addsig(SIGINT, sig_handler);</span><br><span class="line">	addsig(SIGPIPE, SIG_IGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*父进程中m_idx值为-1，子进程中m_idx值大于等于0，我们据此判断接下来要运行</span></span><br><span class="line"><span class="comment">的是父进程代码还是子进程代码*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::run() &#123;</span><br><span class="line">	<span class="keyword">if</span> (m_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">		run_child();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	run_parent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::run_child() &#123;</span><br><span class="line">	setup_sig_pipe();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*每个子进程都通过其在进程池中的序号值m_idx找到与父进程通信的管道*/</span></span><br><span class="line">	<span class="keyword">int</span> pipefd = m_sub_process[m_idx].m_pipefd[<span class="number">1</span>];</span><br><span class="line">	<span class="comment">/*子进程需要监听管道文件描述符pipefd，因为父进程将通过它来通知子进程accept</span></span><br><span class="line"><span class="comment">  新连接*/</span></span><br><span class="line">	addfd(m_epollfd, pipefd);</span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">	T *users = <span class="keyword">new</span> T[USER_PER_PROCESS];</span><br><span class="line">	assert(users);</span><br><span class="line">	<span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">		number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">			<span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">				<span class="keyword">int</span> client = <span class="number">0</span>;</span><br><span class="line">				<span class="comment">/*从父、子进程之间的管道读取数据，并将结果保存在变量client中。如果读取成</span></span><br><span class="line"><span class="comment">        功，则表示有新客户连接到来*/</span></span><br><span class="line">				ret = recv(sockfd, (<span class="keyword">char</span> *) &amp;client, <span class="keyword">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (((ret &lt; <span class="number">0</span>) &amp;&amp; (errno != EAGAIN)) || ret == <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					struct sockaddr_in client_address;</span><br><span class="line">					<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">					<span class="keyword">int</span> connfd = accept(m_listenfd, (struct sockaddr *) &amp;client_address,</span><br><span class="line">					                    &amp;client_addrlength);</span><br><span class="line">					<span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">						<span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">						<span class="keyword">continue</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					addfd(m_epollfd, connfd);</span><br><span class="line">					<span class="comment">/*模板类T必须实现init方法，以初始化一个客户连接。我们直接使用connfd来索引</span></span><br><span class="line"><span class="comment">          逻辑处理对象（T类型的对象），以提高程序效率*/</span></span><br><span class="line">					users[connfd].init(m_epollfd, connfd, client_address);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*下面处理子进程接收到的信号*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">				<span class="keyword">int</span> sig;</span><br><span class="line">				<span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">				ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">						<span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line">							<span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line">								<span class="keyword">pid_t</span> pid;</span><br><span class="line">								<span class="keyword">int</span> stat;</span><br><span class="line">								<span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">									<span class="keyword">continue</span>;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">case</span> SIGTERM:</span><br><span class="line">							<span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">								m_stop = <span class="literal">true</span>;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">default</span>: &#123;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*如果是其他可读数据，那么必然是客户请求到来。调用逻辑处理对象的process方法</span></span><br><span class="line"><span class="comment">      处理之*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">				users[sockfd].</span><br><span class="line"></span><br><span class="line">				        process();</span><br><span class="line"></span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">delete</span>[] users;</span><br><span class="line">	users = <span class="literal">NULL</span>;</span><br><span class="line">	close(pipefd);</span><br><span class="line">	<span class="comment">// close(m_listenfd);/*我们将这句话注释掉，以提醒读者：应该由m_listenfd</span></span><br><span class="line">	<span class="comment">// 的创建者来关闭这个文件描述符（见后文），即所谓的“对象（比如一个文件描述符，又或者</span></span><br><span class="line">	<span class="comment">// 一段堆内存）由哪个函数创建，就应该由哪个函数销毁”*/</span></span><br><span class="line">	close(m_epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::run_parent() &#123;</span><br><span class="line">	setup_sig_pipe();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*父进程监听m_listenfd*/</span></span><br><span class="line">	addfd(m_epollfd, m_listenfd);</span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">	<span class="keyword">int</span> sub_process_counter = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> new_conn = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">		number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">			<span class="keyword">if</span> (sockfd == m_listenfd) &#123;</span><br><span class="line">				<span class="comment">/*如果有新连接到来，就采用Round Robin方式将其分配给一个子进程处理*/</span></span><br><span class="line">				<span class="keyword">int</span> i = sub_process_counter;</span><br><span class="line">				<span class="keyword">do</span> &#123;</span><br><span class="line">					<span class="keyword">if</span> (m_sub_process[i].m_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">					i = (i + <span class="number">1</span>) % m_process_number;</span><br><span class="line">				&#125; <span class="keyword">while</span> (i != sub_process_counter);</span><br><span class="line">				<span class="keyword">if</span> (m_sub_process[i].m_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">					m_stop = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				sub_process_counter = (i + <span class="number">1</span>) % m_process_number;</span><br><span class="line">				send(m_sub_process[i].m_pipefd[<span class="number">0</span>], (<span class="keyword">char</span> *) &amp;new_conn, <span class="keyword">sizeof</span>(new_conn),</span><br><span class="line">				     <span class="number">0</span>);</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;send request to child%d\n&quot;</span>, i);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*下面处理父进程接收到的信号*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line">				<span class="keyword">int</span> sig;</span><br><span class="line">				<span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">				ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">				<span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line">						<span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line">							<span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line">								<span class="keyword">pid_t</span> pid;</span><br><span class="line">								<span class="keyword">int</span> stat;</span><br><span class="line">								<span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">									<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line">										<span class="comment">/*如果进程池中第i个子进程退出了，则主进程关闭相应的通信管道，并设置相应的</span></span><br><span class="line"><span class="comment">                  m_pid为-1，以标记该子进程已经退出*/</span></span><br><span class="line">										<span class="keyword">if</span> (m_sub_process[i].m_pid == pid) &#123;</span><br><span class="line">											<span class="built_in">printf</span>(<span class="string">&quot;child%d join\n&quot;</span>, i);</span><br><span class="line">											close(m_sub_process[i].m_pipefd[<span class="number">0</span>]);</span><br><span class="line">											m_sub_process[i].m_pid = <span class="number">-1</span>;</span><br><span class="line">										&#125;</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="comment">/*如果所有子进程都已经退出了，则父进程也退出*/</span></span><br><span class="line">								m_stop = <span class="literal">true</span>;</span><br><span class="line">								<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line">									<span class="keyword">if</span> (m_sub_process[i].m_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">										m_stop = <span class="literal">false</span>;</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">case</span> SIGTERM:&#123;&#125;</span><br><span class="line">							<span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">								<span class="comment">/*如果父进程接收到终止信号，那么就杀死所有子进程，并等待它们全部结束。当然，</span></span><br><span class="line"><span class="comment">              通知子进程结束更好的方法是向父、子进程之间的通信管道发送特殊数据，读者不妨自己实</span></span><br><span class="line"><span class="comment">              现之*/</span></span><br><span class="line">								<span class="built_in">printf</span>(<span class="string">&quot;kill all the clild now\n&quot;</span>);</span><br><span class="line">								<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line">									<span class="keyword">int</span> pid = m_sub_process[i].m_pid;</span><br><span class="line">									<span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">										kill(pid, SIGTERM);</span><br><span class="line">									&#125;</span><br><span class="line">								&#125;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">							<span class="keyword">default</span>: &#123;</span><br><span class="line">								<span class="keyword">break</span>;</span><br><span class="line">							&#125;</span><br><span class="line">						&#125;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// close(m_listenfd);/*由创建者关闭这个文件描述符（见后文）*/</span></span><br><span class="line">	close(m_epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>





<h4 id="15-4-用进程池实现的简单CGI服务器"><a href="#15-4-用进程池实现的简单CGI服务器" class="headerlink" title="15.4 用进程池实现的简单CGI服务器"></a>15.4 用进程池实现的简单CGI服务器</h4><p>回忆6.2节，我们曾实现过一个非常简单的CGI服务器。下面我们 将利用前面介绍的进程池来重新实现一个并发的CGI服务器，如代码 清单15-2所示。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用进程池实现一个并发CGI服务器*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;processpool.h&quot;</span> <span class="comment">/*引用上一节介绍的进程池*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于处理客户CGI请求的类，它可以作为processpool类的模板参数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cgi_conn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	cgi_conn() = <span class="keyword">default</span>;</span><br><span class="line">	~cgi_conn() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*初始化客户连接，清空读缓冲区*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in &amp;client_addr)</span> </span>&#123;</span><br><span class="line">		m_epollfd = epollfd;</span><br><span class="line">		m_sockfd = sockfd;</span><br><span class="line">		m_address = client_addr;</span><br><span class="line">		<span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">		m_read_idx = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">		<span class="comment">/*循环读取和分析客户数据*/</span></span><br><span class="line">		<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">			idx = m_read_idx;</span><br><span class="line">			ret = recv(m_sockfd, m_buf + idx, BUFFER_SIZE - <span class="number">1</span> - idx, <span class="number">0</span>);</span><br><span class="line">			<span class="comment">/*如果读操作发生错误,则关闭客户连接。但如果是暂时无数据可读，则退出循环*/</span></span><br><span class="line">			<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">					removefd(m_epollfd, m_sockfd);</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/*如果对方关闭连接，则服务器也关闭连接*/</span></span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">				removefd(m_epollfd, m_sockfd);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				m_read_idx += ret;</span><br><span class="line">				<span class="built_in">printf</span>(<span class="string">&quot;user content is:%s\n&quot;</span>, m_buf);</span><br><span class="line">				<span class="comment">/*如果遇到字符“\r\n”，则开始处理客户请求*/</span></span><br><span class="line">				<span class="keyword">for</span> (; idx &lt; m_read_idx; ++idx) &#123;</span><br><span class="line">					<span class="keyword">if</span> ((idx &gt;= <span class="number">1</span>) &amp;&amp; (m_buf[idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>) &amp;&amp; (m_buf[idx] == <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line">						<span class="keyword">break</span>;</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*如果没有遇到字符“\r\n”，则需要读取更多客户数据*/</span></span><br><span class="line">				<span class="keyword">if</span> (idx == m_read_idx) &#123;</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				m_buf[idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				<span class="keyword">char</span> *file_name = m_buf;</span><br><span class="line">				<span class="comment">/*判断客户要运行的CGI程序是否存在*/</span></span><br><span class="line">				<span class="keyword">if</span> (access(file_name, F_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">					removefd(m_epollfd, m_sockfd);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*创建子进程来执行CGI程序*/</span></span><br><span class="line">				ret = fork();</span><br><span class="line">				<span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">					removefd(m_epollfd, m_sockfd);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="comment">/*父进程只需关闭连接*/</span></span><br><span class="line">					removefd(m_epollfd, m_sockfd);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="comment">/*子进程将标准输出定向到m_sockfd，并执行CGI程序*/</span></span><br><span class="line">					close(STDOUT_FILENO);</span><br><span class="line">					dup(m_sockfd);</span><br><span class="line">					execl(m_buf, m_buf, <span class="number">0</span>);</span><br><span class="line">					<span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*读缓冲区的大小*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_epollfd;</span><br><span class="line">	<span class="keyword">int</span> m_sockfd&#123;&#125;;</span><br><span class="line">	sockaddr_in m_address&#123;&#125;;</span><br><span class="line">	<span class="keyword">char</span> m_buf[BUFFER_SIZE]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*标记读缓冲中已经读入的客户数据的最后一个字节的下一个位置*/</span></span><br><span class="line">	<span class="keyword">int</span> m_read_idx&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cgi_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span> &#123;</span>&#125;;</span><br><span class="line">	bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">	address.sin_port = htons(port);</span><br><span class="line">	ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line">	ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">	assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">	processpool&lt;cgi_conn&gt; *pool = processpool&lt;cgi_conn&gt;::create(listenfd);</span><br><span class="line">	<span class="keyword">if</span> (pool) &#123;</span><br><span class="line">		pool-&gt;run();</span><br><span class="line">		<span class="keyword">delete</span> pool;</span><br><span class="line">	&#125;</span><br><span class="line">	close(listenfd);</span><br><span class="line">	<span class="comment">/*正如前文提到的，main函数创建了文件描述符listenfd，那么就由它亲自关闭之*/</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="15-5-半同步-半反应堆线程池实现"><a href="#15-5-半同步-半反应堆线程池实现" class="headerlink" title="15.5 半同步/半反应堆线程池实现"></a>15.5 半同步/半反应堆线程池实现</h4><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230228212216219.png" class="" title="image-20230228212216219">

<p>本节我们实现一个基于图8-10所示的半同步/半反应堆并发模式的 线程池，如代码清单15-3所示。</p>
<p>相比代码清单15-1所示的进程池实现，该线程池的通用性要高得多，因为它使用一个工作队列完全解除 了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工 作线程通过竞争来取得任务并执行它。不过，如果要将该线程池应用 到实际服务器程序中，那么我们必须保证所有客户请求都是无状态的，因为同一个连接上的不同请求可能会由不同的线程处理。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*引用第14章介绍的线程同步机制的包装类*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程池类，将它定义为模板类是为了代码复用。模板参数T是任务类*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadpool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*参数thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line">	<span class="function"><span class="keyword">explicit</span> <span class="title">threadpool</span><span class="params">(<span class="keyword">int</span> thread_number = <span class="number">8</span>, <span class="keyword">int</span> max_requests = <span class="number">10000</span>)</span></span>;</span><br><span class="line">	~threadpool();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*往请求队列中添加任务*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T *request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> m_thread_number;        <span class="comment">/*线程池中的线程数*/</span></span><br><span class="line">	<span class="keyword">int</span> m_max_requests;         <span class="comment">/*请求队列中允许的最大请求数*/</span></span><br><span class="line">	<span class="keyword">pthread_t</span> *m_threads;       <span class="comment">/*描述线程池的数组，其大小为m_thread_number*/</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">list</span>&lt;T *&gt; m_workqueue; <span class="comment">/*请求队列*/</span></span><br><span class="line">	locker m_queuelocker;       <span class="comment">/*保护请求队列的互斥锁*/</span></span><br><span class="line">	sem m_queuestat;            <span class="comment">/*是否有任务需要处理*/</span></span><br><span class="line">	<span class="keyword">bool</span> m_stop;                <span class="comment">/*是否结束线程*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::threadpool(<span class="keyword">int</span> thread_number, <span class="keyword">int</span> max_requests)</span><br><span class="line">    : m_thread_number(thread_number), m_max_requests(max_requests),</span><br><span class="line">      m_stop(<span class="literal">false</span>), m_threads(<span class="literal">nullptr</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> ((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	m_threads = <span class="keyword">new</span> <span class="keyword">pthread_t</span>[m_thread_number];</span><br><span class="line">	<span class="keyword">if</span> (!m_threads) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*创建thread_number个线程，并将它们都设置为脱离线程*/</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;create the%dth thread\n&quot;</span>, i);</span><br><span class="line">		<span class="keyword">if</span> (pthread_create(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] m_threads;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (pthread_detach(m_threads[i])) &#123;</span><br><span class="line">			<span class="keyword">delete</span>[] m_threads;</span><br><span class="line">			<span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~threadpool() &#123;</span><br><span class="line">	<span class="keyword">delete</span>[] m_threads;</span><br><span class="line">	m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt;T&gt;::append(T *request) &#123;</span><br><span class="line">	<span class="comment">/*操作工作队列时一定要加锁，因为它被所有线程共享*/</span></span><br><span class="line">	m_queuelocker.lock();</span><br><span class="line">	<span class="keyword">if</span> (m_workqueue.size() &gt; m_max_requests) &#123;</span><br><span class="line">		m_queuelocker.unlock();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_workqueue.push_back(request);</span><br><span class="line">	m_queuelocker.unlock();</span><br><span class="line">	m_queuestat.post();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> *threadpool&lt;T&gt;::worker(<span class="keyword">void</span> *arg) &#123;</span><br><span class="line">	<span class="keyword">auto</span> *pool = (threadpool *) arg;</span><br><span class="line">	pool-&gt;run();</span><br><span class="line">	<span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> threadpool&lt;T&gt;::run() &#123;</span><br><span class="line">	<span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">		m_queuestat.wait();</span><br><span class="line">		m_queuelocker.lock();</span><br><span class="line">		<span class="keyword">if</span> (m_workqueue.empty()) &#123;</span><br><span class="line">			m_queuelocker.unlock();</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		T *request = m_workqueue.front();</span><br><span class="line">		m_workqueue.pop_front();</span><br><span class="line">		m_queuelocker.unlock();</span><br><span class="line">		<span class="keyword">if</span> (!request) &#123;</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		request-&gt;process();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>在C++程序中使用pthread_create函数时，该函数 的第3个参数必须指向一个静态函数。而要在一个静态函数中使用类的 动态成员（包括成员函数和成员变量），则只能通过如下两种方式来 实现：</p>
<ul>
<li>通过类的静态对象来调用。比如单体模式中，静态函数可以通 过类的全局唯一实例来访问动态成员函数。</li>
<li>将类的对象作为参数传递给该静态函数，然后在静态函数中引 用这个对象，并调用其动态方法。</li>
<li>代码清单15-3使用的是第2种方式：将线程参数设置为this指针， 然后在worker函数中获取该指针并调用其动态方法run。</li>
</ul>
<h4 id="15-6-用线程池实现的简单Web服务器"><a href="#15-6-用线程池实现的简单Web服务器" class="headerlink" title="15.6 用线程池实现的简单Web服务器"></a>15.6 用线程池实现的简单Web服务器</h4><p>在8.6节中，我们曾使用有限状态机实现过一个非常简单的解析 HTTP请求的服务器。下面我们将利用前面介绍的线程池来重新实现一 个并发的Web服务器。</p>
<h5 id="15-6-1-http-conn类"><a href="#15-6-1-http-conn类" class="headerlink" title="15.6.1 http_conn类"></a>15.6.1 http_conn类</h5><p>首先，我们需要准备线程池的模板参数类，用以封装对逻辑任务 的处理。这个类是http_conn，代码清单15-4是其头文件 （http_conn.h），代码清单15-5是其实现文件（http_conn.cpp）。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HTTPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HTTPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">http_conn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*文件名的最大长度*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> FILENAME_LEN = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*读缓冲区的大小*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> READ_BUFFER_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*写缓冲区的大小*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WRITE_BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*HTTP请求方法，但我们仅支持GET*/</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">METHOD</span> &#123;</span> GET = <span class="number">0</span>,</span><br><span class="line">		          POST,</span><br><span class="line">		          HEAD,</span><br><span class="line">		          PUT,</span><br><span class="line">		          DELETE,</span><br><span class="line">		          TRACE,</span><br><span class="line">		          OPTIONS,</span><br><span class="line">		          CONNECT,</span><br><span class="line">		          PATCH &#125;;</span><br><span class="line">	<span class="comment">/*解析客户请求时，主状态机所处的状态（回忆第8章）*/</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="number">0</span>,</span><br><span class="line">		               CHECK_STATE_HEADER,</span><br><span class="line">		               CHECK_STATE_CONTENT &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*服务器处理HTTP请求的可能结果*/</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">HTTP_CODE</span> &#123;</span> NO_REQUEST,</span><br><span class="line">		             GET_REQUEST,</span><br><span class="line">		             BAD_REQUEST,</span><br><span class="line">		             NO_RESOURCE,</span><br><span class="line">		             FORBIDDEN_REQUEST,</span><br><span class="line">		             FILE_REQUEST,</span><br><span class="line">		             INTERNAL_ERROR,</span><br><span class="line">		             CLOSED_CONNECTION &#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*行的读取状态*/</span></span><br><span class="line">	<span class="class"><span class="keyword">enum</span> <span class="title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="number">0</span>,</span><br><span class="line">		               LINE_BAD,</span><br><span class="line">		               LINE_OPEN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	http_conn() = <span class="keyword">default</span>;</span><br><span class="line">	~http_conn() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*初始化新接受的连接*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in&amp; addr)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*关闭连接*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">close_conn</span><span class="params">(<span class="keyword">bool</span> real_close = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*处理客户请求*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*非阻塞读操作*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*非阻塞写操作*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*初始化连接*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*解析HTTP请求*/</span></span><br><span class="line">	<span class="function">HTTP_CODE <span class="title">process_read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*填充HTTP应答*/</span></span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">process_write</span><span class="params">(HTTP_CODE ret)</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*下面这一组函数被process_read调用以分析HTTP请求*/</span></span><br><span class="line">	<span class="function">HTTP_CODE <span class="title">parse_request_line</span><span class="params">(<span class="keyword">char</span> *text)</span></span>;</span><br><span class="line">	<span class="function">HTTP_CODE <span class="title">parse_headers</span><span class="params">(<span class="keyword">char</span> *text)</span></span>;</span><br><span class="line">	<span class="function">HTTP_CODE <span class="title">parse_content</span><span class="params">(<span class="keyword">char</span> *text)</span></span>;</span><br><span class="line">	<span class="function">HTTP_CODE <span class="title">do_request</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">char</span> *<span class="title">get_line</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_read_buf + m_start_line; &#125;</span><br><span class="line">	<span class="function">LINE_STATUS <span class="title">parse_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*下面这一组函数被process_write调用以填充HTTP应答*/</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">unmap</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">add_response</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">add_content</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *content)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">add_status_line</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span> *title)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">add_headers</span><span class="params">(<span class="keyword">int</span> content_length)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">add_content_length</span><span class="params">(<span class="keyword">int</span> content_length)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">add_linger</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">add_blank_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">/*所有socket上的事件都被注册到同一个epoll内核事件表中，所以将epoll文件描述符设置为静态的*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_epollfd;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*统计用户数量*/</span></span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> m_user_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">/*该HTTP连接的socket和对方的socket地址*/</span></span><br><span class="line">	<span class="keyword">int</span> m_sockfd&#123;&#125;;</span><br><span class="line">	sockaddr_in m_address&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*读缓冲区*/</span></span><br><span class="line">	<span class="keyword">char</span> m_read_buf[READ_BUFFER_SIZE]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*标识读缓冲中已经读入的客户数据的最后一个字节的下一个位置*/</span></span><br><span class="line">	<span class="keyword">int</span> m_read_idx&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*当前正在分析的字符在读缓冲区中的位置*/</span></span><br><span class="line">	<span class="keyword">int</span> m_checked_idx&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*当前正在解析的行的起始位置*/</span></span><br><span class="line">	<span class="keyword">int</span> m_start_line&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*写缓冲区*/</span></span><br><span class="line">	<span class="keyword">char</span> m_write_buf[WRITE_BUFFER_SIZE]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*写缓冲区中待发送的字节数*/</span></span><br><span class="line">	<span class="keyword">int</span> m_write_idx&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*主状态机当前所处的状态*/</span></span><br><span class="line">	CHECK_STATE m_check_state;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*请求方法*/</span></span><br><span class="line">	METHOD m_method;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*客户请求的目标文件的完整路径，其内容等于doc_root+m_url，doc_root是网站根目录*/</span></span><br><span class="line">	<span class="keyword">char</span> m_real_file[FILENAME_LEN]&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*客户请求的目标文件的文件名*/</span></span><br><span class="line">	<span class="keyword">char</span> *m_url&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*HTTP协议版本号，我们仅支持HTTP/1.1*/</span></span><br><span class="line">	<span class="keyword">char</span> *m_version&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*主机名*/</span></span><br><span class="line">	<span class="keyword">char</span> *m_host&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*HTTP请求的消息体的长度*/</span></span><br><span class="line">	<span class="keyword">int</span> m_content_length&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*HTTP请求是否要求保持连接*/</span></span><br><span class="line">	<span class="keyword">bool</span> m_linger&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*客户请求的目标文件被mmap到内存中的起始位置*/</span></span><br><span class="line">	<span class="keyword">char</span> *m_file_address&#123;&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*目标文件的状态。通过它我们可以判断文件是否存在、是否为目录、是否可读，并获</span></span><br><span class="line"><span class="comment">取文件大小等信息*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">m_file_stat</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*我们将采用writev来执行写操作，所以定义下面两个成员，其中m_iv_count表示</span></span><br><span class="line"><span class="comment">被写内存块的数量*/</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">m_iv</span>[2]&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> m_iv_count&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="15-6-2-http-conn实现"><a href="#15-6-2-http-conn实现" class="headerlink" title="15.6.2 http_conn实现"></a>15.6.2 http_conn实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../include/http_conn.h&quot;</span></span></span><br><span class="line"><span class="comment">/*定义HTTP响应的一些状态信息*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ok_200_title = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to satisfy.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_403_form = <span class="string">&quot;You do not have permission to get file from this server.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_500_form = <span class="string">&quot;There was an unusual problem serving the requested file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*网站的根目录*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *doc_root = <span class="string">&quot;/home/sen/html/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过fcntl函数通来将一个文件描述符设置为非阻塞的</span></span><br><span class="line"><span class="comment"> * 类似于listenfd = socket(AF_INET, SOCK_NONBLOCK | SOCK_STREAM, 0);</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line">	<span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">	fcntl(fd, F_SETFL, new_option);</span><br><span class="line">	<span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册 POLLIN(数据可读) EPOLLET(高效EPOLL) EPOLLRDHUB(TCP链接被对方关闭)</span></span><br><span class="line"><span class="comment"> * oneshot = true , 操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次, 除非重置</span></span><br><span class="line"><span class="comment"> * EPOLLONESHOT标志 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot)</span> </span>&#123;</span><br><span class="line">	epoll_event event&#123;&#125;;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line">	<span class="keyword">if</span> (one_shot) &#123;</span><br><span class="line">		event.events |= EPOLLONESHOT;</span><br><span class="line">	&#125;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">	setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用epoll_ctl 删除内核事件表, 并且关闭文件描述符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> ev)</span> </span>&#123;</span><br><span class="line">	epoll_event event&#123;&#125;;</span><br><span class="line">	event.data.fd = fd;</span><br><span class="line">	event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">	epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="keyword">bool</span> real_close)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (real_close &amp;&amp; (m_sockfd != <span class="number">-1</span>)) &#123;</span><br><span class="line">		removefd(m_epollfd, m_sockfd);</span><br><span class="line">		m_sockfd = <span class="number">-1</span>;</span><br><span class="line">		m_user_count--; <span class="comment">/*关闭一个连接时，将客户总量减1*/</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in &amp;addr)</span> </span>&#123;</span><br><span class="line">	m_sockfd = sockfd;</span><br><span class="line">	m_address = addr;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*如下两行是为了避免TIME_WAIT状态，仅用于调试，实际使用时应该去掉*/</span></span><br><span class="line">	<span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">	setsockopt(m_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line"></span><br><span class="line">	addfd(m_epollfd, sockfd, <span class="literal">true</span>);</span><br><span class="line">	m_user_count++;</span><br><span class="line">	init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* htp_coon 初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	m_check_state = CHECK_STATE_REQUESTLINE;</span><br><span class="line">	m_linger = <span class="literal">false</span>;</span><br><span class="line">	m_method = GET;</span><br><span class="line">	m_url = <span class="literal">nullptr</span>;</span><br><span class="line">	m_version = <span class="literal">nullptr</span>;</span><br><span class="line">	m_content_length = <span class="number">0</span>;</span><br><span class="line">	m_host = <span class="literal">nullptr</span>;</span><br><span class="line">	m_start_line = <span class="number">0</span>;</span><br><span class="line">	m_checked_idx = <span class="number">0</span>;</span><br><span class="line">	m_read_idx = <span class="number">0</span>;</span><br><span class="line">	m_write_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//  &#x27;\0&#x27;是字符串结束标志，不计入串长，但要占内存空间。</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 *  &#x27;\0&#x27;是一个ASCII控制字符，是转义字符。</span></span><br><span class="line"><span class="comment">	 *  意思是告诉编译器，这不是字符0，而是空字符。空字符\0对应的二进制为0000 0000，而数字0的二进制为0011 0000。</span></span><br><span class="line"><span class="comment">	 *  这里的话 可以使用 bzero代替</span></span><br><span class="line"><span class="comment">	 * */</span></span><br><span class="line">	<span class="built_in">memset</span>(m_read_buf, <span class="string">&#x27;\0&#x27;</span>, READ_BUFFER_SIZE);</span><br><span class="line">	<span class="built_in">memset</span>(m_write_buf, <span class="string">&#x27;\0&#x27;</span>, WRITE_BUFFER_SIZE);</span><br><span class="line">	<span class="built_in">memset</span>(m_real_file, <span class="string">&#x27;\0&#x27;</span>, FILENAME_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从状态机，其分析请参考8.6节，这里不再赘述*/</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">char</span> temp;</span><br><span class="line">	<span class="keyword">for</span> (; m_checked_idx &lt; m_read_idx; ++m_checked_idx) &#123;</span><br><span class="line">		temp = m_read_buf[m_checked_idx];</span><br><span class="line">		<span class="keyword">if</span> (temp == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((m_checked_idx + <span class="number">1</span>) == m_read_idx) &#123;</span><br><span class="line">				<span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_read_buf[m_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">				m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				<span class="keyword">return</span> LINE_OK;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> LINE_BAD;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> ((m_checked_idx &gt; <span class="number">1</span>) &amp;&amp; (m_read_buf[m_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)) &#123;</span><br><span class="line">				m_read_buf[m_checked_idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">				<span class="keyword">return</span> LINE_OK;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> LINE_BAD;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*循环读取客户数据，直到无数据可读或者对方关闭连接*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_read_idx &gt;= READ_BUFFER_SIZE) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_read_idx += bytes_read;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析HTTP请求行，获得请求方法、目标URL，以及HTTP版本号*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">	m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!m_url) &#123;</span><br><span class="line">		<span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">	&#125;</span><br><span class="line">	*m_url++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="keyword">char</span> *method = text;</span><br><span class="line">	<span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		m_method = GET;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">	&#125;</span><br><span class="line">	m_url += <span class="built_in">strspn</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">	m_version = <span class="built_in">strpbrk</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (!m_version) &#123;</span><br><span class="line">		<span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">	&#125;</span><br><span class="line">	*m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	m_version += <span class="built_in">strspn</span>(m_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">	<span class="keyword">if</span> (strcasecmp(m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (strncasecmp(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		m_url += <span class="number">7</span>;</span><br><span class="line">		m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">	&#125;</span><br><span class="line">	m_check_state = CHECK_STATE_HEADER;</span><br><span class="line">	<span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析HTTP请求的一个头部信息*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">	<span class="comment">/*遇到空行，表示头部字段解析完毕*/</span></span><br><span class="line">	<span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line">		<span class="comment">/*如果HTTP请求有消息体，则还需要读取m_content_length字节的消息体，状态机转移到CHECK_STATE_CONTENT状态*/</span></span><br><span class="line">		<span class="keyword">if</span> (m_content_length != <span class="number">0</span>) &#123;</span><br><span class="line">			m_check_state = CHECK_STATE_CONTENT;</span><br><span class="line">			<span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/*否则说明我们已经得到了一个完整的HTTP请求*/</span></span><br><span class="line">		<span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*处理Connection头部字段*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		text += <span class="number">11</span>;</span><br><span class="line">		text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">		<span class="keyword">if</span> (strcasecmp(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">			m_linger = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*处理Content-Length头部字段*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(text, <span class="string">&quot;Content-Length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		text += <span class="number">15</span>;</span><br><span class="line">		text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">		m_content_length = atol(text);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*处理Host头部字段*/</span></span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">		text += <span class="number">5</span>;</span><br><span class="line">		text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">		m_host = text;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;oop!unknow header%s\n&quot;</span>, text);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们没有真正解析HTTP请求的消息体，只是判断它是否被完整地读入了*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx)) &#123;</span><br><span class="line">		text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">		<span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主状态机。其分析请参考8.6节，这里不再赘述*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	LINE_STATUS line_status = LINE_OK;</span><br><span class="line">	HTTP_CODE ret = NO_REQUEST;</span><br><span class="line">	<span class="keyword">char</span> *text = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK))</span><br><span class="line">	       || ((line_status = parse_line()) == LINE_OK)) &#123;</span><br><span class="line">		text = get_line();</span><br><span class="line">		m_start_line = m_checked_idx;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;got 1 http line: %s\n&quot;</span>, text);</span><br><span class="line">		<span class="keyword">switch</span> (m_check_state) &#123;</span><br><span class="line">			<span class="keyword">case</span> CHECK_STATE_REQUESTLINE: &#123;</span><br><span class="line">				ret = parse_request_line(text);</span><br><span class="line">				<span class="keyword">if</span> (ret == BAD_REQUEST) &#123;</span><br><span class="line">					<span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> CHECK_STATE_HEADER: &#123;</span><br><span class="line">				ret = parse_headers(text);</span><br><span class="line">				<span class="keyword">if</span> (ret == BAD_REQUEST) &#123;</span><br><span class="line">					<span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">				&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == GET_REQUEST) &#123;</span><br><span class="line">					<span class="keyword">return</span> do_request();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">case</span> CHECK_STATE_CONTENT: &#123;</span><br><span class="line">				ret = parse_content(text);</span><br><span class="line">				<span class="keyword">if</span> (ret == GET_REQUEST) &#123;</span><br><span class="line">					<span class="keyword">return</span> do_request();</span><br><span class="line">				&#125;</span><br><span class="line">				line_status = LINE_OPEN;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">default</span>: &#123;</span><br><span class="line">				<span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性。如果目标文件存在、</span></span><br><span class="line"><span class="comment"> * 对所有用户可读，且不是目录，则使用mmap将其映射到内存地址m_file_address</span></span><br><span class="line"><span class="comment">处，并告诉调用者获取文件成功*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="built_in">strcpy</span>(m_real_file, doc_root);</span><br><span class="line">	<span class="keyword">int</span> len = <span class="built_in">strlen</span>(doc_root);</span><br><span class="line">	<span class="built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (stat(m_real_file, &amp;m_file_stat) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH)) &#123;</span><br><span class="line">		<span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (S_ISDIR(m_file_stat.st_mode)) &#123;</span><br><span class="line">		<span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">int</span> fd = open(m_real_file, O_RDONLY);</span><br><span class="line">	m_file_address = (<span class="keyword">char</span> *) mmap(<span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">	close(fd);</span><br><span class="line">	<span class="keyword">return</span> FILE_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对内存映射区执行munmap操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::unmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_file_address) &#123;</span><br><span class="line">		munmap(m_file_address, m_file_stat.st_size);</span><br><span class="line">		m_file_address = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写HTTP响应*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::write</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> bytes_have_send = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> bytes_to_send = m_write_idx;</span><br><span class="line">	<span class="keyword">if</span> (bytes_to_send == <span class="number">0</span>) &#123;</span><br><span class="line">		modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">		init();</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line">		<span class="keyword">if</span> (temp &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line">			<span class="comment">/*如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件。虽然在此期间，服务器无</span></span><br><span class="line"><span class="comment">法立即接收到同一客户的下一个请求，但这可以保证连接的完整性*/</span></span><br><span class="line">			<span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">				modfd(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			unmap();</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		bytes_to_send -= temp;</span><br><span class="line">		bytes_have_send += temp;</span><br><span class="line">		<span class="keyword">if</span> (bytes_to_send &lt;= bytes_have_send) &#123;</span><br><span class="line">			<span class="comment">/*发送HTTP响应成功，根据HTTP请求中的Connection字段决定是否立即关闭连接*/</span></span><br><span class="line">			unmap();</span><br><span class="line">			<span class="keyword">if</span> (m_linger) &#123;</span><br><span class="line">				init();</span><br><span class="line">				modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*往写缓冲中写入待发送的数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_response</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (m_write_idx &gt;= WRITE_BUFFER_SIZE) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	va_list arg_list;</span><br><span class="line">	va_start(arg_list, format);</span><br><span class="line">	<span class="keyword">int</span> len = vsnprintf(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx, format, arg_list);</span><br><span class="line">	<span class="keyword">if</span> (len &gt;= (WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx)) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	m_write_idx += len;</span><br><span class="line">	va_end(arg_list);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span> *title)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add_response(<span class="string">&quot;%s%d%s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line">	add_content_length(content_len);</span><br><span class="line">	add_linger();</span><br><span class="line">	add_blank_line();</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add_response(<span class="string">&quot;Content-Length:%d\r\n&quot;</span>, content_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add_response(<span class="string">&quot;Connection:%s\r\n&quot;</span>, (m_linger == <span class="literal">true</span>) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add_response(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *content)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> add_response(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据服务器处理HTTP请求的结果，决定返回给客户端的内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">switch</span> (ret) &#123;</span><br><span class="line">		<span class="keyword">case</span> INTERNAL_ERROR: &#123;</span><br><span class="line">			add_status_line(<span class="number">500</span>, error_500_title);</span><br><span class="line">			add_headers(<span class="built_in">strlen</span>(error_500_form));</span><br><span class="line">			<span class="keyword">if</span> (!add_content(error_500_form)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> BAD_REQUEST: &#123;</span><br><span class="line">			add_status_line(<span class="number">400</span>, error_400_title);</span><br><span class="line">			add_headers(<span class="built_in">strlen</span>(error_400_form));</span><br><span class="line">			<span class="keyword">if</span> (!add_content(error_400_form)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> NO_RESOURCE: &#123;</span><br><span class="line">			add_status_line(<span class="number">404</span>, error_404_title);</span><br><span class="line">			add_headers(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line">			<span class="keyword">if</span> (!add_content(error_404_form)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> FORBIDDEN_REQUEST: &#123;</span><br><span class="line">			add_status_line(<span class="number">403</span>, error_403_title);</span><br><span class="line">			add_headers(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line">			<span class="keyword">if</span> (!add_content(error_403_form)) &#123;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> FILE_REQUEST: &#123;</span><br><span class="line">			add_status_line(<span class="number">200</span>, ok_200_title);</span><br><span class="line">			<span class="keyword">if</span> (m_file_stat.st_size != <span class="number">0</span>) &#123;</span><br><span class="line">				add_headers(m_file_stat.st_size);</span><br><span class="line">				m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">				m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">				m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">				m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">				m_iv_count = <span class="number">2</span>;</span><br><span class="line">				<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">				<span class="keyword">const</span> <span class="keyword">char</span> *ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">				add_headers(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line">				<span class="keyword">if</span> (!add_content(ok_string)) &#123;</span><br><span class="line">					<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">default</span>: &#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">	m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">	m_iv_count = <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*由线程池中的工作线程调用，这是处理HTTP请求的入口函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	HTTP_CODE read_ret = process_read();</span><br><span class="line">	<span class="keyword">if</span> (read_ret == NO_REQUEST) &#123;</span><br><span class="line">		modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">bool</span> write_ret = process_write(read_ret);</span><br><span class="line">	<span class="keyword">if</span> (!write_ret) &#123;</span><br><span class="line">		close_conn();</span><br><span class="line">	&#125;</span><br><span class="line">	modfd(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="15-6-3-main-cpp"><a href="#15-6-3-main-cpp" class="headerlink" title="15.6.3 main.cpp"></a>15.6.3 main.cpp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FD 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line">	<span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">	sa.sa_handler = handler;</span><br><span class="line">	<span class="keyword">if</span> (restart) &#123;</span><br><span class="line">		sa.sa_flags |= SA_RESTART;</span><br><span class="line">	&#125;</span><br><span class="line">	sigfillset(&amp;sa.sa_mask);</span><br><span class="line">	assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_error</span><span class="params">(<span class="keyword">int</span> connfd, <span class="keyword">const</span> <span class="keyword">char</span> *info)</span> </span>&#123;</span><br><span class="line">	<span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">	send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">	close(connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line">	<span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line">	<span class="comment">/*忽略SIGPIPE信号*/</span></span><br><span class="line">	addsig(SIGPIPE, SIG_IGN);</span><br><span class="line">	<span class="comment">/*创建线程池*/</span></span><br><span class="line">	threadpool&lt;http_conn&gt; *pool = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		pool = <span class="keyword">new</span> threadpool&lt;http_conn&gt;;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">/*预先为每个可能的客户连接分配一个http_conn对象*/</span></span><br><span class="line">	<span class="keyword">auto</span> *users = <span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line">	assert(users);</span><br><span class="line">	<span class="keyword">int</span> user_count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">	assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">tmp</span> =</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">	setsockopt(listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">	bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">	address.sin_port = htons(port);</span><br><span class="line">	ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">	assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line">	ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">	assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line">	epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">	<span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">	assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">	addfd(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line">	http_conn::m_epollfd = epollfd;</span><br><span class="line">	<span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		<span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line">		<span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line">			<span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line">			<span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">			<span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line">				<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line">				<span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line">				<span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">				<span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD) &#123;</span><br><span class="line">					show_error(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line">					<span class="keyword">continue</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">/*初始化客户连接*/</span></span><br><span class="line">				users[connfd].init(connfd, client_address);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line">				<span class="comment">/*如果有异常，直接关闭客户连接*/</span></span><br><span class="line">				users[sockfd].close_conn();</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">				<span class="comment">/*根据读的结果，决定是将任务添加到线程池，还是关闭连接*/</span></span><br><span class="line">				<span class="keyword">if</span> (users[sockfd].read()) &#123;</span><br><span class="line">					pool-&gt;append(users + sockfd);</span><br><span class="line">				&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">					users[sockfd].close_conn();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line">				<span class="comment">/*根据写的结果，决定是否关闭连接*/</span></span><br><span class="line">				<span class="keyword">if</span> (!users[sockfd].write()) &#123;</span><br><span class="line">					users[sockfd].close_conn();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	close(epollfd);</span><br><span class="line">	close(listenfd);</span><br><span class="line">	<span class="keyword">delete</span>[] users;</span><br><span class="line">	<span class="keyword">delete</span> pool;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>



<h5 id="15-6-4-Cmakelists-txt"><a href="#15-6-4-Cmakelists-txt" class="headerlink" title="15.6.4 Cmakelists.txt"></a>15.6.4 Cmakelists.txt</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(http_server)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp http_connection/http_conn.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main Threads::Threads)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>目录结构:</p>
<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230311190929809.png" class="" title="image-20230311190929809"></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">okeyia</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://okeyia.github.io/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">http://okeyia.github.io/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://okeyia.github.io" target="_blank">okeyia</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/">服务器编程</a></div><div class="post_share"></div></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E4%B8%8E%E6%A3%80%E6%B5%8B/"><img class="next-cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303101636855.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">四 性能检测和优化</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/" title="一 TCP/IP协议详解"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091414085.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-12-09</div><div class="title">一 TCP/IP协议详解</div></div></a></div><div><a href="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/" title="二 高性能服务器框架"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303091404676.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-01-29</div><div class="title">二 高性能服务器框架</div></div></a></div><div><a href="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E4%B8%8E%E6%A3%80%E6%B5%8B/" title="四 性能检测和优化"><img class="cover" src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202303101636855.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-03-10</div><div class="title">四 性能检测和优化</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AF%87-%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B"><span class="toc-text">第三篇 高性能服务器编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC12%E7%AB%A0-%E9%AB%98%E6%80%A7%E8%83%BDI-O%E6%A1%86%E6%9E%B6%E5%BA%93Libevent"><span class="toc-text">第12章 高性能I&#x2F;O框架库Libevent</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-I-O%E6%A1%86%E6%9E%B6%E5%BA%93%E6%A6%82%E8%BF%B0"><span class="toc-text">12.1  I&#x2F;O框架库概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-Libevent%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-text">12.2 Libevent源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#12-2-1-%E4%B8%80%E4%B8%AA%E5%AE%9E%E4%BE%8B"><span class="toc-text">12.2.1 一个实例</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-2-2-%E6%BA%90%E4%BB%A3%E7%A0%81%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84"><span class="toc-text">12.2.2 源代码组织结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#12-2-3-event-%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-text">12.2.3 event 结构体</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC13%E7%AB%A0-%E5%A4%9A%E8%BF%9B%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">第13章 多进程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-fork%E7%B3%BB%E7%BB%9F"><span class="toc-text">13.1 fork系统</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-exec%E7%B3%BB%E5%88%97%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.2 exec系列系统调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-%E5%A4%84%E7%90%86%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B"><span class="toc-text">13.3 处理僵尸进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-%E7%AE%A1%E9%81%93"><span class="toc-text">13.4 管道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-5-%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">13.5 信号量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-5-1-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%8E%9F%E8%AF%AD"><span class="toc-text">13.5.1 信号量原语</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-5-2-semget"><span class="toc-text">13.5.2 semget</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-5-3-semop%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.5.3 semop系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-5-4-semctl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.5.4 semctl系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-5-5-%E7%89%B9%E6%AE%8A%E9%94%AE%E5%80%BCIPC-PRIVATE"><span class="toc-text">13.5.5 特殊键值IPC_PRIVATE</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-6-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-text">13.6 共享内存</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-6-1-shmget%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.6.1 shmget系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-6-2-shmat%E5%92%8Cshmdt%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.6.2 shmat和shmdt系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-6-3-shmctl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.6.3 shmctl系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-6-5-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98%E5%AE%9E%E4%BE%8B"><span class="toc-text">13.6.5 共享内存实例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-7-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97"><span class="toc-text">13.7 消息队列</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#13-7-1-msgget%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.7.1 msgget系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-7-2-msgsnd%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.7.2 msgsnd系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-7-3-msgrcv%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.7.3 msgrcv系统调用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#13-7-4-msgctl%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8"><span class="toc-text">13.7.4 msgctl系统调用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-8-IPC%E5%91%BD%E4%BB%A4"><span class="toc-text">13.8 IPC命令</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-9-%E5%9C%A8%E8%BF%9B%E7%A8%8B%E9%97%B4%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-text">13.9 在进程间传递文件描述符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC14%E7%AB%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="toc-text">第14章 多线程编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-Linux-%E7%BA%BF%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-text">14.1 Linux 线程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-1-%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B"><span class="toc-text">14.1.1 线程模型</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-1-2-Linux-%E7%BA%BF%E7%A8%8B%E5%BA%93"><span class="toc-text">14.1.2 Linux 线程库</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BB%93%E6%9D%9F%E7%BA%BF%E7%A8%8B"><span class="toc-text">14.2 创建线程和结束线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#14-2-1-pthread-create"><span class="toc-text">14.2.1 pthread_create</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-2-3-pthread-exit"><span class="toc-text">14.2.3 pthread_exit</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-2-4-pthread-join"><span class="toc-text">14.2.4 pthread_join</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-2-5-pthread-cancel"><span class="toc-text">14.2.5 pthread_cancel</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-%E7%BA%BF%E7%A8%8B%E5%B1%9E%E6%80%A7"><span class="toc-text">14.3 线程属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-POSIX%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-text">14.4 POSIX信号量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-%E4%BA%92%E6%96%A5%E9%94%81"><span class="toc-text">14.5 互斥锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#14-5-1-%E4%BA%92%E6%96%A5%E9%94%81%E5%9F%BA%E7%A1%80API"><span class="toc-text">14.5.1 互斥锁基础API</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-5-2-%E4%BA%92%E6%96%A5%E9%94%81%E5%B1%9E%E6%80%A7"><span class="toc-text">14.5.2 互斥锁属性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-5-3-%E6%AD%BB%E9%94%81%E4%B8%BE%E4%BE%8B"><span class="toc-text">14.5.3 死锁举例</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text">14.6 条件变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%9C%BA%E5%88%B6"><span class="toc-text">14.7 线程同步机制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-8-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%8E%AF%E5%A2%83"><span class="toc-text">14.8 多线程环境</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#14-8-1-%E5%8F%AF%E9%87%8D%E5%85%A5%E5%87%BD%E6%95%B0"><span class="toc-text">14.8.1 可重入函数</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-8-2-%E7%BA%BF%E7%A8%8B%E5%92%8C%E8%BF%9B%E7%A8%8B"><span class="toc-text">14.8.2 线程和进程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#14-8-3-%E7%BA%BF%E7%A8%8B%E5%92%8C%E4%BF%A1%E5%8F%B7"><span class="toc-text">14.8.3 线程和信号</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AC%AC15%E7%AB%A0-%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-text">第15章 进程池和线程池</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#15-1-%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%B1%A0%E6%A6%82%E8%BF%B0"><span class="toc-text">15.1 线程池和进程池概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-2-%E5%A4%84%E7%90%86%E5%A4%9A%E5%AE%A2%E6%88%B7"><span class="toc-text">15.2 处理多客户</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-3-%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%BC%82%E6%AD%A5%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-text">15.3 半同步&#x2F;半异步进程池实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-4-%E7%94%A8%E8%BF%9B%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95CGI%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">15.4 用进程池实现的简单CGI服务器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-5-%E5%8D%8A%E5%90%8C%E6%AD%A5-%E5%8D%8A%E5%8F%8D%E5%BA%94%E5%A0%86%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0"><span class="toc-text">15.5 半同步&#x2F;半反应堆线程池实现</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-6-%E7%94%A8%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95Web%E6%9C%8D%E5%8A%A1%E5%99%A8"><span class="toc-text">15.6 用线程池实现的简单Web服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#15-6-1-http-conn%E7%B1%BB"><span class="toc-text">15.6.1 http_conn类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-6-2-http-conn%E5%AE%9E%E7%8E%B0"><span class="toc-text">15.6.2 http_conn实现</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-6-3-main-cpp"><span class="toc-text">15.6.3 main.cpp</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#15-6-4-Cmakelists-txt"><span class="toc-text">15.6.4 Cmakelists.txt</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By okeyia</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"></div><span class="search-close-button"><i class="fas fa-times"></i></span></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>