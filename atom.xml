<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>okeyia</title>
  
  
  <link href="http://okeyia.github.io/atom.xml" rel="self"/>
  
  <link href="http://okeyia.github.io/"/>
  <updated>2023-02-27T07:37:24.729Z</updated>
  <id>http://okeyia.github.io/</id>
  
  <author>
    <name>okeyia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>现代 C++ 教程</title>
    <link href="http://okeyia.github.io/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/"/>
    <id>http://okeyia.github.io/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/</id>
    <published>2022-11-18T07:32:08.000Z</published>
    <updated>2023-02-27T07:37:24.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现代-C-教程"><a href="#现代-C-教程" class="headerlink" title="现代 C++ 教程"></a>现代 C++ 教程</h2><p><strong>现代 C++</strong> (本书中均指 C++11/14/17/20) 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。</p><h3 id="一-迈向现代C"><a href="#一-迈向现代C" class="headerlink" title="一 迈向现代C++"></a>一 迈向现代C++</h3><h4 id="1-1-被弃用的特性"><a href="#1-1-被弃用的特性" class="headerlink" title="1.1 被弃用的特性"></a>1.1 被弃用的特性</h4><p><strong>注意</strong>：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽 量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分 特性其实会『永久』保留。</p><ul><li>不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。 如 char *str = “hello world!”;    // 将出现弃用警告</li><li>auto_ptr 被弃用，应使用 unique_ptr。</li><li>特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 <code>&lt;ccomplex&gt;</code>与**<cstdalign>**  等</li></ul><h4 id="1-2-与C的兼容性"><a href="#1-2-与C的兼容性" class="headerlink" title="1.2 与C的兼容性"></a>1.2 与C的兼容性</h4><p>出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码，例如 Linux 系统调用。</p><p>从现在开始，你的脑子里应该树立『C++ 不是 C 的一个超集』这个观念。在编写 C++ 时，也应该尽可能 的避免使用诸如 void* 之类的程序风格。</p><p>而在不得不使用 C 时，应该注意使用 ==extern “C”== 这种特性， 将 C 语言的代码与 C++ 代码进行分离编译，再统一链接这种做法。</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118155902628.png" class="" title="image-20221118155902628"><p>标识: <code>-std=c++2a</code> 启用预先批准的部分C++ 特性</p><h3 id="二-语言可用性的强化"><a href="#二-语言可用性的强化" class="headerlink" title="二 语言可用性的强化"></a>二 语言可用性的强化</h3><p>当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都 是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及语言可用性，是 指那些发生在运行时之前的语言行为。</p><h4 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h4><h5 id="2-1-1-nullptr"><a href="#2-1-1-nullptr" class="headerlink" title="2.1.1 nullptr"></a>2.1.1 nullptr</h5><blockquote><p>在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东 西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义 为 0。但是C++ 不允许直接将 void * 隐式转换到其他类型。</p><p>但如果编译器尝试把 NULL 定义为 ((void*)0)， 那么在下面这句代码中： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ch = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p> 没有了 void * 隐式转换的 C++ 只好将 NULL 定义为 0。而这依然会产生新的问题，将 NULL 定义 成 0 将导致 C++ 中重载特性发生混乱。 <strong>那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直觉。</strong></p></blockquote><p>C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型 为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><p>下面的程序会判断 **NULL, nullptr, 0是否是同一种类型: **</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="keyword">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="built_in">std</span>::<span class="keyword">nullptr_t</span>&gt;::value)</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-constexpr"><a href="#2-1-2-constexpr" class="headerlink" title="2.1.2  constexpr"></a>2.1.2  constexpr</h5><blockquote><p>常量表达式：比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。</p></blockquote><p>C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这 个关键字明确的告诉编译器应该去验证 foo 在编译期就应该是一个常量表达式。</p><p>从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码在C++ 11 中编译不过, 因为含有分支, 改为以下代码可以编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h4><h5 id="2-2-1-if-switch-变量声明强化"><a href="#2-2-1-if-switch-变量声明强化" class="headerlink" title="2.2.1 if/switch 变量声明强化"></a>2.2.1 if/switch 变量声明强化</h5><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终<strong>没有办法在 if 和 switch 语句中声明一个临时的变量。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 c++17 之前</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>);</span><br><span class="line">itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和Go 语言有点像</span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-初始化列表"><a href="#2-2-2-初始化列表" class="headerlink" title="2.2.2 初始化列表"></a>2.2.2 初始化列表</h5><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。这就为类对象的初始化与普通数组和 POD(Plain Old Data，即没有构造、析构和虚函 数的类或结构体) 的初始化方法提供了<strong>统一的桥梁</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicFoo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">MagicFoo(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">it != <span class="built_in">list</span>.end(); ++it)</span><br><span class="line">vec.push_back(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// after C++11</span></span><br><span class="line">MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = magicFoo.vec.begin();</span><br><span class="line">it != magicFoo.vec.end(); ++it)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。</p><h5 id="2-2-3-结构化绑定"><a href="#2-2-3-结构化绑定" class="headerlink" title="2.2.3 结构化绑定"></a>2.2.3 结构化绑定</h5><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。C++11 新 增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。</p><p>但是，C++11/14 并没有提供一种 ==简单的方法== 直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p><p>C++ 17进行了完善, 给出的结构化绑定可以让我们写出这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int, double, std::string&gt; f() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = f();   <span class="comment">// 简单的进行拆包</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-类型推导"><a href="#2-3-类型推导" class="headerlink" title="2.3 类型推导"></a>2.3 类型推导</h4><p>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这 使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p><h5 id="2-3-1-auto"><a href="#2-3-1-auto" class="headerlink" title="2.3.1 auto"></a>2.3.1 auto</h5><p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11 之前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = vec.cbegin(); it != vec.cend(); ++it)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// C++ 11, 避免代码臭长</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.begin(); it != <span class="built_in">list</span>.end(); ++it)</span><br></pre></td></tr></table></figure><p>从C++ 20 起, auto 还支持函数传参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(i, j) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-decltype"><a href="#2-3-2-decltype" class="headerlink" title="2.3.2 decltype"></a>2.3.2 decltype</h5><p>decltype 关键字是为了解决 auto 关键字只能对<strong>变量</strong>进行类型推导的缺陷而出现的。它的用法和 typeof 很相似：decltype(表达式)。</p><p>有时候，我们可能需要计算某个表达式的类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-3-3-尾返回类型推导"><a href="#2-3-3-尾返回类型推导" class="headerlink" title="2.3.3 尾返回类型推导"></a>2.3.3 尾返回类型推导</h5><p>typename 和 class 在模板参数列表中<strong>没有区别</strong>，在 typename 这个关键字出现之前，都 是使用 class 来定义模板参数的。但在模板中定义有==嵌套依赖类型的变量==时，需要用 ==typename消除歧义== 。</p><p>在介绍 auto 时，我们已经提过 auto 不能用于函数形参进行类型推导，那么 auto 能不能用于推导函数的返回类型呢？例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码很差，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 decltype 推导 x+y 的类型，写出这样的代码：</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) add(T x, U y)</span><br></pre></td></tr></table></figure><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定 义。</p><p>C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键 字将返回类型后置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add2(T x, U y) -&gt; decltype(x+y)&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  C++14 开始是可以直接让普通函数具备返回值推导, 直接写成</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-decltype-auto"><a href="#2-3-4-decltype-auto" class="headerlink" title="2.3.4 decltype(auto)"></a>2.3.4 decltype(auto)</h5><p>decltype(auto) 是 C++14 开始提供的一个略微复杂的用法。</p><p>简单来说，decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的 指定 decltype 的参数表达式。</p><p>学完语言运行时强化  再回头看</p><h4 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h4><h5 id="2-4-1-if-constexpr"><a href="#2-4-1-if-constexpr" class="headerlink" title="2.4.1 if constexpr"></a>2.4.1 if constexpr</h5><p>C++11 引入了 constexpr 关键字，它将表达式或函数编译为常量结果。</p><p>一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断， 岂不是能让程序效率更高？</p><p>C++17 将 constexpr 这个关键字引入到 if 语句中，<strong>允许在代码中声明常量表达式的判断条件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在编译时，实际代码就会表现为如下：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-2-区间for循环"><a href="#2-4-2-区间for循环" class="headerlink" title="2.4.2 区间for循环"></a>2.4.2 区间for循环</h5><p>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">element += <span class="number">1</span>; <span class="comment">// writeable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h4><p>模板的哲学在于将一切能够在编译期处理的问题丢到<strong>编译期</strong>进行处理，仅在运行时处理那些最核心的动 态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</p><h5 id="2-5-1-外部模板"><a href="#2-5-1-外部模板" class="headerlink" title="2.5.1 外部模板"></a>2.5.1 外部模板</h5><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中 编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。 并且，我们没有办法通知编译器不要触发模板的实例化。 </p><p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能 够显式的通知编译器何时进行模板的实例化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>; <span class="comment">// 强行实例化 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure><h5 id="2-5-2-类型别名模板"><a href="#2-5-2-类型别名模板" class="headerlink" title="2.5.2 类型别名模板"></a>2.5.2 类型别名模板</h5><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的</strong>。在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一 个新的名称。因为，模板不是类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T dark;</span><br><span class="line">U magic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法, 因为模板不是类型, 所以使用typedef 不能定义新的名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MagicType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; FakeDarkMagic;</span><br></pre></td></tr></table></figure><p>C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，</span></span><br><span class="line"><span class="comment">// 但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*process)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">using</span> NewProcess = <span class="keyword">int</span>(*)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TrueDarkMagic&lt;<span class="keyword">bool</span>&gt; you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-3-变长参数模板"><a href="#2-5-3-变长参数模板" class="headerlink" title="2.5.3 变长参数模板"></a>2.5.3 变长参数模板</h5><p>在 C++11 之前，无论是类模板 还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数, 所以也可以是0个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;</span><span class="keyword">int</span>,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; darkMagic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;</span>&gt; nothing;</span><br></pre></td></tr></table></figure><p>定义了变长的模板参数，如何对==参数解包==呢？</p><p>首先，我们可以使用 <strong>sizeof…</strong> 来计算参数的个数，：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理 手法：</p><ol><li><p>递归模板函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，</span></span><br><span class="line"><span class="comment">// 进而达到递归遍历所有模板参数的目的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">printf1(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">printf1(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变参模板展开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 printf 的编写</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t0 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化列表展开</p><p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">(<span class="keyword">void</span>) <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行</span></span><br><span class="line"><span class="comment">//前面的 lambda 表达式，完成参数的输出。为了避免编译器警告，我们可以将 std::initializer_list</span></span><br><span class="line"><span class="comment">//显式的转为 void。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h5 id="2-5-4-非类型模板参数推导"><a href="#2-5-4-非类型模板参数推导" class="headerlink" title="2.5.4 非类型模板参数推导"></a>2.5.4 非类型模板参数推导</h5><p>前面我们主要提及的是模板参数的一种形式：类型模板参数。<strong>其中模板的参数 T 和 U 为具体的类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但还有一种常见模板参数形式可以<strong>让不同字面量成为模板参数</strong>，即非类型模板参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> BufSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">buffer_t</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T data[BufSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">buffer_t</span>&lt;<span class="keyword">int</span>, <span class="number">100</span>&gt; buf; <span class="comment">// 100 作为模板参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 C++11 引入了类型推导这 一特性后，我们会很自然的问，既然此处的模板参数以具体的字面量进行传递，能否让编译器辅助我们 进行类型推导，通过使用占位符 auto 从而不再需要明确指明类型？</p><p>C++17 引入了这一特性， 我们的确可以 auto 关键字，让编译器辅助完成具体类型的推导，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">foo&lt;<span class="number">10</span>&gt;(); <span class="comment">// value 被推导为 int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-面向对象"><a href="#2-6-面向对象" class="headerlink" title="2.6 面向对象"></a>2.6 面向对象</h4><h5 id="2-6-1-委托构造"><a href="#2-6-1-委托构造" class="headerlink" title="2.6.1 委托构造"></a>2.6.1 委托构造</h5><p>C++11 引入了委托构造的概念，这使得<strong>构造函数可以在同一个类中一个构造函数调用另一个构造函数</strong>，从而达到简化代码的目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value1;</span><br><span class="line"><span class="keyword">int</span> value2;</span><br><span class="line">Base() &#123;</span><br><span class="line">value1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> value) : Base() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">value2 = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-2-继承构造"><a href="#2-6-2-继承构造" class="headerlink" title="2.6.2 继承构造"></a>2.6.2 继承构造</h5><p>在传统 C++ 中，<strong>构造函数如果需要继承</strong>是需要将参数一一传递的，这将导致效率低下。C++11 利 用关键字 using 引入了继承构造函数的概念：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value1;</span><br><span class="line"><span class="keyword">int</span> value2;</span><br><span class="line">Base() &#123;</span><br><span class="line">value1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> value) : Base() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">value2 = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-3-显式虚函数重载"><a href="#2-6-3-显式虚函数重载" class="headerlink" title="2.6.3 显式虚函数重载"></a>2.6.3 显式虚函数重载</h5><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SubClass::foo 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。</p><p>另 一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成 为了一个普通的类方法，这将造成灾难性的后果。</p><p>C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生。</p><ul><li><p>override 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass1</span> <span class="keyword">final</span>:</span> Base &#123;</span><br><span class="line">&#125;; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass2</span> :</span> SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass3</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-6-4-显式禁用默认函数"><a href="#2-6-4-显式禁用默认函数" class="headerlink" title="2.6.4 显式禁用默认函数"></a>2.6.4 显式禁用默认函数</h5><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成<strong>默认构造函数、复制构造、赋值 算符以及析构函数</strong>。另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。当程序员有需要时， 可以重载这部分函数。</p><p>这就引发了一些需求：无法精确控制默认函数的生成行为。例如禁止类的拷贝时，必须将复制构造 函数与赋值算符声明为 private。尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p><p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Magic() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">Magic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">Magic(<span class="keyword">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-5-强类型枚举"><a href="#2-6-5-强类型枚举" class="headerlink" title="2.6.5 强类型枚举"></a>2.6.5 强类型枚举</h5><p>在传统 C++ 中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类 型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型 的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p><p>C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3 = <span class="number">100</span>,</span><br><span class="line">value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数 字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那 么可以进行比较。</p><p>如果我们希望获得枚举值的时候， 将必须显式的进行类型转换，不过我们可以通过重载 &lt;&lt; 这个算符来 进行输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_enum&lt;T&gt;::value,</span><br><span class="line"><span class="built_in">std</span>::ostream&gt;::type&amp; stream, <span class="keyword">const</span> T&amp; e)&#123;</span><br><span class="line"><span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&#123;</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3 = <span class="number">100</span>,</span><br><span class="line">value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (new_enum::value3 == new_enum::value4)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;new_enum::value3 == new_enum::value4&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; new_enum::value3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-语言运行期的强化"><a href="#三-语言运行期的强化" class="headerlink" title="三 语言运行期的强化"></a>三 语言运行期的强化</h3><h4 id="3-1-Lambda-表达式"><a href="#3-1-Lambda-表达式" class="headerlink" title="3.1 Lambda 表达式"></a>3.1 Lambda 表达式</h4><p>Lambda 表达式，实际上就是提供了一个类 似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用 的。</p><p>Lambda 表达式的基本语法如下：</p><p><code>[捕获列表](参数列表)</code> mutable(可选) 异常属性 -&gt; 返回类型 { // 函数体 }</p><p> 所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下<strong>是不能够使用函数体外部的变量</strong>的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列 表也分为以下几种：</p><ol><li><p>值捕获 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被<strong>创建时拷贝</strong>，而非调用时才拷贝。</p></li><li><p>引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化。</p></li><li><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时 候可以在捕获列表中写一个 &amp; 或 = 向编译器声明采用引用捕获或者值捕获.</p><p>捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表 </li><li>[name1, name2, . . . ] 捕获一系列变量 </li><li>[&amp;] 引用捕获, 让编译器自行推导引用列表 </li><li> [=] 值捕获, 让编译器自行推导值捕获列表</li></ul></li><li><p>表达式捕获</p><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的<strong>均为左值</strong>，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被 声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> important = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = <span class="built_in">std</span>::move(important)](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h4><h5 id="3-2-1-std-function"><a href="#3-2-1-std-function" class="headerlink" title="3.2.1 std::function"></a>3.2.1 std::function</h5><p>Lambda 表达式的本质是一个和<strong>函数对象类型相似的类类型</strong>（称为闭包类型）的对象（称为闭包对象），当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void(int), 参考https://stackoverflow.com/questions/34437557/difference-between-voidint-void-int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo = <span class="keyword">void</span>(<span class="keyword">int</span>); <span class="comment">// 定义 函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于 </span></span><br><span class="line"><span class="comment">//void functional(void(*f)(int) ) &#123; </span></span><br><span class="line"><span class="comment">//f(1); // 通过函数指针调用函数</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">functional(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    </span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用，而另一种 则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，<strong>将能够被调用的对象的类型，统一称之为可调用类型</strong>。而这种类型，便是通过 std::function 引入的。</p><p>C++11 std::function 是一种通用、多态的函数封装，<strong>它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作</strong>，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数 指针的调用不是类型安全的），换句话说，就是函数的容器。</p><p>当我们有了函数的容器之后便能够更加方便 的将函数、函数指针作为对象进行处理。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func = foo;</span><br><span class="line"><span class="keyword">int</span> important = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func2 = [&amp;](<span class="keyword">int</span> value) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func2(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-std-bind-和-std-placeholder"><a href="#3-2-2-std-bind-和-std-placeholder" class="headerlink" title="3.2.2 std::bind 和 std::placeholder"></a>3.2.2 std::bind 和 std::placeholder</h5><p>std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以<strong>将部分调用参数提前绑定到函数身上</strong>成为一 个新的对象，然后在参数齐全后，完成调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将参数 1,2 绑定到函数 foo 上，</span></span><br><span class="line"><span class="comment">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line"><span class="keyword">auto</span> bindFoo = <span class="built_in">std</span>::bind(foo, <span class="built_in">std</span>::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">bindFoo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h4><p>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大 量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能。</p><h5 id="3-3-1-左值、右值、纯右值、将亡值"><a href="#3-3-1-左值、右值、纯右值、将亡值" class="headerlink" title="3.3.1 左值、右值、纯右值、将亡值"></a>3.3.1 左值、右值、纯右值、将亡值</h5><p><strong>左值</strong> (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋 值表达式）后依然存在的持久对象。</p><p><strong>右值</strong> (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。</p><p>也有人将左值翻译为locator value, 意思是可以在内存中找到地址。右值为read value。而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p><p><strong>纯右值</strong> (prvalue, pure rvalue)，纯粹的右值，要么是<strong>纯粹的字面量</strong>，例如 10, true；要么是<strong>求值结果相当于字面量或匿名临时对象</strong>，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。==需要注意的是==，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 正确，&quot;01234&quot; 类型为 const char [6]，因此是左值</span></span><br><span class="line">const char (&amp;left)[6] = &quot;01234&quot;;</span><br><span class="line"><span class="comment">// 断言正确，确实是 const char [6] 类型，注意 decltype(expr) 在 expr 是左值</span></span><br><span class="line"><span class="comment">// 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="string">&quot;01234&quot;</span>), <span class="keyword">const</span> <span class="keyword">char</span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 错误，&quot;01234&quot; 是左值，不可被右值引用</span></span><br><span class="line"><span class="comment">// const char (&amp;&amp;right)[6] = &quot;01234&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将亡值</strong> (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中，纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = foo();</span><br></pre></td></tr></table></figure><blockquote><p>在这样的代码中，就传统的理解而言，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，<strong>会将整个 temp 拷贝一份，然后把 temp 销毁</strong>，如果这个 temp 非常大，这将造成大量 额外的开销（这也就是传统 C++ 一直被诟病的问题）。</p><p>在最后一行中，v 是左值、foo() 返回的值就是 右值（也是纯右值）。但是，v 可以被别的变量捕获到，而 foo() 产生的那个返回值作为一个临时值，一 旦被 v 复制后，将立即被销毁，无法获取、也不能修改。</p><p>而将亡值就定义了这样一种行为：<strong>临时的值能够被识别、同时又能够被移动。</strong></p></blockquote><p>在 C++11 之后，编译器为我们做了一些工作，<strong>此处的左值 temp 会被进行此隐式右值转换</strong>，等价于 static_cast &amp;&amp;&gt;(temp)，进而此处的 v 会将 foo 局部返回的值进行移动。也就是 后面我们将会提到的移动语义。</p><h5 id="3-3-2-右值引用和左值引用"><a href="#3-3-2-右值引用和左值引用" class="headerlink" title="3.3.2 右值引用和左值引用"></a>3.3.2 右值引用和左值引用</h5><p><strong>要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。</strong>右值引用的声明让这个临时值的 生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p><p> C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> lv1 = <span class="string">&quot;string,&quot;</span>; <span class="comment">// lv1 是一个左值</span></span><br><span class="line"><span class="comment">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv1 = <span class="built_in">std</span>::move(lv1); <span class="comment">// 合法, std::move 可以将左值转移为右值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; lv2 = lv1 + lv1; <span class="comment">// 合法, 常量左值引用能够延长临时变量的生命周期</span></span><br><span class="line"><span class="comment">// lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">rv2 += <span class="string">&quot;Test&quot;</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,string,Test</span></span><br><span class="line">    </span><br><span class="line">reference(rv2); <span class="comment">// 输出左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。</p><h5 id="3-3-3-移动语义"><a href="#3-3-3-移动语义" class="headerlink" title="3.3.3 移动语义"></a>3.3.3 移动语义</h5><p>传统 C++ 通过<strong>拷贝构造函数和赋值操作符</strong>为类对象设计了<strong>拷贝/复制</strong>的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> *pointer;</span><br><span class="line"></span><br><span class="line">A() : pointer(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 构造&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A(A &amp;a) : pointer(<span class="keyword">new</span> <span class="keyword">int</span>(*a.pointer)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 拷贝&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">// 无意义的对象拷贝</span></span><br><span class="line">    </span><br><span class="line">A(A &amp;&amp;a) : pointer(a.pointer) &#123;</span><br><span class="line">a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 移动&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 析构&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止编译器优化</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="keyword">bool</span> test)</span> </span>&#123;</span><br><span class="line">A a, b;</span><br><span class="line"><span class="keyword">if</span> (test) <span class="keyword">return</span> a; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A obj = return_rvalue(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; obj.pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *obj.pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 运行结果</span><br><span class="line"></span><br><span class="line">构造 0x2353eb0</span><br><span class="line"> 构造 0x2354ee0</span><br><span class="line"> 移动 0x2354ee0</span><br><span class="line"> 析构 0</span><br><span class="line"> 析构 0x2353eb0</span><br><span class="line">cout obj:</span><br><span class="line">0x2354ee0</span><br><span class="line">1</span><br><span class="line"> 析构 0x2354ee0</span><br></pre></td></tr></table></figure><ol><li>首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出；</li><li><strong>函数返回后，产生一个将亡值</strong>，被 A 的移动构造（A(A&amp;&amp;)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。</li></ol><p>从而避免了无意义的拷贝构造，加强了性能。</p></blockquote><h5 id="3-3-4-完美转发"><a href="#3-3-4-完美转发" class="headerlink" title="3.3.4 完美转发"></a>3.3.4 完美转发</h5><p>前面我们提到了(3.3.2 小节)，<strong>一个声明的右值引用其实是一个左值</strong>。这就为我们进行参数转发（传递）造成了 问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 普通传参:&quot;</span>;</span><br><span class="line">reference(v); <span class="comment">// 始终调用 reference(int&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">pass(<span class="number">1</span>); <span class="comment">// 1 是右值, 但输出是左值</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">pass(l); <span class="comment">// l 是左值, 输出左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于 pass(1) 来说，虽然传递的是右值，但由于 <strong>v 是一个引用，所以同时也是左值</strong>。因此 reference(v) 会调用 reference(int&amp;)，输出『左值』。而对于 pass(l) 而言，l 是一个左值，为什么 会成功传递给 pass(T&amp;&amp;) 呢？</p><p>这是基于引用坍缩规则的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由 于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，既能左引 用，又能右引用。但是却遵循如下规则：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118225944987.png" class="" title="image-20221118225944987"><p>准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为 右引用类型。这才使得 v 作为左值的成功传递。</p><p><strong>完美转发就是基于上述规律产生的。</strong>所谓完美转发，就是为了让我们在传递参数的时候，保持原来的参数类型（左引用保持左引用，右引用保持右引用）。为了解决这个问题，我们应该使用 std::forward 来进行参数的转发（传递）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值引用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值引用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 普通传参: &quot;</span>;</span><br><span class="line">reference(v);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; std::move 传参: &quot;</span>;</span><br><span class="line">reference(<span class="built_in">std</span>::move(v));</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; std::forward 传参: &quot;</span>;</span><br><span class="line">reference(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;</span>;</span><br><span class="line">reference(<span class="keyword">static_cast</span>&lt;T &amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">pass(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">    pass(v);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，所以 std::move 总会接受到一个左值，从而转发调用了 reference(int&amp;&amp;) 输出右值引用。 </p><p>唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发 (传递) 了函数的实参给了内部调用 的其他函数。</p><p> std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值， std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看，std::forward(v) 和 static_cast(v) 是完全一样的。</p></blockquote><h3 id="四-容器"><a href="#四-容器" class="headerlink" title="四 容器"></a>四 容器</h3><h4 id="4-1-线性容器"><a href="#4-1-线性容器" class="headerlink" title="4.1 线性容器"></a>4.1 线性容器</h4><h5 id="4-1-1-std-array"><a href="#4-1-1-std-array" class="headerlink" title="4.1.1 std::array"></a>4.1.1 std::array</h5><ol><li><p>为什么要引入 std::array 而不是直接使用 std::vector？ </p><blockquote><p>与 std::vector 不同，std::array 对象的大小是固定的，<strong>如果容器大小是固定的，那么可以优先考虑使用 std::array 容器</strong>。另外由于 std::vector 是自动扩容的，当存入大量的 数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候就需要手动 运行 shrink_to_fit() 释放这部分内存。</p></blockquote></li><li><p>已经有了传统数组，为什么要用 std::array?</p><blockquote><p>使用 std::array 能够让代码变得更加 ‘‘现代化’’，而且封装了一些操作函 数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort。</p></blockquote></li></ol><h5 id="4-1-2-std-forward-list"><a href="#4-1-2-std-forward-list" class="headerlink" title="4.1.2 std::forward_list"></a>4.1.2 std::forward_list</h5><p>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进 行介绍了。 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一 个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</p><h4 id="4-2-无序容器"><a href="#4-2-无序容器" class="headerlink" title="4.2 无序容器"></a>4.2 无序容器</h4><p>传统 C++ 中的<strong>有序容器 std::map/std::set</strong>，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 &lt; 操作符比较元素大小并判断元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 &lt; 操作符的顺序来逐个遍历。</p><p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。</p><p>C++11 引入了的两组无序容器分别是：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。</p><h4 id="4-3-元组"><a href="#4-3-元组" class="headerlink" title="4.3 元组"></a>4.3 元组</h4><p>关于元组的使用有三个核心的函数： </p><ol><li>std::make_tuple: 构造元组 </li><li>std::get: 获得元组某个位置的值</li><li>std::tie: 元组拆包</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">3.8</span>, ’A’, <span class="string">&quot; 张三&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">2.9</span>, ’C’, <span class="string">&quot; 李四&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1.7</span>, ’D’, <span class="string">&quot; 王五&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">0.0</span>, ’D’, <span class="string">&quot;null&quot;</span>);</span><br><span class="line"><span class="comment">// 如果只写 0 会出现推断错误, 编译失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> student = get_student(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: 0, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(student) &lt;&lt; ’\n’;</span><br><span class="line"><span class="keyword">double</span> gpa;</span><br><span class="line"><span class="keyword">char</span> grade;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="comment">// 元组进行拆包</span></span><br><span class="line"><span class="built_in">std</span>::tie(gpa, grade, name) = get_student(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: 1, &quot;</span> &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; gpa &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名: &quot;</span> &lt;&lt; name &lt;&lt; ’\n’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::get 除了使用常量获取元组对象外，C++14 增加了<strong>使用类型来获取元组中的对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;std::string, double, double, int&gt; t(&quot;123&quot;, 4.5, 6.7, 8);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">double</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 非法, 引发编译期错误</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">3</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="4-3-1-运行期索引"><a href="#4-3-1-运行期索引" class="headerlink" title="4.3.1 运行期索引"></a>4.3.1 运行期索引</h5><p>如果你仔细思考一下可能就会发现上面代码的问题，std::get&lt;&gt; 依赖一个编译期的常量，所以下面 的方式是不合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::get&lt;index&gt;(t);</span><br></pre></td></tr></table></figure><p>那么要怎么处理？答案是，使用 std::variant&lt;&gt;（C++ 17 引入），提供给 variant&lt;&gt; 的类型模板参数可以让一个 variant&lt;&gt; 从而容纳提供的几种类型的变量:</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118232359960.png" class="" title="image-20221118232359960"><p>这样就可以:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tuple_index(t, i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-元组合并与遍历"><a href="#4-3-2-元组合并与遍历" class="headerlink" title="4.3.2 元组合并与遍历"></a>4.3.2 元组合并与遍历</h5><p>还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;std::string, double, double, int&gt; t(&quot;123&quot;, 4.5, 6.7, 8);</span><br><span class="line"><span class="keyword">auto</span> new_tuple = <span class="built_in">std</span>::tuple_cat(get_student(<span class="number">1</span>), <span class="built_in">std</span>::move(t));</span><br></pre></td></tr></table></figure><h3 id="五-智能指针"><a href="#五-智能指针" class="headerlink" title="五 智能指针"></a>五 智能指针</h3><h4 id="5-1-RALL与引用计数"><a href="#5-1-RALL与引用计数" class="headerlink" title="5.1 RALL与引用计数"></a>5.1 RALL与引用计数</h4><p>引用计数这种计数是为了防止内存泄 露而产生的。基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那 么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减 为零时，就自动删除指向的堆内存。</p><p><strong>『记得』手动释放资源，总不是最佳实践。</strong>因为我们很有可能就忘记了去释放资源 而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在 离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。</p><p>而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序 员不再需要关心手动释放内存。这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr， 使用它们需要包含头文件 。</p><h4 id="5-2-std-shared-ptr"><a href="#5-2-std-shared-ptr" class="headerlink" title="5.2 std::shared_ptr"></a>5.2 std::shared_ptr</h4><p>std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当<strong>引用计数变为零</strong>的时候就会将对象自动删除。</p><p>但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。 </p><p>std::make_shared 就能够用来消除显式的使用 new，所以 std::make_shared 会分配创建传入参 数中的对象，并返回这个对象类型的 std::shared_ptr 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; i)</span> </span>&#123;</span><br><span class="line">(*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// auto pointer = new int(10); // illegal, no direct assignment</span></span><br><span class="line"><span class="comment">// Constructed a std::shared_ptr</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> pointer = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">foo(pointer);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// The shared_ptr will be destructed before leaving the scope</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::shared_ptr 可以通过 <strong>get() 方法</strong>来获取原始指针，通过 <strong>reset()</strong> 来减少一个引用计数，并 通过 <strong>use_count()</strong> 来查看一个对象的引用计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数 +1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = pointer.get(); <span class="comment">// 这样不会增加引用计数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">pointer2.reset();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reset pointer2:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="5-3-std-unique-ptr"><a href="#5-3-std-unique-ptr" class="headerlink" title="5.3 std::unique_ptr"></a>5.3 std::unique_ptr</h4><p>std::unique_ptr 是一种<strong>独占的智能指针</strong>，它禁止其他智能指针与其共享同一个对象，从而保证代 码的安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pointer = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_unique 从 C++14 引入</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pointer2 = pointer; <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是C++ 11 中没有实现make_unique, 据说是忘记了, 可以自己实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp; ...args )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;( <span class="keyword">new</span> T( <span class="built_in">std</span>::forward&lt;Args&gt;(args)... ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr。</p><h4 id="5-4-weak-ptr"><a href="#5-4-weak-ptr" class="headerlink" title="5.4 weak_ptr"></a>5.4 weak_ptr</h4><p>如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;B&gt; pointer;</span><br><span class="line"></span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;A&gt; pointer;</span><br><span class="line"></span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">std</span>::make_shared&lt;A&gt;();</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">std</span>::make_shared&lt;B&gt;();</span><br><span class="line">a-&gt;pointer = b;</span><br><span class="line">b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引 用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却只能造成这块区域的引用计数减一，这样 就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了 内存泄露，如图:</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119152443945.png" class="" title="image-20221119152443945"></blockquote><p>解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr 是一种弱引用（相比较 而言 std::shared_ptr 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的 释放流程如图 5.2 所示：<img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119152600314.png" class="" title="image-20221119152600314"></p><p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。 </p><p>*<em>std::weak_ptr 没有 * 运算符和 -&gt; 运算符*</em>，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true； 除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未 被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回 nullptr。</p><h3 id="六-正则表达式"><a href="#六-正则表达式" class="headerlink" title="六 正则表达式"></a>六 正则表达式</h3><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p><ul><li>检查一个串是否包含某种形式的子串；</li><li>将匹配的子串替换</li><li>从某个串中取出符合条件的子串。</li></ul><h4 id="6-1-正则表达式简介"><a href="#6-1-正则表达式简介" class="headerlink" title="6.1 正则表达式简介"></a>6.1 正则表达式简介</h4><h5 id="6-1-1-特殊字符"><a href="#6-1-1-特殊字符" class="headerlink" title="6.1.1 特殊字符"></a>6.1.1 特殊字符</h5><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153031490.png" class="" title="image-20221119153031490"><h5 id="6-1-2-限定符"><a href="#6-1-2-限定符" class="headerlink" title="6.1.2 限定符"></a>6.1.2 限定符</h5><p>限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153120714.png" class="" title="image-20221119153120714"><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153137416.png" class="" title="image-20221119153137416"><h4 id="6-2-std-regex-及其相关"><a href="#6-2-std-regex-及其相关" class="headerlink" title="6.2 std::regex 及其相关"></a>6.2 std::regex 及其相关</h4><p>对字符串内容进行匹配的最常见手段就是使用正则表达式。可惜在传统 C++ 中正则表达式一直没 有得到语言层面的支持，没有纳入标准库，而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时，使用正则表达式也是工业界最为成熟的普遍做法。</p><p><strong>C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex) 进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch（本质是 std::match_results 对象）。</strong></p><p>示例: </p><ul><li><code>[a-z]+\.txt</code>: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多 次，因此 [a-z]+ 能够匹配一个小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字 符，而 <code>\.</code> 则表示匹配字符 .，最后的 txt 表示严格匹配 txt 则三个字母。因此这个正则表达式的 所要匹配的内容就是由纯小写字母组成的文本文件。</li><li>std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是 传入 std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fnames[] = &#123;<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;a0.txt&quot;</span>, <span class="string">&quot;AAA.txt&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 在 C++ 中 \ 会被作为字符串内的转义符，</span></span><br><span class="line"><span class="comment">// 为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">txt_regex</span><span class="params">(<span class="string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">std</span>::regex_match(fname, txt_regex) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;现代-C-教程&quot;&gt;&lt;a href=&quot;#现代-C-教程&quot; class=&quot;headerlink&quot; title=&quot;现代 C++ 教程&quot;&gt;&lt;/a&gt;现代 C++ 教程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;现代 C++&lt;/strong&gt; (本书中均指 C++11/14/17/20)</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>现代化Cmake</title>
    <link href="http://okeyia.github.io/2022/11/06/Modern_CMake/"/>
    <id>http://okeyia.github.io/2022/11/06/Modern_CMake/</id>
    <published>2022-11-06T06:29:04.000Z</published>
    <updated>2022-11-06T15:12:38.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Modern-CMake"><a href="#Modern-CMake" class="headerlink" title="Modern CMake"></a>Modern CMake</h2><blockquote><p>现代的 CMake 是指 CMake 3.4+ ，甚至是 CMake 3.21+ ！ 它简洁、强大、优雅，所以你能够花费你的大部分时间在编写代码上，而不是在一个不可读、不可维护的 Make （或 CMake 2） 文件上浪费时间。 并且 CMake 3.11+ 的构建速度应该也会更加的快！！！</p></blockquote><h3 id="一-基础知识简介"><a href="#一-基础知识简介" class="headerlink" title="一 基础知识简介"></a>一 基础知识简介</h3><hr><h4 id="1-1-最低版本要求"><a href="#1-1-最低版本要求" class="headerlink" title="1.1 最低版本要求"></a>1.1 最低版本要求</h4><p>这是每个 <code>CMakeLists.txt</code> 都必须包含的第一行，默认小写</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br></pre></td></tr></table></figure><p><code>CMake</code> 的版本与它的特性（policies）相互关联，这意味着它也定义了 <code>CMake</code> 行为的变化。</p><h4 id="1-2-设置一个项目"><a href="#1-2-设置一个项目" class="headerlink" title="1.2 设置一个项目"></a>1.2 设置一个项目</h4><p>每一个顶层 CMakelists 文件都应该有下面这一行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(MyProject VERSION <span class="number">1.0</span></span><br><span class="line">                  DESCRIPTION <span class="string">&quot;Very nice project&quot;</span></span><br><span class="line">                  LANGUAGES CXX)</span><br></pre></td></tr></table></figure><p>项目名称是这里的第一个参数。所有的关键字参数都可选的。<code>VERSION</code> 设置了一系列变量，例如 <code>MyProject_VERSION</code> 和 <code>PROJECT_VERSION</code>。<code>DESCRIPTION</code>，对项目进行简单介绍。语言最好不写，英文c++中项目中，可能存在个别的C文件。</p><h4 id="1-3-生成可执行文件"><a href="#1-3-生成可执行文件" class="headerlink" title="1.3 生成可执行文件"></a>1.3 生成可执行文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(one two.cpp three.h)</span><br></pre></td></tr></table></figure><p><code>one</code> 既是生成的可执行文件的名称，也是创建的 <code>CMake</code> 目标(target)的名称。</p><p>紧接着的是源文件的列表，你想列多少个都可以。CMake 很聪明 ，它根据拓展名只编译源文件。</p><p>在大多数情况下，<strong>头文件将会被忽略</strong>；列出他们的唯一原因是为了让他们在 IDE 中被展示出来，目标文件在许多 IDE 中被显示为文件夹。</p><h4 id="1-4-生成一个库"><a href="#1-4-生成一个库" class="headerlink" title="1.4 生成一个库"></a>1.4 生成一个库</h4><p>制作一个库是通过 <code>add_library</code> 命令完成的，并且非常简单：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(one STATIC two.cpp three.h)</span><br></pre></td></tr></table></figure><p>你可以选择库的类型，可以是 <code>STATIC</code>,<code>SHARED</code>, 或者<code>MODULE</code>. </p><ul><li>STATIC 库是链接其他目标时使用的目标文件档案（archives）。</li><li>SHARED 库是动态链接的，并在运行时加载。</li><li>MODULE 库是未链接到其他目标但可以在运行时使用类似 dlopen 的功能动态加载的插件。</li></ul><p><strong>生成的library名会根据<code>STATIC</code>或<code>SHARED</code>成为<code>name.a</code>或<code>name.lib</code>。</strong></p><p>如果你不选择它，CMake 将会通过 <code>BUILD_SHARED_LIBS</code> 的值来选择构建 STATIC 还是 SHARED 类型的库。</p><h4 id="1-5-目标时常伴随着你"><a href="#1-5-目标时常伴随着你" class="headerlink" title="1.5 目标时常伴随着你"></a>1.5 目标时常伴随着你</h4><p>现在我们已经指定了一个目标，那我们如何添加关于它的信息呢？例如，它可能需要包含一个目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(one PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><blockquote><p>The <code>INTERFACE</code>, <code>PUBLIC</code> and <code>PRIVATE</code> keywords are required to specify the scope of the following arguments.</p></blockquote><p><code>target_include_directories</code>  指定编译给定目标时要使用的包含目录。命名的 <code>&lt;target&gt;</code> 必须是由 <code>add_executable()</code> 或  <code>add_library()</code>  等命令创建的，并且不能是 ALIAS 目标。</p><p> <code>PUBLIC</code> 对于一个二进制目标没有什么含义；但对于库来说，它让 CMake 知道，任何链接到这个目标的目标也必须包含这个目录。</p><p>其他选项还有 <code>PRIVATE</code>（只影响当前目标，不影响依赖），以及 <code>INTERFACE</code>（只影响依赖）。</p><p>接下来我们可以将目标之间链接起来：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(another STATIC another.cpp another.h)</span><br><span class="line"></span><br><span class="line"><span class="comment">#target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...)</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(another PUBLIC one)</span><br></pre></td></tr></table></figure><p><code>target_link_libraries</code> 指定一个目标，并且在给出目标的情况下添加一个依赖关系。</p><p>如果不存在名称为 <code>one</code> 的目标，那他会添加一个链接到你路径中 <code>one</code> 库（这也是命令叫 <code>target_link_libraries</code> 的原因）。<strong>或者</strong>你可以给定一个库的完整路径，或者是链接器标志。</p><p><em>最后再说一个有些迷惑性的知识：），经典的 CMake 允许你省略 <code>PUBLIC</code> 关键字，但是你在目标链中省略与不省略混用，那么 CMake 会报出错误。</em></p><h4 id="1-6-include-directories"><a href="#1-6-include-directories" class="headerlink" title="1.6 include_directories"></a>1.6 include_directories</h4><blockquote><p><strong><code>include_directories</code> ([<code>AFTER|BEFORE</code>] [<code>SYSTEM</code>] dir1 [dir2 …])</strong><br> 将指定目录添加到编译器的头文件搜索路径之下，指定的目录被解释成当前源码路径的相对路径。</p></blockquote><p>使用 <code>include_directories</code> 后, 不需在 <code>add_executable()</code> 里面添加 <code>test.h</code>, 编译器会自动寻找, 默认顺序是</p><p><strong><code>/usr/include</code></strong> -&gt; <strong><code>/usr/local/include</code></strong> -&gt; <strong><code>dir1</code></strong> -&gt; **<code>dir2</code>**。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">→ tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include       </span><br><span class="line">│   ├── test.cpp  </span><br><span class="line">│   └── test.h    </span><br><span class="line">└── main.cpp      </span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure><p>cmakeList.txt写法:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><p>有以下两种方式都可以让main函数运行成功:</p><ol><li>在main函数中, 直接使用<code>#include &quot;test.cpp&quot;</code></li><li>在main函数中, 使用#include “test.h”, 但是test.h 必须实现main调用的函数。</li></ol><h4 id="1-7-设置编译器选项以及编译选项"><a href="#1-7-设置编译器选项以及编译选项" class="headerlink" title="1.7 设置编译器选项以及编译选项"></a>1.7 设置编译器选项以及编译选项</h4><p>CMAKE_C_COMPILER：指定C编译器</p><p>CMAKE_CXX_COMPILER：指定C++编译器</p><p>CMAKE_C_FLAGS：指定编译C文件时编译选项，也可以通过add_definitions命令添加编译选项</p><p>在cmake脚本中，设置编译选项（配置编译器）有如下三种方法：</p><p><code>-Wall选项意思是编译后显示所有警告</code>; <code>-Werror选项意思是所有警告当做错误处理</code>。</p><ul><li><p>add_compile_options命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-Wall -Werror )</span><br></pre></td></tr></table></figure></li><li><p>add_definitions 命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_DEFINITIONS</span>(<span class="string">&quot;-Wall -Werror&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>set命令修改CMAKE_CXX_FLAGS 或 CMAKE_C_FLAGS</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;-Wall -Werror -Wstrict-prototypes -Wmissing-prototypes&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>使用这三种方式在有的情况下效果是一样的，但请注意它们还是有区别的：</p><p>add_compile_options命令和add_definitions添加的编译选项是针对所有编译器的(包括c和c++编译器)，而set命令设置CMAKE_C_FLAGS或CMAKE_CXX_FLAGS变量则是分别只针对c和c++编译器的。</p><h3 id="二-变量与缓存"><a href="#二-变量与缓存" class="headerlink" title="二 变量与缓存"></a>二 变量与缓存</h3><hr><h4 id="2-1-本地变量"><a href="#2-1-本地变量" class="headerlink" title="2.1 本地变量"></a>2.1 本地变量</h4><p>你可以这样声明一个本地 ( local ) 变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">&quot;value&quot;</span>)</span><br></pre></td></tr></table></figure><p>变量名通常全部用大写，变量值跟在其后。你可以通过 <code>$&#123;&#125;</code> 来解析一个变量，例如 <code>$&#123;MY_VARIABLE&#125;</code>.</p><p>列表就是简单地包含一系列变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;one&quot;</span> <span class="string">&quot;two&quot;</span>)</span><br></pre></td></tr></table></figure><p>你也可以通过 <code>;</code> 分隔变量，这和空格的作用是一样的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;one;two&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-2-缓存变量"><a href="#2-2-缓存变量" class="headerlink" title="2.2 缓存变量"></a>2.2 缓存变量</h4><p>CMake 提供了一个缓存变量来允许你从命令行中设置变量。CMake 中已经有一些预置的变量，像 <code>CMAKE_BUILD_TYPE</code>。</p><p>通过 <code>set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</code>这个命令来设置的变量就是 Cache Variables。例如 <code>set(MY_CACHE_VAL &quot;666&quot; CACHE STRING INTERNAL)</code>，此时 MY_CACHE_VAL 就是一个 CACHE 变量。相当于一个全局变量，我们在同一个 cmake 工程中都可以使用。</p><ul><li>Cache 变量 CMAKE_INSTALL_PREFIX 默认值是 /usr/local (可以在生成的 CMakeCache.txt 文件中查看)，这时候如果我们 在某个 CMakeLists.txt 中，仍然使用 set(CMAKE_INSTALL_PREFIX “/usr”)，那么此时我们 install 的时候，CMake 以后面的 /usr 作为 CMAKE_INSTALL_PREFIX 的值，这是因为 CMake 规定，有一个与 Cache 变量同名的 Normal 变量出现时，后面使用这个变量的值都是以 Normal 为准，如果没有同名的 Normal 变量，CMake 才会自动使用 Cache 变量。</li><li>所有的 Cache 变量都会出现在 CMakeCache.txt 文件中。这个文件是我们键入 <code>cmake .</code>命令后自动出现的文件。打开这个文件发现，CMake 本身会有一些默认的全局 Cache 变量。例如：CMAKE_INSTALL_PREFIX、CMAKE_BUILD_TYPE、CMAKE_CXX_FLAGSS 等等。可以自行查看。当然，我们自己定义的 Cache 变量也会出现在这个文件中。Cache 变量定义格式为 <code>set(&lt;variable&gt; &lt;value&gt; CACHE STRING INTERNAL)</code>。这里的 <code>STRING</code>可以替换为 <code>BOOL</code> <code>FILEPATH</code> <code>PATH</code> ，但是要根据前面 value 类型来确定。参考。</li><li>修改 Cache 变量。可以通过 <code>set(&lt;variable&gt; &lt;value&gt; CACHE INSTERNAL FORCE)</code>，另一种方式是直接在终端中使用 <code>cmake -D var=value ..</code>来设定默认存在的CMake Cache 变量。</li></ul><h4 id="3-3-环境变量、缓存"><a href="#3-3-环境变量、缓存" class="headerlink" title="3.3 环境变量、缓存"></a>3.3 环境变量、缓存</h4><ul><li>你也可以通过 <code>set(ENV&#123;variable_name&#125; value)</code> 和 <code>$ENV&#123;variable_name&#125;</code> 来设置和获取环境变量，不过一般来说，我们最好避免这么用。</li><li>缓存实际上就是个文本文件，<code>CMakeCache.txt</code> ，当你运行 CMake 构建目录时会创建它。 CMake 可以通过它来记住你设置的所有东西，因此你可以不必在重新运行 CMake 的时候再次列出所有的选项。</li></ul><h3 id="三-寻找其他库"><a href="#三-寻找其他库" class="headerlink" title="三 寻找其他库"></a>三 寻找其他库</h3><h4 id="3-1-OpenMP"><a href="#3-1-OpenMP" class="headerlink" title="3.1 OpenMP"></a>3.1 OpenMP</h4><p><a href="https://cmake.org/cmake/help/latest/module/FindOpenMP.html">OpenMP</a> support was drastically improved in CMake 3.9+. The Modern(TM) way to add OpenMP to a target is:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenMP)</span><br><span class="line"><span class="keyword">if</span>(OpenMP_CXX_FOUND)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(MyTarget PUBLIC OpenMP::OpenMP_CXX)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h4 id="3-2-MPI"><a href="#3-2-MPI" class="headerlink" title="3.2 MPI"></a>3.2 MPI</h4><p>To add MPI, like OpenMP, you’ll be best off with CMake 3.9+.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MPI REQUIRED)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Run: $&#123;MPIEXEC&#125; $&#123;MPIEXEC_NUMPROC_FLAG&#125; $&#123;MPIEXEC_MAX_NUMPROCS&#125; $&#123;MPIEXEC_PREFLAGS&#125; EXECUTABLE $&#123;MPIEXEC_POSTFLAGS&#125; ARGS&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyTarget PUBLIC MPI::MPI_CXX)</span><br></pre></td></tr></table></figure><h3 id="四-参考链接"><a href="#四-参考链接" class="headerlink" title="四 参考链接"></a>四 参考链接</h3><ol><li><a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/">Modern CMake 简体中文版</a></li><li><a href="https://cliutils.gitlab.io/modern-cmake/">An Introduction to Modern CMake</a></li><li><a href="https://cmake.org/cmake/help/v3.15/manual/cmake-commands.7.html#id2">cmake-commands(7)</a></li><li><a href="https://www.cnblogs.com/lidabo/p/16661713.html">cmake cache变量_反复研究好几遍，我才发现关于 CMake 变量还可以这样理解！ </a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Modern-CMake&quot;&gt;&lt;a href=&quot;#Modern-CMake&quot; class=&quot;headerlink&quot; title=&quot;Modern CMake&quot;&gt;&lt;/a&gt;Modern CMake&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;现代的 CMake 是指 CMak</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="cmake" scheme="http://okeyia.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>Git学习以及配置</title>
    <link href="http://okeyia.github.io/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <id>http://okeyia.github.io/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/</id>
    <published>2022-11-05T06:11:13.000Z</published>
    <updated>2022-11-06T00:39:46.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git学习以及配置"><a href="#Git学习以及配置" class="headerlink" title="Git学习以及配置"></a>Git学习以及配置</h2><h3 id="一-Git学习"><a href="#一-Git学习" class="headerlink" title="一 Git学习"></a>一 Git学习</h3><p>可视化 git 学习网站 <a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p><h4 id="1-1-git-checkout"><a href="#1-1-git-checkout" class="headerlink" title="1.1 git checkout"></a>1.1 git checkout</h4><p>用来切换分支,  表明当前所在的分支</p><p><em>在 Git2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）</em></p><h4 id="1-2-git-merge"><a href="#1-2-git-merge" class="headerlink" title="1.2 git merge"></a>1.2 git merge</h4><p>将其他的分支合并到当前的分支,   比如将bugFix 合并到main</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先切换到main分支</span></span><br><span class="line">git checkout main</span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105131530367.png" class="" title="image-20221105131530367"><h4 id="1-3-git-rebase"><a href="#1-3-git-rebase" class="headerlink" title="1.3 git rebase"></a>1.3 git rebase</h4><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p><strong>使用命令 git rebase main 后 发生的变化:</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140803587.png" class="" title="image-20221105140803587"><p>现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。<strong>注意</strong>，提交记录 C3 依然存在（树上那个半透明的节点），而 C3’ 是我们 Rebase 到 main 分支上的 C3 的副本。</p><p>此时main还未更新, 使用下列操作更新main。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105131320406.png" class="" title="image-20221105131320406"><p>由于 <code>bugFix</code> 继承自 <code>main</code>，所以 Git只是简单的把 <code>main</code> 分支的引用向前移动了一下而已。</p><h4 id="1-4-HEAD"><a href="#1-4-HEAD" class="headerlink" title="1.4 HEAD"></a>1.4 HEAD</h4><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p><p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git命令都是从改变 HEAD 的指向开始的。</p><p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p><p><strong>分离的HEAD:</strong> 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。</p><p><strong>举例说明：</strong></p><p><strong>执行以下操作：</strong> 发生的变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout c1</span><br><span class="line">git checkout main</span><br><span class="line">git commit</span><br><span class="line">git checkout c2 </span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140632320.png" class="" title="image-20221105140632320"><h4 id="1-5-撤销变更"><a href="#1-5-撤销变更" class="headerlink" title="1.5 撤销变更"></a>1.5 撤销变更</h4><p> Git里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p><p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p><h5 id="1-5-1-git-reset"><a href="#1-5-1-git-reset" class="headerlink" title="1.5.1 git reset"></a>1.5.1 git reset</h5><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105133031370.png" class="" title="image-20221105133031370"><p>原本的main 是指向c2的, 使用<code>git reset HEAD~1</code>后，main分支有迁回了c1，本地代码库就不知道c2的存在了。</p><h5 id="1-5-2-Git-Revert"><a href="#1-5-2-Git-Revert" class="headerlink" title="1.5.2 Git Revert"></a>1.5.2 Git Revert</h5><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><p><strong>使用命令： git revert HEAD</strong> 进行撤销。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140357585.png" class="" title="image-20221105140357585"><p>在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code>是相同的。</p><p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><h4 id="1-6-远程分支"><a href="#1-6-远程分支" class="headerlink" title="1.6 远程分支"></a>1.6 远程分支</h4><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p><p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><p><strong>远程仓库（在图示中）的样子：</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140500408.png" class="" title="image-20221105140500408"><h4 id="1-7-git-fetch"><a href="#1-7-git-fetch" class="headerlink" title="1.7 git fetch"></a>1.7 git fetch</h4><p>Git远程仓库相当的操作实际可以归纳为两点：</p><p><strong>向远程仓库传输数据以及从远程仓库获取数据</strong>。既然我们能与远程仓库同步，那么就可以分享任何能被 Git管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p>执行 <strong>git fetch</strong> 的变化：</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105134417699.png" class="" title="image-20221105134417699"><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><h4 id="1-8-git-pull"><a href="#1-8-git-pull" class="headerlink" title="1.8 git pull"></a>1.8 git pull</h4><p>然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/main</code></li><li><code>git rebase o/main</code></li><li><code>git merge o/main</code></li><li>等等</li></ul><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><ol><li><p>使用命令 <code>git fetch; git merge o/main</code></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105135236346.png" class="" title="image-20221105135236346"><p>我们用 <code>fetch</code> 下载了 <code>C3</code>, 然后通过 <code>git merge o/main</code> 合并了这一提交记录。现在我们的 <code>main</code> 分支包含了远程仓库中的更新（在本例中远程仓库名为 <code>origin</code>）</p></li><li><p>使用 <code>git pull</code> 可以达到同样的效果</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105135555684.png" class="" title="image-20221105135555684"></li></ol><h4 id="1-9-git-push"><a href="#1-9-git-push" class="headerlink" title="1.9 git push"></a>1.9 git push</h4><p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code> 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p><p>*注意 —— <code>git push</code> 不带任何参数时的行为与 Git的一个名为 <code>push.default</code> 的配置有关。它的默认值取决于你正使用的 Git的版本，但是在教程中我们使用的是 <code>upstream</code>*。</p><p><strong>使用 git push 后的变化：</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140045762.png" class="" title="image-20221105140045762"><p>远程仓库接收了 <code>C2</code>，远程仓库中的 <code>main</code> 分支也被更新到指向 <code>C2</code> 了，我们的远程分支 (o/main) 也同样被更新了。所有的分支都同步了！</p><h3 id="二-ssh-key-配置"><a href="#二-ssh-key-配置" class="headerlink" title="二 ssh-key 配置"></a>二 ssh-key 配置</h3><hr><h4 id="2-1-github-使用-token"><a href="#2-1-github-使用-token" class="headerlink" title="2.1 github 使用 token"></a>2.1 github 使用 token</h4><p>为了安全起见，github不再支持密码登录，改为了token，token就相当于一个比较安全的密码，获取到的token是全局的，可以对所有仓库进行操作</p><ol><li><p>获取token，在个人设置下，Developer settings中，新增token</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105112248257.png" class="" title="image-20221105112248257"></li><li><p>拿到token后，有两种使用方式</p><ul><li><p>使用git的时候，每次输入账号密码，这里的密码就是token，但是每次使用都要输入，比较麻烦</p></li><li><p>在git中的远程分支添加token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除原来的分支</span></span><br><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加由token构成的新分支</span></span><br><span class="line">git remote add origin https://token(这里改为自己的token)/okeyia/gem5_vans.git</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105112958726.png" class="" title="image-20221105112958726"></li><li><p>然后就可以愉快的 <code>git push origin master</code>了</p></li></ul></li></ol><h4 id="2-2-github-添加私钥"><a href="#2-2-github-添加私钥" class="headerlink" title="2.2 github 添加私钥"></a>2.2 github 添加私钥</h4><p>这里的话配置的是 <strong>某个仓库</strong> 的私钥，只允许对某个仓库进行操作。第 <strong>2.1</strong> 章节 配置的全局的私钥，可以对账号下面的所有仓库进行操作。</p><p>建议新建一个demo的仓库，在demo中进行配置</p><ol><li><p>在终端中生成一个 github 的 <code>ssh-key</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;xxxxx@qq.com&#x27; -f ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>将私钥对应的公钥,也就是 <strong>github_id_rsa.pub</strong> 的内容copy到github中某个仓库</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105105215110.png" class="" title="image-20221105105215110"></li><li><p>按照<strong>第2.3章节</strong>，配置 config 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.ssh/config</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">内容如下</span></span><br><span class="line">Host github.com</span><br><span class="line">   HostName github.com</span><br><span class="line">   IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line">   </span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 600 ~/.ssh/config</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>配置完成后, 测试一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现一下内容, 则说明配置成功</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Hi 用户名/仓库名! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span>  </span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3-为主机指定私钥"><a href="#2-3-为主机指定私钥" class="headerlink" title="2.3 为主机指定私钥"></a>2.3 为主机指定私钥</h4><p>主机上可能存在多个私钥, 但是连接的时候默认使用的是<code>id_rsa</code>,  如果不匹配的话, 则连接失败。有三种方法实现为主机指定密钥：</p><ul><li><p>ssh -i xxxx 用户@ip地址，（这里xxx是指密钥文件），这样的话每次都要输入密钥文件，比较麻烦</p></li><li><p>将密钥交给 <strong>ssh-agent</strong> 进行管理，但是ssh-agent在系统中并没有开启自启，每次都需要手动开启，不推荐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-agent bash   <span class="comment">#启动 ssh-agent</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add Identity_Linux  <span class="comment"># 为 ssh-agent 添加私钥。这里的 Identity_Linux 是我的私钥文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add -l   <span class="comment">#查看已添加的私钥</span></span></span><br></pre></td></tr></table></figure></li><li><p>配置 <strong>config</strong> 文件，一劳永逸，强烈推荐</p></li></ul><p>SSH的配置文件有两个:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ~/.ssh/config            <span class="comment"># 用户配置文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/ssh/ssh_config      <span class="comment"># 系统配置文件</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 个人建议只配置用户配置文件</span></span><br><span class="line">chmod 600 ~/.ssh/config</span><br></pre></td></tr></table></figure><p>常用的配置参数:</p><ul><li><p><strong>Host</strong></p><p>用于我们执行 SSH 命令的时候如何匹配到该配置。</p><ul><li><code>*</code>，匹配所有主机名。</li><li><code>*.example.com</code>，匹配以 .example.com 结尾。</li><li><code>!*.dialup.example.com,*.example.com</code>，以 ! 开头是排除的意思。</li><li><code>192.168.0.?</code>，匹配 192.168.0.[0-9] 的 IP。</li></ul></li><li><p><strong>HostName</strong></p><p>真实的主机名，默认值为命令行输入的值（允许 IP）</p></li><li><p><strong>Port</strong></p><p>默认端口为22, 使用其他端口的话加上 <code>-p xxx</code></p></li><li><p><strong>User</strong></p><p>登录的用户名</p></li><li><p><strong>IdentityFile</strong></p><p>指定连接的私钥</p></li></ul><p><strong>本地配置实例如下:</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104210515209.png" class="" title="image-20221104210515209"><h3 id="三-gitignore-文件"><a href="#三-gitignore-文件" class="headerlink" title="三 .gitignore 文件"></a>三 .gitignore 文件</h3><p>本地仓库的文件目录结构如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── a.cpp</span><br><span class="line">├── afs</span><br><span class="line">│   └── bfs</span><br><span class="line">├── b.c</span><br><span class="line">├── b.cpp</span><br><span class="line">├── bfs</span><br><span class="line">│   ├── a.cpp</span><br><span class="line">│   └── b.c</span><br><span class="line">├── b.o</span><br><span class="line">└── cfs</span><br><span class="line">    └── fs</span><br><span class="line">        └── bfs</span><br><span class="line">            └── test.txt</span><br></pre></td></tr></table></figure><h4 id="3-1-忽略文件"><a href="#3-1-忽略文件" class="headerlink" title="3.1 忽略文件"></a>3.1 忽略文件</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># this is .gitignore file.</span><br><span class="line"># 以下是忽略的文件</span><br><span class="line">bfs</span><br></pre></td></tr></table></figure><p>只写bfs的话, 忽略同名的文件夹以及文件。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213043599.png" class="" title="image-20221104213043599"><h4 id="3-2-忽略文件而不忽略目录"><a href="#3-2-忽略文件而不忽略目录" class="headerlink" title="3.2 忽略文件而不忽略目录"></a>3.2 忽略文件而不忽略目录</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">bfs</span><br><span class="line">!bfs/</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213424804.png" class="" title="image-20221104213424804"><h4 id="3-3-忽略目录而不忽略文件"><a href="#3-3-忽略目录而不忽略文件" class="headerlink" title="3.3 忽略目录而不忽略文件"></a>3.3 忽略目录而不忽略文件</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">bfs/</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213251537.png" class="" title="image-20221104213251537"><h4 id="3-4-通配符"><a href="#3-4-通配符" class="headerlink" title="3.4 通配符"></a>3.4 通配符</h4><hr><p>常用的通配符有：</p><p>（1）星号“*” ：匹配多个字符；</p><p>（2）问号“?”：匹配除 ‘/’外的任意一个字符；</p><p>（3）方括号“[xxxx]”：匹配多个列表中的字符；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">*.[co]</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104214535749.png" class="" title="image-20221104214535749"><h4 id="3-5-其他规则"><a href="#3-5-其他规则" class="headerlink" title="3.5 其他规则"></a>3.5 其他规则</h4><ol><li>空行不匹配任何文件；</li><li>git 跟踪文件，而不是目录；</li><li>在 .gitignore 文件中，每行表示一种模式；</li><li>如果本地仓库文件已被跟踪，那么即使在 .gitignore 中设置了忽略，也不起作用。这个时候使用 <code>git rm -rf --cached .</code> 先将git cache中的内容全部删除, 然后再重新添加。</li><li>.gitignore 文件也会被上传的到远程仓库，所以，同一个仓库的人可以使用同一个.gitignore 文件。</li></ol><h3 id="四-参考链接"><a href="#四-参考链接" class="headerlink" title="四 参考链接"></a>四 参考链接</h3><ol><li><a href="https://linux.die.net/man/5/ssh_config">ssh_config(5) - Linux man page</a></li><li><a href="https://blog.csdn.net/senlin1202/article/details/122081089">SSH Config 使用</a></li><li><a href="https://gitee.com/help/articles/4229#article-header0">Gitee git 配置多个SSH-KEY</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git学习以及配置&quot;&gt;&lt;a href=&quot;#Git学习以及配置&quot; class=&quot;headerlink&quot; title=&quot;Git学习以及配置&quot;&gt;&lt;/a&gt;Git学习以及配置&lt;/h2&gt;&lt;h3 id=&quot;一-Git学习&quot;&gt;&lt;a href=&quot;#一-Git学习&quot; class=&quot;he</summary>
      
    
    
    
    <category term="工欲善其事, 必先利其器" scheme="http://okeyia.github.io/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B-%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="git配置" scheme="http://okeyia.github.io/tags/git%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>求职算法总结</title>
    <link href="http://okeyia.github.io/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://okeyia.github.io/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-10-24T07:52:03.000Z</published>
    <updated>2022-12-23T12:04:52.388Z</updated>
    
    <content type="html"><![CDATA[<hr><p>还没有总结完!   待续……..</p><hr><h2 id="求职算法总结"><a href="#求职算法总结" class="headerlink" title="求职算法总结"></a>求职算法总结</h2><p>为什么选择c++ 作为主攻语言?   C/C++ 能让我见识到整个计算机体系结构是如何被搭建起来的、程序是如何跑起来的、程序是如何被编译链接在一起的、函数的底层构造是怎样的。</p><h3 id="〇-递归中的时间复杂度"><a href="#〇-递归中的时间复杂度" class="headerlink" title="〇 递归中的时间复杂度"></a>〇 递归中的时间复杂度</h3><p>递归算法的时间复杂度表达式：O(T) = R * O(s)。</p><p>O(T) 表示时间复杂度， R表示递归调用的次数， O(s)每次递归调用计算的时间复杂度。</p><blockquote><p> 斐波那契函数,  它的递归关系是f(n) = f(n-1) + f(n-2),  这里将 n = 5 作为输入,  </p><p>递归过程 抽象成一棵递归树,  在这棵二叉树中每一个节点都是一次递归，那么这棵树有多少个节点呢？  </p><p>一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点, 所以该递归算法的时间复杂度为O(2^n)。</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220921_195136.png" class="" title="Clip_20220921_195136"></blockquote><h3 id="一-二分法"><a href="#一-二分法" class="headerlink" title="一 二分法"></a>一 二分法</h3><hr><h4 id="1-1-找下界"><a href="#1-1-找下界" class="headerlink" title="1.1 找下界"></a>1.1 找下界</h4><p><strong>问题定义：</strong>给定一个升序数组，我们将满足  <code>x ≥ target</code> 的第一个元素定义为 <strong>下界</strong> 。</p><p><code>C++ STL</code>中的 <code>lower_bound()</code> 函数就实现了这个功能。</p><h5 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h5><p>对于数组 <code>[1,2,3,5,5,5,6,7,9]</code>，令 <code>target=5</code>，则满足 <code>x ≥ target</code> 的下界的下标应该是 <code>3</code>。</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_141823.jpg" class="" title="Clip_20220919_141823"><p>可以看到，从这个位置将数组分为左右两部分，**左侧的元素都「小于」<code>target</code>，右侧的元素都「大于等于」<code>target</code>**。</p><p><strong>定义变量 ：</strong></p><ul><li>区间范围为 <code>[left,right]</code>，<code>left</code>、<code>right</code> 是区间的左右边界的下标</li><li><code>mid</code> 是 <code>[left,right]</code> 的中间位置</li><li>初始时，<code>left</code>、<code>right</code> 分别指向数组的第一个和最后一个元素</li><li><strong>当 <code>left &gt; right</code> 时，表示区间为空</strong></li></ul><p>如果我们在二分查找的过程中，<strong>不断右移 <code>left</code>，左移 <code>right</code>，使得所有「小于」<code>target</code> 的元素都在 <code>left</code> 左侧，所有「大于等于」<code>target</code> 的元素都在 <code>right</code> 右侧，那么当区间为空时，<code>left</code> 就是要查找的下界</strong></p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_142137.jpg" class="" title="Clip_20220919_142137"><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><p>根据上述思路，<strong>算法步骤</strong>如下：</p><ul><li>若 <code>nums[mid] &gt;= target</code>，说明 <code>[mid,right]</code> 区间的所有元素均「大于等于」<code>target</code>，因此 <code>right</code> 左移，有 <code>right = mid-1</code></li><li>否则，说明 <code>[left,mid]</code> 区间的所有元素均「小于」<code>target</code>，因此 <code>left</code> 右移，有 <code>left = mid+1</code></li><li>重复上述步骤，直到区间为空，表示找到了下界，**返回 <code>left</code>**。因此循环条件为 <code>left &lt;= right</code>，表示“区间不为空”</li><li>注意，上述两个赋值语句均跳过了中间元素 <code>mid</code></li></ul><p>上述的查找过程如下： </p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_142436.jpg" class="" title="Clip_20220919_142436"><h5 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找满足 x ≥ target 的下界的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> search（<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] &gt;= target)&#123;  <span class="comment">// 这里的比较运算符与题目要求一致</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;   <span class="comment">// 返回下界的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，**<code>if</code> 的判定条件和给定的比较规则是一致的<strong>：要找满足 <code>x &gt;= target</code> 的第一个元素，所以是 <code>if nums[m] &gt;= target</code>。如果要找满足 <code>x &gt; target</code> 的第一个元素，那么只需改为 <code>if nums[m] &gt; target</code>。</strong><code>if</code> 为真时更新 <code>right</code>**。</p><p>最后注意一些细节：</p><ul><li><code>left</code>、<code>right</code> 的初值为 <code>0</code>、<code>n-1</code>，表示「闭区间」</li><li>循环的判定条件是 <code>left &lt;= right</code>，表示区间不为空</li><li>更新 <code>left</code> 和 <code>right</code> 时均跳过了中间元素 <code>mid</code></li></ul><h4 id="1-2-找上界"><a href="#1-2-找上界" class="headerlink" title="1.2 找上界"></a>1.2 找上界</h4><p>定义：满足 <code>x &lt; target</code> 的<strong>最后一个元素</strong>为「上界」。</p><p>给定一个 <code>target</code>，要求返回升序数组中上界的下标。比如：对于数组 <code>[0,1,2,3,4]</code>，当 <code>target=3</code> 时，返回下标 <code>2</code>；当 <code>target=5</code> 时，返回下标 <code>4</code>。</p><p>根据上界和下界的定义，我们可以发现：<strong>上界和「互补的」下界是相邻的，并且 <code>上界 = 下界 - 1</code>**。比如 <code>x ≤ target</code> 的上界和 <code>x &gt; target</code> 的下界相邻。因此，</strong>所有找上界的问题，都可以转换为「互补的」找下界的问题。**</p><p>对于 <code>x &lt; target</code> 而言，要找上界，套用上文的模板，实现 <code>x &gt;= target</code> 的下界, 参考 <a href="#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81">模板代码</a>。</p><p>然后再将下界 减一, 就是我们要找的上界。</p><h4 id="1-3-参考例题"><a href="#1-3-参考例题" class="headerlink" title="1.3 参考例题"></a>1.3 参考例题</h4><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 寻找下界, 第一个 x &gt;= target的位置</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt;= target) right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= nums.size() || nums[left] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找 x == taget 最后一次出现的位置, 只需查找 x &lt;= target的上界 </span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断一下是否越界，或者不相等</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;searchFirst(nums,target),searchLast(nums,target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-4-二分参考链接"><a href="#1-4-二分参考链接" class="headerlink" title="1.4 二分参考链接"></a>1.4 二分参考链接</h4><ol><li></li></ol><h3 id="二-回溯"><a href="#二-回溯" class="headerlink" title="二 回溯"></a>二 回溯</h3><p>回溯法解决的问题</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯解决的问题都可以抽象为树形结构，因为回溯解决的都是在集合中查找子集，集合的大小构成了树的宽度，递归的深度。</p><h4 id="2-1-回溯算法模板"><a href="#2-1-回溯算法模板" class="headerlink" title="2.1 回溯算法模板"></a>2.1 回溯算法模板</h4><ol><li>回溯函数模板返回值以及参数</li><li>回归函数终止条件</li><li>回溯搜索的遍历过程</li></ol><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_200402.png" class="" title="Clip_20220919_200402"><p>综上，回溯算法模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-startIndex-开始位置"><a href="#2-2-startIndex-开始位置" class="headerlink" title="2.2 startIndex 开始位置"></a>2.2 <code>startIndex</code> 开始位置</h4><p>如果是一个集合来求组合的话，就需要<code>startIndex</code>, 例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！</a></p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用<code>startIndex</code>, 如 <a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">回溯算法：电话号码的字母组合</a></p><h4 id="2-3-去重"><a href="#2-3-去重" class="headerlink" title="2.3 去重"></a>2.3 去重</h4><p>分为:  <strong>“树层去重”和“树枝去重”</strong></p><h3 id="三-哈希表"><a href="#三-哈希表" class="headerlink" title="三 哈希表"></a>三 哈希表</h3><h4 id="3-1-set-集合"><a href="#3-1-set-集合" class="headerlink" title="3.1 set(集合)"></a>3.1 set(集合)</h4><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><h4 id="3-2-map-映射"><a href="#3-2-map-映射" class="headerlink" title="3.2 map(映射)"></a>3.2 map(映射)</h4><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><h3 id="四-动态规划"><a href="#四-动态规划" class="headerlink" title="四 动态规划"></a>四 动态规划</h3><p>模板:</p><ol><li>确定<code>dp</code> 数组 (<code>dp table</code>) 以及下表的含义</li><li>确定递推公式</li><li><code>dp</code> 数组初始化</li><li>确定遍历顺序</li><li>举例推导 数组</li></ol><p><strong>分类解题模板</strong><br>背包问题大体的解题模板是两层循环，分别遍历物品<code>nums</code>和背包容量target，然后写转移方程，<br>根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法</p><p><strong>首先是背包分类的模板：</strong><br>1、0/1背包：外循环 <code>nums</code> ,内循环 target, target 倒序且 <code>target&gt;=nums[i]</code> ;<br>2、完全背包：外循环 <code>nums</code> ,内循环 target, target 正序且<code>target&gt;=nums[i]</code>;<br>3、组合背包(考虑顺序)：外循环target,内循环 <code>nums</code>, target正序且 <code>target&gt;=nums[i]</code>;<br>4、分组背包：这个比较特殊，需要三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板</p><p><strong>然后是问题分类的模板：</strong><br>1、最值问题: <code>dp[i] = max/min(dp[i], dp[i-nums]+1)</code>或<code>dp[i] = max/min(dp[i], dp[i-num]+nums)</code>;<br>2、存在问题**<code>(bool)</code>**：<code>dp[i]=dp[i]||dp[i-num]</code>;<br>3、组合问题：<code>dp[i]+=dp[i-num]</code>;</p><p>这样遇到问题将两个模板往上一套大部分问题就可以迎刃而解</p><h4 id="4-1-01-背包问题"><a href="#4-1-01-背包问题" class="headerlink" title="4.1 01 背包问题"></a>4.1 01 背包问题</h4><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221001190410813.png" class="" title="image-20221001190410813"><p><code>dp[i][j]</code> : <strong>表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>对于<code>物品i</code>来说,  有两种状态,  <strong>放入</strong> 或者 <strong>不放</strong>:</p><ol><li>不放的话, <code>dp[i][j]就是dp[i - 1][j]</code></li><li>放入的话, 由<code>dp[i - 1][j - weight[i]]</code>推出</li></ol><p>所以递推公式为:  <code> dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code> </p><p>初始化数组:</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20221001_191233.png" class="" title="Clip_20221001_191233"><p>遍历代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-滚动数组"><a href="#4-2-滚动数组" class="headerlink" title="4.2 滚动数组"></a>4.2 滚动数组</h4><blockquote><p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><p>每一行的 <code>dp[i][∗]</code> 状态值都只与上一行的 <code>dp[i-1][*]</code>状态值有关，因此可基于滚动数组的思想进行对状态空间 <code>dp</code> 进行优化而省去第一维度</p><p><strong>其实可以发现如果把<code>dp[i - 1]</code>那一层拷贝到<code>dp[i]</code>上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p></blockquote><p>滚动数组:  需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p><p>在一维<code>dp</code>数组中，<code>dp[j]</code>表示：容量为j的背包，所背的物品价值可以最大为<code>dp[j]</code>。</p><p><code>dp[j]</code>可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为<code>j - weight[i]</code>的背包所背的最大价值。</p><p>所以递推公式为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量, 从大到小</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历背包是倒序的</strong>,  仔细想一想为为什么要倒叙 ?</p><blockquote><p>考虑到我我们在更新 <code>dp[j]</code>时，使用的其实是上一行的 <code>dp</code>值；而如果第二层循环从小到大计算的话，那么 <code>dp[j−nums[i-1]]</code> 先于 <code>dp[j]</code> 被更新，因此当我们计算 <code>dp[j]</code>值的时候，<code>dp[j−nums[i-1]]</code>已经是被更新过的状态，而不再是上一行的 <code>dp</code> 值了。</p><p>而在第二层循环中，通过从大到小计算则可巧妙地保证在计算 <code>dp[j]</code> 时所用到的 <code>dp[j]</code>]和 <code>dp[j-nums[i-1]]</code>均来自上一行。</p></blockquote><h4 id="4-3-完全背包"><a href="#4-3-完全背包" class="headerlink" title="4.3 完全背包"></a>4.3 完全背包</h4><h4 id="4-4-典型例题"><a href="#4-4-典型例题" class="headerlink" title="4.4 典型例题"></a>4.4 典型例题</h4><p> <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>    <a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">题解</a></p><p>怎么将数学思维和代码结合起来</p><blockquote><p> 题目要求是计算不同二叉搜索树的个数。定义两个函数：</p><p>G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。</p><p>F(i, n) 以 ii为根、序列长度为 n 的不同二叉搜索树个数 (1≤i≤n)</p><p>G(n) 可以从 F(i, n) 得到，而 F(i, n) 又会递归地依赖于 G(n)。</p></blockquote><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20220930214755016.png" class="" title="image-20220930214755016"><h4 id="4-5-参考链接"><a href="#4-5-参考链接" class="headerlink" title="4.5 参考链接"></a>4.5 参考链接</h4><ol><li><a href="https://leetcode.cn/problems/coin-change/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-sq9n/">一篇文章吃透背包问题！（细致引入+解题模板+例题分析+代码呈现）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;还没有总结完!   待续……..&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;求职算法总结&quot;&gt;&lt;a href=&quot;#求职算法总结&quot; class=&quot;headerlink&quot; title=&quot;求职算法总结&quot;&gt;&lt;/a&gt;求职算法总结&lt;/h2&gt;&lt;p&gt;为什么选择c++ 作为主攻语言?   C</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://okeyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C/C++常用刷题技巧</title>
    <link href="http://okeyia.github.io/2022/09/17/C_C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://okeyia.github.io/2022/09/17/C_C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2022-09-17T00:28:27.000Z</published>
    <updated>2022-11-14T02:39:55.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-C-常用刷题技巧"><a href="#C-C-常用刷题技巧" class="headerlink" title="C/C++常用刷题技巧"></a>C/C++常用刷题技巧</h2><p><strong>万能头文件</strong></p><blockquote><p>万能头文件</p><p>基本包括了大部分的STL库函数，使用方便快捷</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="一-vector"><a href="#一-vector" class="headerlink" title="一  vector"></a>一  vector</h3><h4 id="1-1-一维vector初始化"><a href="#1-1-一维vector初始化" class="headerlink" title="1.1  一维vector初始化"></a>1.1  一维vector初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first; <span class="comment">// 空的vector，只是一个列表的头，里面没有元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">second</span> <span class="params">(<span class="number">4</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 初始化一个具有4个元素的vector，每个元素的值都是100</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">third</span> <span class="params">(second.begin(), second.end())</span></span>; <span class="comment">// 通过其他vector的迭代器的方式，进行拷贝复制初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fourth</span> <span class="params">(third)</span></span>; <span class="comment">// 直接对其他vector的拷贝复制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>, <span class="number">2</span>, <span class="number">77</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fifth</span> <span class="params">(myints, myints+<span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>; <span class="comment">// 将数组转化成vector，需要提供的是数组的首地址和地址偏移。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sixth = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>&#125;; <span class="comment">// 指定内容进行构造，内容为1,5,4,6的vector</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vars;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;<span class="comment">//建立一个vector</span></span><br><span class="line"></span><br><span class="line">test.push_back(<span class="number">1</span>);</span><br><span class="line">test.push_back(<span class="number">2</span>);<span class="comment">//把1和2压入vector，这样test[0]就是1,test[1]就是2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//使用下标访问元素</span></span><br><span class="line"><span class="comment">//使用迭代器访问元素.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++)&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec.insert(vec.begin()+i,a);<span class="comment">//在第i+1个元素前面插入a;</span></span><br><span class="line">vec.erase(vec.begin()+<span class="number">2</span>);<span class="comment">//删除第3个元素</span></span><br><span class="line">vec.erase(vec.begin()+i,vec.end()+j);<span class="comment">//删除区间[i,j-1];区间从0开始</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.size()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//向量大小</span></span><br><span class="line">vec.clear();<span class="comment">//清空</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sort(v.begin(),v.end());              <span class="comment">//用sort()函数从小到大进行排序</span></span><br><span class="line">reverse(v.begin(),v.end());          <span class="comment">// 用reverse()函数翻转数组</span></span><br><span class="line">v.size()                             <span class="comment">// 返回容器的大小</span></span><br><span class="line">v.empty()                             <span class="comment">//判断容器是否为空，为空返回0，不为空则为1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v[<span class="number">0</span>];                          <span class="comment">// 打印第一个元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v[v.size()]                     <span class="comment">//打印最后一个元素</span></span><br><span class="line">lower_bound(v.begin(),v.end(),a)      <span class="comment">//在有序数组中返回第一个大于等于a的元素的下标,返回值的是地址</span></span><br><span class="line">upper_bound(v.begin(),v.end(),a)-v.begin()  <span class="comment">//在有序数组中返回第一个大于a的元素的下标,这里通过减去首地址，得到了下标位置</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  <span class="comment">//定义迭代器方便得到元素值，相当于指针</span></span><br><span class="line">it=upper_bound(v.begin,v.end(),a)    </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(*it)                          <span class="comment">//这里返回的是第一个大于a的元素的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-二维数组初始化"><a href="#1-2-二维数组初始化" class="headerlink" title="1.2 二维数组初始化"></a>1.2 二维数组初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维vector的初始化</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vars(size, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size, <span class="number">0</span>)); <span class="comment">// （size,size）的矩阵，元素全部是0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; a(<span class="number">3</span>);<span class="comment">//初始化的是3*3的矩阵,注意我们所申请的矩阵行数和列数默认相等的</span></span><br><span class="line"><span class="comment">//如果我们需要行数和列数不相等的二维数组，那么我们可以对每一行所包含的元素个数加以限制；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)<span class="comment">//利用resize函数将每一行的元素个数设置为5个，即5列 </span></span><br><span class="line">a[i].resize(<span class="number">5</span>);<span class="comment">//此时我们得到的就是一个3行5列的二维数组</span></span><br></pre></td></tr></table></figure><p>如果我们采用size函数来得到数组规模，那么我们所得到的结果是矩阵的行数，如果需要得到列数可以使用<code>a[0].size()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; a(<span class="number">3</span>);<span class="comment">//初始化的是3*3的矩阵 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)<span class="comment">//利用resize函数将每一行的元素个数设置为5个，即5列 </span></span><br><span class="line">a[i].resize(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//打印的是vector的行数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>除上述初始化行列数不同的二维数组之外，我们也可以直接定义</strong>，结果也是3行5列的二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Array(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Array[<span class="number">0</span>].size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下也可以</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;num =</span><br><span class="line">&#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="二-字符串部分"><a href="#二-字符串部分" class="headerlink" title="二 字符串部分"></a>二 字符串部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">string</span> t=<span class="string">&quot;m&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;<span class="comment">//不包括空格</span></span><br><span class="line">getline(<span class="built_in">cin</span>,s);<span class="comment">//读取一行，可以包含空格</span></span><br><span class="line">s.append(t);<span class="comment">//将字符t添加到s  </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s+t;  <span class="comment">//同上述效果一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//find(“字符串”) / find(&quot;字符串&quot;,postion)   ---找不到就返回很大很大的数,可以与-1比较</span></span><br><span class="line"><span class="keyword">if</span>(s1.find(s2)==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;在s1中未找到s2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.find(t)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//找子序列t在s中出现的首次位置</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.find(t,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//从第二个位置开始找，找子序列t在s中出现的首次位置</span></span><br><span class="line"><span class="keyword">int</span> len = s.size();<span class="comment">//字符串s的⻓度</span></span><br><span class="line"><span class="keyword">int</span> len = s.length();<span class="comment">//字符串s的⻓度</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*s1.begin()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指向字符串的第一个元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(s1.end()<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指向字符串的最后一个元素</span></span><br><span class="line"></span><br><span class="line">reverse(s.begin(), s.end());<span class="comment">//字符串反转</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> sTemp=s1.substr(<span class="number">1</span>);<span class="comment">//下标1开始到结束</span></span><br><span class="line"><span class="comment">//截取substr（pos,num） ----在哪个位置截取，截取多少字符</span></span><br><span class="line"><span class="built_in">string</span> sTemp2 = s1.substr(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//下标1开始，截取3个字符</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sTemp&lt;&lt;<span class="string">&quot;----&quot;</span>&lt;&lt;sTemp2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//访问字符串的0处的位置</span></span><br><span class="line"><span class="built_in">string</span> s1,s2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个字符串之间的大小关系</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1==s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1&gt;s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1&lt;s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//插入insert(position,&quot;字符串&quot;)</span></span><br><span class="line">s1.insert(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br><span class="line"><span class="comment">//删除 erase(pos,num)----在哪个位置删除多少字符</span></span><br><span class="line">s1.earse(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将123456转为字符串</span></span><br><span class="line">s1 = to_string(<span class="number">123456</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br><span class="line"><span class="comment">//将字符型1234转为int类型   ---string to int</span></span><br><span class="line"><span class="keyword">int</span> x=stoi(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三-栈"><a href="#三-栈" class="headerlink" title="三 栈"></a>三 栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;  //要引入库函数</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">      s.push(i);<span class="comment">//入栈操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问s的栈顶元素</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.size()&lt;&lt;<span class="built_in">endl</span>;  输出s的元素个数</span><br><span class="line">   s.pop(); <span class="comment">// 删除栈顶元素但不返回其值</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.empty()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//非空返回0，是空返回1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四-队列"><a href="#四-队列" class="headerlink" title="四 队列"></a>四 队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;//要引入库函数</span></span></span><br><span class="line">   <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        s.push(i);<span class="comment">//将i元素接到队列的末端；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;首元素为：&quot;</span>&lt;&lt;s.front()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问队首元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;队尾元素：&quot;</span>&lt;&lt;s.back()&lt;&lt;<span class="built_in">endl</span>;  访问队尾元素</span><br><span class="line">     s.pop(); <span class="comment">// 弹出队列的第一个元素，并不会返回元素的值；</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.empty()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//非空返回0，是空返回1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五-set"><a href="#五-set" class="headerlink" title="五 set"></a>五 set</h3><blockquote><p>⼀个<code>set</code>⾥⾯的各元素是各不相同的（重复元素自动删除），⽽且<code>set</code>会按照元素进⾏从⼩到⼤排序</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">  s.insert(<span class="number">2</span>);<span class="comment">//插入元素</span></span><br><span class="line"></span><br><span class="line">  s.insert(<span class="number">100</span>);<span class="comment">//插入元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    s.insert(i);<span class="comment">//插入元素</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//迭代变量set&lt;int&gt;::iterator it</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s.begin();it!=s.end();it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//集合的遍历，it是一个迭代的指针</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span> v: s)  <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//输入结果：0 1 2 3 4 5 100</span></span><br><span class="line"><span class="comment">//按照从小到大排序，且删除相同元素</span></span><br><span class="line"></span><br><span class="line">s.erase(<span class="number">3</span>);<span class="comment">//删除元素为3的</span></span><br><span class="line">s.clear();<span class="comment">//清空</span></span><br><span class="line">s.size();<span class="comment">//长度</span></span><br><span class="line">s.empty();<span class="comment">//判空</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*s.find(<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//查找某一个num值，返回的是迭代器，因此需要*来输出</span></span><br></pre></td></tr></table></figure><h3 id="六-哈希表"><a href="#六-哈希表" class="headerlink" title="六 哈希表"></a>六 哈希表</h3><h4 id="6-1-map"><a href="#6-1-map" class="headerlink" title="6.1 map"></a>6.1 map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">  mp[x] =i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v: mp) <span class="built_in">cout</span>&lt;&lt;v.first&lt;&lt;<span class="string">&quot; ： &quot;</span>&lt;&lt;v.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-2-unordered-map"><a href="#6-2-unordered-map" class="headerlink" title="6.2 unordered_map"></a>6.2 unordered_map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">//2. 初始化</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 插入元素</span></span><br><span class="line"><span class="comment">//3.1 数组形式</span></span><br><span class="line"><span class="built_in">map</span>[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//3.2 直接插入</span></span><br><span class="line"><span class="built_in">map</span>.insert( &#123; &#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; , &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>&#125; &#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 修改元素</span></span><br><span class="line"><span class="built_in">map</span>[<span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 删除元素</span></span><br><span class="line"><span class="comment">//5.1 删除key为&#x27;a&#x27;的元素</span></span><br><span class="line"><span class="built_in">map</span>.erase(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line"><span class="comment">//5.2删除第一个元素</span></span><br><span class="line"><span class="built_in">map</span>.erase(<span class="built_in">map</span>.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 判断元素是否存在</span></span><br><span class="line"><span class="comment">//6.1 如果元素存在</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">&#x27;a&#x27;</span>)!=<span class="built_in">map</span>.end())</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>.count(<span class="string">&#x27;a&#x27;</span>)!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 清空所有元素    </span></span><br><span class="line"><span class="built_in">map</span>.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 遍历取值并取出键和值</span></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span>&amp; a : <span class="built_in">map</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> key= a.first;</span><br><span class="line">    <span class="keyword">int</span>  value= a.second;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); it++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> key = it-&gt;first;</span><br><span class="line">        <span class="keyword">int</span>  value = it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9. 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>.empty() )</span><br><span class="line">    </span><br><span class="line"><span class="comment">//10. 求元素个数</span></span><br><span class="line"><span class="built_in">map</span>.size();</span><br></pre></td></tr></table></figure><h3 id="七-ACM模式输入输出参考书程序"><a href="#七-ACM模式输入输出参考书程序" class="headerlink" title="七 ACM模式输入输出参考书程序"></a>七 ACM模式输入输出参考书程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;  //INT_MIN 和 INT_MAX的头文件  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 直接输入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 直接输入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 只读取一个字符 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2： cin.get(ch) 或者 ch = cin.get() 或者 cin.get()</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch)) &#123;   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式3 ：ch = getchar()  </span></span><br><span class="line"><span class="keyword">while</span> (getchar()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1给定一个数，表示有多少组数（可能是数字和字符串的组合），然后读取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;   <span class="comment">//每次读取1 + n 个数，即一个样例有n+1个数 </span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理这组数/字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2 首先给一个数字，表示需读取n个字符，然后顺序读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;  <span class="comment">//输入数量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">strs.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理这组字符串</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.未给定数据个数，但是每一行代表一组数据，每个数据之间用空格隔开</span></span><br><span class="line"><span class="comment">//4.1使用getchar() 或者 cin.get() 读取判断是否是换行符，若是的话，则表示该组数（样例）结束了，需进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ele;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ele) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = ele;</span><br><span class="line"><span class="comment">// getchar()   //读取单个字符</span></span><br><span class="line"><span class="comment">/*while (cin.get() != &#x27;\n&#x27;) &#123;*/</span>   <span class="comment">//判断换行符号</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) &#123;  <span class="comment">//如果不是换行符号的话，读到的是数字后面的空格或者table</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.2 给定一行字符串，每个字符串用空格间隔，一个样例为一行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line"><span class="keyword">if</span> (getchar() == <span class="string">&#x27;\n&#x27;</span>) &#123;  <span class="comment">//控制测试样例</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">strs.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.3 使用getline 读取一整行数字到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> input;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, input)) &#123;  <span class="comment">//读取一行</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">data</span><span class="params">(input)</span></span>;  <span class="comment">//使用字符串流</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (data &gt;&gt; num) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.4 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> words;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, words)) &#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">data</span><span class="params">(words)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (data &gt;&gt; str) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.5 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。每个字符中间用&#x27;,&#x27;间隔</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while (cin &gt;&gt; line) &#123;  //因为加了“，”所以可以看出一个字符串读取</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (getline(ss, str, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言读取字符、数字</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch)) &#123; <span class="comment">//获得单个字符</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;  <span class="comment">//遇到空白停止</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str);  <span class="comment">//读入一行字符串</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="八-其他"><a href="#八-其他" class="headerlink" title="八 其他"></a>八 其他</h3><h4 id="自带的宏常量"><a href="#自带的宏常量" class="headerlink" title="自带的宏常量"></a>自带的宏常量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = INT_MIN;</span><br><span class="line"><span class="keyword">int</span> N = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">//通常用来代替最大值，防止运算过程中溢出  0x16进制</span></span><br></pre></td></tr></table></figure><h4 id="字符串判断函数"><a href="#字符串判断函数" class="headerlink" title="字符串判断函数"></a>字符串判断函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isdigit</span>(c)  <span class="comment">//判断c字符是不是数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)  <span class="comment">//判断c字符是不是字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(c)  <span class="comment">//判断c字符是不是数字或者字母</span></span><br><span class="line"><span class="built_in">tolower</span>(c)  <span class="comment">//转为小写</span></span><br><span class="line"><span class="built_in">toupper</span>(c)  <span class="comment">//转为大写</span></span><br></pre></td></tr></table></figure><h4 id="字符串和数值间的转换"><a href="#字符串和数值间的转换" class="headerlink" title="字符串和数值间的转换"></a>字符串和数值间的转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">string</span> str = to_string(num); <span class="comment">//整形转字符串</span></span><br><span class="line"><span class="keyword">int</span> number = stoi(str);  <span class="comment">//字符串转为整形 stol()是字符串转为长整形</span></span><br></pre></td></tr></table></figure><h4 id="迭代器的二分"><a href="#迭代器的二分" class="headerlink" title="迭代器的二分"></a>迭代器的二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">44</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k = lower_bound(nums.begin(), nums.end(), <span class="number">56</span>) - nums.begin(); <span class="comment">//第一个大于等于目标值的迭代器位置</span></span><br><span class="line"><span class="keyword">int</span> k = upper_bound(nums.begin(), nums.end(), <span class="number">56</span>) - nums.begin(); <span class="comment">// 找到第一个大于目标值的迭代器位置</span></span><br></pre></td></tr></table></figure><h4 id="字符串转为小写"><a href="#字符串转为小写" class="headerlink" title="字符串转为小写"></a>字符串转为小写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**op作用的范围[str1.begin(), str1.end], 作用完成后，存储位置的开头为：str2.begin()，op为toupper/tolower*/</span></span><br><span class="line">transform(str1.begin(), str1.end(), str2.begin(), ::<span class="built_in">toupper</span>);</span><br><span class="line">transform(str1.begin(), str1.end(), str2.begin(), ::<span class="built_in">tolower</span>);</span><br></pre></td></tr></table></figure><h4 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">//默认是大根堆</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq; <span class="comment">//小根堆</span></span><br></pre></td></tr></table></figure><h4 id="快速初始化数组"><a href="#快速初始化数组" class="headerlink" title="快速初始化数组"></a>快速初始化数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这个函数是按字节初始化的</span></span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">-1</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> nums);</span><br></pre></td></tr></table></figure><h4 id="C-11的特性"><a href="#C-11的特性" class="headerlink" title="C++11的特性"></a>C++11的特性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> ListNode(); <span class="comment">// auto 关键字</span></span><br><span class="line">Node* pre = <span class="literal">nullptr</span>   <span class="comment">// nullptr代替NULL</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp; <span class="comment">//哈希表 内部是无序的</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">//无序集合</span></span><br></pre></td></tr></table></figure><h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(n).to_string();</span><br><span class="line">    reverse(s.begin(), s.end());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(s).to_ulong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><p>将字符串按照空格分割</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world my name is yao jun&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; str)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>hello</p><p>world</p><p>my</p><p>name</p><p>is</p><p>yao</p><p>jun</p><p>7</p></blockquote><h4 id="四舍五入保留小数"><a href="#四舍五入保留小数" class="headerlink" title="四舍五入保留小数"></a>四舍五入保留小数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">double</span> num = <span class="number">22.23434</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;%.2f&quot;</span>, num);</span><br><span class="line"><span class="built_in">string</span> s = str;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串按格式拆分"><a href="#字符串按格式拆分" class="headerlink" title="字符串按格式拆分"></a>字符串按格式拆分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;12:59:36&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(str2, a.c_str(), <span class="built_in">strlen</span>(a.c_str()));</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">sscanf</span>(str2, <span class="string">&quot;%d:%d:%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;w&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>12 59 36</p></blockquote><h4 id="相同字符的字符串"><a href="#相同字符的字符串" class="headerlink" title="相同字符的字符串"></a>相同字符的字符串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果:</p><p>aaaaaaaaaa</p></blockquote><h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; node_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; tt;</span><br><span class="line">    tt.push_back(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    tt.push_back(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    sort(tt.begin(), tt.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node: tt)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;node.b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>1 5</p><p>2 3</p></blockquote><h4 id="优先队列自定义排序"><a href="#优先队列自定义排序" class="headerlink" title="优先队列自定义排序"></a>优先队列自定义排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="comment">// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; node_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line">    pq.push(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    pq.push(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    pq.push(&#123;<span class="number">2</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pq.top().a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pq.top().b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果</p><p>2 5</p><p>2 3</p><p>1 5</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-C-常用刷题技巧&quot;&gt;&lt;a href=&quot;#C-C-常用刷题技巧&quot; class=&quot;headerlink&quot; title=&quot;C/C++常用刷题技巧&quot;&gt;&lt;/a&gt;C/C++常用刷题技巧&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;万能头文件&lt;/strong&gt;&lt;/p&gt;
&lt;blockquo</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://okeyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>QT学习笔记</title>
    <link href="http://okeyia.github.io/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://okeyia.github.io/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-08-16T08:08:03.000Z</published>
    <updated>2022-11-26T03:05:37.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QT学习笔记"><a href="#QT学习笔记" class="headerlink" title="QT学习笔记"></a>QT学习笔记</h2><hr><p>未完待续。。。。。。 预计寒假期间完成</p><hr><h3 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h3><h4 id="pro-配置文件"><a href="#pro-配置文件" class="headerlink" title=".pro 配置文件"></a>.pro 配置文件</h4><h4 id="QT注意事项"><a href="#QT注意事项" class="headerlink" title="QT注意事项"></a>QT注意事项</h4><ul><li><p>命名规范</p><ul><li>类名 首字母大写，单词和单词之间首字母大写</li><li>函数名 变量名称 首字母小写,单词和单词之间首字母大写</li></ul></li><li><p>快捷键</p><ul><li>注释 ctrl + /</li><li>运行 ctrl + r</li><li>编译 ctrl + b</li><li>查找 ctrl + f</li><li>帮助文档 F1</li><li>自动对齐 ctrl + i</li><li>同名的.h和.cpp切换 F4</li></ul></li></ul><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><ul><li>按钮常用API</li></ul><ol><li>show() 以顶层方式弹出窗口控件</li><li>setParent() 选择依赖方式</li><li>setText() 设置文本</li><li>resize() 重置窗口大小</li><li>move() 移动</li><li>setWindowTitle() 设置窗口大小</li><li>setFixedSize() 设置固定窗口大小</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line"><span class="comment">// btn-&gt;show();</span></span><br><span class="line"><span class="comment">// 让 btn 对象依赖于myWidget 中</span></span><br><span class="line">btn-&gt;setParent(<span class="keyword">this</span>);</span><br><span class="line">btn-&gt;setText(<span class="string">&quot;第一个按钮&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="QT中的对象树"><a href="#QT中的对象树" class="headerlink" title="QT中的对象树"></a>QT中的对象树</h4><ol><li>当创建的对象在堆区的时候,如果指定的父亲是QObject 派生下来的类或者子类</li><li>派生下来的类,可以不需要管理释放操作,会将对象放入对象树一定程度上简化了内存回收机制</li></ol><p>这里的话 ,打印顺序是反的, 是先打印了代码, 但是对象还没有释放掉。 正确的理解过程是先释放 我的按钮类 析构， 然后myWidget类析构 调用。</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220818125200089.png" class="" title="image-20220818125200089"><h4 id="QT的窗口坐标系"><a href="#QT的窗口坐标系" class="headerlink" title="QT的窗口坐标系"></a>QT的窗口坐标系</h4><ol><li>笛卡尔坐标系[左上角为0,0点]</li></ol><h4 id="QT信号和槽"><a href="#QT信号和槽" class="headerlink" title="QT信号和槽"></a>QT信号和槽</h4><p>connect( 信号的发送者 ,信号的具体信息(函数的地址), 信号的接受者,信号的处理(槽)(也是函数的地址))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求:点击 &quot;我的按钮&quot; 关闭窗口</span></span><br><span class="line">connect(mybtn3,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;myWidget::close);</span><br></pre></td></tr></table></figure><ul><li>信号槽的优点 松散耦合,信号发送端 和 接收端本身是没有关联的,通过connectl连接,将两者耦合在一起<ul><li>信号关键字：Signals<ul><li>chlicked(bool) 点击</li><li>pressed() 按下</li><li>released() 释放</li><li>toggled(bool) 切换状态</li></ul></li><li>槽的关键字：Slots</li></ul></li><li>自定义信号和槽位函数<ul><li>自定义信号<ul><li>写在类的signals下,返回值为void,可以有参数,支持重载,不需要实现</li></ul></li><li>自定义槽函数<ul><li>不能写在signals下,public slots[公共的槽函数] 5.4版本以后全局函数或者public都行</li><li>返回值也是void,需要声明,也需要实现,可以有参数,支持重载</li></ul></li><li>然后用connect连接信号和槽</li><li>触发信号 emit</li><li>信号和槽重载，需要函数指针，明确指向函数的地址</li><li>QString 转char * 使用.toUtf8().data()</li><li>信号和槽连接：触发这个信号才能触发槽<ul><li>一个信号可以连接多个槽</li><li>多个信号也可以连接同一个槽函数</li><li>信号和槽的参数和类型必须对应</li><li>信号的参数个数可以多于槽的参数个数</li></ul></li><li>信号和信号连接 触发一个信号也能触发另外一个信号</li><li>断开信号 disconnect(参数一样)</li></ul></li></ul><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><ul><li>C++11版本特性 [CONFIG += c++11] 匿名函数对象<ul><li>Lambda表达式函数声明 <code>[]()&#123;&#125;</code><ul><li>[=] 允许使用局部变量</li><li>[&amp;] 允许使用引用传递变量</li><li>[变量] 允许变量使用值传递</li><li>mutable 可修改值传递进来的参数[虽然还是局部变量]<ul><li><code>[m]()mutable&#123;m+=100;打印&#125;;</code> 不加mutable会报错</li></ul></li><li>-&gt;类型 带返回值<ul><li><code>int ret = []()-&gt;int&#123;return 1000&#125;();</code></li></ul></li></ul></li><li>Lambda表达式函数调用 <code>[]()&#123;&#125;()</code></li><li>最常见的<code>[=]()&#123;&#125;</code></li></ul></li></ul><h3 id="MainWindow"><a href="#MainWindow" class="headerlink" title="MainWindow"></a>MainWindow</h3><h4 id="菜单栏-QMenuBar"><a href="#菜单栏-QMenuBar" class="headerlink" title="菜单栏 QMenuBar"></a>菜单栏 QMenuBar</h4><pre><code>* 菜单栏最多只能有一个    + QMenuBar * bar = menuBar(); setMenuBar(bar);    + 创建菜单        * QMenu * fileMenu = bar-&gt;addMenu(&quot;文件&quot;);            + 创建菜单栏目                * QAction * newAction =  fileMenu-&gt;addAction(&quot;新建&quot;);            + 添加分隔符                 * fileMenu-&gt;addSeparator();</code></pre><h4 id="工具栏-QToolBar"><a href="#工具栏-QToolBar" class="headerlink" title="工具栏 QToolBar"></a>工具栏 QToolBar</h4><pre><code>* 工具栏可以有多个    + QToolBar * toolBar = new QToolBar(this);      + addToolBar(toolBar);        * 可选参数 默认停靠范围            + addToolBar(Qt::BottomToolBarArea,toolBar);        * 只允许左右停靠            + toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea);        * 取消浮动            + toolBar-&gt;setFloatable(false);        * 设置禁止移动            + toolBar-&gt;setMovable(false);        * 给工具栏设置栏目            + toolBar-&gt;addAction(&quot;绝了&quot;或者QAction);        * 给工具栏添加控件            + toolBar-&gt;addWidget(QPushButton按钮);</code></pre><h4 id="状态栏-QStatusBar"><a href="#状态栏-QStatusBar" class="headerlink" title="状态栏 QStatusBar"></a>状态栏 QStatusBar</h4><pre><code>* 状态栏最多只能有一个    + QStatusBar * stBar = statusBar();    + setStatusBar(stBar);        * 添加标签控件            + QLabel * label = new QLabel(&quot;左侧提示的信息&quot;,this);            + QLabel * label1 = new QLabel(&quot;右侧提示的信息&quot;,this);            + stBar-&gt;addWidget(label);            + stBar-&gt;addPermanentWidget(label1);</code></pre><h4 id="铆接部件-QDockWidget"><a href="#铆接部件-QDockWidget" class="headerlink" title="铆接部件 QDockWidget"></a>铆接部件 QDockWidget</h4><pre><code>* 铆接部件可以有多个    + QDockWidget * dockWidget = new QDockWidget(&quot;浮动&quot;,this);    + addDockWidget(Qt::BottomDockWidgetArea,dockWidget); 放置位置下面 如果没有中心部件默认占满        + 只允许上下                * dockWidget-&gt;setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);  </code></pre><h4 id="中心部件"><a href="#中心部件" class="headerlink" title="中心部件"></a>中心部件</h4><pre><code>* 中心内容也只能有一个    + 文本窗口 QTextEdit        + QTextEdit * edit = new QTextEdit(this);        + setCentralWidget(edit); //设置中心部件</code></pre><h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><ol><li>将图片文件文件夹拷贝到项目下</li><li>右键项目-&gt;添加新文件-&gt;Qt-&gt;Qt recourse File</li><li>res 生成 res.qrc</li><li>右键res.qrc-&gt;open in editor 编辑资源</li><li>添加前缀 添加文件</li><li>使用 “: + 前缀名 + 文件名”</li></ol><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><pre><code>+ 只能有一个的是set 可以允许多个是add</code></pre><h4 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h4><ul><li>模态对话框 不可以对其他窗口进行操作<ul><li>QDialog dlg(this);</li><li>dlg.exec();</li><li>消息对话框<ul><li>错误对话框 QMessageBox::critical(this,”critical”,”错误”);</li><li>信息对话框 information</li><li>提问对话框 question</li><li>警告对话框warning</li><li>颜色对话框<ul><li>QColor a = QColorDialog::getColor(QColor(255,0,0));</li></ul></li><li>文件对话框 最后一个是过滤<ul><li>QString str = QFileDialog::getOpenFileName(this,”打开文件”,”./“,”(*.cpp)”);</li></ul></li><li>字体对话框<ul><li>bool flag;</li><li>QFont font = QFontDialog::getFont(&amp;flag,QFont(“华文彩云”,12));</li><li>setFont(font);//设置字体</li></ul></li></ul></li></ul></li><li>非模态对话框 可以对其他窗口进行操作<ul><li>QDialog *dlg2 = new QDialog(this); //为了确保不释放,开在堆上</li><li>dlg2-&gt;show();</li><li>dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose);//55号 用于按关闭键自动释放[QWidge的对象树是在关闭总的窗口才会全部释放]</li></ul></li></ul><h4 id="列表控件-listWidget"><a href="#列表控件-listWidget" class="headerlink" title="列表控件 listWidget"></a>列表控件 listWidget</h4><ul><li>QListWidgetItem * item = new QListWidgetItem(“锄禾日当午”);</li><li>ui-&gt;listWidget-&gt;addItem(item); //添加进去</li><li>item-&gt;setTextAlignment(Qt::AlignCenter); //居中</li></ul><h4 id="ui窗口自布局"><a href="#ui窗口自布局" class="headerlink" title="ui窗口自布局"></a>ui窗口自布局</h4><ol><li>Spacers 弹簧 Widget div盒子</li><li>Group Box 分组[适用于Radio Button]</li><li>主窗口设置垂直布局后可以在sizePolicy-&gt;垂直策略-&gt;Fixed来使组件高度合适</li><li>如果找不到某个组件的信号或者槽，找基类</li></ol><h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><ol><li>add new -&gt; 设计师类</li><li>使用自定义组件<ul><li>查看基类[如widget] 从界面库中拖出来一个widget组件,然后点击提升为,写入类名<ul><li>[设置全局后可以直接在右键中显示]<br>3 自定义组件只有同基类才能被提升</li></ul></li></ul></li></ol><h4 id="QT事件-QEvent"><a href="#QT事件-QEvent" class="headerlink" title="QT事件 QEvent"></a>QT事件 QEvent</h4><ul><li><p>鼠标事件</p><ul><li>事件是虚函数,可以进行重载<br>//鼠标进入事件<br>virtual void enterEvent(QEvent *event);<br>//鼠标离开事件<br>virtual void leaveEvent(QEvent *event);<br>//鼠标按下<br>virtual void mouseReleaseEvent(QMouseEvent *ev);<br>//鼠标释放<br>virtual void mousePressEvent(QMouseEvent *ev);<br>//鼠标移动<br>virtual void mouseMoveEvent(QMouseEvent *ev);  </li></ul></li><li><p>定时器 QTimeEvent</p><ul><li>利用事件实现定时器<ul><li>startTimer(1000); 启动定时器，单位毫秒,返回一个唯一定时器id</li><li>void timerEvent(QTimerEvent * ev)<ul><li>定时器函数,可以通过ev-&gt;timerId()== id1来判断当前是哪个id进来的</li></ul></li></ul></li><li>定时器类QTimer<ul><li>//通过定时器类<br>  QTimer * timer = new QTimer(this);<br>  //启动定时器 每隔500秒发一个信号<br>  timer-&gt;start(500);<br>  //连接信号<br>  connect(timer,&amp;QTimer::timeout,中括号小括号{<br>  static int num = 1;<br>  ui-&gt;label_5-&gt;setText(QString::number(num++));<br>  });  </li></ul></li></ul></li><li><p>event事件分发器</p><ul><li>bool event(QEvent * ev)<ul><li>返回值是bool类型，如果返回true，代表用户要处理这个事件,不向下分发事件了[类似于钩子]</li></ul></li><li>事件枚举QEvent<ul><li>ev.type();</li><li>拦截后使用子类的操作可以使用静态类型转换<ul><li>QMouseEvent *ev = static_cast&lt;QMouseEvent *&gt;(QEvent中行参);</li></ul></li></ul></li><li>但是尽量别拦截</li></ul></li><li><p>事件过滤器</p><ul><li>在app到事件分发器前还能做个过滤</li><li>使用方式<ul><li>给控件安装时间过滤器<ul><li>installEventFilter(this);</li></ul></li><li>重写eventfilter事件</li></ul></li></ul></li></ul><h4 id="绘图-QPainter"><a href="#绘图-QPainter" class="headerlink" title="绘图 QPainter"></a>绘图 QPainter</h4><ul><li>绘图事件 void paintEvent(QPaintEvent *)</li><li>画家类 QPainter(构图的设备)<ul><li>拿起笔 .setPen(笔)</li><li>拿起刷子 .setBrush(刷子)</li></ul></li><li>画笔类 QPen(笔的颜色)</li><li>画刷类 QBrush(笔的颜色)</li><li>高级操作<ul><li>效率降低的抗锯齿<ul><li>painter.setRenderHint()</li></ul></li><li>改变画家位置<ul><li>painter.save();保存当前位置</li><li>painter.restore(); 还原到保存的位置</li><li>painter.translate(); 移动画家</li></ul></li><li>画家绘制图片drawPixmap</li></ul></li></ul><h4 id="绘图设备"><a href="#绘图设备" class="headerlink" title="绘图设备"></a>绘图设备</h4><ul><li>QPixmap 专门对图像显示做了优化</li><li>QBitmap 色深限定为1</li><li>QImage 专门为图像的像素级访问做了优化</li><li>QPicture 可以记录和重视画家的QPainter的各类命令<ul><li>自定义绘图操作 </li></ul></li></ul><h4 id="文件读写-QFile"><a href="#文件读写-QFile" class="headerlink" title="文件读写 QFile"></a>文件读写 QFile</h4><ul><li>file.open(打开方式) QtODevice::readOnly</li><li>全部读取 file.readAll() 按行读 file.readLine() 判断文件末尾atend()</li><li>QFile默认支持的是utf-8 指定格式 QTextCodec<ul><li>QTextCodec *codec = QTextCodec::codecForName(“gbk”);</li><li>ui-&gt;textEdit-&gt;setText(codec-&gt;toUnicode(array)); </li></ul></li><li>关闭文件对象 file.close();</li></ul><h4 id="文件信息-QFileInfo"><a href="#文件信息-QFileInfo" class="headerlink" title="文件信息 QFileInfo"></a>文件信息 QFileInfo</h4><ul><li>QFileInfo info(path);</li><li>后缀名 info.suffix()</li><li>创建日期 info.birthTime().toString(“yyyy/MM/dd hh:mm:ss”);</li><li>修改日期 info.lastModified().toString(“yyyy/MM/dd hh:mm:ss”);</li></ul><h4 id="Qss-前端人狂喜"><a href="#Qss-前端人狂喜" class="headerlink" title="Qss 前端人狂喜"></a>Qss 前端人狂喜</h4><ul><li>#myButton 这里的id实际上就是objectName指定的值</li><li>伪状态<ul><li>:active 当小部件驻留在活动窗口中时，将设置此状态</li><li>:checked    该控件被选中时候的状态</li><li>:hover    鼠标在控件上方</li><li>:pressed    该控件被按下时的状态</li><li>:disabled    该控件禁用时的状态</li><li>:first    该控件是第一个（列表中）</li><li>:focus    该控件有输入焦点时</li></ul></li></ul><h4 id="动画-QPropertyAnimation"><a href="#动画-QPropertyAnimation" class="headerlink" title="动画 QPropertyAnimation"></a>动画 QPropertyAnimation</h4><p>//winLabel 你要对那个组件使用动画  geometry几何结构<br>QPropertyAnimation * an = new QPropertyAnimation(winLabel,”geometry”);<br>//动画时间<br>an-&gt;setDuration(1000);<br>//动画开始<br>an-&gt;setStartValue(QRect(winLabel-&gt;x(),winLabel-&gt;y(),winLabel-&gt;width(),winLabel-&gt;height()));<br>//动画结束<br>an-&gt;setEndValue(QRect(winLabel-&gt;x(),winLabel-&gt;y() + 300,winLabel-&gt;width(),winLabel-&gt;height()));<br>//动画方式<br>an-&gt;setEasingCurve(QEasingCurve::OutBounce);<br>an-&gt;start();  </p><h4 id="背景音乐-QSound"><a href="#背景音乐-QSound" class="headerlink" title="背景音乐 QSound"></a>背景音乐 QSound</h4><ul><li>qmake: QT += multimedia</li><li>QSound * startSound = new QSound(“:/res/TapButtonSound.wav”,this); 载入音效</li><li>startSound-&gt;play(); 播放</li><li>startSound-&gt;setLoops(-1); -1循环次数无限</li></ul><h4 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h4><ul><li>debug-&gt;release</li><li>运行 运行失败添加环境变量D:\QT\5.12.3\mingw73_64\lib</li><li>把 Goldreverse.exe 单独丢到一个文件夹下</li><li>cmd中路径后windeployqt .\Goldreverse.exe 运行</li><li>此时已经可以使用了</li><li>深入打包[hm nis edit][<a href="https://www.bilibili.com/video/BV1g4411H78N?p=63&amp;spm_id_from=pageDriver%5D">https://www.bilibili.com/video/BV1g4411H78N?p=63&amp;spm_id_from=pageDriver]</a></li><li>HM NIS Edit 和 NSIS</li></ul><h3 id="Qt-amp-Clion-配置"><a href="#Qt-amp-Clion-配置" class="headerlink" title="Qt &amp; Clion 配置"></a>Qt &amp; Clion 配置</h3><h4 id="工具链的配置"><a href="#工具链的配置" class="headerlink" title="工具链的配置"></a>工具链的配置</h4><p>主要是配置工具链中的工具集，注意选中qt安装路径中的mingw</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221105202452526.png" class="" title="image-20221105202452526"><h4 id="CmakeList中的设置"><a href="#CmakeList中的设置" class="headerlink" title="CmakeList中的设置"></a>CmakeList中的设置</h4><p>在CmakeList中设置CMAKE_PREFIX_PATH 为 Qt安装路径中的cmake</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221105202714141.png" class="" title="image-20221105202714141"><h4 id="关于乱码问题"><a href="#关于乱码问题" class="headerlink" title="关于乱码问题"></a>关于乱码问题</h4><p>写入到student.text中的数据, 打开是乱码, 暂时还没有解决</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://blog.csdn.net/qq_41622214/article/details/124776481?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-124776481-blog-115482634.pc_relevant_multi_platform_whitelistv3&spm=1001.2101.3001.4242.1&utm_relevant_index=3">CLion配置Qt环境</a></li></ol><h3 id="案例一-翻金币"><a href="#案例一-翻金币" class="headerlink" title="案例一: 翻金币"></a>案例一: 翻金币</h3><hr><p><a href="https://www.bilibili.com/video/BV1g4411H78N?p=52&vd_source=d4177fc7398a75956465a504f7fd3259">视频链接</a></p><ul><li>收获<ol><li>删除资源文件后需要删除debug文件,不然会报错</li><li>界面的切换可以使用信号和槽 即其它界面emit发送一个信号,主界面接收<ul><li>当然也可以选择记录父类指针,但是必须要在构造函数中多传个参数，而不是使用默认的parent</li></ul></li><li>在按钮上方有其他组件，可以使用label-&gt;setAttribute(Qt::WA_TransparentForMouseEvents);让其可以点到按钮[51号属性]</li><li>界面翻转金币 本质上是个按钮 <ul><li>人点击后 </li><li>金币触发翻转</li><li>定时器每隔30ms发送一次信号给金币</li><li>金币触发图片重新放置,到最大值或者最小值的时候关闭定时器</li><li>金币中有坐标i 和 j 以及一个flag 来确定该金币在页面中的位置</li></ul></li><li>锁定窗口 m_chooseScence-&gt;setGeometry(this-&gt;geometry()); 每次进入或者退出都锁定他的位置</li></ol></li><li>延时器<br>QTimer::singleShot(毫秒,拉姆达表达式);</li></ul><h3 id="案例二-学生管理"><a href="#案例二-学生管理" class="headerlink" title="案例二: 学生管理"></a>案例二: 学生管理</h3><hr><p>参考大佬的代码, 建议连接上数据库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;QT学习笔记&quot;&gt;&lt;a href=&quot;#QT学习笔记&quot; class=&quot;headerlink&quot; title=&quot;QT学习笔记&quot;&gt;&lt;/a&gt;QT学习笔记&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;未完待续。。。。。。 预计寒假期间完成&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;QWidget&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Processor Counter Monitor</title>
    <link href="http://okeyia.github.io/2022/07/27/Processor_Counter_Monitor/"/>
    <id>http://okeyia.github.io/2022/07/27/Processor_Counter_Monitor/</id>
    <published>2022-07-26T16:08:58.000Z</published>
    <updated>2022-11-06T05:08:30.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Processor-Counter-Monitor测量cache及带宽"><a href="#Processor-Counter-Monitor测量cache及带宽" class="headerlink" title="Processor-Counter-Monitor测量cache及带宽"></a>Processor-Counter-Monitor测量cache及带宽</h2><p>Performance Counter Monitor（PCM）是一个由英特尔开发的，也是基于PMU(performance monitoring unit)一个性能检测工具。</p><p>它是运行在msr 内核模块(perf是内核系统调用吧？)上的，提供了C++ API。</p><ul><li>pcm：CPU、cache</li><li>pcm-memory：内存带宽（每频道及每个DRAM DIMM槽）</li><li>pcm-latency：L1 cahce</li><li>pcm-pcie：PCIe</li><li>pcm-numa：NUMA架构</li><li>pcm-power：能耗</li></ul><p><a href="https://github.com/opcm/pcm">最新版</a> , 复现论文[Saga-Bench: Software and Hardware Characterization of Streaming Graph Analytics Workloads] 的过程中, <a href="https://github.com/opcm/pcm/tree/91dbfaaf1a956c669de6cb705e033bd28e313ef7">用到的历史版本</a> 。 </p><h3 id="一-编译PCM"><a href="#一-编译PCM" class="headerlink" title="一 编译PCM"></a>一 编译PCM</h3><p>从 <code>github</code> 下载好源码, 进行编译,  编译完成后, 测试实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">0.1秒监测一次，结果输出为test.csv文件</span></span><br><span class="line">sudo ./pcm.x 0.1 -csv=test.csv --external-program Test</span><br></pre></td></tr></table></figure><p>第一次运行可能会出现如下错误:</p><blockquote><p>PCM Error: can’t open MSR handle for core 0<br>Can not access CPUs Model Specific Registers (MSRs).<br>Try to execute ‘modprobe msr’ as root user and then<br>you also must have read and write permissions for /dev/cpu/<em>/msr devices (/dev/msr</em> for Android). The ‘chown’ command can help.<br>Access to Processor Counter Monitor has denied (no MSR or PCI CFG space access).</p></blockquote><p>解决方法, 切换到 root 用户, 执行 modprobe msr 。</p><h3 id="二-测量L2-L3-cache的缺失率"><a href="#二-测量L2-L3-cache的缺失率" class="headerlink" title="二 测量L2 L3 cache的缺失率"></a>二 测量L2 L3 cache的缺失率</h3><h4 id="2-1-pcmBasic-h"><a href="#2-1-pcmBasic-h" class="headerlink" title="2.1 pcmBasic.h"></a>2.1 pcmBasic.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCMBasic_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCMBasic_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/cpucounters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">CounterStateType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_processor_level_stats</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; out, <span class="keyword">const</span> PCM * m, <span class="keyword">const</span> CounterStateType &amp; state1, <span class="keyword">const</span> CounterStateType &amp; state2)</span></span>&#123;</span><br><span class="line">    assert(out.is_open());</span><br><span class="line">    <span class="comment">/* Output format/order: L2 MPKI, L3 MPKI, L2 hit rate, LLC hit rate, TLP (active cycles method), TLP (C state method = BigBench paper&#x27;s method)</span></span><br><span class="line"><span class="comment">     incoming QPI link utilization, outgoing QPI link utilization */</span></span><br><span class="line">    assert(m-&gt;isL2CacheMissesAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL3CacheMissesAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL2CacheHitRatioAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL3CacheHitRatioAvailable());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> uint32 qpiLinks = (uint32)m-&gt;getQPILinksPerSocket();    </span><br><span class="line">    <span class="keyword">double</span> incoming = <span class="number">0.0</span>; <span class="keyword">double</span> outgoing = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 i = <span class="number">0</span>; i &lt; m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (uint32 l = <span class="number">0</span>; l &lt; qpiLinks; ++l)&#123;</span><br><span class="line">            incoming += <span class="number">100.</span> * getIncomingQPILinkUtilization(i, l, state1, state2);</span><br><span class="line">            outgoing += <span class="number">100.</span> * getOutgoingQPILinkUtilization(i, l, state1, state2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> overallIncomingQPILinkUitlization = incoming / (m-&gt;getNumSockets() * qpiLinks);</span><br><span class="line">    <span class="keyword">double</span> overallOutgoingQPILinkUitlization = outgoing / (m-&gt;getNumSockets() * qpiLinks);</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; (<span class="keyword">double</span>(getL2CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2)) * <span class="number">1000</span> &lt;&lt; <span class="string">&quot;,&quot;</span> </span><br><span class="line">    <span class="comment">// L3 MPKI</span></span><br><span class="line">    &lt;&lt; (<span class="keyword">double</span>(getL3CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2)) * <span class="number">1000</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getL2CacheHitRatio(state1, state2) &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getL3CacheHitRatio(state1, state2) &lt;&lt; <span class="string">&quot;,&quot;</span>   </span><br><span class="line">    &lt;&lt; (<span class="keyword">double</span>(getCycles(state1, state2))/getInvariantTSC(state1, state2)) * <span class="number">100</span>  &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getCoreCStateResidency(<span class="number">0</span>, state1, state2)*<span class="number">100.</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; overallIncomingQPILinkUitlization &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; overallOutgoingQPILinkUitlization &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">CounterStateType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_processor</span><span class="params">(<span class="keyword">const</span> PCM * m, <span class="keyword">const</span> CounterStateType &amp; state1, <span class="keyword">const</span> CounterStateType &amp; state2, <span class="keyword">bool</span> update)</span></span>&#123;</span><br><span class="line">    ofstream out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(update)&#123;</span><br><span class="line">        out.open(<span class="string">&quot;UpdateProcLevel.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app); </span><br><span class="line">        display_processor_level_stats(out, m, state1, state2); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        out.open(<span class="string">&quot;AlgProcLevel.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app); </span><br><span class="line">        display_processor_level_stats(out, m, state1, state2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out.close();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCMBasic_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="2-2-调用实现"><a href="#2-2-调用实现" class="headerlink" title="2.2 调用实现"></a>2.2 调用实现</h4><p>注意: 调用程序的源码中使用 <code>#include pcmBasic.h</code> 包含头文件 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ######################### PCM Memory initialization Start ########################</span></span><br><span class="line">    PCM* m = PCM::getInstance();    </span><br><span class="line">    <span class="keyword">bool</span> PMM = <span class="literal">false</span>, update = <span class="literal">false</span>; <span class="keyword">int</span> rankA = <span class="number">-1</span>, rankB = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;hasPCICFGUncore())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Unsupported processor model (&quot;</span> &lt;&lt; m-&gt;getCPUModel() &lt;&lt; <span class="string">&quot;).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (m-&gt;memoryTrafficMetricsAvailable())</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;For processor-level memory bandwidth statistics please use pcm.x&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    ServerUncorePowerState * BeforeState = <span class="keyword">new</span> ServerUncorePowerState[m-&gt;getNumSockets()];</span><br><span class="line">    ServerUncorePowerState * AfterState = <span class="keyword">new</span> ServerUncorePowerState[m-&gt;getNumSockets()];</span><br><span class="line">    uint64 BeforeTime = <span class="number">0</span>, AfterTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before counter states     </span></span><br><span class="line">    <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i&lt;m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        BeforeState[i] = m-&gt;getServerUncorePowerState(i); </span><br><span class="line">    &#125;</span><br><span class="line">    BeforeTime = m-&gt;getTickCount();        </span><br><span class="line">    <span class="comment">// ####################### PCM Memory initialization Done #######################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// ######################### PCM Memory finalization Start ########################</span></span><br><span class="line">    AfterTime = m-&gt;getTickCount();</span><br><span class="line">    <span class="comment">// after counter states     </span></span><br><span class="line">    <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i&lt;m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        AfterState[i] = m-&gt;getServerUncorePowerState(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calculate_bandwidth(m, BeforeState, AfterState, AfterTime-BeforeTime, update, PMM);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] BeforeState;</span><br><span class="line">    <span class="keyword">delete</span>[] AfterState;</span><br><span class="line">    m-&gt;cleanup();</span><br><span class="line">    <span class="comment">// ###################### PCM Memory finalization Done #################</span></span><br></pre></td></tr></table></figure><h3 id="三-测量内存带宽"><a href="#三-测量内存带宽" class="headerlink" title="三 测量内存带宽"></a>三 测量内存带宽</h3><h4 id="3-1-pcmMemory-h"><a href="#3-1-pcmMemory-h" class="headerlink" title="3.1 pcmMemory.h"></a>3.1 pcmMemory.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCMMemory_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCMMemory_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处更改为pcm的路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/cpucounters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Programmable iMC counter</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_RANK_A 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_RANK_A 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_RANK_B 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_RANK_B 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARTIAL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMM_READ 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMM_WRITE 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NM_HIT 0  <span class="comment">// NM :  Near Memory (DRAM cache) in Memory Mode</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_DELAY_DEFAULT 1.0 <span class="comment">// in seconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_DELAY_MIN 0.015 <span class="comment">// 15 milliseconds is practical on most modern CPUs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_CALIBRATION_INTERVAL 50 <span class="comment">// calibrate clock only every 50th iteration</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uint32 max_sockets = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> uint32 max_imc_channels = ServerUncorePowerState::maxChannels;</span><br><span class="line"><span class="keyword">const</span> uint32 max_edc_channels = ServerUncorePowerState::maxChannels;</span><br><span class="line"><span class="keyword">const</span> uint32 max_imc_controllers = ServerUncorePowerState::maxControllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">memdata</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> iMC_Rd_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_Wr_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Rd_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Wr_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_Wr_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Wr_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> M2M_NM_read_hit_rate[max_sockets][max_imc_controllers];</span><br><span class="line">    <span class="keyword">float</span> EDC_Rd_socket_chan[max_sockets][max_edc_channels];</span><br><span class="line">    <span class="keyword">float</span> EDC_Wr_socket_chan[max_sockets][max_edc_channels];</span><br><span class="line">    <span class="keyword">float</span> EDC_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> EDC_Wr_socket[max_sockets];</span><br><span class="line">    uint64 partial_write[max_sockets];</span><br><span class="line">    <span class="keyword">bool</span> PMM;</span><br><span class="line">&#125; <span class="keyword">memdata_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output format: </span></span><br><span class="line"><span class="comment">socket(i) read bW, socket(i) write BW for all i; system read BW; system write BW; system total BW</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_bandwidth_alg</span><span class="params">(PCM *m, <span class="keyword">memdata_t</span> *md)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sysReadDRAM = <span class="number">0.0</span>, sysWriteDRAM = <span class="number">0.0</span>, total = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;AlgMem.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)&#123;</span><br><span class="line">        out &lt;&lt; md-&gt;iMC_Rd_socket[skt] <span class="comment">/* socket read BW (MB/s) */</span> &lt;&lt;  <span class="string">&quot;,&quot;</span> &lt;&lt; md-&gt;iMC_Wr_socket[skt] <span class="comment">/* socket write BW (MB/s) */</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;       </span><br><span class="line">        sysReadDRAM += md-&gt;iMC_Rd_socket[skt];   <span class="comment">// system read BW (MB/s)</span></span><br><span class="line">        sysWriteDRAM += md-&gt;iMC_Wr_socket[skt];  <span class="comment">// system write BW (MB/s)      </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total = sysReadDRAM + sysWriteDRAM;</span><br><span class="line">    out &lt;&lt; sysReadDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sysWriteDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_bandwidth_update</span><span class="params">(PCM *m, <span class="keyword">memdata_t</span> *md)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sysReadDRAM = <span class="number">0.0</span>, sysWriteDRAM = <span class="number">0.0</span>, total = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;UpdateMem.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)&#123;</span><br><span class="line">        out &lt;&lt; md-&gt;iMC_Rd_socket[skt] <span class="comment">/* socket read BW (MB/s) */</span> &lt;&lt;  <span class="string">&quot;,&quot;</span> &lt;&lt; md-&gt;iMC_Wr_socket[skt] <span class="comment">/* socket write BW (MB/s) */</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;        </span><br><span class="line">        sysReadDRAM += md-&gt;iMC_Rd_socket[skt];   <span class="comment">// system read BW (MB/s)</span></span><br><span class="line">        sysWriteDRAM += md-&gt;iMC_Wr_socket[skt];  <span class="comment">// system write BW (MB/s)      </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total = sysReadDRAM + sysWriteDRAM;</span><br><span class="line">    out &lt;&lt; sysReadDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sysWriteDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate_bandwidth</span><span class="params">(PCM *m, <span class="keyword">const</span> ServerUncorePowerState uncState1[], <span class="keyword">const</span> ServerUncorePowerState uncState2[], uint64 elapsedTime, <span class="keyword">bool</span> update, <span class="keyword">bool</span> PMM)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//const uint32 num_imc_channels = m-&gt;getMCChannelsPerSocket();</span></span><br><span class="line">    <span class="comment">//const uint32 num_edc_channels = m-&gt;getEDCChannelsPerSocket();</span></span><br><span class="line">    <span class="keyword">memdata_t</span> md;</span><br><span class="line">    md.PMM = PMM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)</span><br><span class="line">    &#123;</span><br><span class="line">        md.iMC_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_PMM_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_PMM_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.EDC_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.EDC_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.partial_write[skt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i &lt; max_imc_controllers; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            md.M2M_NM_read_hit_rate[skt][i] = <span class="number">0.</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> uint32 numChannels1 = m-&gt;getMCChannels(skt, <span class="number">0</span>); <span class="comment">// number of channels in the first controller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(m-&gt;getCPUModel()) &#123;</span><br><span class="line"><span class="keyword">case</span> PCM::KNL:</span><br><span class="line">            <span class="keyword">for</span>(uint32 channel = <span class="number">0</span>; channel &lt; max_edc_channels; ++channel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getEDCCounter(channel,READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getEDCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.EDC_Rd_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                    md.EDC_Wr_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                md.EDC_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getEDCCounter(channel,READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                md.EDC_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getEDCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                md.EDC_Rd_socket[skt] += md.EDC_Rd_socket_chan[skt][channel];</span><br><span class="line">                md.EDC_Wr_socket[skt] += md.EDC_Wr_socket_chan[skt][channel];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">for</span>(uint32 channel = <span class="number">0</span>; channel &lt; max_imc_channels; ++channel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getMCCounter(channel,READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getMCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>) <span class="comment">//In case of JKT-EN, there are only three channels. Skip one and continue.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!PMM || (getMCCounter(channel,PMM_READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getMCCounter(channel,PMM_WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        md.iMC_Rd_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                        md.iMC_Wr_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                md.iMC_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                md.iMC_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                md.iMC_Rd_socket[skt] += md.iMC_Rd_socket_chan[skt][channel];</span><br><span class="line">                md.iMC_Wr_socket[skt] += md.iMC_Wr_socket_chan[skt][channel];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(PMM)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.iMC_PMM_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,PMM_READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                    md.iMC_PMM_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,PMM_WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                    md.iMC_PMM_Rd_socket[skt] += md.iMC_PMM_Rd_socket_chan[skt][channel];</span><br><span class="line">                    md.iMC_PMM_Wr_socket[skt] += md.iMC_PMM_Wr_socket_chan[skt][channel];</span><br><span class="line"></span><br><span class="line">                    md.M2M_NM_read_hit_rate[skt][(channel &lt; numChannels1)?<span class="number">0</span>:<span class="number">1</span>] += (<span class="keyword">float</span>)getMCCounter(channel,READ,uncState1[skt],uncState2[skt]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    md.partial_write[skt] += (uint64) (getMCCounter(channel,PARTIAL,uncState1[skt],uncState2[skt]) / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span> (PMM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(uint32 c = <span class="number">0</span>; c &lt; max_imc_controllers; ++c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(md.M2M_NM_read_hit_rate[skt][c] != <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.M2M_NM_read_hit_rate[skt][c] = ((<span class="keyword">float</span>)getM2MCounter(c, NM_HIT, uncState1[skt],uncState2[skt]))/ md.M2M_NM_read_hit_rate[skt][c];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(update) display_bandwidth_update(m, &amp;md);</span><br><span class="line">    <span class="keyword">else</span> display_bandwidth_alg(m, &amp;md);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCMMemory_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="3-2-调用实现"><a href="#3-2-调用实现" class="headerlink" title="3.2 调用实现"></a>3.2 调用实现</h4><p>注意: 调用程序的源码中使用 <code>#include pcmMemory.h</code> 包含头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// #################### PCM Processor Level Stats initialization Start #######################</span></span><br><span class="line">    PCM* m = PCM::getInstance();    </span><br><span class="line">    <span class="keyword">bool</span> update = <span class="literal">false</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CoreCounterState&gt; cstates1, cstates2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SocketCounterState&gt; sktstate1, sktstate2;</span><br><span class="line">    SystemCounterState sstate1, sstate2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before counter states     </span></span><br><span class="line">    m-&gt;getAllCounterStates(sstate1, sktstate1, cstates1);        </span><br><span class="line">    <span class="comment">// #################### PCM Processor Level Stats initialization Done ###################</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ################### PCM Processor Level Stats finalization Start ####################</span></span><br><span class="line">    <span class="comment">// after counter states     </span></span><br><span class="line">    m-&gt;getAllCounterStates(sstate2, sktstate2, cstates2);</span><br><span class="line"></span><br><span class="line">    display_processor(m, sstate1, sstate2, update);    </span><br><span class="line">    </span><br><span class="line">    m-&gt;cleanup();</span><br><span class="line">    <span class="comment">// ######################## PCM Processor Level Stats finalization Done ###################</span></span><br></pre></td></tr></table></figure><h3 id="四-编译连接"><a href="#四-编译连接" class="headerlink" title="四 编译连接"></a>四 编译连接</h3><p>makefile 的编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PCM_DIR := /home/server2/pcm</span><br><span class="line"></span><br><span class="line">PCM_HDR := $(wildcard $(PCM_DIR)/*.h)</span><br><span class="line">PCM_SRC := $(wildcard $(PCM_DIR)/*.cpp)</span><br><span class="line"><span class="meta">#</span><span class="bash">PCM_OBJ := $(patsubst %.cpp,%.o,$(wildcard $(PCM_DIR)/*.cpp))</span></span><br><span class="line">PCM_OBJ := msr.o cpucounters.o pci.o mmio.o client_bw.o utils.o</span><br><span class="line">PCM_OBJ := $(addprefix $(PCM_DIR)/,$(PCM_OBJ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALL= memory_footprint run_static_algorithm run_batch_updates run_simultaneous_updates_queries</span><br><span class="line">all: $(ALL)</span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash"> : tools/%.cpp $(PCM_OBJ)</span></span><br><span class="line">        $(CC) $(CFLAGS) $(PFLAGS) -o $@ $^ $(JEMALLOC)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(PCM_OBJ) : $(PCM_SRC)</span></span><br><span class="line">cd $(PCM_DIR) &amp;&amp; make -f $(PCM_DIR)/Makefile</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f *.o $(ALL)</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/abasak24/SAGA-Bench/tree/master/pcmResource">saga-Bench pcmResource</a> 的代码实现</li><li><a href="https://chhzh123.github.io/blogs/2019-02-19-pcm/">CPU/内存监视器</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Processor-Counter-Monitor测量cache及带宽&quot;&gt;&lt;a href=&quot;#Processor-Counter-Monitor测量cache及带宽&quot; class=&quot;headerlink&quot; title=&quot;Processor-Counter-Moni</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="http://okeyia.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Cache" scheme="http://okeyia.github.io/tags/Cache/"/>
    
    <category term="Bandwidth" scheme="http://okeyia.github.io/tags/Bandwidth/"/>
    
  </entry>
  
  <entry>
    <title>图处理相关论文</title>
    <link href="http://okeyia.github.io/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    <id>http://okeyia.github.io/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/</id>
    <published>2022-05-15T03:43:57.000Z</published>
    <updated>2022-11-17T09:45:45.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图处理的相关论文"><a href="#图处理的相关论文" class="headerlink" title="图处理的相关论文"></a>图处理的相关论文</h2><blockquote><p>Benchmark：主要是对比别人的方法，这个方法不一定是最好的，但一定是最具有代表性且被广泛认可的（一种标准和规范）。其所用的数据就是benchmark data，其方法就是benchmark method，你提出的方法在benchmark data上得出的结果与benchmark method 的结果对比才知道你的方法是否足够好。</p><p>baseline:  主要关注自己提出的方法，比最原始最简单的方法出来的结果（参照物）。然后在这个基础上改进，增加各种组件，可以看出提升多少，通过baseline我们可以知道这个方法能不能work, 有多少提升。</p></blockquote><h3 id="STINGER-流图的高性能数据结构"><a href="#STINGER-流图的高性能数据结构" class="headerlink" title="STINGER: 流图的高性能数据结构"></a>STINGER: 流图的高性能数据结构</h3><hr><blockquote><p> Stinger的关键属性是具有偏斜度分布的语义图上的快速插入，删除和更新。提出了一种新的数据结构，能够达到比较快的更新速度。</p></blockquote><p>正是由于在偏斜度分布的图上面进行的，所有才会使用batch 更新的方法，在batch 中  STINGER 的后续实现首先对批次进行排序（通常一次 100,000 条边更新），以便将发生在特定顶点上的所有边更新与插入分开的删除分组在一起。</p><p><strong>为什么会有batch</strong>        </p><blockquote><p>在具有许多线程上下文和内存库的系统上，数据结构中的工作量或并行性通常不足以一次处理单个更新。为了解决这个问题，我们开始批量处理边缘更新。一个批次摊销了进入数据结构的成本，并提供了大量的独立工作要做。</p></blockquote><p><strong>实验：</strong> 为什么采用batch 更新的方式，当batch 的大小发生变化的时候，每秒更新的变数会提高？ 每秒更新的边的个数是怎么计算的？</p><blockquote><p>我们测量处理数据结构中每个边缘更新所花费的时间。我们测量了几个批次，并以每秒更新的形式报告了性能。</p></blockquote><p><strong>进一步的优化:</strong>  </p><blockquote><p>然而，在无标度图中，少数顶点将面临多次更新，而大多数顶点只有一次更新或根本没有更新。这种工作负载不平衡限制了我们可以利用的并行量，并迫使大多数线程等待少数线程完成。</p></blockquote><p>为了解决这个问题，跳过了对边进行分类，并行的处理每条边的插入。但是，处理同一顶点上的两个边更新事件会引入竞争条件，必须通过适当的同步来处理。 并没有在软件商提出解决办法，而是使用Cray XMT 是这个场景的完美系统。（Cray XMT（Cray eXtreme MultiThreading，[1] 代号 Eldorado[2]）是 Cray 公司基于第三代 Tera MTA 架构的可扩展多线程共享内存超级计算机架构，针对大型图问题），但是这个系统近10年没有消息。</p><p><strong>缺点:</strong>  在整篇论文中只提到了更新，没有考虑查询的情况。</p><h3 id="图处理工作负载内存层次结构的分析与优化"><a href="#图处理工作负载内存层次结构的分析与优化" class="headerlink" title="图处理工作负载内存层次结构的分析与优化"></a>图处理工作负载内存层次结构的分析与优化</h3><p align = "right" > ——2019年发表在 `HPCA` 上面的一篇论文<p/><hr><p>Analysis and Optimization of the Memory Hierarchy for Graph Processing Workloads。</p><p><strong>提出问题:</strong> 在微架构级别，性能受到单机内存图分析的内存子系统效率低下的限制。本文的目标是解决单机内存图分析的内存效率低下问题。</p><ol><li>首先，我们在模拟的多核架构上对图形处理工作负载进行深入的数据类型感知表征。我们分析 1) 乱序内核中的内存级并行性和 2) 缓存层次结构中的请求重用距离。我们发现，涉及不同应用程序数据类型的加载-加载依赖链构成了实现高内存级并行性的主要瓶颈。我们还观察到不同的图数据类型表现出异构的重用距离。因此，私有 L2 缓存对性能的贡献可以忽略不计，而共享 L3 缓存表现出更高的性能敏感度。</li><li>基于他们的观察结构，提出了 DROPLET，这是一种用于图应用程序的数据感知解耦 预取器。 DROPLET 根据其固有的重用距离以不同的方式预取不同的图形数据类型。</li></ol><p>这里通过 <code>Using Cycle Stacks to Understand Scaling Bottlenecks in Multi-Threaded Workloads</code> 介绍的方法，使用pagerank 在 orkut上面 得到了 ==Cycle stack==。  45% 的周期是 DRAM 绑定的停顿周期，而内核被充分利用而仅在 15% 的周期内没有停顿。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221114164748773.png" class="" title="image-20221114164748773"><h4 id="一-借鉴的方向"><a href="#一-借鉴的方向" class="headerlink" title="一 借鉴的方向"></a>一 <strong>借鉴的方向</strong></h4><blockquote><p>现代 CPU 中使用的三种关键延迟容忍技术是 OoO 执行产生的 MLP、片上缓存(常说的三级cache)和预取。</p><p>OoO 执行依赖于重新排序缓冲区 (ROB) 向前看指令流，它可以在加载/存储队列、非阻塞缓存和 DRAM 中的并行性的帮助下支持多个正在运行的内存请求。</p></blockquote><p>这里主要参考优化的第一个方向,  通过两个特征来深入了解fig 1中的内存受限行为</p><ol><li>乱序执行中的内存级并行性（MLP）</li><li>cache层次结构中的重用距离</li></ol><blockquote><p>参考知乎: <a href="https://www.zhihu.com/question/28611947">https://www.zhihu.com/question/28611947</a></p><p><strong>instruction size 的概念:</strong>  标量乱序执行的核心就是不断的检查未来的指令，并从中发掘可以并行执行的指令，从而最终提升IPC。这个可以乱序执行的指令窗口叫做instruction window，这是衡量现代CPU性能的一个重要指标（举个不太恰当的例子，以前参加智能车比赛，摄像头看得越远理论上可以跑的越快）。</p><p>有两个关键因素影响着不断增加的instruction window size，一个是<strong>分支预测</strong>（branch prediction），准确的分支预测（目前的指标可以做到小于10MPKI，MPKI是没1000条指令中预测错误数目）可以保证绝大多数情况下instruction window 中的指令都是在正确的 程序路径 上。否则总是错误的预测执行（speculative execution）反而会降低IPC。 另外一个关键就是<strong>寄存器重命名和 reorder buffer 的大小</strong>。reorder buffer是实现乱序执行同时保持程序正确性和精确异常的关键，每条指令在译码之后会分配一个reorder buffer的entry，reorder buffer后面会按照指令顺序commit保证程序正确性。通常指令窗口大小（instruction window size）就是reorder buffer entry size，intel的几个关键节点的微架构的instruction window大小如下，Nehalem（45nm）128， Haswell（22nm）192，Sunny Cove（10nm）352。苹果的M1目前达到了~600（一部分原因是ARM不需要micro-ops译码，从而可以实现更高的instruction译码带宽8-wide）。</p></blockquote><h4 id="二-特征描述"><a href="#二-特征描述" class="headerlink" title="二 特征描述"></a>二 特征描述</h4><h4 id="2-1-指令窗口大小不是阻碍-MLP-的因素"><a href="#2-1-指令窗口大小不是阻碍-MLP-的因素" class="headerlink" title="2.1 指令窗口大小不是阻碍 MLP 的因素"></a>2.1 指令窗口大小不是阻碍 MLP 的因素</h4><ol><li>之前有论文说 ROB是影响MLP的主要因素，他们通过扩大指令窗口的大小，发现==带宽==并没有明显的增加。</li><li>第二个是发现加速比也没有明显的增加。</li></ol><h4 id="2-1-2-负载依赖链阻止实现高-MLP"><a href="#2-1-2-负载依赖链阻止实现高-MLP" class="headerlink" title="2.1.2 负载依赖链阻止实现高 MLP"></a>2.1.2 负载依赖链阻止实现高 MLP</h4><blockquote><p>laod-load dependency chains prevent achieving high MLP</p></blockquote><p>为了理解为什么大的ROB不能提升内存间的并行, 我们跟踪 ROB 中加载指令的依赖关系, MLP 受固有的应用程序级依赖特性的限制。</p><h4 id="2-1-3-图属性数据是依赖链中的消费者"><a href="#2-1-3-图属性数据是依赖链中的消费者" class="headerlink" title="2.1.3 图属性数据是依赖链中的消费者"></a>2.1.3 图属性数据是依赖链中的消费者</h4><p>平均而言，我们发现图形属性数据主要是消费者（53.6%）而不是生产者（5.9%）。发布(issuing)图形属性数据加载被延迟并且不能并行化，因为它必须依赖生产者加载来计算地址。</p><h4 id="2-1-4-私有-L2-缓存表现出可忽略的性能敏感性，而共享-LLC-表现出更高的性能敏感性"><a href="#2-1-4-私有-L2-缓存表现出可忽略的性能敏感性，而共享-LLC-表现出更高的性能敏感性" class="headerlink" title="2.1.4 私有 L2 缓存表现出可忽略的性能敏感性，而共享 LLC 表现出更高的性能敏感性"></a>2.1.4 私有 L2 缓存表现出可忽略的性能敏感性，而共享 LLC 表现出更高的性能敏感性</h4><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221116195030491.png" class="" title="image-20221116195030491"><p>如图 4a 所示，我们将 LLC 大小从 8MB 更改为 64MB，并找到 17.4%（最大 3.25X）性能改进的最佳点，LLC 容量增加 4 倍。平均 LLC MPKI（每千克指令缺失）从基线中的 20 减少到 16 (16MB) 到 12 (32MB) 到 10 (64MB)。相应的加速比分别为 7%、17.4% 和 7.6%。最佳点是在降低的未命中率和更大的 LLC 访问延迟之间取得平衡。</p><p>图 4b(i) 显示 L2 命中率（在基线中已经非常低，为 10.6%）在容量增加 2 倍后增加到仅 15.3%，而集关联性增加 4 倍没有影响（命中率升至仅 10.9%）。</p><p>图 4b(ii) 显示系统性能对不同的 L2 缓存配置（容量和集合关联性）表现出很小的敏感性。最左边的条表示没有私有 L2 缓存的架构，与 256KB 缓存相比没有减速。因此，没有私有 L2 缓存的架构同样适用于图形处理。</p><h4 id="2-1-5-属性数据是-LLC-容量的主要受益者"><a href="#2-1-5-属性数据是-LLC-容量的主要受益者" class="headerlink" title="2.1.5 属性数据是 LLC 容量的主要受益者"></a>2.1.5 属性数据是 LLC 容量的主要受益者</h4><p>为了了解哪种数据类型受益于更大的 LLC，图 4c 显示了对于每种数据类型，最终从 DRAM 获取数据的内存引用的百分比。属性数据下降最为明显.</p><h4 id="2-1-6-图结构缓存行在所有数据类型中具有最大的重用距离。-Graph-property-cacheline-具有比-L2-缓存服务更大的重用距离"><a href="#2-1-6-图结构缓存行在所有数据类型中具有最大的重用距离。-Graph-property-cacheline-具有比-L2-缓存服务更大的重用距离" class="headerlink" title="2.1.6 图结构缓存行在所有数据类型中具有最大的重用距离。 Graph property cacheline 具有比 L2 缓存服务更大的重用距离"></a>2.1.6 图结构缓存行在所有数据类型中具有最大的重用距离。 Graph property cacheline 具有比 L2 缓存服务更大的重用距离</h4><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221116195837647.png" class="" title="image-20221116195837647"><blockquote><p>Graph structure cacheline has the largest reuse distance among all the data types. Graph property cacheline has a larger reuse distance than that serviced by the L2 cache.</p></blockquote><p>为了进一步了解 L2 和 L3 缓存的不同性能敏感性，我们按应用程序数据类型分解内存层次结构使用情况，如图 7 所示。</p><ol><li>在大多数基准测试中，对结构数据的访问由 L1 缓存和 DRAM 提供服务，这表明 L1 中丢失的缓存行是在遥远的过去引用的缓存行，因此它已从 L2 和 L3 缓存中被逐出。 重用距离超出 LLC 的服务能力这一事实解释了为什么更大的 LLC 无法显着降低图 4c 中片外结构访问的比例。</li><li>另一方面，L1 缓存中丢失的大部分属性数据加载不能由 L2 缓存提供服务，但可以由 LLC 和 DRAM 提供服务。总的来说，LLC 在服务属性访问方面比结构访问更有用。因此，property cacheline 的重用距离相对较小，但仍大于 L2 缓存捕获的重用距离</li><li>最后，图 7 提供的证据表明，对中间(顶点)数据的访问主要是 L1 缓存和 LLC 中的片上缓存命中。</li></ol><p>**最终: ** 三种数据类型的重用距离解释了为什么私有 L2 缓存无法为内存请求提供服务并且显示出微不足道的好处。</p><h4 id="三-总结与机遇"><a href="#三-总结与机遇" class="headerlink" title="三 总结与机遇"></a>三 总结与机遇</h4><p>图形分析中内存限制的停顿行为是由两个问题引起的：</p><ol><li>不同数据类型的异构重用距离导致密集的 DRAM 访问以检索结构和属性数据。</li><li>由于负载依赖链导致的低 MLP，限制了重叠 DRAM 访问的可能性</li></ol><hr><h3 id="Graphfire：为图处理协同获取、插入和替换策略"><a href="#Graphfire：为图处理协同获取、插入和替换策略" class="headerlink" title="Graphfire：为图处理协同获取、插入和替换策略"></a>Graphfire：为图处理协同获取、插入和替换策略</h3><blockquote><p>已经开发了专门的图形定制预取机制、处理器设计和内存层次结构引擎，以容忍此类访问的长时间延迟. ==但是==这些方法要么过于占用带宽，要么需要进行侵入性硬件更改，从而抑制通用计算的灵活性，要么依赖于限制真正加速的软件预处理。</p></blockquote><p>这项工作引入了 Graphfire，这是一种灵活的内存层次结构方法，可以学习图形处理中的不同访问模式，并利用专门的获取、插入和替换优化的协同作用来解决有问题的间接访问，而无需依赖软件或 ISA 支持。</p><h4 id="一-已有工作的问题"><a href="#一-已有工作的问题" class="headerlink" title="一 已有工作的问题"></a>一 已有工作的问题</h4><ul><li>大量工作涉及缓存管理技术 这些技术都没有考虑图形应用程序的特定访问模式，而是专注于那些在更常规的工作负载中众所周知和常见的模式，例如streaming、strided、thrashing、mixed 等。因此，当这些技术应用于图形分析时，这些技术产生的任何硬件开销都被浪费了。</li><li>GRASP [15] 提出了针对图分析的领域专业化 LLC 管理的第一步，但会产生基于度的图重新排序的软件预处理成本 [14]。软件预处理使得该技术对于大图不太实用，例如在许多应用场景中，输入图只被处理一次 [5]，或者甚至没有完全遍历图，例如在搜索算法中。</li></ul><p>据我们所知，对于图形应用程序<strong>，不存在可以在没有软件支持的情况下学习和优化其访问模式的内存层次结构方法</strong>。</p><h4 id="二-我们的工作"><a href="#二-我们的工作" class="headerlink" title="二 我们的工作"></a>二 我们的工作</h4><p>以优化图形应用程序的缓存性能为目标，我们的工作做出以下==关键观察==：</p><ol><li>内存层次结构必须专门针对有问题的间接访问（ problematic indirect accesses）来缓解它们的瓶颈。</li><li>要与软件无关，==轻量级机制==必须自动识别 PIA，这可以在每个指令的基础上实现。</li><li>虽然 PIA 是不规则的，但其中的一个子集具有很高的重用性，因此 LLC 必须保留它们。</li></ol><p><strong>所用的方法：</strong></p><p>鉴于这些观察结果，本文提出了 Graphfire，这是一种灵活的、基于硬件的内存层次结构方法</p><ul><li>了解图形应用程序中何时出现 PIA</li><li>通过定制的获取、插入和替换策略优化它们的性能。</li></ul><h4 id="三-MOTIVATION"><a href="#三-MOTIVATION" class="headerlink" title="三 MOTIVATION"></a>三 MOTIVATION</h4><h5 id="3-1-内存访问模式"><a href="#3-1-内存访问模式" class="headerlink" title="3.1 内存访问模式"></a>3.1 内存访问模式</h5><p>图形应用程序因数据遍历引起的不规则内存访问而臭名昭著。最先进、高效的算法实现通过两个嵌套的内核循环迭代地执行图形遍历，并利用压缩稀疏行 (CSR) 格式将输入数据集有效地存储为一维密集数组 [45]。</p><p>指针间接访问发生在顶点属性数组中，该数组存储每个顶点的结果，例如距离或等级 [6]。 CSR 数组存储图形信息，例如顶点和边缘位置，但经常和/或不经常访问。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117103412358.png" class="" title="image-20221117103412358"><p><strong>上图是图处理内核的伪代码</strong>， 外部循环（第 2-5 行）遍历顶点工作列表（针对当前算法迭代），而内部循环（第 6-13 行）分析当前顶点的邻居以潜在地更新它们的数据，具体取决于算法的目标。如果更新了邻居，则将其添加到下一次算法迭代的工作列表中（第 12-13 行）。该算法在工作列表为空（第 1 行）时终止，即图已遍历且更新已稳定。</p><p>==外循环中的指令==相对于内循环中的指令很少出现，特别是对于具有高边顶点比的图。访问是流式的或间接的（这里的访问是流失的是什么意思? 一直访问吗?） </p><h6 id="3-1-1-Infrequent-Streaming"><a href="#3-1-1-Infrequent-Streaming" class="headerlink" title="3.1.1 Infrequent, Streaming"></a>3.1.1 Infrequent, Streaming</h6><p>这些访问出现在外部 for 循环或内部循环的条件内部，并具有流式行为。如图 1 的第 2 行所示，该算法遍历顶点工作列表并以流方式加载每个顶点索引。然而，这种访问并没有表现出良好的局部性，因为在内核的内部循环中，每次访问都可以被多次内存访问分开。</p><h6 id="3-1-2-Infrequent-Indirect"><a href="#3-1-2-Infrequent-Indirect" class="headerlink" title="3.1.2 Infrequent, Indirect"></a>3.1.2 Infrequent, Indirect</h6><p>这些指针间接访问出现在外部 for 循环或内部循环中的条件。当前顶点 v 索引到 vertex_ptr 数组以加载其邻居列表索引（第 4-5 行）并确定内循环迭代次数。对起始索引的第一个加载（第 4 行）是指针间接的，而第二个（第 5 行）具有局部性。另一个间接访问来自有条件地更新顶点属性数据（第 10 行）。但是，这些不规则访问不会对性能产生重大影响，因为它们很少发生。</p><h6 id="3-1-3-Primary-Streaming-Accesses-PSAs"><a href="#3-1-3-Primary-Streaming-Accesses-PSAs" class="headerlink" title="3.1.3 Primary Streaming Accesses (PSAs)"></a>3.1.3 Primary Streaming Accesses (PSAs)</h6><p>这些访问发生在内部 for 循环的关键路径中，并执行流式加载或存储到相邻索引（第 6 行）。这些是真正的流式访问，同时展示了时间和空间局部性，并且它们经常且定期发生。因此，它们是缓存友好的，不会造成数据供应瓶颈。我们将这些访问称为主要流访问 (PSA) 来描述这些特征。</p><h6 id="3-1-4-Primary-Indirect-Accesses"><a href="#3-1-4-Primary-Indirect-Accesses" class="headerlink" title="3.1.4 Primary Indirect Accesses"></a>3.1.4 Primary Indirect Accesses</h6><p>这些访问也发生在内部 for 循环的关键路径中，并执行指针间接加载（在第 8 行中突出显示）到顶点属性数组，以便为给定的邻居加载数据。由于这些间接访问发生在每个循环迭代中，并且具有导致性能成本的较长延迟，因此它们是图应用程序的数据供应瓶颈的原因。我们将它们称为主要间接访问 (PIA)，并在下一节中详细介绍它们的特性。</p><h5 id="3-2-The-Problems-with-PIAs"><a href="#3-2-The-Problems-with-PIAs" class="headerlink" title="3.2 The Problems with PIAs"></a>3.2 The Problems with PIAs</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117112612220.png" class="" title="image-20221117112612220"><p>顶点属性数组是 PIA 的主要来源，但是分析footprint, 发现只占应用程序总内存占用量的很小一部分。（这里的内存占用是指什么？）然后做实验发现了<strong>尽管 PIA 的数据占用空间相对较小，但它们本身占应用程序访问总数的很大一部分。</strong> 当应用程序遍历图形时，必须对顶点属性数组进行频繁更新。将不规则性与频率相结合会产生==内存延迟性能瓶颈==。</p><p>图 3 将总内存延迟分解为 PIA 与其他内存访问。在所有应用程序和输入中，PIA 的延迟平均占总内存延迟的 88%，构成了主要的应用程序性能瓶颈。因此，必须在内存层次结构中进行创新，以解决这些引用所表现出的缺乏规律性和局部性的问题。</p><h6 id="3-2-1-Lack-of-Locality"><a href="#3-2-1-Lack-of-Locality" class="headerlink" title="3.2.1 Lack of Locality"></a>3.2.1 Lack of Locality</h6><p>不幸的是，PIA 的不规则性导致它们表现出较差的局部性。对于上述应用程序/输入组合，平均而言，在 64B 逐出缓存行中有 54.1 (L1)、59.9 (L2) 和 59.5 (L3) 字节未使用。因此，为 PIA 获取整个缓存行的数据是一种浪费。这个没有具体的数据来表示？ 是怎么计算出来的？</p><h6 id="3-2-2-访问模式之间的干扰"><a href="#3-2-2-访问模式之间的干扰" class="headerlink" title="3.2.2 访问模式之间的干扰"></a>3.2.2 访问模式之间的干扰</h6><p>同一缓存集中不同内存访问模式的共存会损害性能。 PIA 可能会被 PSA 或其他不频繁访问逐出，从而导致多次冲突未命中，尤其是具有高重用性的 PIA 应保留在 LLC [6] 中。由于其不规则性和频率，PIA 是 LLC 中的主要驱逐对象。平均而言，21% 的驱逐是由其他类型的访问造成的。消除这种干扰可以提高 PIA 的缓存性能。</p><h6 id="3-2-3-变量-PIA-重用"><a href="#3-2-3-变量-PIA-重用" class="headerlink" title="3.2.3 变量 PIA 重用"></a>3.2.3 变量 PIA 重用</h6><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117112845107.png" class="" title="image-20221117112845107"><p>图 4 展示了 BFS 在 Kronecker 网络上运行时的 PIA 访问和重用直方图。这捕捉了许多现实世界数据集的幂律趋势。图 4a 显示很少有顶点被频繁访问，而大多数顶点很少被访问。具有高重用性的顶点不应被低重用性 PIA 逐出。图 4b 说明了 PIA 重用距离的可变性。许多被重用，但大多数重用距离太长（相对于缓存关联性）以防止 PIA 被逐出。因此，PIA 的替换策略应适应顶点特征。</p><h3 id="用于图形分析的领域专用缓存管理"><a href="#用于图形分析的领域专用缓存管理" class="headerlink" title="用于图形分析的领域专用缓存管理"></a>用于图形分析的领域专用缓存管理</h3><p>Domain-Specialized Cache Management for Graph Analytics                                              ——HPCA 20</p><hr><h3 id="多核系统中处理内存干扰的技术-17-浙大"><a href="#多核系统中处理内存干扰的技术-17-浙大" class="headerlink" title="多核系统中处理内存干扰的技术 17 浙大"></a>多核系统中处理内存干扰的技术 17 浙大</h3><p>在多核系统中，同时运行的多个应用程序相互竞争访问共享的资源，如互连、高速缓 存和内存等。如果对可用的共享高速缓存容量和内存带宽的管理不恰当的话，不同应用程 序相互干扰，严重影响对方的运行。</p><blockquote><p>例如，在内存处，应用程序原有的行缓冲命中率和阵列级并行度会受到破坏，同时请求在读写队列中等待的时间也会因竞争激烈程度的加剧而 大幅增加；在高速缓存处，不同应用程序可能相互驱逐对方在高速缓存中的块，导致原有 命中率的破坏。</p></blockquote><p>请求在内存处的时延主要包含在队列中的等待时间和在DRAM中执行时间，这两 个部分受内存调度算法的影响特别大。</p><h4 id="创新-基于动态多层次优-先级的内存访问调度算法-DMPS"><a href="#创新-基于动态多层次优-先级的内存访问调度算法-DMPS" class="headerlink" title="创新: 基于动态多层次优 先级的内存访问调度算法 DMPS"></a>创新: 基于动态多层次优 先级的内存访问调度算法 DMPS</h4><p>识别应用程序的内存访问调度算法一般 由三部分组成：</p><ol><li>检测应用程序的内存访问特征；</li><li>基于内存访问特征来将应用程序分 类，以至于易受干扰的应用程序拥有更高的优先级；</li><li>选择优先级最高的就绪命令来执 行。</li></ol><h4 id="一-DRAM-访问过程"><a href="#一-DRAM-访问过程" class="headerlink" title="一 DRAM 访问过程"></a>一 DRAM 访问过程</h4><p>行缓冲是阵列中感应放大器单元的集合，是DRAM和内存控制器交互的接口。一般来说，行缓冲的大小为 <code>2-16KB</code>。</p><p>在行缓冲的行没有被关掉之前，行缓冲类似于高速缓存， 命中的话可减小访问延迟。到DRAM的访问可分为三步：</p><ol><li>激活命令，在目标阵列中打 开目标行，将其内容转移到行缓冲中</li><li>读写命令，在行缓冲中访问目标列；</li><li>预充电 命令，将行缓冲中的内容写回阵列的数组，关闭行缓冲的行。</li></ol><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220727095026744.png" class=""><h4 id="二-页管理策略"><a href="#二-页管理策略" class="headerlink" title="二 页管理策略"></a>二 页管理策略</h4><p>页管理策略管理行缓冲中感应放大器的操作，基本的策略有两种：开页策略和关页策 略</p><p>在开页策略中，<strong>行缓冲只在没 有到打开行的访问且有到其他行的访问时才关闭。</strong>开页策略的重要假设是一旦某一行数 据移到行缓冲中，那么在不久的将来该行的其他列会被访问，即偏爱到同一行的访问，适 合于空间局部性好的应用程序。访问类型主要是行命中和行冲突，对于行命中率高的程 序，开页策略能大幅提高性能。</p><p>在关页策略中，行缓冲在每个访问结束后都会关闭，访问 类型只有行关闭。关页策略适合到不同行的随机访问，同时每个访问的时延一样，有利于 带宽分配和实时控制</p><h4 id="三-地址映射机制"><a href="#三-地址映射机制" class="headerlink" title="三 地址映射机制"></a>三 地址映射机制</h4><p>地址映射机制负责将系统的内存地址空间映射到DRAM的逻辑结构中，具体来说，地 址映射机制将访问的物理地址转换成通道、排、阵列、行、列等值，具体化数据的放置位 置，对于性能有巨大的影响。当某块放置在某阵列中，下一块可以放置在同一行中、或者 同一阵列的下一行中、或者同一排的下一阵列中、或者同一通道的下一排中、又或者下一 通道中，所以地址映射机制决定了内存系统中可利用的并行度。</p><p>常见的地址映射机制有两 种：块交叉(Cacheline Interleaving)和行交叉(Row Interleaving)，如图2．3所示。行交叉将 连续的块放置在同一行中，试图最大化行缓冲命中率，适用于开页策略；而块交叉将连续 的块分散到不同的通道、排和阵列中，从而最大化内存访问并行度，适用于关页策略。最 小化开页(Minimalist Open Page) 则在两者之间做了权衡，通过少量的行命中实现开页 的增益，同时提高并行度来防止访问饥饿的现象和保证公平性。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220727103932041.png" class="" title="image-20220727103932041"><hr><h3 id="基于依赖感知的动态有向图处理加速器-20-华科"><a href="#基于依赖感知的动态有向图处理加速器-20-华科" class="headerlink" title="基于依赖感知的动态有向图处理加速器 20 华科"></a>基于依赖感知的动态有向图处理加速器 20 华科</h3><p>图算法通常需要对整个图进行反复迭代处理，不断地更新图顶点状态值，最终使 得所有图顶点状态值都不再发生改变，才停止迭代处理过程。因此，现有动态图处理 系统通常采用图迭代模型对最新图镜像执行增量计算。</p><p>目前的图迭代模型通常包括 批量同步迭代方法（Bulk Synchronous Parallel，BSP）模型和异步迭代模型。</p><h4 id="1-同步迭代模型"><a href="#1-同步迭代模型" class="headerlink" title="1 同步迭代模型"></a>1 同步迭代模型</h4><p>如图 1.3 所示，同步 BSP 迭代模型使用同步屏障机制将整个执行流程划分为数 个迭代周期。在每轮迭代中，基本并行处理单元被分配给各线程并行处理，通过对图 顶点及其相连的边执行运算以获得图顶点状态值（即，算法结果）。然而，由于同步 屏障的限制，各个图顶点都只能使用其前序图顶点在前一轮迭代中的旧状态值来计 算各自的新状态值，所有图顶点都完成各自的计算才能开始新的一轮迭代。迭代周期 交错进行，直到达到收敛状态。当 图处理系统并行处理图数据时，图数据被划分为并 行块并且分配给不同的处理单元。不同并行块之间通过共享内存或者消息通信机制 进行数据交换。</p><p>近年来，软件图处理系统和图加速器提出许多图划分方法，运行时负 载均衡策略和访存优化策略以提高每一轮迭代中图处理系统的吞吐率，并且已经达 到很好的效果。然而，受限于同步 BSP 迭代模型，图顶点的状态值在每轮迭代中只 能到达其直接后代图顶点，造成图顶点状态值的缓慢传播。因此，现有的同步 BSP 迭代模型不能有效支持动态图增量计算对低延迟和实时性的要求。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801201253986.png" class="" title="image-20220801201253986"><h4 id="2-异步迭代模型"><a href="#2-异步迭代模型" class="headerlink" title="2 异步迭代模型"></a>2 异步迭代模型</h4><p>不同于同步 BSP 迭代模型，如图 1.4 所示，异步迭代模型消除了同步屏障，当 前迭代计算得到的结果可以立即用于同一迭代中其它图顶点的状态值更新。因此，在 采用异步迭代模型的情况下，动态图中的图顶点的状态值传递速度通常快于同步 BSP 迭代模型，能够加快迭代收敛速度。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801201340527.png" class="" title="image-20220801201340527"><p>然而在异步迭代中，同时处理相邻图顶点会导致共享内存的读写冲突。为保证 异步迭代的顺序一致性，一些工作[20]对共享数据加锁以避免相邻图顶点的同时处 理。这导致大量锁开销，严重影响了大度图顶点的执行效率，对异步迭代处理性能 产生影响。为了减少原子开销，一些子图中心的异步迭代方法针对系统资源数 量，将有向图划分为图数据块并且分配图数据块给各个并行处理单元。不同图数据 块被并行地处理，通过消息通信机制同步不同图数据块之间的图顶点状态值。在各 个数据块内部，图顶点被串行地，异步地执行以快速传递图顶点状态值。</p><h4 id="3-设计动机"><a href="#3-设计动机" class="headerlink" title="3 设计动机"></a>3 设计动机</h4><blockquote><p>现有的同步 BSP 迭代模型和异步迭代模型能够提升有向图算法的并行度， 广泛应用于多种图处理系统和图加速器中。然而，由于动态有向图增量计算对实时性 要求极高，现有的迭代模型仍然面临着收敛速度缓慢和冗余数据计算和访问等问题， 无法满足用户对动态有向图处理的实时性需求。</p></blockquote><p>在动态有向图增量计算中，受到动态图变化影响的图顶点会沿着有向路径不断 地传递各自的状态值，因此，动态有向图处理的实时性直接受到图顶点的状态值传递 速度的影响。对于迭代有向图算法，每个图顶点都需要读取其前序图顶点的状态值以 重复更新自身的最新状态值，直到迭代收敛为止。但是，当在现有平台上并行执行图 算法时，大多数图顶点和它的前序图顶点被多个并行处理单元同时处理，在每轮迭代 中根据其前序图顶点的过时状态值更新以更新自身的状态值。结果，当使用现有的同 步/异步迭代模型时，活跃图顶点的最新状态值只能够缓慢地沿着有向路径传播到其 他的图顶点，并且根据其它图顶点的陈旧状态值来重复进行计算以更新自身。这不仅 浪费了大量时间用于处理冗余图顶点，还需要高额访存开销以反复加载这些图数据。</p><h5 id="3-1-同步BSP迭代过程"><a href="#3-1-同步BSP迭代过程" class="headerlink" title="3.1 同步BSP迭代过程"></a>3.1 同步BSP迭代过程</h5><p>如图 2.1 所示，动态图处理系统采用同步 BSP 迭代模型执行增量计算。在初始 状态时，动态有向图中所有的图顶点都达到收敛状态，并且相应的计算结果被维护。 当动态有向图结构发生变化时，例如，新增加了指向𝑣&amp;、𝑣’和𝑣(的边，需要重新进行 增量计算以获得最新图镜像的计算结果。图处理系统将激活图顶点，并且按照同步 BSP 迭代方式处理这些图顶点。在第一轮同步迭代中，𝑣&amp;的状态值首先被传递给其 后代图顶点𝑣’。然而，由于同步屏障，活跃图顶点的新状态值不能够立即被同一轮同 步迭代中的其它图顶点使用，因此，𝑣’不能够立即使用𝑣&amp;的状态值，也无法将𝑣&amp;的状态值立即传递给其后代图顶点𝑣(。当新的一轮迭代开始后，𝑣’才将自己接收到的𝑣&amp;传 递来的状态值后得到的结果传递给𝑣(。按照这种方式，在图数据块 P2 中的图顶点需 要至少三轮同步迭代才能将状态值传递给其它图数据块，造成了大量的冗余图数据 计算和访问，导致图顶点状态值缓慢地在有向图中传播。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801204827566.png" class="" title="image-20220801204827566"><h5 id="3-2-异步迭代模型"><a href="#3-2-异步迭代模型" class="headerlink" title="3.2 异步迭代模型"></a>3.2 异步迭代模型</h5><blockquote><p>由于传统的 round-robin 异步迭代模型[21]通常按照图顶点索引次序依次异步串行地处理活跃图顶 点，这忽略了有向图结构本身的更新依赖关系，导致低拓扑顺序的图顶点比高拓扑顺 序的图顶点先被处理。已经处理过的图顶点的状态值只能在下一轮异步迭代中才能 再次被处理，因此，在传统的异步迭代模型下，图顶点状态值仍然缓慢地在有向图中 传播，造成冗余图顶点更新。</p></blockquote><p>如图 2.2 所示，当动态图处理系统采用 round-robin 异步迭代模型执行增量计算 时，在其中一轮异步迭代过程中，一条已经被动态图改变量激活的有向路径（即， 𝑣&amp; → 𝑣’ → 𝑣(）上的图顶点可能被分配任意的图顶点索引次序，当图数据块 P2 被调 度处理时，其中的图顶点被按照图顶点索引次序依次异步串行地更新图顶点状态值。 然而，在每一轮异步迭代中，图顶点按照𝑣(，𝑣’，𝑣&amp;的顺序依次向后代图顶点传递各 自的图顶点状态值。由于已经处理过的图顶点的状态值只能在下一轮异步迭代中才 能再次被更新，因此在本轮异步迭代中，尽管图顶点可以立即使用并传递其前序图顶 点的状态值，但是其后代图顶点只能在下一轮迭代才能被重新更新。由于有向路径 (𝑣&amp; → 𝑣’ → 𝑣( → 𝑣))中包含 3 条边，因此至少需要进行三轮异步迭代（包含线程间同 步），图数据块 P2 才能将图顶点状态值完全传递给其它图数据块。因此，无论是同 步迭代模型，还是传统异步迭代模型，都 无法有效感知动态有向图的更新依赖关系，无法利用拓扑结构来加速动态有向图增量计算中的图顶点状态值传递。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801204945409.png" class="" title="image-20220801204945409"><h4 id="二-实验部分"><a href="#二-实验部分" class="headerlink" title="二 实验部分"></a>二 实验部分</h4><blockquote><p>The Aspen interface is an extension of Ligra’s interface. It includes the full Ligra interface-vertexSubsets, edgeMap, and various other functionality on a fixed graph. </p><p>On top of Ligra, we add a set of functions for updating the graph - in particular, for inserting or deleting sets of edges or sets of vertices. We also add a flat-snapshot function.  所有处理和更新的函数都是工作在固定大小的、不变的图镜像版本上面.</p></blockquote><h3 id="四-RisGraph-A-Real-Time-Streaming-System-for-Evolving-Graphs-to-Support-Sub-millisecond-Per-update-Analysis-at-Millions-Ops-s"><a href="#四-RisGraph-A-Real-Time-Streaming-System-for-Evolving-Graphs-to-Support-Sub-millisecond-Per-update-Analysis-at-Millions-Ops-s" class="headerlink" title="四 RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s"></a>四 RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s</h3><blockquote><p>单调算法（例如可达性和最短路径）在实时分析中广泛使用，以获得 both static and temporal insights(见解)，并且可以通过增量计算加速。现有的 streaming system 采用增量计算模型，并实现低潜伏期或高吞吐量，但不能两者兼而有之。</p><p>RisGraph 通过局部数据访问和更新的并行性解决挑战.</p><p>单调算法在不断 evolving graph 中经常使用,  其中包括可及性，广度搜索，最短路径，连接的组件（和最小/最大标签传播(Connected Components, and Min/Max Label Propagation)。它需要扫描大量数据甚至整个图表，以重新计算不断发展的图的每个快照上的单调算法。增量计算的想法可以通过利用先前的结果来减少冗余计算来加速单调算法。</p></blockquote><p>RisGraph 单边更新， 与批处理相比，Per-Update分析对延迟友好，产生最新结果，并提供最准确，最详细的信息。它只留下一个开放的问题：如何在per-update analysis 中提供高吞吐量。</p><h4 id="一-motivation"><a href="#一-motivation" class="headerlink" title="一 motivation"></a>一 motivation</h4><p>已有的解决方案：<code>Kickstarter</code> 和 <code>Differential Dataflow</code> 是最先进的代表, <code>Kickstarter</code> 提出了单调算法的增量图计算模型，而<code>Differential Dataflow</code>则呈现了无图形意识的广义增量模型。</p><p><strong>不足:</strong>  如果<code>Kickstarter</code> 和 <code>Differential Dataflow</code> 每次更改图形时都（Per Update Analysis）进行分析，则每秒只能处理大约1000个更新。they rely on batching to trade latency for higher throughput(以延迟换吞吐量), benefiting from larger concurrency and lower overheads.  此外，它们提供了批处理模式以进一步优化吞吐量，从而降低了分析的频率，并仅对每批批次产生一个汇总的最终结果。</p><p><strong>不足举例:</strong>  我们以2010年Twitter-2010 [48]的范围进行广度优先搜索（<code>BFS</code>）。为了满足20 ms延迟需求（实时分析[65]），这些系统的吞吐量仅为1K OPS/s。为了提供 100K OPS/s的吞吐量，它们需要批量超过 <code>20k</code> 的更新，并且平均处理时间增长到150毫秒以上。因此，现有的流图系统不能同时通过批处理满足延迟和吞吐量要求。尽管如此，批处理模式还是整个更新，跳过了中间状态，这些状态在某些情况下可能有用，例如财务欺诈检测和交易综合性。</p><p><strong>单边更新的挑战：</strong> </p><ol><li>无法像 batch 更新那样，均摊开销</li><li>高吞吐量和低延迟 的目标要求系统有效地进行两种工作负载。修改图表时，它需要将每个更新应用于数据结构，并提供更新的图表，以便在短时间内进行分析。为了启用每个更新的实时分析，系统需要一个图形感知的设计，以利用单个更新的局部性，而不是利用整个图形扫描的典型技术。此外，它需要一种新的机制才能使平行性进行PerDate Processing，这对于在不批处理的情况下实现高吞吐量也很重要。</li></ol><p><strong>guiding idea：</strong></p><ol><li>局部数据访问的想法来自以下观察结果：图形流系统的常用图形感知技术仍然需要不必要的整个图形扫描[43，54，68，77]。如果我们仅通过访问受更新影响的必要顶点来避免这些扫描，我们将获得更好的性能，因此我们建议使用称为索引的邻接列表和稀疏阵列的数据结构来启用本地化访问。</li><li>我们通过并行处理更新（跨越并行性），同时维护应用程序的每个语义，进一步改善了吞吐量。我们提出了一种算法，以识别可以并行执行的更新，并一个一个更新以保持低延迟，以及原子能，隔离和Per Update分析的正确性。</li></ol><h4 id="二-实验结果"><a href="#二-实验结果" class="headerlink" title="二 实验结果"></a>二 实验结果</h4><p>四种算法： BFS、SSSP、SSWP、WCC</p><p>我们首先加载90％的边缘，选择10％的边缘作为从加载边缘的删除更新，然后将其余（10％）边缘视为插入更新。删除和更新占比1:1。</p><p>与<code>Kickstarter</code>相比，<code>Risgraph</code>的性能改进主要是我们本地化数据访问的信用（第3节）。 <code>Risgraph</code>的表现优于差异数据流，这主要是由于专门的图形感知引擎和增量模型。例如，与<code>Risgraph</code>相比，在Twitter-2010上重新计算<code>BFS</code>的处理时间为78倍。</p><h4 id="三-相关工作"><a href="#三-相关工作" class="headerlink" title="三 相关工作"></a>三 相关工作</h4><ol><li><code>Kickstarter</code> 通过追踪依赖关系和修剪近似值，为单调算法提供了正确的增量计算。 </li><li><code>Grapu</code>  by components-based classification and in-buffer <code>precomputation</code> 加速批处理单调算法。</li><li><code>Graphin</code> 结合了一个I-GAS模型，该模型会逐步处理固定尺寸的更新。</li><li><code>GraphBolt</code> 提出了一个通用的增量模型来 处理 non-monotonic algorithms like Belief Propagation,，但比单调算法的 <code>kickstarter</code> 涉及更多的开销。</li></ol><h3 id="五-GraphPulse-An-Event-Driven-Hardware-Accelerator-for-Asynchronous-Graph-Processing"><a href="#五-GraphPulse-An-Event-Driven-Hardware-Accelerator-for-Asynchronous-Graph-Processing" class="headerlink" title="五 GraphPulse: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing"></a>五 <code>GraphPulse</code>: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing</h3><p>​                                                                                                                                                                                                ——2020 MICRO</p><blockquote><p>大规模的图处理带来了一些问题:</p><ol><li>首先，内存密集型处理会给内存系统带来压力, 和计算型系统相比, 内存占用更大, 频率更高. 大型内存占用还会导致内存带宽瓶颈并加剧长期访问延迟.</li><li>其次，由于顶点的并发更新，大多数计算模型中访问共享图状态的同步开销很高.</li><li>跟踪活动顶点或者边缘的开销很大, 这种跟踪是必不可少的，因为计算是不规则的，而在每次迭代中都有不同的顶点和边缘的子集。</li></ol><p>综上, 我们认为，现代处理体系结构不太适合按大规模进行图形处理应用程序</p></blockquote><p><code>GraphPulse</code> 围绕事件驱动计算的想法, 它表示计算为event， when the value of a  vertex changes to update vertices on all outgoing edges(当顶点的值更改为更新所有传出边上的顶点时)通常生成.</p><h3 id="六-JetStream-Graph-Analytics-on-Streaming-Data-with-Event-Driven-Hardware-Accelerator"><a href="#六-JetStream-Graph-Analytics-on-Streaming-Data-with-Event-Driven-Hardware-Accelerator" class="headerlink" title="六 JetStream: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator"></a>六 <code>JetStream</code>: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator</h3><blockquote><p><code>Jetstream</code> 扩展了最近提出的基于事件的加速器，用于图形工作负载，以支持流更新。它通过事件驱动的计算模型来处理累积和单调图算法，该模型限制了访问图形顶点的较小子集，有效地重用以前的查询结果以消除冗余，并优化了增强内存存储器带宽利用率的内存访问模式。</p></blockquote><p><code>Jetstream在Kickstarter和GraphBolt</code> 软件框架上达到了约18倍的速度，这些系统在较小的批次尺寸下具有明显较高的加速度。</p><p>更新的 batch 大小只占原始图大小的很小一部分, 如果重头计算的话势必会带来一些不必要的冗余。逐步支持删除的问题更具挑战性，只有Kickstarter [45]，GraphBolt [26]和DZIG [25]支持它。</p><p>支持的算法：supports all algorithms compatible with delta-accumulative computation。</p><p>相对于增加，删除操作更加麻烦，我们在两个阶段中支持删除：</p><ol><li>将图形的上一个版本的逐步转换为更新图的可恢复状态</li><li>bringing the results to convergence again.</li></ol><h3 id="七-图处理相关论文"><a href="#七-图处理相关论文" class="headerlink" title="七 图处理相关论文"></a>七 图处理相关论文</h3><h4 id="三-how怎么解决这个问题"><a href="#三-how怎么解决这个问题" class="headerlink" title="三 how怎么解决这个问题"></a>三 how怎么解决这个问题</h4><p>GRASP augments existing cache policies to maximize reuse of hot vertices by protecting them against cache thrashing, while maintaining sufficient flexibility to capture the reuse of other vertices as needed.</p><ul><li><h4 id="论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别"><a href="#论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别" class="headerlink" title="论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别"></a>论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别</h4></li></ul><blockquote><p>这并未提出新的重排序方法, 而是使用已有的重排序方法,  引用下面两篇论文.</p><ul><li> [A Closer Look at Lightweight Graph Reordering](# A Closer Look at Lightweight Graph Reordering)</li><li>[Making caches work for graph analytics](# Making caches work for graph analytics)</li></ul></blockquote><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220511164905637.png" class="" title="image-20220511164905637"><center>(a) Software applies vertex reordering, which segregates hot vertices at the beginning of the array. (b) GRASP interface exposes an ABR pair per Property Array to be configured with the bounds of the array. (c) GRASP identifies regions exhibiting different reuse based on an LLC size. </center><ul><li>Page5  论文中是如何识别热数据顶点，如何pinpoint(准确找到)热数据区域以及如何对访问进行归类；</li></ul><blockquote><ul><li><p>Conveniently, the hottest vertices are located at the beginning of the Property Array in a contiguous region thanks to the application of skew-aware reordering as seen in Fig. 3(a).  <strong>也就是说, 热顶点是通过排序得到的</strong>。</p></li><li><p>会在属性数组起始地址抓两个LLC-sized 的子区域， 一个 HIgh Reuse Region, 另一个Moderate Reuse Region.</p></li><li><p>GRASP determines this by comparing the address with the bounds of the High Reuse Region of each Property Array. </p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220511165057988.png" class="" title="image-20220511165057988"><p>GRASP encodes the classification result (High-Reuse, Moderate-Reuse, Low-Reuse or Default) as a 2-bit Reuse Hint, and forwards it to the LLC along with each cache request, as shown in Fig. 4, to guide specialized insertion and hit-promotion policies as described next.</p></li></ul></blockquote><h4 id="四-what-解决之后得到什么结论"><a href="#四-what-解决之后得到什么结论" class="headerlink" title="四 what 解决之后得到什么结论"></a>四 what 解决之后得到什么结论</h4><h5 id="4-1-Graph-process-framework"><a href="#4-1-Graph-process-framework" class="headerlink" title="4.1 Graph process framework"></a>4.1 Graph process framework</h5><blockquote><p>ligra, a widely used graph processing framework that supports both pull- and push-based computations, including switching from pull to push (and vice versa) at the start of every iteration. </p></blockquote><h5 id="4-2-Software-evaluation"><a href="#4-2-Software-evaluation" class="headerlink" title="4.2  Software evaluation"></a>4.2  Software evaluation</h5><p>论文中涉及的重排序技术</p><blockquote><p><strong>Sort</strong>  reorders vertices in the memory space by sorting them in the descending order of their degree.</p></blockquote><blockquote><p><strong>HubSort</strong>  segregates(隔离) hot vertices in a contiguous region by assigning them a continuous range of vertex IDs in their descending order of degree. In doing so, Hub Sorting essentially sorts all hot vertices, while largely preserving structure for the cold vertices.</p></blockquote><blockquote><p><strong>DBG</strong> , unlike Sort and HubSort, does not rely on sorting to segregate hot vertices. Instead, DBG coarsely(粗略的) partitions all vertices into a small number of groups based on their degree. Similar to Sort and HubSort, DBG is effective at improving spatial locality; however, unlike the other two techniques, DBG is able to largely preserve the existing graph structure.</p></blockquote><blockquote><p><strong>Gorder</strong> is evaluated as a representative of complex techniques. As Gorder is only available in a single-thread implementation, while reporting the net runtime of Gorder for a given dataset, we optimistically divide the reordering time by 40 (maximum number of threads supported on the server) to provide a fair comparison with skew-aware techniques whose reordering implementation is fully parallelized.</p></blockquote><h3 id="八-A-Closer-Look-at-Lightweight-Graph-Reordering"><a href="#八-A-Closer-Look-at-Lightweight-Graph-Reordering" class="headerlink" title="八 A Closer Look at Lightweight Graph Reordering"></a>八 A Closer Look at Lightweight Graph Reordering</h3><h4 id="二-why"><a href="#二-why" class="headerlink" title="二 why"></a>二 why</h4><p>To address the limitations of existing skew-aware reordering techniques, </p><ul><li> Sort achieves the maximum reduction in the cache footprint of hot vertices. However, in doing so, Sort completely decimates existing graph structure</li><li>Hub Sorting and Hub Clustering both classify vertices as hot or cold based on their degree and preserve the structure for cold vertices. However, in dealing with hot vertices, they resort to inefficient extremes. </li><li>At one extreme, Hub Sorting employs fine-grain reordering that sorts all hot vertices, destroying existing graph structure. At the other extreme, Hub Clustering does not apply any kind of reordering among hot vertices, sacrificing significant opportunity in improving cache efficiency</li></ul><p>we propose Degree-Based Grouping <a href="https://github.com/faldupriyank/dbg">DBG</a>。</p><h4 id="三-how"><a href="#三-how" class="headerlink" title="三 how"></a>三 how</h4><h5 id="3-1-the-dbg-algorithm"><a href="#3-1-the-dbg-algorithm" class="headerlink" title="3.1 the dbg algorithm"></a>3.1 the dbg algorithm</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220512161706297.png" class="" title="image-20220512161706297"><center>  DBG algorithm. Degree can be in-degree or out-degreeor sum of both.</center><h5 id="3-2-the-dbg-example"><a href="#3-2-the-dbg-example" class="headerlink" title="3.2 the dbg example"></a>3.2 the dbg example</h5><p> Vertex degree is shown inside the box while original vertex ID is shown below the box.</p><p>Vertex ordering in memory after DBG. In this example, DBG partitions vertices into three groups with degree ranges [0, 20), [20, 40) and [40, 80). DBG maintains a relative order of vertices within a group. As a result, many vertices are placed nearby the same vertices as before the reordering such as vertex sets (P4, P5, P6), (P0, P1) and (P10, P11).</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220512162204354.png" class="" title="image-20220512162204354"><center>Vertex ordering in memory after DBG. </center><h5 id="3-3-运行作者实验"><a href="#3-3-运行作者实验" class="headerlink" title="3.3 运行作者实验"></a>3.3 运行作者实验</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1. 编译 这一步注意设置DBG_ROOT, 要不然下面第二部会出现错误</span></span><br><span class="line">export DBG_ROOT=&#x27;/home/server2/dbg&#x27;</span><br><span class="line">cd ~/dbg/apps</span><br><span class="line">make -j </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2. 下载数据集</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//el --&gt; edge list of the form (src, dst) <span class="keyword">in</span> text file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//bel --&gt; edge list of the form (src, dst) <span class="keyword">in</span> binary file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//vgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//cvgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges (no self or redundant edges)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//csvgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges (no self or redundant edges)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//         graph is symmetric -- so <span class="keyword">for</span> every edge (u, v) there also exist (v, u)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//cintgr --&gt; binary csr format with int weight <span class="keyword">for</span> edges (no slef or redundant edges)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">//edges are assumed to take 8 bytes and vertices (and edge weights) are assumed to take 4 bytes <span class="keyword">in</span> binary file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">//all *gr files contain a header of 24 bytes as follows:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//number of vertices</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//number of edges</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//major number</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//minor number</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//gr files are implemented based on the implementation from Galois.</span></span><br><span class="line"></span><br><span class="line">wget http://snap.stanford.edu/data/web-Google.txt.gz</span><br><span class="line">gunzip web-Google.txt.gz</span><br><span class="line">../graph-convert-utils/clean_edgelist.py web-Google.txt web-Google.el</span><br><span class="line">../graph-convert-utils/convert.sh web-Google</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3. Run individual application， 运行之前安装numactl，否则会出现错误。 安装命令 sudo apt install numactl</span></span><br><span class="line">make REORDERING_ALGO=5 DEGREE_USED_FOR_REORDERING=0 DATASET=web-Google run-PageRank</span><br></pre></td></tr></table></figure><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220513152610369.png" class="" title="image-20220513152610369"><h3 id="九-Making-caches-work-for-graph-analytics"><a href="#九-Making-caches-work-for-graph-analytics" class="headerlink" title="九 Making caches work for graph analytics"></a>九 Making caches work for graph analytics</h3><p>Hub sorting was proposed as a variant of Sort that aims to preserve some structure while reducing the cache footprint of hot vertices.</p><h3 id="十-Speedup-Graph-Processing-by-Graph-Ordering"><a href="#十-Speedup-Graph-Processing-by-Graph-Ordering" class="headerlink" title="十 Speedup Graph Processing by Graph Ordering"></a>十 Speedup Graph Processing by Graph Ordering</h3><p>Gorder—— the state-of-the-art structure-aware reordering technique.</p><h3 id="十一-如何直接对属性数组进行冷热数据分离"><a href="#十一-如何直接对属性数组进行冷热数据分离" class="headerlink" title="十一 如何直接对属性数组进行冷热数据分离"></a>十一 如何直接对属性数组进行冷热数据分离</h3><blockquote><p>这里对冷热数据分离是什么意思?  </p><p>是划分出high reuse region、Moderate （适度）Reuse Region， 不常用数据？</p></blockquote><h4 id="1-1-DBG-实验"><a href="#1-1-DBG-实验" class="headerlink" title="1.1 DBG 实验"></a>1.1 DBG 实验</h4><p>在dbg的实验中, 将el格式的图转为了cvgr –&gt; binary csr format with no weight for edges (no self or redundant edges), cintgr –&gt; binary csr format with int weight for edges (no slef or redundant edges)。pagerank算法应该是借助 ligra 使用了 cvgr格式的图。这里的话没有cache，还需要自己配置才能获取到冷热数据，因此还要看以前的grasp这个仓库。</p><h4 id="1-2-grasp实验"><a href="#1-2-grasp实验" class="headerlink" title="1.2 grasp实验"></a>1.2 grasp实验</h4><p>在[Domain-Specialized Cache Management for Graph Analytics ](# 图处理相关论文) 这篇论文中,  通过dbg重排序后，作者直接定义了两个cache大小的区域, 分别获取high、 moderate 区域。</p><h3 id="十二-Proceedings-of-the-ACM-on-Measurement-and-Analysis-of-Computing-Systems-Vol-3-No-3-Article-60"><a href="#十二-Proceedings-of-the-ACM-on-Measurement-and-Analysis-of-Computing-Systems-Vol-3-No-3-Article-60" class="headerlink" title="十二  Proceedings of the ACM on Measurement and Analysis of Computing Systems Vol. 3, No. 3, Article 60"></a>十二  Proceedings of the ACM on Measurement and Analysis of Computing Systems Vol. 3, No. 3, Article 60</h3><p>CHARACTERIZATION METRICS</p><h4 id="1-1-Performance-Metrics"><a href="#1-1-Performance-Metrics" class="headerlink" title="1.1 Performance Metrics"></a>1.1 Performance Metrics</h4><ol><li>We measure single-threaded application performance using instructions per cycle (IPC)</li><li>For multithreaded applications, we show parallel speedup (i.e., the single-threaded execution time divided by the parallel execution time), which accounts for synchronization overheads.</li><li>To quantify the memory intensity of an application, we use the number of misses per kilo-instruction (MPKI) issued by the last-level cache for that application to DRAM.</li></ol><h4 id="1-2-Parallelism-Metrics"><a href="#1-2-Parallelism-Metrics" class="headerlink" title="1.2 Parallelism Metrics"></a>1.2 Parallelism Metrics</h4><p>Prior works have used either memory-level parallelism (MLP) [26, 47, 137, 152, 181] or bank-level parallelism (BLP) to quantify the amount of parallelism across memory requests</p><p>MLP measures the average number of outstanding memory requests for an application, but this does not capture the amount of parallelism offered by the underlying hardware.</p><p>BLP measures the average number of memory requests that are actively being serviced for a single thread during a given time interval.</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221004152901298.png" class="" title="image-20221004152901298"><h4 id="1-3-Contention-Metrics"><a href="#1-3-Contention-Metrics" class="headerlink" title="1.3 Contention Metrics"></a>1.3 Contention Metrics</h4><p>An important measure of spatial and temporal locality in memory is the row buffer hit rate, also known as row buffer locality.</p><p>To quantify the row hit rate, prior works count the number of row buffer hits and the number of row buffer misses, which they define as any request that does not hit in the currently-open row.</p><blockquote><p>To accurately capture row buffer locality, we introduce a new characterization methodology where we break down memory requests into: (1) row buffer hits; (2) row buffer misses, which only include misses for a DRAM request where the bank does not have any row open; and (3) row buffer conflicts, which consist of misses where another row is currently open in the bank and must be closed (<code>i.e., precharged</code>) first. Row buffer conflicts provide us with important information about how the amount of parallelism exposed by a DRAM type can limit opportunities to concurrently serve multiple memory requests, which in turn hurts performance.</p></blockquote><p>为了准确捕获行缓冲区局部性，我们引入了一种新的特征方法，将内存请求分解为：</p><p>（1）行缓冲区命中；</p><p>（2）行缓冲区错过，其中仅包括银行没有任何行打开的DRAM请求的错过； </p><p>（3）行缓冲冲突，其中包括当前在银行中打开另一排，必须首先关闭（即预处理）的失误。行缓冲冲突为我们提供了有关DRAM类型暴露的并行量如何限制同时服务多个内存请求的机会，这反过来又损害了性能。</p><h3 id="十三-Graphfire-Synergizing-Fetch-Insertion-and-Replacement-Policies-for-Graph-Analytics"><a href="#十三-Graphfire-Synergizing-Fetch-Insertion-and-Replacement-Policies-for-Graph-Analytics" class="headerlink" title="十三 Graphfire: Synergizing Fetch, Insertion, and Replacement Policies for Graph Analytics"></a>十三 Graphfire: Synergizing Fetch, Insertion, and Replacement Policies for Graph Analytics</h3><blockquote><p> With the goal of optimizing cache performance for graph applications, our work makes the following key observations: (i) The memory hierarchy must specialize for the problematic indirect accesses (PIAs) to alleviate their bottlenecks. (ii) To be software-agnostic, a lightweight mechanism must automatically identify PIAs, which can be achieved on a perinstruction basis. (iii) While PIAs are irregular, a subset of them have high reuse, so the LLC must retain them.</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图处理的相关论文&quot;&gt;&lt;a href=&quot;#图处理的相关论文&quot; class=&quot;headerlink&quot; title=&quot;图处理的相关论文&quot;&gt;&lt;/a&gt;图处理的相关论文&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Benchmark：主要是对比别人的方法，这个方法不一定是最好的，</summary>
      
    
    
    
    <category term="学术论文" scheme="http://okeyia.github.io/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="图重排序" scheme="http://okeyia.github.io/tags/%E5%9B%BE%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenMP并行编程</title>
    <link href="http://okeyia.github.io/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    <id>http://okeyia.github.io/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-13T00:57:55.000Z</published>
    <updated>2022-11-21T05:14:00.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenMP并行编程"><a href="#OpenMP并行编程" class="headerlink" title="OpenMP并行编程"></a>OpenMP并行编程</h2><h3 id="一-编程模型"><a href="#一-编程模型" class="headerlink" title="一 编程模型"></a>一 编程模型</h3><p>OpenMP是共享存储体系结构上的一个并行编程模型。 适合于SMP共享内存多处理系统和多核处理器体系结构。</p><ul><li><p>OpenMP是基于线程的并行编程模型。 </p></li><li><p>OpenMP采用Fork-Join并行执行方式： </p><ul><li>OpenMP程序开始于一个单独的主线程（Master  Thread），然后主线程一直串行执行，直到遇见第 一个并行域(Parallel Region)，然后开始并行执行并行 区域。</li><li>其过程如下： Fork:主线程创建一个并行线程队列，然后，并行域中的代 码在不同的线程上并行执行； Join:当并行域执行完之后，它们或被同步或被中断，最后 只有主线程在</li></ul></li></ul><img src="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/image-20220422102521910.png" class="" title="image-20220422102521910"><hr><h3 id="二-Clion中-Cmake-文件"><a href="#二-Clion中-Cmake-文件" class="headerlink" title="二 Clion中 Cmake 文件"></a>二 Clion中 Cmake 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FIND_PACKAGE(OpenMP REQUIRED)</span><br><span class="line">if (OPENMP_FOUND)</span><br><span class="line">    message(&quot;OPENMP FOUND&quot;)</span><br><span class="line">    set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; $&#123;OpenMP_C_FLAGS&#125;&quot;)</span><br><span class="line">    set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;OpenMP_CXX_FLAGS&#125;&quot;)</span><br><span class="line">endif () </span><br></pre></td></tr></table></figure><h3 id="三-代码实例"><a href="#三-代码实例" class="headerlink" title="三 代码实例"></a>三 代码实例</h3><h4 id="3-1-pragma-omp-parallel"><a href="#3-1-pragma-omp-parallel" class="headerlink" title="3.1 #pragma omp parallel"></a>3.1 #pragma omp parallel</h4><p>parallel制导命令表示接下来由花括号括起来的区域将创建多个线程并行执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-制导指令-for"><a href="#3-2-制导指令-for" class="headerlink" title="3.2  制导指令 for"></a>3.2  制导指令 for</h4><p>在并行域里面用 <code>#pragma omp for</code>，在这条语句之后的一个for循环语句中每一个要循环的任务将被分配给不同的线程去执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有这行代码, 2个线程每一个都将运行一次for循环, 加完这条代码, 2个线程共同运行一次for循环</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码和下面的代码, 结果是相同的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-schdule指令"><a href="#3-3-schdule指令" class="headerlink" title="3.3 schdule指令"></a>3.3 schdule指令</h4><p>在以上的任务中，各个线程自动分配到要执行的任务标号，没有对任务做一些进一步的调度，接下来介绍的字句将会对for循环任务的调度做更细致一些的规定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schedule(type, size);</span><br><span class="line"><span class="comment">// type参数有四种：1.static, 2.dynamic, 3.guided, 4.runtime</span></span><br><span class="line"><span class="comment">// size参数是整形数据：表示循环迭代次数划分的单位。</span></span><br></pre></td></tr></table></figure><h5 id="3-3-1-静态调度"><a href="#3-3-1-静态调度" class="headerlink" title="3.3.1 静态调度"></a>3.3.1 静态调度</h5><p>静态调度，不用size参数时分配给每个程序的都是 <code>n/t</code> 次连续迭代，n 为迭代次数，t为并行的线程数目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(static)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-动态调度"><a href="#3-3-2-动态调度" class="headerlink" title="3.3.2 动态调度"></a>3.3.2 动态调度</h5><p>动态调度模式是先到先得的方式进行任务分配，不用size参数的时候，先把任务干完的线程先取下一个任务，以此类推，而不是一开始就分配固定的任务数。</p><p>使用size参数的时候，分配的任务以size为单位，一次性分配size个。虽然很智能，在任务难度不均衡的时候适合用dynamic，否则会引起过多的任务动态申请的开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(dynamic,3)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-section-指令"><a href="#3-4-section-指令" class="headerlink" title="3.4 section 指令"></a>3.4 section 指令</h4><p>sections 把不同的区域 交给不同的线程去执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel sections</span></span><br><span class="line">   &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-single指令"><a href="#3-5-single指令" class="headerlink" title="3.5 single指令"></a>3.5 single指令</h4><p>single制导指令所包含的代码段只有一个线程执行，别的线程跳过该代码，如果没有nowait子句，那么其他线程将会在single制导指令结束的隐式同步点等待。有 <code>nowait</code> 子句其他线程将跳过等待往下执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp single</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;single thread=&quot;</span> &lt;&lt; omp_get_thread_num()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-注意点-pargma-omp-for"><a href="#3-5-注意点-pargma-omp-for" class="headerlink" title="3.5  注意点 #pargma omp for"></a>3.5  注意点 #pargma omp for</h4><p>单独使用 <code>#pargma omp for</code>, 相当于没有并行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rank:&quot;</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// 有序输出100行, 全是进程0 相当于没有并行</span></span><br></pre></td></tr></table></figure><h3 id="四-使用OpenMp-实现-std-accumulate"><a href="#四-使用OpenMp-实现-std-accumulate" class="headerlink" title="四 使用OpenMp 实现 std:: accumulate"></a>四 使用OpenMp 实现 std:: accumulate</h3><blockquote><p>最近刚好在学习C++ 并行编程，学习到了怎么使用多线程实现 <code>std::accumulate</code> , 比较一下两者的差异。</p></blockquote><p>下面是直接运行的代码:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">sum += dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面这个程序中，试图用sum来累加变量和。#pragma omp parallel for告诉编译器要把这个for语句拆开来并行执行。</p><p>注意 sum 定义在并行块外面，所以在并行块中会共享这个变量。也就是说在四个核中用的是同一个变量，对于sum + = i 语句，是先把sum的值取出来和 i 相加后再把结果赋给sum变量。</p><p>既然四个线程用的是同一个sum，那么如果sum在线程0中取出来了，另一个线程中也同时取出来了同样值的sum，加完后值在两个线程中都会被送就回到sum，那么就会造成有一次操作被重写了（数据碰撞），也就是说最后的结果很可能小于正确的结果。</p></blockquote><h4 id="4-1-pragma-omp-critical"><a href="#4-1-pragma-omp-critical" class="headerlink" title="4.1 #pragma omp critical"></a>4.1 #pragma omp critical</h4><p>这条语句是告诉编译器下面的代码块很关键，任何时刻都只能有一个线程执行该代码块。不过这样的话<strong>代码会在多个核中的运行会相互影响</strong>，对性能有一定影响，最好的解决方法是用规约reduction。</p><blockquote></blockquote><h4 id="4-2-reducation-规约"><a href="#4-2-reducation-规约" class="headerlink" title="4.2 reducation(规约)"></a>4.2 reducation(规约)</h4><blockquote><p>reduction (+:sum) 告诉编译器，这并行块要用规约，+表示求和操作，sum是目标变量名。这样的话，编译器就会给每个线程一个sum的拷贝并正确初始化为0，然后<strong>每个线程执行完之后再合并</strong>。规约只适用于固定的操作符。</p><img src="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/image-20221121112738508.png" class="" title="image-20221121112738508"></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2022/11/21.</span></span><br><span class="line"><span class="comment">// 使用规约求和</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp=&#123;<span class="number">100</span>&#125;;</span><br><span class="line">srand(time(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成1千万个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">dp.push_back(rand() % <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for reducation(+:sum)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">sum += dp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;使用openmp所花费的时间为: &quot;</span> </span><br><span class="line">        &lt;&lt; (<span class="built_in">std</span>::chrono::system_clock::now() - start).count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-firstprivte和lastprivate"><a href="#4-3-firstprivte和lastprivate" class="headerlink" title="4.3 firstprivte和lastprivate"></a>4.3 firstprivte和lastprivate</h4><blockquote><p>如果我们不想要已经定义了的变量在多个线程中共享，想要让每个线程有自己的拷贝怎么办呢？</p><p>下面就简单介绍一个private从句，以及firstprivate和lastprivate。通过使用#pragma omp parallel private（variable list），告诉编译器在下面的并行块中每个线程都对variable list列出的变量进行拷贝。不过值得注意的时，每个线程中拷贝的变量的初始值是不确定的，执行完并行块后该变量的值也不确定。</p><p>所以就有了firstprivate和lastprivate，firstprivate 是说<strong>变量的初始值就是按照该变量进入并行块之前的值初始化</strong>；lastprivate 是说退出并行块后，按照串行情况最后的一个值给到主线程中的变量。如果同时使用firstprivate和lastprivate，那么该变量就会有和串行是一样的初始值和结束值。</p></blockquote><h3 id="五-参考链接"><a href="#五-参考链接" class="headerlink" title="五 参考链接"></a>五 参考链接</h3><ol><li><p><a href="https://www.jianshu.com/p/796d531c08ed">并行计算工具OpenMP 二</a></p></li><li><p><a href="https://cloud.tencent.com/developer/ask/sof/491657">使用clang-12时，CMake的find_package( OpenMP )找不到OpenMP</a> 保持clang版本与libomp版本一致,  如 clang版本为10, 安装对应的libomp版本.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libomp-10-dev</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.ibm.com/docs/en/xl-c-aix/13.1.2?topic=processing-pragma-omp-parallel">pragma omp parallel</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenMP并行编程&quot;&gt;&lt;a href=&quot;#OpenMP并行编程&quot; class=&quot;headerlink&quot; title=&quot;OpenMP并行编程&quot;&gt;&lt;/a&gt;OpenMP并行编程&lt;/h2&gt;&lt;h3 id=&quot;一-编程模型&quot;&gt;&lt;a href=&quot;#一-编程模型&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>How-to-read-papers</title>
    <link href="http://okeyia.github.io/2022/05/09/How-to-read-papers/"/>
    <id>http://okeyia.github.io/2022/05/09/How-to-read-papers/</id>
    <published>2022-05-09T09:29:40.000Z</published>
    <updated>2022-11-13T15:18:05.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何阅读论文"><a href="#如何阅读论文" class="headerlink" title="如何阅读论文"></a>如何阅读论文</h2><blockquote><p>研一萌新, 最近在读论文的时候, 读到后半部分，前面讲的什么东西都已经忘完了, 不得不重新回顾。这样读起来有种深陷泥潭、举步维艰的感觉，然后觉得可能是自己读论文的方法有问题——没有从整体上把握整篇论文，只陷于个细节里面去了。感觉自己是时候该学习一下读论文的方法,  提高自己效率。</p></blockquote><p>通常来说，读论文一般有以下四个要素：</p><ul><li>What 这篇论文要解决什么问题？</li><li>Why 这篇文章为什么要解决这个问题, 解决这个问题有什么意义?<ul><li>Importance, implication, relevance</li><li>切入点：现有文献、研究方法</li></ul></li><li>how 这篇文章如何解决了这个问题?<ul><li>Problem formulation, research methods, data, experiments, etc</li></ul></li><li>what 解决这篇文章之后得到怎么样的结论<ul><li>Conclusions, perspectives, outlook, etc.</li></ul></li></ul><h3 id="一-论文各部分的重要性"><a href="#一-论文各部分的重要性" class="headerlink" title="一 论文各部分的重要性"></a>一 论文各部分的重要性</h3><ol><li>摘要 abstract: 论文最重要的部分，一般由导师直接把关</li><li>引言 introduction: 重要性仅次于摘要，内容更加易懂</li><li>相关工作 related work: 对领域内工作的分类和总结</li><li>其他章节: 论文细节，对于理解本论文非常重要。</li><li>总结 conclusion: 全文总结和展望</li><li>参考文献 reference: 论文引用的文献列表</li><li>附录 Appendix: 部分无法放到正文中的内容，如过分细节的证明和算法</li></ol><h3 id="二-快速阅读（泛读）"><a href="#二-快速阅读（泛读）" class="headerlink" title="二 快速阅读（泛读）"></a>二 快速阅读（泛读）</h3><p><strong>观点：</strong></p><ul><li><strong>快速阅读其实是一种技巧，一个捷径。</strong>你可能从这些图片中以及标题中获取大约70%，80%甚至90%的论文信息。</li><li>对于<strong>作者</strong>来说，他会思考论文的任务是什么？研究发现是什么？是什么内容让这篇文章重要且有吸引力？一个论文需要帮助大家明白究竟是想表达什么。站在读者的视角，你需要理解文章的观点。写论文的准则：你必须要让论文易于阅读。你必须要让每个读者都可以轻松阅读。</li><li>对于<strong>读者</strong>来说，我需要学习这篇文章嘛？我有多需要从这篇文章中学习？ 我能学到什么？当我一定程度上理解了文章，对我有什么影响？</li><li><strong>一篇论文包含四个部分，标题，摘要，引言和剩下的部分。</strong>作者应该花等长的时间写这4个部分。 但对于学生来说，大家真的需要大部分精力在实验，公式上。</li></ul><p><strong>如何进行快速阅读：</strong></p><ol><li> <strong>整篇论文都是在概括浓缩（abstraction）的过程中</strong>，引言是文章的浓缩，摘要是引言的浓缩，标题是摘要的浓缩。</li><li><strong>引言：论文是关于什么的？解决什么问题？为什么论文有意思？有什么新的发现？文章为什么是好的？</strong></li><li>摘要：我们可以有层次地阅读论文。我们可以将论文分解并加上一些有趣的亮点，这有利于阅读。<strong>论文中摘要部分说了什么？之后你需要看看这篇论文真正的发现是什么？我为什么需要在意这些东西？</strong></li></ol><p>如果时间有限，直接读abstract是最高效的方法。如果时间还很充裕，那么就把introduction也读一遍。读完这两部分，就应该能基本理解论文的核心思想。</p><p><strong>WARNING</strong>:读得速度越快，对论文的理解越差，甚至会出现误解。因此，想要好好理解一篇论文，精读是非常必要的。</p><h3 id="三-精读"><a href="#三-精读" class="headerlink" title="三 精读"></a>三 精读</h3><p>通过泛读（快速）阅读筛选完论文之后，需要精读部分的重要论文。我个人建议将精读分为几个阶段进行:</p><ol><li>理解论文基本原理: motivation，所用的理论？</li><li>理解论文详细内容: 深入理解论文细节，包括定义、假设和相关公式等</li><li><del>能够重现实验</del>（未必需要）: 能否重现整个实验，并得到相同结果？</li><li>组织讨论: 与其他人进行讨论，可能有没有疏忽的地方？或者理解不到位的地方？</li><li>设计更好的方案: 能不能更进一步，设计更好的方法？</li></ol><p><strong>每个阶段可以对应一次或者多次阅读，通过多次阅读来加深对论文的理解</strong>。不要指望一口气能够理解整篇论文。很多原因会造成理解不够深入甚至理解错误，例如现阶段的知识面不够，或者对于某些概念理解错误等。所以需要多次阅读（如果有必要，多次讨论）来避免这类问题。</p><p><strong>WARNING</strong>:讨论是非常必要的（最好由阅读论文的人主讲），当其他人从他的角度提出疑问时，很可能会给意想不到的惊喜。</p><h3 id="四-沈向洋-经读论文的方法"><a href="#四-沈向洋-经读论文的方法" class="headerlink" title="四 沈向洋: 经读论文的方法"></a>四 沈向洋: 经读论文的方法</h3><ol><li><p>批判性阅读</p><ul><li><strong>批判性阅读的核心就是不断否定，不断质问，不断怀疑。</strong></li><li><strong>由于批判性阅读会花费很多时间，你可能时不时卡住。我建议你，不要惊慌失措！批判性阅读确实很难，但你要坚持下去，定能度过难关。</strong></li><li><strong>搞明白你可以到哪里获取帮助，可以求助谁。但要站在对方角度进行思考，不能过多占用对方的时间。</strong></li></ul></li><li><p>创造性阅读</p><ul><li>简单地说，如果我要根据这篇论文做一些研究，有什么新的东西我可以做？最终，你<strong>需要根据你所学的论文以及相关的论文思考，你是否有足够棒的想法能够让你在未来三到五月里进行相关研究？</strong></li><li><strong>真正理解论文是能够根据论文提出问题并回答问题。</strong></li></ul></li><li><p>问题列表</p><ul><li>客观性问题：论文是关于什么的？核心观点是什么？有什么局限性？作者有没有公开代码？数据是否可用？这个想法是否真的不错？论文中想法是否有违直觉？论文的贡献是否重要？实验做的如何？</li><li>主观性问题：关于这篇论文我有没有遗漏的地方？这篇论文对我有没有帮助？我是否可以直接用文中的方法解决问题？这篇论文是否值得持续研究下去？别人对这篇论文有什么想法呢？谁是这个领域的专家？<strong>如果我有机会见到论文的作者，我会问什么问题？</strong></li></ul></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/Richardyu114/How-to-Read-and-Write-Research-Paper">How-to-Read-and-Write-Research-Paper</a></li><li><a href="https://github.com/qiyuangong/How_to_Search_and_Read_a_Paper">How_to_Search_and_Read_a_Paper</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何阅读论文&quot;&gt;&lt;a href=&quot;#如何阅读论文&quot; class=&quot;headerlink&quot; title=&quot;如何阅读论文&quot;&gt;&lt;/a&gt;如何阅读论文&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;研一萌新, 最近在读论文的时候, 读到后半部分，前面讲的什么东西都已经忘完了, 不</summary>
      
    
    
    
    <category term="学术论文" scheme="http://okeyia.github.io/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="怎么读论文" scheme="http://okeyia.github.io/tags/%E6%80%8E%E4%B9%88%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>pinatrace</title>
    <link href="http://okeyia.github.io/2022/05/03/Pintool/"/>
    <id>http://okeyia.github.io/2022/05/03/Pintool/</id>
    <published>2022-05-03T01:35:30.000Z</published>
    <updated>2022-09-05T12:40:20.249Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-Inter-pin-使用简介"><a href="#一-Inter-pin-使用简介" class="headerlink" title="一 Inter pin 使用简介"></a>一 Inter pin 使用简介</h4><blockquote><p>其实在研一上学期，就接触pin了，但仅仅只停留在理论上，没有实践。本次主要使用pin来获取某一个段代码访问内存的trace。官网给出的examples中有一个pinatrace.cpp, 只能获取到<strong>整个代码的访问trace</strong>, 因此需要对pintrace.cpp做出一个更改。</p></blockquote><blockquote><p>现在pin版本已经更新到了pin 3.22, 下载链接:  <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html">Pin - A Binary Instrumentation Tool - Downloads</a></p></blockquote><blockquote><p>由于网上可以搜到的大多pintools工具都是几年前的,  因此提供一个旧版本的pin下载链接:  <a href="https://github.com/wangziqi2013/wangziqi2013.github.io/blob/master/static/pin-2.14.tar.gz">Pin 2.14 下载链接</a> <a href="http://software.intel.com/sites/landingpage/pintool/downloads/pin-3.5-97503-gac534ca30-gcc-linux.tar.gz">pin 3.5 下载链接</a> <a href="https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.7-97619-g0d0c92f4f-gcc-linux.tar.gz">pin 3.7 下载链接</a></p></blockquote><blockquote><p>用户手册: <a href="https://software.intel.com/sites/landingpage/pintool/docs/98547/Pin/html/index.html#BuildingInsideKit">Pin 3.22 User Guide</a></p></blockquote><h4 id="二-代码示例"><a href="#二-代码示例" class="headerlink" title="二 代码示例"></a>二 代码示例</h4><h5 id="2-1-pinatrace-cpp"><a href="#2-1-pinatrace-cpp" class="headerlink" title="2.1 pinatrace.cpp"></a>2.1 pinatrace.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pin.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CHAR * ROI_BEGIN = <span class="string">&quot;__app_roi_begin&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> CHAR * ROI_END = <span class="string">&quot;__app_roi_end&quot;</span>;</span><br><span class="line"></span><br><span class="line">FILE * trace;</span><br><span class="line"><span class="keyword">bool</span> isROI = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a memory read record</span></span><br><span class="line"><span class="function">VOID <span class="title">RecordMemRead</span><span class="params">(VOID * ip, VOID * addr, CHAR * rtn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return if not in ROI</span></span><br><span class="line">    <span class="keyword">if</span>(!isROI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Log memory access in CSV</span></span><br><span class="line">    <span class="comment">//fprintf(trace,&quot;%p,R,%p\n&quot;, ip, addr);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;%p\n&quot;</span>,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a memory write record</span></span><br><span class="line"><span class="function">VOID <span class="title">RecordMemWrite</span><span class="params">(VOID * ip, VOID * addr, CHAR * rtn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return if not in ROI</span></span><br><span class="line">    <span class="keyword">if</span>(!isROI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Log memory access in CSV</span></span><br><span class="line">    <span class="comment">//fprintf(trace,&quot;%p,W,%p\n&quot;, ip, addr);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;%p\n&quot;</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set ROI flag</span></span><br><span class="line"><span class="function">VOID <span class="title">StartROI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isROI = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set ROI flag</span></span><br><span class="line"><span class="function">VOID <span class="title">StopROI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isROI = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is called for every instruction and instruments reads and writes</span></span><br><span class="line"><span class="function">VOID <span class="title">Instruction</span><span class="params">(INS ins, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Instruments memory accesses using a predicated call, i.e.</span></span><br><span class="line">    <span class="comment">// the instrumentation is called iff the instruction will actually be executed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// On the IA-32 and Intel(R) 64 architectures conditional moves and REP</span></span><br><span class="line">    <span class="comment">// prefixed instructions appear as predicated instructions in Pin.</span></span><br><span class="line">    UINT32 memOperands = INS_MemoryOperandCount(ins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over each memory operand of the instruction.</span></span><br><span class="line">    <span class="keyword">for</span> (UINT32 memOp = <span class="number">0</span>; memOp &lt; memOperands; memOp++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get routine name if valid</span></span><br><span class="line">        <span class="keyword">const</span> CHAR * name = <span class="string">&quot;invalid&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(RTN_Valid(INS_Rtn(ins)))</span><br><span class="line">        &#123;</span><br><span class="line">            name = RTN_Name(INS_Rtn(ins)).c_str();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (INS_MemoryOperandIsRead(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            INS_InsertPredicatedCall(</span><br><span class="line">                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,</span><br><span class="line">                IARG_INST_PTR,</span><br><span class="line">                IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                IARG_ADDRINT, name,</span><br><span class="line">                IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Note that in some architectures a single memory operand can be</span></span><br><span class="line">        <span class="comment">// both read and written (for instance incl (%eax) on IA-32)</span></span><br><span class="line">        <span class="comment">// In that case we instrument it once for read and once for write.</span></span><br><span class="line">        <span class="keyword">if</span> (INS_MemoryOperandIsWritten(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            INS_InsertPredicatedCall(</span><br><span class="line">                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,</span><br><span class="line">                IARG_INST_PTR,</span><br><span class="line">                IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                IARG_ADDRINT, name,</span><br><span class="line">                IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pin calls this function every time a new rtn is executed</span></span><br><span class="line"><span class="function">VOID <span class="title">Routine</span><span class="params">(RTN rtn, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get routine name</span></span><br><span class="line">    <span class="keyword">const</span> CHAR * name = RTN_Name(rtn).c_str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,ROI_BEGIN) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Start tracing after ROI begin exec</span></span><br><span class="line">        RTN_Open(rtn);</span><br><span class="line">        RTN_InsertCall(rtn, IPOINT_AFTER, (AFUNPTR)StartROI, IARG_END);</span><br><span class="line">        RTN_Close(rtn);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name,ROI_END) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Stop tracing before ROI end exec</span></span><br><span class="line">        RTN_Open(rtn);</span><br><span class="line">        RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)StopROI, IARG_END);</span><br><span class="line">        RTN_Close(rtn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pin calls this function at the end</span></span><br><span class="line"><span class="function">VOID <span class="title">Fini</span><span class="params">(INT32 code, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fclose(trace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Print Help Message                                                    */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="function">INT32 <span class="title">Usage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIN_ERROR( <span class="string">&quot;This Pintool prints a trace of memory addresses\n&quot;</span></span><br><span class="line">              + KNOB_BASE::StringKnobSummary() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Main                                                                  */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize symbol table code, needed for rtn instrumentation</span></span><br><span class="line">    PIN_InitSymbols();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Usage</span></span><br><span class="line">    <span class="keyword">if</span> (PIN_Init(argc, argv)) <span class="keyword">return</span> Usage();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open trace file and write header</span></span><br><span class="line">    trace = fopen(<span class="string">&quot;roitrace.csv&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;pc,rw,addr,rtn\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add instrument functions</span></span><br><span class="line">    RTN_AddInstrumentFunction(Routine, <span class="number">0</span>);</span><br><span class="line">    INS_AddInstrumentFunction(Instruction, <span class="number">0</span>);</span><br><span class="line">    PIN_AddFiniFunction(Fini, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never returns</span></span><br><span class="line">    PIN_StartProgram();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改完pinatrace.cpp 后, 重新make, 生成pinatrace.so文件。</p></blockquote><h5 id="2-2-roi-h"><a href="#2-2-roi-h" class="headerlink" title="2.2 roi.h"></a>2.2 roi.h</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ROI_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _ROI_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* General Markers */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noinline)) __app_roi_begin()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noinline)) __app_roi_end()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="2-3-hello-world-cpp"><a href="#2-3-hello-world-cpp" class="headerlink" title="2.3 hello_world.cpp"></a>2.3 hello_world.cpp</h5><p><strong>注意</strong>: hello_world.cpp 中必须包含 <code>extern &quot;C&quot; &#123; #include &lt;roi.h&gt; &#125;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;roi.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __app_roi_begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;hello,world!\n&quot;</span>;</span><br><span class="line">    __app_roi_end();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;second line!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对hello_world 进行编译, 此处-I.表示从当前目录寻找extern <span class="string">&quot;C&quot;</span> &#123;<span class="comment">#include &lt;roi.h&gt;&#125;中的roi.h。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I 头文件 例如xx.h， 寻找的顺序是：-I&#123;path&#125;–&gt;/usr/include–&gt;/usr/<span class="built_in">local</span>/include</span></span><br><span class="line">g++ -o hello_world hello_world.cpp -I.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">~/pin-3.21-bak/pin -t ~/pin-3.21-bak/source/tools/ManualExamples/obj-intel64/pinatrace.so -- ./hello_world</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">结果生成 roitrace.csv</span></span><br></pre></td></tr></table></figure><p>参考链接：</p><ol><li><p><a href="https://github.com/vnaveen0/pin_tools">pin_tools</a></p></li><li><p><a href="https://stackoverflow.com/questions/32026456/how-can-i-specify-an-area-of-code-to-instrument-it-by-pintool/32029564#32029564">How can i specify an area of code to instrument it by pintool?</a></p></li><li><p><a href="https://bbs.pediy.com/thread-269711.htm">有毒的学Pin记录（一）</a></p></li><li><p><a href="http://brieflyx.me/2017/binary-analysis/intel-pin-intro/">Intel Pin 基本用法</a></p></li><li><p><a href="https://anhkgg.com/pin-use-note-function-analysis/">pin使用小记-函数分析</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一-Inter-pin-使用简介&quot;&gt;&lt;a href=&quot;#一-Inter-pin-使用简介&quot; class=&quot;headerlink&quot; title=&quot;一 Inter pin 使用简介&quot;&gt;&lt;/a&gt;一 Inter pin 使用简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;其</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="http://okeyia.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Gem5" scheme="http://okeyia.github.io/tags/Gem5/"/>
    
    <category term="pintools" scheme="http://okeyia.github.io/tags/pintools/"/>
    
    <category term="memtoryTrace" scheme="http://okeyia.github.io/tags/memtoryTrace/"/>
    
  </entry>
  
  <entry>
    <title>颈肩操</title>
    <link href="http://okeyia.github.io/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/"/>
    <id>http://okeyia.github.io/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/</id>
    <published>2022-04-17T07:30:36.000Z</published>
    <updated>2022-04-17T07:52:09.115Z</updated>
    
    <content type="html"><![CDATA[<h4 id="放松颈肩-环节疲劳"><a href="#放松颈肩-环节疲劳" class="headerlink" title="放松颈肩, 环节疲劳"></a>放松颈肩, 环节疲劳</h4><p>珍爱生命, 远离ICU, 经过本人测试, 本套颈肩操可以有效缓解颈部疲劳, 放在博客提醒自己。</p><h4 id="第一节-颈部捏按"><a href="#第一节-颈部捏按" class="headerlink" title="第一节 颈部捏按"></a>第一节 颈部捏按</h4><blockquote><p>3次为一组，连续捏按8组。</p><p>左右各8组，交替进行。</p><p>保持轻柔和缓，捏按力度，持续渗透。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153521407.png" class="" title="image-20220417153521407"><h4 id="第二节-左顾右盼"><a href="#第二节-左顾右盼" class="headerlink" title="第二节 左顾右盼"></a>第二节 左顾右盼</h4><blockquote><p>缓慢转向一侧，保持3秒钟。</p><p>左右各8组。</p><p>注意旋转要匀速和缓，切忌猛烈地转动</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153637390.png" class="" title="image-20220417153637390"><h4 id="第三节-前俯后仰"><a href="#第三节-前俯后仰" class="headerlink" title="第三节 前俯后仰"></a>第三节 前俯后仰</h4><blockquote><p>前后各自保持3秒钟。<br>重复做8次。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153737110.png" class="" title="image-20220417153737110"><h4 id="第四节-左右侧曲"><a href="#第四节-左右侧曲" class="headerlink" title="第四节 左右侧曲"></a>第四节 左右侧曲</h4><blockquote><p>左右到位后，各自坚持3秒。左右各8次.</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153845908.png" class="" title="image-20220417153845908"><h4 id="第五节-悬肩舒颈"><a href="#第五节-悬肩舒颈" class="headerlink" title="第五节 悬肩舒颈"></a>第五节 悬肩舒颈</h4><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153937510.png" class="" title="image-20220417153937510"><h4 id="第六节-头颈相抗"><a href="#第六节-头颈相抗" class="headerlink" title="第六节 头颈相抗"></a>第六节 头颈相抗</h4><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154028268.png" class="" title="image-20220417154028268"><h4 id="第七节-颈项争力"><a href="#第七节-颈项争力" class="headerlink" title="第七节 颈项争力"></a>第七节 颈项争力</h4><blockquote><p>左手置于胸前, 右手置于背后, 手掌向右平行推出, 颈部向左转动, 保持三秒钟.</p><p>再换右手, 重复八次。 </p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154105726.png" class="" title="image-20220417154105726"><h4 id="第八节-仰头忘掌"><a href="#第八节-仰头忘掌" class="headerlink" title="第八节 仰头忘掌"></a>第八节 仰头忘掌</h4><blockquote><p>仰视手背, 配合深呼吸, 重复八次。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154614780.png" class="" title="image-20220417154614780"><h4 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接:"></a>视频链接:</h4><p><a href="https://www.bilibili.com/video/BV1ci4y1S7en?spm_id_from=333.999.0.0">北汽颈肩操</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;放松颈肩-环节疲劳&quot;&gt;&lt;a href=&quot;#放松颈肩-环节疲劳&quot; class=&quot;headerlink&quot; title=&quot;放松颈肩, 环节疲劳&quot;&gt;&lt;/a&gt;放松颈肩, 环节疲劳&lt;/h4&gt;&lt;p&gt;珍爱生命, 远离ICU, 经过本人测试, 本套颈肩操可以有效缓解颈部疲劳, 放在</summary>
      
    
    
    
    
    <category term="放松自己" scheme="http://okeyia.github.io/tags/%E6%94%BE%E6%9D%BE%E8%87%AA%E5%B7%B1/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://okeyia.github.io/2022/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://okeyia.github.io/2022/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-04-15T12:11:17.000Z</published>
    <updated>2022-11-17T01:39:53.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是正则表达式-？"><a href="#什么是正则表达式-？" class="headerlink" title="什么是正则表达式 ？"></a>什么是正则表达式 ？</h2><blockquote><p>正则表达式是一种被用于从文本中检索符合某些特定模式的文本。</p></blockquote><p>正则表达式是从左到右来匹配一个字符串的。“Regular Expression”这个词太长了，我们通常使用它的缩写“regex”或者“regexp”。<br>正则表达式可以被用来替换字符串中的文本、验证表单、基于模式匹配从一个字符串中提取字符串等等。</p><p>想象一下，您正在编写应用程序，并且您希望在用户选择用户名时设置规则。我们希望用户名可以包含字母，数字，下划线和连字符。<br>为了让它看起来不丑，我们还想限制用户名中的字符数量。这时我们可以使用以下正则表达式来验证用户名：</p><p align="center"><img src="https://i.imgur.com/UrDb9qc.png" alt="Regular expression"></p><p>上面这个正则表达式可以匹配 <code>john_doe</code>，<code>jo-hn_doe</code> 和 <code>john12_as</code>。但是它不能匹配 <code>Jo</code>，因为该字符串里面包含大写字符，并且它太短了。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">基本匹配</a></li><li><a href="#2-%E5%85%83%E5%AD%97%E7%AC%A6">元字符</a><ul><li><a href="#21-%E8%8B%B1%E6%96%87%E5%8F%A5%E5%8F%B7">英文句号</a></li><li><a href="#22-%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a><ul><li><a href="#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86">否定字符集</a></li></ul></li><li><a href="#23-%E9%87%8D%E5%A4%8D">重复</a><ul><li><a href="#231-%E6%98%9F%E5%8F%B7">星号</a></li><li><a href="#232-%E5%8A%A0%E5%8F%B7">加号</a></li><li><a href="#233-%E9%97%AE%E5%8F%B7">问号</a></li></ul></li><li><a href="#24-%E8%8A%B1%E6%8B%AC%E5%8F%B7">花括号</a></li><li><a href="#25-%E5%AD%97%E7%AC%A6%E7%BB%84">字符组</a></li><li><a href="#26-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">分支结构</a></li><li><a href="#27-%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">转义特殊字符</a></li><li><a href="#28-%E5%AE%9A%E4%BD%8D%E7%AC%A6">定位符</a><ul><li><a href="#281-%E6%8F%92%E5%85%A5%E7%AC%A6%E5%8F%B7">插入符号</a></li><li><a href="#282-%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7">美元符号</a></li></ul></li></ul></li><li><a href="#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">简写字符集</a></li><li><a href="#4-%E6%96%AD%E8%A8%80">断言</a><ul><li><a href="#41-%E6%AD%A3%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">正向先行断言</a></li><li><a href="#42-%E8%B4%9F%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">负向先行断言</a></li><li><a href="#43-%E6%AD%A3%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">正向后行断言</a></li><li><a href="#44-%E8%B4%9F%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">负向后行断言</a></li></ul></li><li><a href="#5-%E6%A0%87%E8%AE%B0">标记</a><ul><li><a href="#51-%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99">不区分大小写</a></li><li><a href="#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2">全局搜索</a></li><li><a href="#53-%E5%A4%9A%E8%A1%8C%E5%8C%B9%E9%85%8D">多行匹配</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">常用正则表达式</a></li></ul><h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式只是我们用于在文本中检索字符串的模式。例如正则表达式 <code>cat</code>，表示：字母 <code>c</code> 后面跟着一个字母 <code>a</code>，再后面跟着一个字母 <code>t</code>。</p><pre>"cat" => The <a href="#learn-regex"><strong>cat</strong></a> sat on the mat</pre><p>正则表达式 <code>123</code> 会匹配字符串“123”。通过将正则表达式中的每个字符逐个与要匹配的字符串中的每个字符进行比较，来完成正则匹配。<br>正则表达式通常区分大小写，因此正则表达式 <code>Cat</code> 与字符串“cat”不匹配。</p><pre>"Cat" => The cat sat on the <a href="#learn-regex"><strong>Cat</strong></a></pre><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符在写在方括号内时有特殊含义。<br>元字符如下：</p><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配除换行符以外的任意字符。</td></tr><tr><td align="center">[ ]</td><td>字符类，匹配方括号中包含的任意字符。</td></tr><tr><td align="center">[^ ]</td><td>否定字符类。匹配方括号中不包含的任意字符</td></tr><tr><td align="center">*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td align="center">+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td align="center">?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr><tr><td align="center">{n,m}</td><td>花括号，匹配前面字符至少 n 次，但是不超过 m 次。</td></tr><tr><td align="center">(xyz)</td><td>字符组，按照确切的顺序匹配字符 xyz。</td></tr><tr><td align="center">&#124;</td><td>分支结构，匹配符号之前的字符或后面的字符。</td></tr><tr><td align="center">&#92;</td><td>转义符，它可以还原元字符原来的含义，允许你匹配保留字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ \ &#124;</code></td></tr><tr><td align="center">^</td><td>匹配行的开始</td></tr><tr><td align="center">$</td><td>匹配行的结束</td></tr></tbody></table><h2 id="2-1-英文句号"><a href="#2-1-英文句号" class="headerlink" title="2.1 英文句号"></a>2.1 英文句号</h2><p>英文句号 <code>.</code> 是元字符的最简单的例子。元字符 <code>.</code> 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 <code>.ar</code>，表示：任意字符后面跟着一个字母 <code>a</code>，<br>再后面跟着一个字母 <code>r</code>。</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也称为字符类。方括号被用于指定字符集。使用字符集内的连字符来指定字符范围。方括号内的字符范围的顺序并不重要。<br>例如正则表达式 <code>[Tt]he</code>，表示：大写 <code>T</code> 或小写 <code>t</code> ，后跟字母 <code>h</code>，再后跟字母 <code>e</code>。</p><pre>"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p>然而，字符集中的英文句号表示它字面的含义。正则表达式 <code>ar[.]</code>，表示小写字母 <code>a</code>，后面跟着一个字母 <code>r</code>，再后面跟着一个英文句号 <code>.</code> 字符。</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a></pre><h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说插入字符 <code>^</code> 表示一个字符串的开始，但是当它在方括号内出现时，它会取消字符集。例如正则表达式 <code>[^c]ar</code>，表示：除了字母 <code>c</code> 以外的任意字符，后面跟着字符 <code>a</code>，<br>再后面跟着一个字母 <code>r</code>。</p><pre>"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-3-重复"><a href="#2-3-重复" class="headerlink" title="2.3 重复"></a>2.3 重复</h2><p>以下元字符 <code>+</code>，<code>*</code> 或 <code>?</code> 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。</p><h3 id="2-3-1-星号"><a href="#2-3-1-星号" class="headerlink" title="2.3.1 星号"></a>2.3.1 星号</h3><p>星号 <code>*</code> 表示匹配上一个匹配规则零次或多次。正则表达式 <code>a*</code> 表示小写字母 <code>a</code> 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。<br>例如正则表达式 <code>[a-z]*</code>，表示：一行中可以包含任意数量的小写字母。</p><pre>"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.</pre><p>星号 <code>*</code> 可以与元符号 <code>.</code> 用在一起，用来匹配任意字符串 <code>.*</code>。星号 <code>*</code> 可以与空格符 <code>\s</code> 一起使用，用来匹配一串空格字符。<br>例如正则表达式 <code>\s*cat\s*</code>，表示：零个或多个空格，后面跟小写字母 <code>c</code>，再后面跟小写字母 <code>a</code>，再在后面跟小写字母 <code>t</code>，后面再跟零个或多个空格。</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex"><strong>cat</strong></a>.</pre><h3 id="2-3-2-加号"><a href="#2-3-2-加号" class="headerlink" title="2.3.2 加号"></a>2.3.2 加号</h3><p>加号 <code>+</code> 表示匹配上一个字符一次或多次。例如正则表达式 <code>c.+t</code>，表示：一个小写字母 <code>c</code>，后跟任意数量的字符，后跟小写字母 <code>t</code>。</p><pre>"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.</pre><h3 id="2-3-3-问号"><a href="#2-3-3-问号" class="headerlink" title="2.3.3 问号"></a>2.3.3 问号</h3><p>在正则表达式中，元字符 <code>?</code> 用来表示前一个字符是可选的。该符号匹配前一个字符零次或一次。<br>例如正则表达式 <code>[T]?he</code>，表示：可选的大写字母 <code>T</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><h2 id="2-4-花括号"><a href="#2-4-花括号" class="headerlink" title="2.4 花括号"></a>2.4 花括号</h2><p>在正则表达式中花括号（也被称为量词？）用于指定字符或一组字符可以重复的次数。例如正则表达式 <code>[0-9]&#123;2,3&#125;</code>，表示：匹配至少 2 位数字但不超过 3 位（0 到 9 范围内的字符）。</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p>我们可以省略第二个数字。例如正则表达式 <code>[0-9]&#123;2,&#125;</code>，表示：匹配 2 个或更多个数字。如果我们也删除逗号，则正则表达式 <code>[0-9]&#123;2&#125;</code>，表示：匹配正好为 2 位数的数字。</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><pre>"[0-9]{2}" => The number was 9.<a href="#learn-regex"><strong>99</strong></a><a href="#learn-regex"><strong>97</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><h2 id="2-5-字符组"><a href="#2-5-字符组" class="headerlink" title="2.5 字符组"></a>2.5 字符组</h2><p>字符组是一组写在圆括号内的子模式 <code>(...)</code>。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重复前一个字符。<br>但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。<br>例如正则表达式 <code>(ab)*</code> 表示匹配零个或多个的字符串“ab”。我们还可以在字符组中使用元字符 <code>|</code>。例如正则表达式 <code>(c|g|p)ar</code>，表示：小写字母 <code>c</code>、<code>g</code> 或 <code>p</code> 后面跟字母 <code>a</code>，后跟字母 <code>r</code>。</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-6-分支结构"><a href="#2-6-分支结构" class="headerlink" title="2.6 分支结构"></a>2.6 分支结构</h2><p>在正则表达式中垂直条 <code>|</code> 用来定义分支结构，分支结构就像多个表达式之间的条件。现在你可能认为这个字符集和分支结构的工作方式一样。<br>但是字符集和分支结构巨大的区别是字符集只在字符级别上有作用，然而分支结构在表达式级别上依然可以使用。<br>例如正则表达式 <code>(T|t)he|car</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>，或匹配小写字母 <code>c</code>，后跟小写字母 <code>a</code>，后跟小写字母 <code>r</code>。</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><h2 id="2-7-转义特殊字符"><a href="#2-7-转义特殊字符" class="headerlink" title="2.7 转义特殊字符"></a>2.7 转义特殊字符</h2><p>正则表达式中使用反斜杠 <code>\</code> 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code>。在特殊字符前面加 <code>\</code>，就可以使用它来做匹配字符。<br>例如正则表达式 <code>.</code> 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 <code>.</code> 字符，正则表达式 <code>(f|c|m)at\.?</code>，表示：小写字母 <code>f</code>、<code>c</code> 或者 <code>m</code> 后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟可选的 <code>.</code> 字符。</p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h2 id="2-8-定位符"><a href="#2-8-定位符" class="headerlink" title="2.8 定位符"></a>2.8 定位符</h2><p>在正则表达式中，为了检查匹配符号是否是起始符号或结尾符号，我们使用定位符。<br>定位符有两种类型：第一种类型是 <code>^</code> 检查匹配字符是否是起始字符，第二种类型是 <code>$</code>，它检查匹配字符是否是输入字符串的最后一个字符。</p><h3 id="2-8-1-插入符号"><a href="#2-8-1-插入符号" class="headerlink" title="2.8.1 插入符号"></a>2.8.1 插入符号</h3><p>插入符号 <code>^</code> 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 <code>^a</code>（如果 a 是起始符号）匹配字符串 <code>abc</code>，它会匹配到 <code>a</code>。<br>但是如果我们使用正则表达式 <code>^b</code>，它是匹配不到任何东西的，因为在字符串 <code>abc</code> 中“b”不是起始字符。<br>让我们来看看另一个正则表达式 <code>^(T|t)he</code>，这表示：大写字母 <code>T</code> 或小写字母 <code>t</code> 是输入字符串的起始符号，后面跟着小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><h3 id="2-8-2-美元符号"><a href="#2-8-2-美元符号" class="headerlink" title="2.8.2 美元符号"></a>2.8.2 美元符号</h3><p>美元 <code>$</code> 符号用于检查匹配字符是否是输入字符串的最后一个字符。例如正则表达式 <code>(at\.)$</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟一个 <code>.</code> 字符，且这个匹配器必须是字符串的结尾。</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><pre>"(at\.)$" => The fat cat sat on the m<a href="#learn-regex"><strong>at.</strong></a></pre><h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下：</p><table><thead><tr><th align="center">简写</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td align="center">\w</td><td>匹配所有字母和数字的字符：<code>[a-zA-Z0-9_]</code></td></tr><tr><td align="center">\W</td><td>匹配非字母和数字的字符：<code>[^\w]</code></td></tr><tr><td align="center">\d</td><td>匹配数字：<code>[0-9]</code></td></tr><tr><td align="center">\D</td><td>匹配非数字：<code>[^\d]</code></td></tr><tr><td align="center">\s</td><td>匹配空格符：<code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td align="center">\S</td><td>匹配非空格符：<code>[^\s]</code></td></tr></tbody></table><h2 id="4-断言"><a href="#4-断言" class="headerlink" title="4. 断言"></a>4. 断言</h2><p>后行断言和先行断言有时候被称为断言，它们是特殊类型的 <strong><em>非捕获组</em></strong>（用于匹配模式，但不包括在匹配列表中）。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。<br>例如我们想获取输入字符串 <code>$4.44 and $10.88</code> 中带有前缀 <code>$</code> 的所有数字。我们可以使用这个正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>，表示：获取包含 <code>.</code> 字符且前缀为 <code>$</code> 的所有数字。<br>以下是正则表达式中使用的断言：</p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center">?=</td><td>正向先行断言</td></tr><tr><td align="center">?!</td><td>负向先行断言</td></tr><tr><td align="center">?&lt;=</td><td>正向后行断言</td></tr><tr><td align="center">?&lt;!</td><td>负向后行断言</td></tr></tbody></table><h3 id="4-1-正向先行断言"><a href="#4-1-正向先行断言" class="headerlink" title="4.1 正向先行断言"></a>4.1 正向先行断言</h3><p>正向先行断言认为第一部分的表达式的后面必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。<br>要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 <code>(?=...)</code>。先行断言表达式写在括号中的等号后面。<br>例如正则表达式 <code>(T|t)he(?=\sfat)</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟字母 <code>h</code>，后跟字母 <code>e</code>。<br>在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配后面跟着 <code>fat</code> 的 <code>The</code> 或 <code>the</code>。</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><h3 id="4-2-负向先行断言"><a href="#4-2-负向先行断言" class="headerlink" title="4.2 负向先行断言"></a>4.2 负向先行断言</h3><p>当我们需要指定第一部分表达式的后面不跟随某一内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样，<br>唯一的区别在于我们使用否定符号 <code>!</code> 而不是等号 <code>=</code>，例如 <code>(?!...)</code>。<br>我们来看看下面的正则表达式 <code>(T|t)he(?!\sfat)</code>，表示：从输入字符串中获取全部 <code>The</code> 或者 <code>the</code> 且不匹配 <code>fat</code> 前面加上一个空格字符。</p><pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h3 id="4-3-正向后行断言"><a href="#4-3-正向后行断言" class="headerlink" title="4.3 正向后行断言"></a>4.3 正向后行断言</h3><p>正向后行断言用于获取跟随在特定模式之后的所有匹配内容。正向后行断言表示为 <code>(?&lt;=...)</code>。例如正则表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code>，表示：从输入字符串中获取在单词 <code>The</code> 或 <code>the</code> 之后的所有 <code>fat</code> 和 <code>mat</code> 单词。</p><pre>"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h3 id="4-4-负向后行断言"><a href="#4-4-负向后行断言" class="headerlink" title="4.4 负向后行断言"></a>4.4 负向后行断言</h3><p>负向后行断言是用于获取不跟随在特定模式之后的所有匹配的内容。负向后行断言表示为 <code>(?&lt;!...)</code>。例如正则表达式 <code>(?&lt;!(T|t)he\s)(cat)</code>，表示：在输入字符中获取所有不在 <code>The</code> 或 <code>the</code> 之后的所有单词 <code>cat</code>。</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><h2 id="5-标记"><a href="#5-标记" class="headerlink" title="5. 标记"></a>5. 标记</h2><p>标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。</p><table><thead><tr><th align="center">标记</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>不区分大小写：将匹配设置为不区分大小写。</td></tr><tr><td align="center">g</td><td>全局搜索：搜索整个输入字符串中的所有匹配。</td></tr><tr><td align="center">m</td><td>多行匹配：会匹配输入字符串每一行。</td></tr></tbody></table><h3 id="5-1-不区分大小写"><a href="#5-1-不区分大小写" class="headerlink" title="5.1 不区分大小写"></a>5.1 不区分大小写</h3><p><code>i</code> 修饰符用于执行不区分大小写匹配。例如正则表达式 <code>/The/gi</code>，表示：大写字母 <code>T</code>，后跟小写字母 <code>h</code>，后跟字母 <code>e</code>。<br>但是在正则匹配结束时 <code>i</code> 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 <code>g</code> 标记，因为我们要在整个输入字符串中搜索匹配。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h3 id="5-2-全局搜索"><a href="#5-2-全局搜索" class="headerlink" title="5.2 全局搜索"></a>5.2 全局搜索</h3><p><code>g</code> 修饰符用于执行全局匹配（会查找所有匹配，不会在查找到第一个匹配时就停止）。<br>例如正则表达式 <code>/.(at)/g</code>，表示：除换行符之外的任意字符，后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>。<br>因为我们在正则表达式的末尾使用了 <code>g</code> 标记，它会从整个输入字符串中找到每个匹配项。</p><pre>".(at)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h3 id="5-3-多行匹配"><a href="#5-3-多行匹配" class="headerlink" title="5.3 多行匹配"></a>5.3 多行匹配</h3><p><code>m</code> 修饰符被用来执行多行的匹配。正如我们前面讨论过的 <code>(^, $)</code>，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 <code>m</code> 修饰符。<br>例如正则表达式 <code>/at(.)?$/gm</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，匹配除了换行符以外任意字符零次或一次。而且因为 <code>m</code> 标记，现在正则表达式引擎匹配字符串中每一行的末尾。</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre><pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ul><li><strong>正整数</strong>：<code>^\d+$</code></li><li><strong>负整数</strong>：<code>^-\d+$</code></li><li><strong>电话号码</strong>：<code>^+?[\d\s]&#123;3,&#125;$</code></li><li><strong>电话代码</strong>：<code>^+?[\d\s]+(?[\d\s]&#123;10,&#125;$</code></li><li><strong>整数</strong>：<code>^-?\d+$</code></li><li><strong>用户名</strong>：<code>^[\w\d_.]&#123;4,16&#125;$</code></li><li><strong>字母数字字符</strong>：<code>^[a-zA-Z0-9]*$</code></li><li><strong>带空格的字母数字字符</strong>：<code>^[a-zA-Z0-9 ]*$</code></li><li><strong>密码</strong>：<code>^(?=^.&#123;6,&#125;$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li><li><strong>电子邮件</strong>：<code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;)*$</code></li><li><strong>IPv4 地址</strong>：<code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li><li><strong>小写字母</strong>：<code>^([a-z])*$</code></li><li><strong>大写字母</strong>：<code>^([A-Z])*$</code></li><li><strong>网址</strong>：<code>^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]])&#123;2,4&#125;([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$</code></li><li><strong>VISA 信用卡号码</strong>：<code>^(4[0-9]&#123;12&#125;(?:[0-9]&#123;3&#125;)?)*$</code></li><li><strong>日期（MM/DD/YYYY）</strong>：<code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]&#123;2&#125;$</code></li><li><strong>日期（YYYY/MM/DD）</strong>：<code>^(19|20)?[0-9]&#123;2&#125;[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li><li><strong>万事达信用卡号码</strong>：<code>^(5[1-5][0-9]&#123;14&#125;)*$</code></li></ul><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>Report issues</li><li>Open pull request with improvements</li><li>Spread the word </li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT © <a href="mailto:ziishaned@gmail.com">Zeeshan Ahmed</a></p><hr><p><strong><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-">⬆ top</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是正则表达式-？&quot;&gt;&lt;a href=&quot;#什么是正则表达式-？&quot; class=&quot;headerlink&quot; title=&quot;什么是正则表达式 ？&quot;&gt;&lt;/a&gt;什么是正则表达式 ？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;正则表达式是一种被用于从文本中检索符合某些特定模式</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Overview of DRAMs</title>
    <link href="http://okeyia.github.io/2022/04/15/DRAM%E6%80%BB%E7%BB%93/"/>
    <id>http://okeyia.github.io/2022/04/15/DRAM%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-15T12:05:15.000Z</published>
    <updated>2022-04-25T13:46:46.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Overview-of-DRAMs"><a href="#Overview-of-DRAMs" class="headerlink" title="Overview of DRAMs"></a><strong>Overview of DRAMs</strong></h3><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415150456153.png" class="" title="image-20220415150456153"><blockquote><p>DRAM子系统是一个相对复杂的整体的一部分。此图显示了一个双向多处理器，每个处理器都有自己的专用辅助缓存。与本章最相关的部分以深灰色阴影显示：CPU、内存控制器和单个DRAM</p></blockquote><h3 id="DRAM-Basics-Internals-Operation"><a href="#DRAM-Basics-Internals-Operation" class="headerlink" title="DRAM Basics: Internals, Operation"></a>DRAM Basics: Internals, Operation</h3><p>  <strong>DRAM</strong>: A random-access memory (RAM) that uses  a single transistor-capacitor(晶体管电容器) pair for each bit .  下图显示了DRAM内部存储单元的电路: </p><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415151328606.png" class="" title="image-20220415151328606"><p>DRAM内部的组织。DRAM内存阵列是一个由存储单元组成的网格，其中一行和一列的每个交叉点存储一位数据. </p><blockquote><p>This circuit is  dynamic because the capacitors storing electrons  are not perfect devices, and their eventual leakage  requires that, to retain information stored there, each  capacitor in the DRAM must be periodically refreshed (i.e. , read and rewritten)</p></blockquote><blockquote><p>Each DRAM die(芯片) contains one or more memory arrays, rectangular grids of storage cells with each cell  holding one bit of data.  By identifying the intersection of a row  and a column (by specifying a row address and a column address to the DRAM), a memory controller can  access an individual storage cell inside a DRAM chip  so as to read or write the data held there</p></blockquote><blockquote><p>the capacitor lies at the intersection  of a wordline and a bitline; <strong>it is connected to the bitline through a transistor controlled by the wordline</strong>.  A transistor is, among other things, a switch, and  when the voltage on a wordline goes high, all of the  transistors attached to that wordline become closed  switches (turned on), connecting their respective  capacitors to the associated bitlines. The capacitors at each intersection of wordline and bitline are  extremely small and hold a number of electrons that  are miniuscule relative(相对较小的) to the physical characteristics  of those bitlines.  </p></blockquote><blockquote><p>The capacitors at each intersection of wordline and bitline are  extremely small and hold a number of electrons that  are miniuscule relative to the physical characteristics  of those bitlines. Therefore, special circuits called  sense amplifiers are used to detect the values stored  on the capacitors when those capacitors become  connected to their associated bitlines. </p><p><strong>The sense  amplifiers first precharge the bitlines to a voltage level  that is halfway between logic level 0 and logic level 1.</strong>  When the capacitors are later connected to the bitlines through the transistors, the capacitors <strong>change  the voltage levels on those bitlines</strong> very slightly(轻微地). The  sense amplifiers detect the minute changes and pull the bitline voltages all the way to logic level 0 or 1.  Bringing the voltage on the bitlines to fully high or  fully low, as opposed to the precharged state between  high and low, actually recharges the capacitors as  long as the transistors remain on(连通). </p></blockquote><h4 id="Multiple-Memory-Arrays"><a href="#Multiple-Memory-Arrays" class="headerlink" title="Multiple Memory Arrays"></a>Multiple Memory Arrays</h4><blockquote><p> If the memory arrays  are designed to act in unison, they operate as a unit,  and the memory chip typically transmits or receives  a number of bits <strong>equal to</strong> the number of arrays each time the memory controller accesses the DRAM.</p></blockquote><p>For  example, in a simple organization, a x4 DRAM (pronounced “by four”) indicates that the DRAM has at  least <strong>four memory arrays</strong> and that a column width is  4 bits (each column read or write transmits 4 bits of  data). In a x4 DRAM part, four arrays each read 1 data  bit in unison, and the part sends out 4 bits of data  each time the memory controller makes a column  read request.</p><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415153809797.png" class="" title="image-20220415153809797"><p>NOTICE:   <strong>each of the DRAM illustrations in Figure  represents multiple arrays but a single bank. Each set of memory arrays that operates independently of other  sets is referred to as a bank, not an array .</strong></p><h4 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h4><blockquote><p>Because a system can have multiple DIMMs, each  of which can be thought of as an independent bank,  and the DRAM devices(内存颗粒) on each DIMM can implement internally multiple independent banks, the  word “rank” was introduced to distinguish DIMM-level independent operation versus(和) internal-bank-level independent operation. </p></blockquote><blockquote><p>A system is composed of potentially many  independent DIMMs. <strong>Each DIMM may contain one  or more independent ranks</strong>. Each rank is a set of  DRAM devices that operate in unison, and internally  each of these DRAM devices implements one or more  independent banks. Finally, <strong>each bank is composed  of slaved memory arrays</strong>, where the number of arrays  is equal to the data width of the DRAM part (i.e., a x4  part has four slaved arrays per bank)</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415155638103.png" class="" title="image-20220415155638103"><center>DIMMs, ranks, banks, and arrays </center><hr><h4 id="Memory-controller-and-Memory-modules"><a href="#Memory-controller-and-Memory-modules" class="headerlink" title="Memory controller and Memory modules"></a>Memory controller and Memory modules</h4><blockquote><p>The busses in a JEDEC-style organization are classified by their function and organization into data,  address, control, and chip-select busses. </p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415161510722.png" class="" title="image-20220415161510722"><center>a memory controller and two memory modules with a 16-bit data bus and an 8-bit address and command bus</center><blockquote><p>The data bus that transmits data to and from  the DRAMs is relatively wide. It is often 64 bits wide,  and it can be much wider in high-performance systems. A dedicated address bus carries row and column addresses to the DRAMs, and its width grows  with the physical storage on a DRAM device (typical  widths today are about 15 bits). A control bus is composed of the row and column strobes(选通), output enable,  clock, clock enable, and other related signals. These  signals are similar to the address-bus signals in that  they all connect from the memory controller to every  DRAM in the system. Finally, there is a chip-select  network that connects from the memory controller  to every DRAM in a rank (a separately addressable  set of DRAMs). </p></blockquote><h4 id="the-chip-select-bus"><a href="#the-chip-select-bus" class="headerlink" title="the chip-select bus"></a>the chip-select bus</h4><blockquote><p>The chip-select bus contains a separate wire(线路) for every rank of DRAM in  the system.  The chip-select signal passes over a wire  unique to each small set of DRAMs and enables or  disables the DRAMs in that rank so that they, respectively, either handle the request currently on the bus  or ignore the request currently on the bus. Thus, <strong>only  the DRAMs to which the request is directed handle  the request</strong>. Even though all DRAMs in the system  are connected to the same address and control busses and could, in theory, all respond to the same  request at the same time, the chip-select bus prevents this from happening. </p></blockquote><h4 id="the-Steps-of-a-DRAM-Read"><a href="#the-Steps-of-a-DRAM-Read" class="headerlink" title="the Steps of a DRAM  Read"></a>the Steps of a DRAM  Read</h4><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415164647716.png" class="" title="image-20220415164647716"><center> System organization and the steps of a DRAM  read </center><blockquote><p>As mentioned previously, a DRAM device connects indirectly to a microprocessor through a  memory controller; the microprocessor connects  to the memory controller through some form of  network (bus, point-to-point, crossbar, etc.); and  the memory controller connects to the DRAM  through another network (bus, point-to-point, etc.).  </p></blockquote><blockquote><p>Figure also illustrates the steps of a typical  DRAM read operation. After ordering and queueing  requests, the microprocessor sends a given request  to the memory controller. Once the request arrives at  the memory controller, it is queued until the DRAM is  ready and all previous and/or higher priority requests  have been handled. The memory controller’s interface to the DRAM is relatively complex (compared  to that of an SRAM, for instance); the row-address  strobe (RAS) and column-address strobe (CAS) components are shown in detail in next Figure. </p></blockquote><blockquote><p>The memory controller must decompose the provided data address into components that identify the  appropriate rank within the memory system, the bank  within that rank, and the row and column inside the  identified bank. The components identifying the row  and column are called the row address and the column address. <strong>The bank identifier is typically one or  more address bits</strong>. The rank number ends up causing  a chip-select signal to be sent out over a single one of  the separate chip-select lines. </p></blockquote><h4 id="the-Bitlines-Be-Precharged"><a href="#the-Bitlines-Be-Precharged" class="headerlink" title="the Bitlines Be Precharged"></a>the Bitlines Be Precharged</h4><blockquote><p>Once the rank, bank, and row are identified, the  bitlines in the appropriate bank must be precharged (set to a logic level halfway between 0 and 1). Once  the appropriate bank has been precharged, <strong>the second step</strong> is to activate the appropriate row inside the  identified rank and bank by setting the chip-select  signal to activate the set of DRAMs comprising the desired bank, sending the row address and bank  identifier over the address bus, and signaling the  DRAM’s  RAS pin (row-address strobe—the bar indicates that the signal is active when it is low). </p><p>This tells  the DRAM to <strong>send an entire row of data (thousands  of bits) into the DRAM’s sense amplifiers</strong> (circuits  that detect and amplify the tiny logic signals represented by the electric charges in the row’s storage  cells). This typically takes a few tens of nanoseconds,  and the step may have already been done (the row  or page could already be open or activated, meaning  that the sense amps might already have valid data in  them). </p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415165940565.png" class="" title="image-20220415165940565"><center> The multi-phase DRAM-access protocol. The row access drives a DRAM page onto the bitlines to be sensed by the  sense amps. The column address drives a subset of the DRAM page onto the bus (e.g., 4 bits).</center><p>NOTICE: separately transmitted row and  column addresses</p><blockquote><p>Once the sense amps have recovered the values,  and the bitlines are pulled to the appropriate logic  levels, the memory controller <strong>performs the last step</strong>,  which is to read the column (column being the name  given to the data subset of the row that is desired),  by setting the chip-select signal to activate the set of  DRAMs comprising the desired bank, sending the  column address and bank identifier over the address  bus, and signaling the DRAM’s  CAS pin (column address strobe—like  RAS , the bar indicates that it is active when low).  </p><p>This causes only a few select bits in the sense amplifiers to be connected to the output  drivers, where they will be driven onto the data bus.  Reading the column data takes on the order of tens of  nanoseconds. When the memory controller receives  the data, it forwards the data to the microprocessor. </p></blockquote><h4 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h4><blockquote><p>A clock transmits a continuous signal with regular  intervals of “high” and “low” values. It is usually illustrated as a square wave or semi-square wave with each  period identical to the next, as shown in Figure 7.9. The  upward portion of the square wave is called the positive  or rising edge of the clock, and the downward portion  of the square wave is called the negative or falling edge of the clock. The primary clock in a computer system is  called the system clock or global clock, and it typically  resides on the motherboard (the PCB that contains the  microprocessor and memory bus). The system clock  drives the microprocessor and memory controller and  many of the associated peripheral devices directly. If  the clock drives the DRAMs directly, the DRAMs are  called synchronous DRAMs. If the clock does not drive  the DRAMs directly, the DRAMs are called asynchronous DRAMs. In a synchronous DRAM, steps internal  to the DRAM happen in time with one or more edges  of this clock. In an asynchronous DRAM, operative  steps internal to the DRAM happen when the memory controller commands the DRAM to act, and those  commands typically happen in time with one or more  edges of the system clock.</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415190728890.png" class="" title="image-20220415190728890"><center> Example clock signals</center><blockquote><p>Clocks are typically shown as square waves (bottom) or sort of square waves (top). They  repeat ad infinitum, and the repeating shape is called a clock cycle. The two clocks pictured above have the same frequency—the  number of cycles in a given time period</p></blockquote><h3 id="DRAM-中文"><a href="#DRAM-中文" class="headerlink" title="DRAM 中文"></a>DRAM 中文</h3><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/Simplified-topology-of-DRAM-organization.png" class="" title="Simplified-topology-of-DRAM-organization"><p>影响DRAM的性能:</p><ul><li>内存容量</li><li>内存的延时周期</li><li>内存的带宽</li></ul><h4 id="内存带宽"><a href="#内存带宽" class="headerlink" title="内存带宽"></a>内存带宽</h4><p>内存带宽的影响是内存中现存的非常严重的问题，而影响内存带宽的主要因素是 行冲突</p><p>地址层级如下:</p><ol><li>通道（Channel） 通道是 DRAM 内存系统结构中最高的级别。独立内存控制器之间不同通道的运 行是没限制的。为了更优化的性能设计，连续的存取指令在缓存层已经被映射到不同 的通道了。</li><li>排（Rank） 排是通道的下一层，DRAM 的存取是在同一个通道的不同排之间也是可以并行 运行的</li><li>体（Bank）类似于连续的存取指令作用在不同的排上，当连续的指令作用在同一个排的不同 体时，DRAM 的内存系统仍然会有并行运行的存在。对于现在的 DRAM 设备而言， 将连续的存取指令通过调度方式分配到同一个排的不同体上，要比分配到同一个通道 的不同排上更加高效，因为这样不需要多余的周期来进行数据总线上的转换。</li><li>行（Row）在通用 DRAM 内存系统中，每个体在执行时，仅能激活（Active）一个行，当 有连续的指令通过调度映射到同一个体的不同行时，需要将第一个行进行预充电操作 （Precharge），再对第二个行进行激活操作，才能顺利进行连续指令的运行。这样做 便会造成大量的延迟，同时伴随的还有行冲突的数量会增加。想要降低行冲突出现的 概率，需要通过地址映射将连续的指令映射到同一个体的同一个行上面，这样行命中 的比例变化提升很多。从而能够有效的提升 DRAM 的性能</li><li>列（Column）当连续的指令作用在同一个体的同一个行时，此时不需要预充电操作，在获取数 据时，根据时间局部性和空间局部性 ，内存控制器会把整个行的数据都取出来放在 敏感放大器上。所以，第二个指令所映射的列也会以极高的效率获得。</li></ol><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410095244676.png" class="" title="image-20220410095244676"><p>地址映射不单单是内存中的地址翻译，它是连接着处理器、内存控制器和内存的 重要桥梁。因为地址在计算机系统中不同模块传输的状态不同，有物理地址和逻辑地 址，所以，需要地址映射来进行合理的转化。</p><h4 id="虚拟地址与物理地址"><a href="#虚拟地址与物理地址" class="headerlink" title="虚拟地址与物理地址"></a>虚拟地址与物理地址</h4><blockquote><p>虚拟地址（Virtual Address） 如果 CPU 启用了内存管理单元（Memory Management Unit，又称 MMU），CPU 核发出的地址将被内存管理单元截获，从 CPU 传输到内存管理单元的地址称为虚拟 地址(Virtual Address，简称 VA</p></blockquote><blockquote><p>物理地址（Physical Address）： 如果中央处理器不存在内存管理单元，或者未启用，则其核在获取指令或者访存 时发出的地址将被直接传到 CPU 的外部地址引脚上，被内存芯片接受，则称为物理 地址（Physical Address）。 内存管理单元将该地址译成另外地址发到 CPU 的外部地址引脚上，便意味着将 虚拟地址转化成了物理地址。内存管理单元是以页（Page）为单位的，对于 32 位 CPU 而言，通常一页为 4K。例如，虚拟地址 0xb700 1000<del>0xb700 1fff 是一个页，可能被 MMU 映射到物理地址 0x2000</del>0x2fff，物理内存中的一个物理页面也称为一个页框 (Page Frame)。 当内存控制器将虚拟地址转化成能够索引到具体 DRAM 每个数据模块的物理地 址后，DRAM 便会通过物理地址而索引到内存中具体的数据，再通过数据总线反馈 给 CPU[8]</p></blockquote><h4 id="内存带宽-1"><a href="#内存带宽-1" class="headerlink" title="内存带宽"></a>内存带宽</h4><h5 id="ROW-行"><a href="#ROW-行" class="headerlink" title="ROW 行"></a>ROW 行</h5><blockquote><p>在通用 DRAM 内存系统中，每个体在执行时，仅能激活（Active）一个行，当 有连续的指令通过调度映射到同一个体的不同行时，需要将第一个行进行预充电操作 （Precharge），再对第二个行进行激活操作，才能顺利进行连续指令的运行。这样做 便会造成大量的延迟，同时伴随的还有行冲突的数量会增加。想要降低行冲突出现的 概率，需要通过地址映射将连续的指令映射到同一个体的同一个行上面，这样行命中 的比例变化提升很多。从而能够有效的提升 DRAM 的性能</p></blockquote><h5 id="Column-列"><a href="#Column-列" class="headerlink" title="Column 列"></a>Column 列</h5><blockquote><p>当连续的指令作用在同一个体的同一个行时，此时不需要预充电操作，在获取数 据时，根据时间局部性和空间局部性 ，内存控制器会把整个行的数据都取出来放在 敏感放大器上。所以，第二个指令所映射的列也会以极高的效率获得</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410174402971.png" class="" title="image-20220410174402971"><h5 id="连续存取指令"><a href="#连续存取指令" class="headerlink" title="连续存取指令"></a>连续存取指令</h5><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410183659726.png" class="" title="image-20220410183659726"><h5 id="开页模式策略"><a href="#开页模式策略" class="headerlink" title="开页模式策略"></a>开页模式策略</h5><blockquote><p>开页的策略其 适用的环境是，如果有连续的指令到来，那么在执行完第一个指令后，并不会通过预 充电命令关掉该行。当内存控制器使用开页模式策略时，某行数据被取出存放在一个 DRAM 体的敏感放大器中的同一行的不同列，它可以快速的直接执行，此时会有最 小的延迟称为 Tcas。这种情况下，当另外一个读取指令指向了同一个行，因为该行已 经激活在敏感放大器中，所以它仅仅需要列命令，便可将数据从敏感放大器传递到内 存控制器中 ，这样的延迟是最小的。当然，另一方面，当连续的指令作用的是同一 个体的不同行时，内存控制器在执行第二个访问操作时，必须将第一个行通过预充电 指令关掉，同时再打开另外一个指令所指向的那个行，这样才可以执行第二个的列选取.  </p></blockquote><h5 id="关页策略"><a href="#关页策略" class="headerlink" title="关页策略"></a>关页策略</h5><p>关 页策略适用的环境是，当连续的指令到来以后，在执行完第一个指令，紧接着发布一 个预充电的指令来关掉该行，所以它适用于行冲突很多的情况下</p><h4 id="行冲突现象"><a href="#行冲突现象" class="headerlink" title="行冲突现象:"></a>行冲突现象:</h4><p>如果连续的地址存取指令，它们通过地址映射的算法后，指向的是同一个体的不同行，这会产生大量的延迟，因为上述第一个行需要激活的指令，才能执行第一个存取的请求，因为第二个不同于第一个行，因为同一个体一次仅能激活一个行，所以，需要将第一个行进行预充电的操作， 来使第一个行的状态变为关闭，紧接着再发布第二个指令来激活第二个请求所指向的行，在此两个行为以后，才可以执行第二个请求， 获取第二个行的数据，存放在行缓冲区中。因为这样的操作比第一种情况多出了一个 预充电与一个激活的指令延迟，所以效率是非常低的。这样的情况我们称之为行冲突现象. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Overview-of-DRAMs&quot;&gt;&lt;a href=&quot;#Overview-of-DRAMs&quot; class=&quot;headerlink&quot; title=&quot;Overview of DRAMs&quot;&gt;&lt;/a&gt;&lt;strong&gt;Overview of DRAMs&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="http://okeyia.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Computer Architecture" scheme="http://okeyia.github.io/tags/Computer-Architecture/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下实用工具配置</title>
    <link href="http://okeyia.github.io/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
    <id>http://okeyia.github.io/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</id>
    <published>2022-04-09T13:52:31.000Z</published>
    <updated>2022-11-05T02:22:36.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-shell配置"><a href="#一-shell配置" class="headerlink" title="一 shell配置"></a>一 shell配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装插件的脚本</span></span><br><span class="line">sudo apt install wget curl git zsh vim tldr -y</span><br><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line">sed -i &#x27;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting z)/&#x27; ~/.zshrc</span><br><span class="line"></span><br><span class="line">git clone https://github.com/okeyia/honukai-iterm-zsh.git ~/.oh-my-zsh/custom/themes</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/robbyrussell/honukai&#x27; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>好用的shell有很多, 如fish、zsh、Oh-my-zsh ，本教程以Oh-my-zsh为例，配置教程如下：</p><h3 id="1-安装zsh"><a href="#1-安装zsh" class="headerlink" title="1 安装zsh"></a>1 安装zsh</h3><p>以ubuntu为例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><h3 id="2-下载oh-my-zsh-源码"><a href="#2-下载oh-my-zsh-源码" class="headerlink" title="2 下载oh-my-zsh 源码"></a>2 下载oh-my-zsh 源码</h3><h4 id="2-1-脚本安装方式"><a href="#2-1-脚本安装方式" class="headerlink" title="2.1 脚本安装方式"></a>2.1 脚本安装方式</h4><p>使用curl或者wget</p><table><thead><tr><th>Method</th><th>Command</th></tr></thead><tbody><tr><td>curl</td><td><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td>wget</td><td><code>sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr></tbody></table><h4 id="2-2-手动安装"><a href="#2-2-手动安装" class="headerlink" title="2.2 手动安装"></a>2.2 手动安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.sh</span><br><span class="line">sudo sh install.sh</span><br></pre></td></tr></table></figure><h3 id="3-安装-oh-my-zsh插件及主题"><a href="#3-安装-oh-my-zsh插件及主题" class="headerlink" title="3 安装 oh-my-zsh插件及主题"></a>3 安装 oh-my-zsh插件及主题</h3><h4 id="3-1-插件—代码高亮"><a href="#3-1-插件—代码高亮" class="headerlink" title="3.1 插件—代码高亮"></a>3.1 插件—代码高亮</h4><ol><li>克隆源码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件 <code>~/.zshrc</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( [plugins...] zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><ol start="3"><li>是配置文件生效</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="3-2-插件—自动补全"><a href="#3-2-插件—自动补全" class="headerlink" title="3.2 插件—自动补全"></a>3.2 插件—自动补全</h4><ol><li><p>克隆源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( # other plugins... zsh-autosuggestions)</span><br></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-3-主题—honukai"><a href="#3-3-主题—honukai" class="headerlink" title="3.3 主题—honukai"></a>3.3 主题—honukai</h4><ol><li><p>主题配置文件一般存放于  <code>~/.oh-my-zsh/custom/themes</code> 文件夹, 进入到该文件夹, 执行该命令, 将下面的内容(复制内容如下)复制进去.  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim honukai.zsh-theme </span><br></pre></td></tr></table></figure><p><strong>复制内容如下:</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Based on the great ys theme (http://ysmood.org/wp/2013/03/my-ys-terminal-theme/)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Machine name.</span></span><br><span class="line"><span class="keyword">function</span> box_name &#123;</span><br><span class="line">    [ -f ~/.box-name ] &amp;&amp; cat ~/.box-name || <span class="built_in">echo</span> <span class="variable">$HOST</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory info.</span></span><br><span class="line"><span class="built_in">local</span> current_dir=<span class="string">&#x27;$&#123;PWD/#$HOME/~&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VCS</span></span><br><span class="line">YS_VCS_PROMPT_PREFIX1=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[white]%&#125;on%&#123;<span class="variable">$reset_color</span>%&#125; &quot;</span></span><br><span class="line">YS_VCS_PROMPT_PREFIX2=<span class="string">&quot;:%&#123;<span class="variable">$fg</span>[cyan]%&#125;&quot;</span></span><br><span class="line">YS_VCS_PROMPT_SUFFIX=<span class="string">&quot;%&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line">YS_VCS_PROMPT_DIRTY=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[red]%&#125;✖︎&quot;</span></span><br><span class="line">YS_VCS_PROMPT_CLEAN=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[green]%&#125;●&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Git info.</span></span><br><span class="line"><span class="built_in">local</span> git_info=<span class="string">&#x27;$(git_prompt_info)&#x27;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_PREFIX=<span class="string">&quot;<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX1&#125;</span>git<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX2&#125;</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_SUFFIX</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_DIRTY=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_DIRTY</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_CLEAN=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_CLEAN</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HG info</span></span><br><span class="line"><span class="built_in">local</span> hg_info=<span class="string">&#x27;$(ys_hg_prompt_info)&#x27;</span></span><br><span class="line"><span class="function"><span class="title">ys_hg_prompt_info</span></span>() &#123;</span><br><span class="line"><span class="comment"># make sure this is a hg dir</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&#x27;.hg&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX1&#125;</span>hg<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -n $(hg branch 2&gt;/dev/null)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="subst">$(hg status 2&gt;/dev/null)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_DIRTY</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_CLEAN</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_SUFFIX</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompt format: \n # USER at MACHINE in DIRECTORY on git:BRANCH STATE [TIME] \n $</span></span><br><span class="line">PROMPT=<span class="string">&quot;</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[blue]%&#125;#%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[cyan]%&#125;%n \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;at \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[green]%&#125;<span class="subst">$(box_name)</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;in \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;<span class="variable">$&#123;current_dir&#125;</span>%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;git_info&#125;</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;[%*]</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125;→ %&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$USER</span>&quot;</span> == <span class="string">&quot;root&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">PROMPT=<span class="string">&quot;</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[blue]%&#125;#%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$bg</span>[yellow]%&#125;%&#123;<span class="variable">$fg</span>[cyan]%&#125;%n%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;at \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[green]%&#125;<span class="subst">$(box_name)</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;in \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;<span class="variable">$&#123;current_dir&#125;</span>%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;git_info&#125;</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;[%*]</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125;→ %&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;honukai&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-用户默认使用zsh"><a href="#4-用户默认使用zsh" class="headerlink" title="4 用户默认使用zsh"></a>4 用户默认使用zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which zsh                #查看zsh的路径</span><br><span class="line">sudo vi /etc/passwd      #以用户sen为例, 将/bin/bash 改为/usr/bin/zsh</span><br></pre></td></tr></table></figure><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220924155931302.png" class="" title="image-20220924155931302"><h2 id="二-sudo-免密码"><a href="#二-sudo-免密码" class="headerlink" title="二 sudo 免密码"></a>二 sudo 免密码</h2><p>个别情况下，sudo 免密设置的特别麻烦，这里可对某个管理员用户设置sudo 免输入免密。本教程以<code>ubuntu 18.04</code> 为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br><span class="line"><span class="meta">#</span><span class="bash">在%sudo ALL=(ALL:ALL) ALL下面添加如下一行</span></span><br><span class="line">username  ALL=(ALL) NOPASSWD: ALL, 这里的username就是你自己的用户名</span><br><span class="line"><span class="meta">#</span><span class="bash">添加完成 如下图所示, 之后按Ctrl+O，接着按回车确定保存文件。最后Ctrl+X退出编辑</span></span><br></pre></td></tr></table></figure><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409220215145.png" class="" title="image-20220409220215145"><h2 id="三-vmware-配置git代理"><a href="#三-vmware-配置git代理" class="headerlink" title="三 vmware 配置git代理"></a>三 vmware 配置git代理</h2><h3 id="1-主机ip及虚拟机ip设置"><a href="#1-主机ip及虚拟机ip设置" class="headerlink" title="1 主机ip及虚拟机ip设置"></a>1 主机ip及虚拟机ip设置</h3><h4 id="1-1-VMware网络编辑器配置"><a href="#1-1-VMware网络编辑器配置" class="headerlink" title="1.1 VMware网络编辑器配置"></a>1.1 VMware网络编辑器配置</h4><p>如图所示: </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221141249.png" class="" title="网络编辑器配置"><h4 id="1-2-本机VMnet8-设置"><a href="#1-2-本机VMnet8-设置" class="headerlink" title="1.2 本机VMnet8 设置"></a>1.2 本机VMnet8 设置</h4><p>请确保本机VMnet8的本机ip地址和虚拟机IP地址处于同一网段, 如图中所示, 配置为: 192.168.1.1</p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221513434.png" class="" title="image-20220409221513434"><h4 id="1-3-测试与主机连接"><a href="#1-3-测试与主机连接" class="headerlink" title="1.3 测试与主机连接"></a>1.3 测试与主机连接</h4><p>在虚拟机中<code>ping</code>主机, 如果能<code>ping</code>通, 就代表连接无问题. </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221853038.png" class="" title="image-20220409221853038"><h3 id="2-gitconfig设置"><a href="#2-gitconfig设置" class="headerlink" title="2 .gitconfig设置"></a>2 .gitconfig设置</h3><h4 id="2-1-本机中运行代理软件"><a href="#2-1-本机中运行代理软件" class="headerlink" title="2.1 本机中运行代理软件"></a>2.1 本机中运行代理软件</h4><p>本次以v2rayN为例, 代理开启pac模式, 设置中打开允许局域网连接,</p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409222218684.png" class="" title="image-20220409222218684"><h4 id="2-2-查看所用协议"><a href="#2-2-查看所用协议" class="headerlink" title="2.2 查看所用协议"></a>2.2 查看所用协议</h4><p>在代理页面查看配置的协议及端口号。v2rayN中一般都是http协议和socks5协议, 记下配置的端口号. </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409222519626.png" class="" title="image-20220409222519626"><h4 id="2-3-编辑-gitconfig文件"><a href="#2-3-编辑-gitconfig文件" class="headerlink" title="2.3 编辑 .gitconfig文件"></a>2.3 编辑 <code>.gitconfig</code>文件</h4><p>使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global socks5://userName:userPwd@127.0.0.1:10809</span><br><span class="line">git config --global socks5://userName:userPwd@127.0.0.1:10809</span><br></pre></td></tr></table></figure><p><strong>或者</strong> 在用户目录下，编辑.gitconfig文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加以下内容, 这里的ip的值就是1.2节中配置的主机ip, 端口号就是2.2中的端口号, 注意端口号和协议保持一致, 可以配置socks5协议, 也可以配置http协议, 这里配置的是http协议。</span></span><br><span class="line">[http]</span><br><span class="line">    sslVerify = false</span><br><span class="line">    proxy = http://192.168.10.1:10809</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">注意：如果使用socks5协议的话，可能需要用户名和密码（默认是不需要的），socks5配置格式如下：</span></span><br><span class="line">[http]                                                                               </span><br><span class="line">    proxy = socks5://userName:userPwd@127.0.0.1:10809</span><br></pre></td></tr></table></figure><h2 id="四-github-clone-加速"><a href="#四-github-clone-加速" class="headerlink" title="四 github clone 加速"></a>四 github clone 加速</h2><p>如果自己本机没有配置代理,   可使用国内的某些代理网站.   <a href="https://gitclone.com/docs/howto/howto_github">github clone 加速</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-shell配置&quot;&gt;&lt;a href=&quot;#一-shell配置&quot; class=&quot;headerlink&quot; title=&quot;一 shell配置&quot;&gt;&lt;/a&gt;一 shell配置&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="工欲善其事, 必先利其器" scheme="http://okeyia.github.io/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B-%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="Tools" scheme="http://okeyia.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>复现师兄论文实验</title>
    <link href="http://okeyia.github.io/2022/03/13/%E5%A4%8D%E7%8E%B0%E5%B8%88%E5%85%84%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    <id>http://okeyia.github.io/2022/03/13/%E5%A4%8D%E7%8E%B0%E5%B8%88%E5%85%84%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/</id>
    <published>2022-03-13T07:05:41.000Z</published>
    <updated>2022-11-06T00:38:57.178Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b963e430fdcd63331ecf8da00e85b68c2ddcda7788cf3885fe52308ad479ae60">e8ddf16f6a907c53c402f597f0c2281f2d7aac72253b3449ac2f4958d425e4708939b0421678b058df7b574f2a20007e61d25057c51aa67913fabc023c3d73494eccaa335c69a5dde71800ac33dc951944d77760c7bf01b6c31af0a16f1c0952bdd51f36a4ccf7ea2417f35a9c1293b6f23ab88fb618b8f94f8262a7cffe802fa67bebb1363a3f78c305ee32db600db354663cf276924d653f0b0185099545d14218dfb81d4f984a974436e28157f892e2847dacac013ccb245d3f7c5eee159f2808230a0710b6ee3eadf884d48fd15d10a8ad70d968ad152e9bdc70be171c2ed49e643bf6e132330221de45d9f8f6dc2a23c9e5f7d19a1453bbc601184be48db3800769b6d0edacd0b2f3ecf4fbb0644ef825c1ba340ce05712b613cf75ca29b20f09c0eeb3013ac874b676f5a8fcb0e39edc4dfbcae1551afbe43d2181f3b115b90a4673c9144cd00bbe622bbb0e855c9473e8d09fa741bea29ed840cb993a30f3806313c4363664025393c92721161cdd95c970d9f786a5ef4a6287e20b90ee1035a209791a559be4f33b3ff26c4ca5aa4d261efd40e67829cb12242c6a40b6c64fa00a4395ae8d1887e08653d8e7a799dadd259b4cd81a66cd6b6c82985b73340c9dcda35b49e9bacaf52fd7adae534d3e46388c77168c2a7f581ab2f063e1c4b646d27fc0800878f289925db5a0fff67bf96219d5d62d525f2f885e41addb2a27944d78e22124ed657904f7956ce13234bdb72e59d4f7dded6d696be7c769138df8f190ca4fc496f3407cf0951ddcefe87f239e149a3848f26c55570d3218658669174c41f3d81e47227662d98d3e85965ee29072fd8d8362020456ca8cf5899c39911cc509f65f26347f8de36a9d82d9202c091ed3ece57c25c62e09316ed91ce0f547ba992a39e6dd0ee76f8d3c3fa89e83df5fed2a541b266c5c2733deb6dad5ece37498413fdb77d650b00ac70a532e8a1ad443c1c24e836714bfe56d30ab659bf737c3a3b6d9896386a84777d61d0db1cfb70f6b28736e832dc216fca658eda012a1cf29122170254aaa1da2b34a218a9c00f7b0463504707b0990a11534435524ab044ecae0ffdb373944ddcefe9b70d3a73b980e34688c3d5a237b066036d94a776fc340f04330cb5fd76f04da8a4d1e64eb87343b5932880c1e088df72dbe1635189a38ddb9fd12060dfeae4d4109e8bbf44b252976308b9e12d22843b8566295385fa90bdf0f5cc0833506877332b16a5d6eb9b7c799969ebd8f8752095f99db1110890ddfd9fef0b356c6cd5e1e0671415e25317286497ecfde35c2e87658008e62a5b2cc6b1c7567d6793af600d5f90800832311d0fb26e86322f3fde999461f771845b797e11c2831929d7b8a2886ca6208b2712a7c95b550a4469cbe05050f430e32ceb62161645b34cf2fbd79927e9979af17531b42e81cbf4666a660defbe68b977326b67779982355ab640a061823aa7e09bee1694bb3760d7782ecc88cb0492078e7c1c603afa883ae8bf3fe9e040c9d6d5ab1bd1976e7eb24e75bb29ac0abdf3e741232c27e3a2ee54513927e0cb848951a77226280bc197961e9c8bb66acbed8870e00d7f517138f3c5d6c3169f880b664dda71cc6d1a5c314ed41d88dd9a96af24770b5847a09ba23355d5616da7a10660382cfa7b74b20f060e000bee9a5bcebbc378857c0022795cdcaffb18093d200201bbb25096db5d62b6e55b219651f59922ed3906de41c23496f73bb20f6a8050ef31a29989649cbe598d42ee91ebbddb6fdcdfa8eb42f2ed78aa1384904e7c859bd6712c5f8f4e04e5eb32ef11a897c4cf78b4a6826d8b8d295d4e808831c72dbe8c55c69c9f893a266a83d63f9356e19594c6f1ef44d9894e9e1f3ed46e439c152b3d777936fa8c43686d2cd8565aff7178632eac82f3fea5faf4e523c0dd093393855f631bf0c075e5ac4cb5f26b3350c73ed361cdd7cfd6f4c4e8a53116dcfc7b61647edc8656b81b42d2dec7529aec6751360c528f21e517db6cb39d7b0f3eeec183df1acef9d30587e56bd0c4ea3187de7d28b2e02cadbeb825d54619749823b1e5c907506cb709865a78bacf3e451ca8d0cbfb76e8e00c0dbd12793b85b3a2e2521795f3073329dcbb1b81000eed2c0be72d0af6176cb581cd3ac418af70f7ca507fe3781684639e5e0a2411d2c6985aa63e8721bd90df5e1db19914f0b4a7dfe3b3edf17e51ed8fff28e78771350241270d39a231427c8b9945c015fbf2a8e673eea0b7cd78f210b8f776be3825acc73de19e22b6bd24b1754b05eb24d92855bfdaebc63918e5452132d68f77b9cfd70dd6d839f34f1d4e1a2eecc11e489dd4e07e178ec8fcd25e6f942137f82b9e5e4a056958b146d0d0e4aa42bef70c0140eabcc4bdbbc0eba37acf0d0a85c9062b1000a9745b66c1c81ade6432566a4081ad2ea1ade22f70fca34423cca8638891a3368a9aab512c54e1f29eec118823c37a6aae6298ba52641225ade348efb28323fe7daa2a5ef9b2fba669f1354bc5ab3d3feb4b2932845c9b13f990a53e88b71ac812d68c553ec7d914553b11355aaa6ecfdb3228b6a0802426c59644a75052383e924682ac2d5cf380b448a5ca4ab8d8e98e35302ffc6498cd2aca17f1852fba7eda150612d2bcc9ab73f3d1fd081a053a77bf885ae62b1a77557799818a08d1636ecf761c162fc6b327d762785c0b0740f6044a8dc5a7a792f41e236e665058bc32096ce9e9398cdbe1318da5ba22aa9757b6565d8662e022d3ec1a7d5a278444c648c5fa3d699d6db073899b15ef4b29dc3c009207066a157a850868ac033ad32896df2b12d05c53441a8849aefd92f1c9adebc5b909c2788dd87e841e8c959724161d4a31ab0b9936ded7d48bf13ae03e8b8569ccf30c484249ffe8ebd99586927594cacdbf20defc80dbbb4586a5853768e4af7ff5176c095b6e6ff29b0a27fc94a789ace86ed99b7cac984d8a9fda276f458772294022cee5c9254ebbc74c53359ec73bc37233901d06865e9679e69c625f93738e8d25fbc5b37774b40cfdd2f2a7fcf317f3ae79b5d094e12166bd3b25958efce69a97dfad930218c61a60490e80c54bbf17f6b6dab11fdc8fecbfe20e02acd62959b394adfffaaa975c011eb2292252e829026ab7d86c361eea9971346f789c6ab86496aa0e25d585c1fdd2866a6cf19ed62abb7a981882e14b7afd894dff7bd6d42b9919973ac7385a81241172903237e779b48a9c24360376599bd86dc42dc99eb0613f0ec3e2f1c099dd5fcbfa362bd2bba64b058dc462fefb0305315d7479d566c67b144fed1835a0493473dfdbdcc043dbb102825f1fbc88c9f5a4d811eee89679a758b1fbe726d1ea56ad4df740e49e1a4e72c2623b9b5a52fffec46bd1658afd665a40aa55ba8aefc066c159c0fa124cc83fa7e8626eb9162f3bc3871bcf3364bacb7cf45a0a17b8fd1e48511f0b89173e33e781e8117afb42f6e1e800265f7bb9acf4c60fadadbe0a3711908df423f8ca2c9ccb787018a09a0c881ba2e702580510adc3727cb6d9da265a25a92ab617a110e6b09f02a7d2048a6d093f6a7a9736bf82b02481224c114a4cdc99b8171b9c2cafd678475ac30530f02da05defee7744869512e357224e1bfdeb0f007dd5ce8780b6fcea45342023278fa7f12c2676d1799a5f3e792a7a3c621db20b69f198b6301f4f403a52f29de3d1546e529d071414a01f0edf0114914319100a3f35af32020ad29c446ac1b79165d9162eb616da885569da001792bec512fa5e59656a64ad6041eac88694433e3dd15ae48d8a18dd0c1ce10086e9eecbcb37108313d0e99d01bf723f6c7d6d1902bbf373fb34ec8fefc8941a5b74721116c7f2a68fd14241e977adeaac8d3b284cbf4a3b3d7d20f66f6ade81d706c0d892f7b8a67665f8cfa86c6719cecadbf1e6de65a31d5384aa87d79cafd58c70483ac83d190645f7edcb68b1ebb7d1782d8640e071ed17f1911f033eba7ac9ad8e6629b4c701b44495816c00cb078e0a9280e38654dec734ffe02300562bb49aa9168347c6d7a67510452d6e50187254623f0491d7f7c760904b8cbbe597b8d5158de4e5582acca1402115c5fdf6a6cc14a34c962832b5b78d0ad0b5232561c7c320e9a5eb3b665683121c6978190f702f1c28424c00907d401ba74d915a4ecbe7cf2c87841176c1d1ba9fec92850c4ccc5ee776db056eb33dbaaf4ddde72b0bc84cd8c36af9792ef0f452974c83bfa8ab440817e72214de36b6738a192421b151b2119d47078325a6708e612c347caa151d7e9da9e269bf646ad0ae76d55cf885880f3a5c8ebb18279cd9afaf2f2315a7812735f181b5bbf9ff194e9909bebe266118f67e5f5765afac06b818714c2682120aecaabaf7eac24ec141d7a3f5960edb1d7e1fe31558bb9877485f74bddf57df08fae690f8f6fb26eacae95411e598402ff5bb98dbf973233fac8c740d697f0856dcf00ffc16570f9b025061da423891c7b0cfdeb746e1f20bd2d8f9098e038631f13d63ad493fcba41e6a558efa454e72ac11c9e1dde166ce82f7783ee6749a29497f884ee4579059d063fea384e37327396dfb3cf73b921e3a43b3094c82877071ccbb4719d36e6c9970e874abccf8f33d1e5e07243b5b759de325341a45d33fd861bbe6a77f7bd73506912f6a8362e6b564f18f1e0457a60ab0a922df3831b66cd68e80f93510d67e3014e9f23123a68b7a6d2e60920355f34abbf6dc7ec25c62cf16f55b99ee59ba1a9a75239b49ec34b08e2de21726199ba60a4e3225c675274825caae79e97676ae6e3b21ae445e55f737576c733903ec58a10c1c6c731c375031795023d2434167cdcaedad6305c72e9772604edb0ab2d5dfb2da48d7794f2281cce52426fc9c597a92ad029ab27e62e0a938582ac325b1b28049c62fe11441bf7d12c85be35138dc40b3cce5b74311513aefc4c6f3344e438270fe26aec0c265531b9d710671e35b131241ffb92eee1a60d173c8cfed75bdbf54ac695939e4a1453ab573a2bca8eb0ce77ff6b43e0918ae97634966d9264fe5eb0eab9ccf6c07a1a7b10a145d4d89000198d40fd91ccc2a3b340d76969e88a6cfcf8e3fd8b40ba9936c8c37eb0a7cac5d1b57f91d179dbe63e9423ab2dcfb777f415c873dbcfe7b1e95218b7711c244e178a3b9064123f3035fbee0b185023dbe844168c96736d91b81d08ac9e229a90508b0e5a4cb83b4f68e6a33f1862947971c5b232cd66ba3300142bc8114ee7319aa5d66784a1ed6b34e744d4dbfebeebe81feb040ce644077f815cda40eb737cca4ea419966b1341901ee00a886993f93a12aed56e272b4dccc77ce2f83999f55976cecc7aed6ae6cc711a50ed8e66d75e27498f1ee94ad0a9aac6a0dd5ccd64973d0aef2d40e10b22c4cad5ab5423963372f516cf29bb3001b65cd46c2e8b4d1b85f05cbc6477163eef4128b01ab228d04cd65a292cffb772b252c30dceb6cc508971398ca720bcb36e5225e477c7e055dc1d342985961a224b89bb29500b5c22c8212e85cceb0ad8758418f8f5d8e9183100d9a9fe0598eedf8e9132122dca3cfe722988372b625b3b7766185899d1a73ea6347c15dd98721c51ae513be2e2992014cc30968f9ef66727dec2af91d42e27720a4367f77ff282cdd62dcc4d2a8f34b2a1adc27705c52cce8bbbcf8464e82ce03336ac02ab9286743f9a9596ce12bf669c4e9049c9646bb8e41c13e7b9425f8b1af275b64aa5dd5722b200d13050a35e1e2a263144fafba5360cbf3bfe751f77757f708a2f2427546b99c08df11f4d6968ae243475c182b785fdc0c9232ba854eed6bad070ee98c104dae5e66300cfe1ffeb96be2d3c9d08b50105313ff6c5c79470e0f6edb5a48327ac6fd78ea9400fff52427dbd892d589dcd26869c3c02a58399e08b6a0c2c77ce0b9bf2247914a150bfe0639593cdd7ba6dfa3986546ad229526471aff3f3073f799d72ce54408bbd18d2493afe11b34dab8f3c92262e1f104bc4d52aa8a6af98e5b221b5785f3e83cc9789e10fec61f0003c596186d54fa7c696c593ee3204cf16e577878ab8929b32feb428746c37caa68a01630019a41ac3d51f1d5696801cca303953ac0ff12b30d29a474a80aa3f75ddb3b791d6dd8b5264c71696d1fbe7cceebc961670d1c63f038f9a999a4bd913d7792b1c5fd60a079dcf278e69fbd5ee627b12ac75ce5e86db52b4a284d110638f9123afc96c881217970bbb60c60410c174dc01f472fa61c26169d67d007565ae6bd5c22791cbcf9a7e6c0d95d88772c5262361c416ee30c9abb74f86a39abebb3b7c792e01caf8bb94b6f54245c154c1052f0a04c3fd52ef148bab70d2b4a46ea7f175f339132660db70ac2ae1efe5ec8b252a1df803c929b23d00c8c1a7a7e6be6b99e28af39b58c288d7970b995e603cb2846ee6944b55dbf0f9761b694682473918443dc908ef61e80e44d865f9e5fd19b072e1efd5718e73c0546099ae50203d6563a86cb6690804fe4950dc88e3834119bee24f4de4c280afa512f941c6c7704fc4f3b805d12c3c870094a950144c511710b2a723c7efe4779f146a372b5354004934eb4615b83825106aede8f9de958f424566c72853d9ca426680d881d94bc75284c1fec4fc0d536c829ed0b5e8568419efb0dbae0544b22dd7e0ec593620fb10c39a44a72f496c5ae82f6999b500cbf691a69b86fb428d3e693164f38da8f4bd34e16722dd822c678edfcf6509d14b1b6d6f41b7b0ab12194a6df27563d4eece9560e18e1ac4352ab8193f7c06bb247cb6670afea8ff0190a8f91c07c281a7166d187048ca2639c769089669bef3525b3001704694b40e8d2a225f841b35738bf2dcd600f7fcc4af9f775815808b3d6b3be7a9b2b6235dce59ca4a55691cce032bc9fba4ae7d68e76cef9e11c5d963d8ff992a0a61b128b485ca448c733af21a10f673b0bca67facbad4e9b19080f00801cf67bfe0aff5e3a4bbe20d285c99f1a28158ab27827d7e04bbbf27d1da613e091c0c568954f524cee89d190245a6426e091072ec6ff82dbb1d39d6b5409b6e77e81f54ffc705f173c6a5ec31ab47173356a506feff22f7c41a9bc62df0c27520608c46ac18c72ef5c0392289ad0d0a8fc689d7a0c372b8699407135524754a5169b6e3eb7f313bcf2cf93017a0acb054e86c38c28375470770cfe412083a7bf5aeb253faf0c7902fb8a25a2ab11079fe66ae0f868f7aa06c7186cd8941610bb3e903ce1f8e0222edf0045fad8a854af8e2a401e9e55e37050ef1387f2875b6737cde972a202b41aa23aa00217dfddc9929d9ef5099808acc20c07e3089847aa65aa07cfd9d685bf43bd2d077f3b2cf463d9782ceb28eefa6419260cedda1c023766174d0e62af52b41f0275d93a1595d9b44015b11c5908f1f51aa8190d203c47cd6c6bf85035d03707e9c864d3b9ce9fa4d147bf7008048e975a4cb232613e660019362e3bb674c318ef14c613a74d4aa37e83a135047e3fef5d4d136511d56b7e11b1de16563c8c074db22c1a0d4e583880638a844021182233258023e21739f98369710803de95d586ff9b96761349e44309851f0a7ea77afacd4bed5798f408324aa7988e37daec989570334ec04b7b8447f22b9cabbbfdf18c3340109dcaef1e6b49a238b0901527c7e57edd39d042a93799cd10d11fa47943ccfdb38270278121408a020552daceec2e07d4899520e1f64444d109393e399d399b7c3bcd51c222f4b27048d8dbf4a1811564efe3b95d8dc96bd9e79b300c47944e93488605fdedc72e2b6d2be74e679cefccb7283c42cdf4740a1d74d693fd8d94b11e360e1d6cfa5d29b904e2364aba5705a656e4ac9d961dfa881cc44612d5ec5aeb804e3c6ca56a6d6ef1db24f04fc70ed558baa652d7544a4e3b840ad51dfc6ebbbf6150d20fc1e36e1d25f32e853c144eb42a80dffbf0d80c74908ad759d78bb4557ae10578d799a1b5ee1387c05dd55af6d0cd56f3cf4f2cc1b909e2d1a542677b263c686fbec48c481f40e651ad9c0703906632f69bd12fc6e8d1a4e8586acde0c118bed687c898ef132076167cedd660a71b3a3ce270ac67a05e4e1b7fd7f6fc13433f60c1253cec338edfe4e44c85dc6c1c2edd9b735e63a23b2be93af9f0f9e95ae0b078008cf050dcf3883bda4f9fd8920d44a59b927b7c4bb7d414cd955120b45bcd38926fa8270e3b65f5327854dd973af9b165c022d03a288ae5610f5d12286cc73a4d2a96b32a1d1dc11a57316e6ad8356a493381b2cdf6342573fa66e05cf0c385d853f8eaee73bb031641932c129f36b0415109c0f74af288ef3c5af26cf50376b005addfc8da6148ee8890168e711f593640a24b099d627bb3e2ddb634d53a37834d847a50b63e701a418214a186089119cb1deacc30c696e209bc325f37f57623773d6159c6f235535c6b8e1157812e7d244c57e2754c7c6c9d961b0ef97ab403172d580cb61baf8a1b9372c105ab4fc379b147e5d1723c2e126edc4ef624c20ed56384853b683bc6c67b71ba25dcd2f18976d0c046d9da453ab425679c0a84a33f71e0987f470b97a48829b2cd3772c6d0c606676bf884b6aea916ac863c007a66cf2f6a363bba04d3d78b4387611bd49d7fd1ebc4d8c775b0f695fd7d35a30f39b886f6ce61a0de33c7d122fe84efe24bd91e69e4a335a32723c6f679858ad659207b2ce3a889d76dc7054a1f49de1f3422dc70224ec11ed8ffcf5f6cc8e0e55987d742c7258ddb6e44ac00ebaad6e306c2b2690e64b95e2b2fc106379b48b71201b7e86fd70b31c59abad73f7828a75b945279dafee8d84367e05ad9e65b99ec1a80eafb260550db8f4edb4c119a24a65f3a794339a26ef9e186a2aa872b65f620cb1ea4d9e76022788fb33baf8d9aaed892d6dba4b62f9b2bfaa65cf653feef49e8a136b6f8f7ab8babdc6573ba8b69d2dda1a1a8bafcac3800067ef74d1e2cdbeb591f2ef2acb09d1d2c6565984e5b1d993a680c0e0d177de37c07c4882db952859cb9c849d45d799b01e02fcf26045a5783bd188c1d102adb8e4a2adcb90853f65caf88ea884c1014c6977097aec037d54511e62069bb18a4a87d903bb24bec77a9243a34ea52567ca8c820f56df000bd704b52b31e6d46f64019f88dc5cbd133bbfdc90017ba5118462d0b9eb4f56ccbbf52414b2fba370249e879062118cdc92faeee778aff75144e2f5cf1ca7e90c0a85c17a2198ac770fa54d4c7d056fecbacf916687d939e38d311355c233fd74420406d7b8adca5b01352928a549c386b31f360d5a01c22724b9fafd1ec76bee19db36fbc3dddae49c8736a70c0d400eeeeb3bd0b82f07f2834773c10bd314f406fda98142260c1900ea85f7450c34dbdd3db84b12b7290ceb50eda5b200ca0b080a422302b93e2a7ed63b8c9ecf924ca61ea19a853777c593fb7d1eab71663c84e8ac4b21943c2d76ab9513b9768d14014e9a18fc7693838133e82f320951e7807d875953898c21174ff867cbe7dddeb03fd4c5cc14119eb6db9118448cc42463978db177a7973ae165d8df0e581c63f3fd726ff245be148adda5794b88e66ea289dd1222a2a812a1fe8d96273b01b4208daea5cdf8d623e7c20f185456356fa75f77ef8f2973143b532b91e3ff030503c3cda18a9eb70031b7174fa18fd3244571da5e2840b03c02266136cd8c0a3004eea812fb1b0014078efaa37bae1fea6804a85d51af01d7532f778057af89b3f14342e6a328ed9cd439bf9e93e5749b550d22c38fbe24b87ebfde0d842da8bd2811dd9c431d3b6fdf4305d6b54f9ec96d8b0bee18ff44e6abbd11f42255a070f8eb5aaa66a11a81b133d30f84a01802210878eecc4ac2b357e64fe6cb6d9965a49490a081717221297b5b86e70171a9b6c88c1330a90de192581206a4d997cae724e813898fcbe60d98dcb2de04061cad75b315f4048cdbc2c87949da7fae6a6950b98f2d91760e341e290f3870af97ca0a829987333386795a0c9f9c8a4de77c57544ca311447c203e71a7a97201fe34d586e346eea35b3502e79c2e36e8c16eee776268422e5656840ccd8976b034d20c4259a7f7c2abdb293ef99298e9b064d336de85703eb53fe45c7397a3bf108cbaa80dd360e96a6197540bb521ec3b60b0170a4f9f231bfefd416a6adc9cc7ccc1f7004aa9a800fa92697c5a03d5211d05323f3fe54055d23017ee711ba2717db6ef87a83940b0125865350d665c8fd8154e73791084adc29dd34ef455b9a22bec607bd7d283a95ead44709915e2c0e47eb1164a8b74ae37b010627e51aa52799460bad8d24c43c5ddc821faf9a7f2b75cea34b7f8b7fe11a208c7acf1ccdf7c874582ffc89e36450c7a505e13af1078eb23b32ded0e67fd682da643b61fca7bbd831a09f82510f2137b17bf55517cfebdb3aefa16875fa871bb9ea85d1cdef61f03923f9825b4e60f782c73fb956fa09f8d2f15455ab05f07cb7cdcc3d61b395a79887b09cad9faaf197d35c176bbddcd4888c8eb5730bd7d489ece7ed631c09de238a07d5561c5ff002d3fc5599b7de20dad4f6e90cde32663b86d85953b3b5bfb2d76e7d1aeb83a9bab07b10d38728871d4a974da902b83a834595ba8c8c16ac178cc5e8c03527d7647607c458d79d48fe27f0d973042a0b16da5d3b2b50615a18bc1cac9c167b891c2cf34cbd3418df4e4dc5f0f30babfa8e48003d3f9aab0ac84e8dafebcd223913947f4d7ffaf35a5b6c91d2937c47871b2cbb2e73042ff4a5e709e70ab1b4bf32fa27aedca63ef2837c1717bb2064bd181ac9f58797734493566965d53367c09f25d192a9d6b20e85867d805cdd57a2b4884ed081749b967bbb4c26313938f261f89a9b20f0269889156a0d9de7fd5d517c5b177a6ddc30d78c7705804816eb0bc7c96d236d2a324a5415577f56061506269200d922c466d05c295189f496d60e820acdcd118fbd8839c4d03b47d92204d62f031d9dbe222120f224093359ab9161675cbe1ec8bcd30ae817f753b6a9c4b18c3c2962468946f1e78e83c7d7bf7da6a32080bbf360459e39030400682b788409e22fa87ae881650c7fcfd9baed461ae543e1ce5585aab51e4aab16a09c23da9535233a06349ad4fc383da1e1e11d659fbcf6cbfd43b2ee8428951679997ebb065892b11b1719283d8fa781eff2aed60a39d1d06d6ecf8a0dafe68e402286ec2b753a2a84465598718774a6f4f80a3cbbff3229c85882628ee1e5b95c417ea352823f6cf4d4361ff521b0a55073783e8f224641794f2035be7f6ad90889c24a94b04681dceec43916ad64ba1516c09b1a6f3ddd183bfc44eeeed118264699a627b1ae7cadd58ea9fb524c666b6f56051791a629823faca55f184f36ede83b738febc9422cf4ba06a24881e6907e3ccc1987e805ed1c1229308f809e070da6893e44a990d1e27ae71edf2cf33bcf55ec85c19ef112beae9314640c3b560c2940e8d26777f636103087b4e63b7b79786f4fbd2187d29db16dfef2f0e1a6ee5d3b3054a67c45042695c57ce475df28fc3211336d73a3242779041cfa2e8392c5abbc6189c36573a1e346c8295ec63c4fffbff9093864de014fb12f363d5b94aaa0213dcef025017063e78cc8065083c931d303d13c9463ba3be2073b6c795cf319e82f26181694de78aff6a4a77eb017d3906bf41f195f5234ec6d80145b4a29d76c6d719e80fea12f09d1f26e1fcbbadc461cefd61cb04e2059184b5dd00f02be2c8a649df0e6d0958d5fd4eacdd648ea7ca04ec0e8ba142ebd94aee03d72c733ac4fa24e20fa6b6f89b9b4bb4fbadb6bc61e06c52b74fb2ab9a2ea9115827997bc5b29ba4537b4a32398a55aba7ec2df3cff1c619bfbf5672ea3bcb98cede3cd3f88bd9b3fe689258d1c2f322c628db6a5b106d40fb8122596c0e203a3bebaebdd48d859c5797e6b15744de429c6b32d56677101f3f6597a2dc461c37473904023a58011d600c65a5b2caca41bb4e8448371a761ac59d99bc16c74d10d4ec7d1cdbd4ad7818a15f0288dc09519aa0cdf986cb2af2224feac0c7203f83678b39edceccb9d1b859a1571c53099ffc262967732f1cb255c42e7a630499ddc26c60a6c962db51f797cf7f4710b4c837b12f34439187247b356c3a010e1ce9ad04e76df8ff9732b8c106a49d17fd51d2a82a98bbb6fb6d2613b6659b57802f53d6f57bed7f3f7615c915785942da9a318c8e46001116665bd6741be2ed5ebca0262c4da22f2b6eef968b87afd9de7ee5a23034fc5d69b40d63a8229ca1a9926f1a9e883d60f89919f619411b81039b9310865db034f926bc0efe3827ac5931127167aa861b68ddc6d3562d6bcb01280a7839b453d290f9d91852ec420287fd93c516577e9d872c8233d64f3fcc43c9f80b3ce2b149db382da69bb9a68747c7486408b7da61f0e3130495b3f19149933b3f88c9ac09140b53c703def7991ec3e5f53b6bd0ec42ac174d3c3a674117c0131600ede7cf26d1fb78da78e0e1383459a8f35227d3561077fb1e5cb4e3bdda1fb3e2893c02437a53883d930e0a90c55638c49e39d3369b03f047792cdbc94a1629f272447560afd62516a912e93f5b53bf5f70fb937db74f56eadc8de655ab3903304e47a764dcb584a3e1df2fa57b5acaa3a322e2dfbb88750a47ce7523d3dd1bb512953b375d0b8cc9af565f02d031bf544ae9f74fe2c18af1785dd3e13161a60168117066000f95ad45028e64313a897bf71fea3c0cb068f052a3d1544df5bdc26074b8d28bfe550f67e1ae149fadd32a98b4640e455df4927e5b92f57afc38ddf0e8bf6aa2102ba8d47c16656c44e79abb1cb6bed0cbd2fadf8de4cb0c00cfcedde3e7847f692ae1e7028e6490b8063cdd7bf699d0558d7d3f75d6d993a97bdc00f832e0b36a3e7e73d50ed5386cd56ff37fde108d333f658448933e5816ab8359c7faa8ffb0a6880daf0239766a1f0af783fbe60204dfdc0cb6fa34845b6ec2a846b3c8ea93b572c4384a4bd07ed47d584cee93d5baf697ba051f0d0dcebae81508a6a3939bd7fa152c21829648c848b6e56d60f5c9c18784939062cc35714f4e0f8cb6e2f8fe0d88894dc846dfd7ce21c6ac2626925b38d20d913c901bf89e59a78f6663c172ae418af94e335111b0d14ccd22f6be82bd31891a9d5bd7183ddfb80810116232b5175a5151fba645748a1f13b3a883f10a4b70f0b5f2949b10b5cfea1113eaf71f0e0bd39fa7f8d141ad8bdeceaaa2aa48c05c4518cdded5b4c5e75b2b8a2c0a3487fb6d3ce2edd751413eabb597649669a9461dd844e3b5e4fe5927e03b6bd1386d3ed42b5d7450c37c90ffc7ba3013c1831e279ef96d04544437ecd8e82ec5e7cdc81cf41ace4f28fe936eee1dd45f84255259975323d0e20d455fe0a220c9cfa86a26b95b42c1ec3895d5bf7247c9a1cd4bac4f5fa225907d2303e8a73f9ee78884735bf85e0048335bd75a9d3f90c5315b95b9711c29101f7057265ef12d883056e9acf21e2bdf92d41b25d2fe49d05a9f47c4400d1567a2c28eb14e482c8c06c85090ba3633aa017c775f47c4eec6f62807de86ee63db672d9f08fb8cc8d2b1c5b4546b51c263e4736ef9c2661d5c22d601bc96cbb0d728952e761f03829eef002eec9b43f409569cc88a9a14c513fc8d7fa9834ef0ff2cd1baefc5f0622946b75427d50f3c9dae07adb160647ac167827732ec730d83882879f85409aa113b93bc091660ce9e553e54971fa21c5b3226b6fe0ef269a4233ea8bf109f6f5f14912002fae323ff340306498c9b3ab9c683fcb048af620ece334237be795bed86ee246685f6426ceb66196d3ec6065e59dea8c900a71f387b1b73ff55bcb549cbe9e504129b37f9667db2a9616c31c1c76c84c96b3d5b048dcdaa4a1f5cc9e4883b37bfac34e5bf67e3d081d259a95e418d0f0654767a6aeaf2407564a69ca7ec6fae527af334706affbb163bed349bc0bbdcb2f4d9a732e5089db5745b37a2ff5689afc634a4db06ea09fc51b51ecf8d4fd0a65e0ea0a61fec2e6f7c886d1da912ca31b317fede8167cd5b0271cc5dad3856a67621806e6ea52b6efddbc3221fdc24692bbe40d48405601fa430f76bad80cfbb08c2f3d98d7444438801a20170826363aea1588f947e12cfc4c5185f5c3abc8dac288f59673c201563dfde3240d279eef24677b614cc2c45bab6d5237d383d6a96140ef1e659277ad0fe7be32ab6925f56c76e01d739d3b4a9e01aafdae17cf87f0ee900ebeafaf0a2eb8670bbf56fe5ea63a9cf419e53fb3a371c2890f39b229f21a1d26849df4841281c0d293a5c62d4179f2605c92cd6c211a936f2d0519fbd646259f6e5ff0465b1764b9d0ade9ed76b039574cc49b691c5099646c067dc02859e4e3c96e4f751f65e71a119e7e6f2ca7f268239aa705e8e0b6d3660c7724bf3884a035de60f3540d71c407c2261afa5fe3c877082ea21456000afb1ca022dd4a16b7d9b5f3ac97dcf2796b70c36e88b5a5fb4b74b771f06ff7db636e31fef3389e6cfd755a55e74f5800ff4a06d2506f4ca9d5db52c0f9eb91514ec189528304b2e88f2c573181f73a498b2250046626814021ead25741810fbb7077e3652b920365186649b992626aa3df47948efcb30b08c4c7f6fc412db6ec7f67fa01d115cd4be5e62bf8007974e0410c8127e07a112787dac6a5d8c8a5b81648978521ee8213152c5339606328291422d43cc4f61636d9cd1a7850352378f7fb749c8b5083faea30b4de31fe7bebee87ecff23d7597ee7bf92587458058d59fad8b7e514d9841952ab35e60ea16423914d2a8d8fadcd536f0db36d642ac6dd36cfa98ef661c84bea2560280c06f875208de1b8c6d717b28845ecbf7f2b9c7b5a44fda4eb86485642eb4a64be04d8a378b8a13b977d4f3d95527f3cb4cc621d4cbe96f994b547ccf5e6b385ce7d46b3090ce7c8f62e548ec1aeb0ed1eb0dd5574d68132c722cff8b2200836a8d76136c35f36e08d97e251c4160ddb7acef91f1daab5b1b8f5490d9e04e7fdbabb7bc3c3cb08b3bb444259dd3ad47e7235629adb7c7127662346f5064662dd20003bd84c9a2daa363d260fe0bc54bb34d83ff74d93a28a795e73f0cc534b57c2288487a409355ef91d5fa5958ce90183c25a3fa71c49f466cd3c9679443ac419f1f22d6fd8bb759cb96d25c9c586e9ec887fc26c5476a903d327df09d0ea51a9eb49a95ebaac17c7263dccdfe57fac26fe4617e40a73ac93f2d4f458c95f50681dc9c429ed6be06a2b36d2f850140878e842bac899ff79ac22d662ffd75276f7678190e7081373f56c8e360da32093c31b6e93a55c52f01370c6155285a4db14a73fd296bbd722dde011eaf4c7bab0bcdc7615f75e1a83f002e5a3434ff113866fc8967f249a982904144532149e647a0618d0d7a0169680fd2776d82c188ec9dbfab8e3539bfbafd0a116c587dea77fc0592ef98755c0df201ec6a9280ca9e48fd880e1b45cc892f1a335b6b7589fabf38bcb923c7b06fe5a995c4964d1bb3565320e6cfd1e97e96df4bc396b6ae0d2efb55e2ef365dc5770be9f7d94dde3e60b118931493d23764a99d83f7269408fe2dcc8e40bbe8ef3e8de35e7df587fea165c3cb306f9663b0e3de4f5e982b73949ccf88127b90a9f60439bac6ee1d90d754afc8a3fd2105b4f1f1455638dc9b92ed312b1e3d3fa890e83b7508b0d45dae004606648c09b57aa8ec5d4736820835ba17a1c4278fc6ea5f26c66eb79904115e830ee3e4b5d726aaee41d61c23d02371a1283a7c553d3dec1c7e7b4a94e01fe24e4ab7023afbe7bebef49fe4188c6ea1dcdd0575b75dc07ee584a8d7124108bcbfdbdb40b67d6a149495f0aebffd60f3e28f6ae68975cfbbe643a45578f37cbc855dc22d24a5c6496c9f982378d555e2ed404c10ebe9a57a3fdd08eaccc9665a36956452ee2554f51848a6afeec5d91927e0560a563fb3c6f1ddbb39da61b15ac26d51f179f74148c15ec7ed31907e61c0204dd6e8d219e1e2e04b8be4cb38afacf447eb76c0bc623222aea1c6e870c48b9dfc5f19fe4c404eb1decd9f2fa952446395ecffd5492b2b1ae7ffbb01a1bbcdb5814c132c02876bb5a1543c42c1b7acf4c499bd225ada2e7be1905d7f6b1ab12e59140f2cab2c2a02455ff51fc49426dc7f148372360b43d1e6c427bde5a08e32c1096310af77bb6e3a36595ba70f2a5308bb7b5f6f194cee038870048d2be5a69497065d0d6ef0be8519b6ae6d9710aed46839c9303e99fcd43779411da79fa7031e418cdb4e3b38375ada5cf8aee23a642f54c0777d88061aa1142498a3b106d02d4f7cff48d64c998de0111283fad5cce482dc80180bad71d290792237c3c46a55dd839358a63a86c206719daecca746fc123ee35531e6f00bdce168a1046afc21b3d989418162a7061d2387e774ecb8d53e53fdb2b3665914239cf24e4d4e8ecdccc5f3c20ba6c23351a2c0cb67750c7c31e0d2fcebc7227caf30bd2baf7eede864bebe806b1681bcd51ce87a2ffd69f282e5e90d316f70aa1ed9f1635ba06ebcb8e90ad56d21419382e684fbf9f4589d879507f244fd156e98f2af3e045219c2df5201432f9f91172280f87af1d63e0e98e2f58218db52e8e373109114059cfc242a8807340f03f5e479e2836ea5a6be8131ab7ae8aaac0ceb92f128f9f9832a8c314469a14cc65252d012302d9fd41746f94258981f800404ec333503f83cb3dd748b555b9892f300533134f1775faf1c70ada8811b9771587c23bb00d084964edad6c95bffb1c38774a746f5305fc8002b229d5cf6c4d23005dd66c55fa95d6b17a4660f7580add4a3896c116edfe97ad58b250ac3d993606a8a901405cf92802cffd06e1977cd73d549dba786eba3c93696a5ccbb04e27599c4925ec8624a950b250a247dadea4784aabf86422c68cec93531609a2a6d03e6de69032f62885a8c8ccf9c50c7a5dcdfd1e4724bd51eabf030afc201fb33b5191d2ac716ba52d52169da0fde6f95861c5e2d1a965bfb27740ab28dba1e56924e5d16a3c14ece0bbd38f4537a337f2bb91d94090c72b69b414f71ee1efd8e4bf0b772af999b479d802d185e328bf999eb2c5d884bc9a0d4a22ee3db36c706790dd21814fd1619eb1c17ed788c2140957c61283f7fb7b212df086095249c5caaabc37f3bfd68edf91ca9718a332f976db0e1e300a33a36d8220da285fd389c762c40647a77d535c585fd52f665cee1148b5e2dc2385b54d3c238cb25bbc9572e85888580a21b70efba7e94e30919e9fd013028421f2bafea114dd35258e0448bf28c11b2b9de3ad041b1616654ef0fc7b3081216b6bb8512faf90b8ce20fc41d541b2bb8e5361128be241a9786f29b03eaf58aa747588b62f4bb15f9566199a8e6bdbd786df74923f66162c663e1a4c5825dd4d1158e928a48f0968293ef6d2f137759a847b5b0c4d22339d594c49fd78ec24f85f8ff9192fa806fc0848b6c79d12ee2bbdf4d018341af0244004251a9e138e2a536681279d3a4e71022e7be8c0ce73ecd9a729c8727cb4dedcc69bc7ee03449fa6c165cb17aa4b1e352b72a0971664f6734b0c6fdbce38fc8b58d23e437be22e1d826d7650db4ec24422934b5ae3a6bdc76645a2cb7a7c4ecfde014a36b99df897eef95c25bebe1b6bd46dd2daf03229b7eadf38bd79ddc1ee424b4050662d0665443dea924dfd43ca54762dd857da2e8376c40b2fbc06e334fb4021a321731017af247bb56476508dfb6292b15e575c7ad0b5ff6d61fbf31b01ce21ca0e21520176be75c4a8f496c07a96b8215c44aa3c7bc75abbbb3be4eecd721a81eb261ef40e3bcd867f638d6b85fc72085f3e9143c98391b579ea6cebac2cb65415f73be2a4106cab880597cabff2f39b073f7c014b530f12e1ea844fae689b2202038e18fc4e3e0c866cc26870780a8a41faeb64ed56654c0082a927b07db60b72ddf6dfd7d04bda395b1d79fbbdfd860df18fea38db10902bee9cdc31bb6f66b7f49bcbac442444318d38377720086b91957f9eb9a1807fc5d5c20cf352382653571fcecb322186e66399802b69d012875ceb470de2830f780d3d1c221d155a19a75ccb6f96b1bbe9133c0c334e99b56b57c4bc8ae915b0f7d660b932a50b79e68925c4309b2966bfd0908896023ec483741e2bffca95015ff4aaa6cb464be0b28a15656c5d66f01cb84e79d6d171b69d0b9f79fba33c52ca82f8d1fc6ab9b7935f35b0839efed9ea17c1bea77e750a6a67f655b6ece7ac56fee877a707568d82f9ccb6460d514abe72e4768d93caf9306417724e5318809092bf59a289ce015d90159e762a9457e66a0a6a37356171e049342466553ac30cf5e541ae1abfad54cb2b3b188140f8281f64d2a32ba34d8e1bad2b452aa701fa2aedde8059ae4b097c34156d4a66a60ad712302a0b06053ed558d5894d59346f72f15caef092ba3e1b350d463cd7ed35da8e808c2d7da54e9e7251a8011ea96f33d52652d2cbfb5856bb168c006ae9a5a53f67ab90dfc4b8085b4731ceddf9c7ac1aa956bedaf6aea070f2493d67cfab0858a9f7d8bae89b272aae0abf5f4cb739554f676be6b7c330ed40ababf1325241e47390ac56042ada7ac01868b355dc94f09759bcc3a97bd3b026a5490f51f8b73ff9a2400a6184c96fe9c204333ea5c2bf1df77f9c9e4928286e6f75398fdf7f9794148bf839e7c378a161e75c462de2f011573f99c990e22e04add92f96497158f9fdab63aa7e8bbd84c284f1aca53cf9fa3a7c946327b3390ad1218ede796b4ed0695da0f1cf008ebb424711553c8101f16e7374845f12404c034e110301ae5c735a8b2ce7a5a189b296004e27af602a1cd83319a3de6eb05f133e7bbb1f649f467abf69c769207e73de2eea9f3f304345326e6a6d6f0df0961e9075ea3cc06df4ef6250e06cddf0f557da3c549465f5ecc62213e407aa7a541f66a9cb161257e96950cce447401271e62a7fa5d7f958b324cabda6c78ee9de0feeb5c9cefa95d05a516f97e83948ddcff45d0389b6d421f5858d465965fb60c782fad56dd1f8a335d2cde24733d2ffc57fdfe5438b734955618af1f44c72d7a5a77a3f24e54614042e1d4968ab4397f39dfa9b8a62e647a250f8d1b0e6a6c87bcaa2aa3df9dfd5ff33c88291e2163842189c4c57d49a5af0f37868ae9855323968272b0201d25b5a6899299deee2c10c12066f5070fb710e7a36380d2df1aff1bd9233a648f51ec86c0874cb1dbb1265d941fbf3a2656c8462bf6b98c4a2e8198d8660331230e53073875f10b1d8a375f0547ef010b505af9a513741a42e171d1be557d01ce875d075e84c534d6d1f607a5f01251f7453ece5938b3f739c6fe181021b491387900058abfb9258faae3614e827cb1da364522a0f14fbc7fcafe5fa1796a4cf7eb9bca7877ffe4381dc6411ee8eaceda41106cc27a1a23943b11d3d6385b39cc1a724696e5a2d06ea5e189df675bffe6d1caff7dfd2ebf3351a05f5e5d59aefe0192df058ce1239e52fd44cc71285c3d3d3fcdccffb7148e9f2b9631cec6a2289b92ac9481ec89d4fb2a9fd1e05fd658fe9cee4ef0a51eda1f83290e0b5078d74674f12b5d3fe80bda83ed48dd4f6d44083be349526605b18a1d8160030d12af64146ea63781b3436abcd1b58f5527c6fd6325f4e24156b69077f64de3924e7613870d8256d048358cadec836ed85713870d64b37c7f69f6a3ba8e5ec6c8d74c53aed3ee28a3c4f081800411cbbb7195d52a46960d6df968d53f0c0db5581a048790e37d79e080e795ef488119e2a13debb833d690747cc89d302bcd281b19887452cef23742f9729b687211d2fd5885887704fbecc241232a35e6b4f9d8f69c67dd5b312a6d3eb67cd5036ac96709f52c0664b17a6cb88076360b5c8ab47d4449e0990fec584d73d8f6b676e540ef593a38165ef0b283f9b5557a37387689e03c0af0ebcb4878087a89d26e0ad89e74dc325643e3c87e832bfe38e63780a65cdd776c1ef5f87287305bd1ba74941b2a080006ec1954a16358823cc7030b52200871df533cd038129057450bcb0a2a6abbcce522315aabeb54256e4e23df638ab77ab815884494e90f587cf4bf81b0266edf51c24adb1576a23617696e495510e74e04eb7ba23256ff896477d62fb2e99c90051bedfb52248e050a1627d39933389c7c2327d97ff8a0d13ca12d7ce0c3bc14e4185cbf8ed3d55826de6ba470f8cf5b61a1b5bd531f098f9d5cd6b4a2b1b499cee879e12c20c5e6e24cf0e975f62be4a7b40efdf8c422a282b6719022b4ec7cd15b73a3ee78c112b1e16b818125eb191b1033e0cb163f3ab163c70e197c7a6a7460f49b34746da2495f913da96a59908eb1720569aee4d4ee307c6a95cf0f93a27b108d066f308fca9615d5e45380a7bc305c3937d05084f741ff9996e1f504f5b25572d6636fe226444b3a8ce812e76565e153a0275c3f5846510003e3efee24390df6157843cec8ccb381c89c2360bfa687b4306d1c4d43f0cc99a4881328ade97f94a4d858c254bb1c335b4f7ba11239d209dddcc379dda07d3a7972636cb7ed5a0f87bb29a0aca08749ff4e51471b224e7fb26abd8a426bdaa8623aced4583f4bda7e642a6a83405c86923e6688a2518f89bcfe108a8876a2c2fea7b8c192d19dd66ef5f59a11451751b182c67c6092c09b0b19766fd52cf1b7de02eb50754485b00bacb798280f7cf6181adb771da4e39211dff54b032f9fb9cef6049a5485a4a00a79059a3f44bb307727f57ad794d4731f306b274af2675fdb0a2a583cc50ddf28153f249517f6362315b3177a67b96b8b786ca1719d79ad1868fc06e796acdf807e2330999416597207cde3440cb3227fe923f1678c264bb5927cc6b1cd203e986514ac02c8baddcb86e07009372e88db6eb217cafcdba8cb6f6ac3944ad41f8f90001f72704c243e3a0965dcaa8d28915d0b54c014fdf9a155e803086c5b3e36410e9153d5dd3aa9aa828e16ba9338ad5785929af04e0e8aa3104cce7cf4f7289063c29228b9530a95143b57aa1656e06a1ab3d24b7203d0f346022189980d9dca89c16664751cc7408047cc1364d9c05f9b2fa4ba51687ea4dffc4f9b60afdde1d5500986a24190b6c82928b47933de08687828a2481d8b3846ba5c9f235bd2b1310b4d3366538d13917a40a3ef76b85b49781df3055390be52f3abad46bcef1df9abe38ae8fc0563586428cb4653aa1511415a7e27feb9c04ff45bd272cbef13747e1e8ff7a28b8c735ed75a076ca28431c8069061b9c286ccea6290ee950c604108f881e9b6eda1a72b14a4582ce8ca0ffe5e5bfa0ecb30a0a0302edfbd911fa21e57a1ec0a8bc8913abe6f06526a214186ff51f8d44ba2572fb78cb21824673bb9184bf8616ce5de703182ce5958fa1dd0239c6f8df8cf59b0599ef04300c9b264f0bef9b7185bf636b05a65225b367958ea50ae5e749951d7a66e375d01e7bc45fab0ccdba8b8b1a5ece3f08d7c0a261988e1c05a980061fa8a3512d9b8511e0489812f86b39569e250fbf12ac572e8f8074a324efec134a8f529f4a461e1bcf8121caea700386d893f4096348a2c1ee292ea2d5d79e9a560851ec601224ea2c26d655a8617999fe59c1179d70948120388f25639d85acc60cbd8d513e0a94a83621c8d8a3603bfde40236e4c375983da1a8ceda36e60cfad839fa26ac84e91683c86e33d6c02863eb4cb92e37983c54688d5497e7344e4cbfdb202c7bea23a011c7608503396086d16ea2a9e0860912caa16e0730e59e636bcc9d2cbd70d1a10ced3cdde21eb0523555737efddbfb43c5d43df62b1d3945ba77fc76a532e4fb84f1f8e4a5efc8a6ad4c842d50e8d2f999837f9e12cd815ecda9150151abfe638ead53d813ba6b275e302af21bf689e9a863a10578c4fa82370a5782fc1bafe1e99bab9e10202e045b23400f321295948d14d5ce0fec1324683194e0a37166c95ba25fe9eda9c8f513f257c3eb2d786cf69adc4c33f5ec595e47ff2f8ceb2101935f3159dff604013295e884642c38bf625390deb154656b6545354f35906aaa34c78d984a9df41e13058108ebcc12d509894f55ab5af998008e3845b9e8a156f4cee77992963c0a981bd226f7ef6f7b5e2c3cf2dd9222a54672b0c80fc857fa564c3b0b5634037e3d59bcf48221ac0fedfd1abf5204dbfbb073c7d11c955734ef09eddabf89066f12aaf1dd1fb5482b9ea16d889a84664d52bf40b15f60ef212c3f133e2e6018f0d1cf185471ce6ad372b8ef4abcfc946ab9ea424b649ee18c20e897b90a3a24a32a6111d314b0ecf8d5453b3a600c5b2c6d70cf72695b435353ccd3a1db05d1d04a4b927fbc1c2870875da7fdbf8651ee3b508c4557d8510a261a47995236dd15506705f33d035f2196c1412559e2f9a456721bfa7eedd2134a81273cba6bbff7a5fe0c130e772f0a50427f6ae65f4da92a2d25bdbc6b151babaa0689c4c5af8266d140750a89077cd3660ec54a2509ed9ae5b44b5d8b58b2eb8075b8cd362905916d2a3dd4411701c7b23f74bf40f47873e2631953d8631aeed1675b7df380f32704479877ffb64006de454c15453a03eaa481cc93f7b2d6ee19361bbb24b7e3c452278bb0d0a4ffeecda936274cba800e132937b0397a521303ef98c482347a4139120e65c8a3ccd9d0d1ec97e62be684e5a8882b922a405c0b790950958070ed5db47adf8795b40b5f55a146eaa0fd136f545f414ea6c07fb020308d01a760e40fe3cdb6b0fc060af1edaf42e19bbac18e4c9be39842c63229c2de3df2b7fa3178d223947141c98cbff5b5d2c2e7c376c96721d70d2e61f9691065d3774a6d4ddf2184844ef33342cb8c207c24b5db768bb780e7ef064a499091b84f9f0144fbe4bf559eb973ed0aee7597eb08d7b1d7bf5cfa9adf36e0321955834473548c251b55cef93469aa086be08eecb39af61a8f05750ef6b3c0d2902175600f5c32da49328883d573d18ce6b54ad2f8e331ae1f9ed1f382ab1b673a1e81db1bcc0ec8e332f1aef8a18b577dc22de0899027df1d87cc3bf310cb7a4fd01b4d377860bc193bea84e6126b33d9abfd3b5e8b351b147626d36be853c6c52763a5a922b23ce7770277477f1ab43ed2911b307b57454df935bc15349163c95669ae1142df312344b1f9fe9d7489db19afb18ff28e595d010e6410cf99e7cdd18b65c6d703a0d49c57d3170469e9c001d9444d0a76ea3f8dfde58736e6b00be15f4a20487818a1acbcae9d2242173a432fed119768b66bc8c4e9bf4b45edb53a474cf7da6f496e1406c547b521fb56a1d7d4af26aeee07c93ad0ba9a4f3bc208a5eee002fa090163cc4e832981beff52a2295a994db9d9c349295a98a2783429491d389eb6dc83907b88f0d4284a8049dcdaa9ef5f564ee3abc7dcc37301290b9b4be33c2260b932f7c0a6d41e49fafad291ca3a3f75959c0ce0aca1990b1464bbbe859d19f031fe01e4745161fd08a4ef9b7d2aac3bf1462e7da521ecc969e21eac441d21d5f2b37d6c5aa1bfe7b168328297544c6dfd46bc2236f0df06beb725c3b1939ced10d4e589da032b3819c1a65f26570e250c2915d0783425b0f8b29c25a2d9405963a4054d6c0f44d59a56bb5a072c1f42f05d9bb2e7e9bc91aeffc0475434eca4adbb902273d0843785d087a3494e67a98758a3ffc5f05d0b515dad2c94de44879d3bee8bc4b76e5f089775f0b6ddf1e3653bc4669094d9f57c1436b85676f4a238327b1380ef2e9fc93478944ce58d4c89b1b3b35f1194d2cb1b2e0c3f02c76fc320773c8bd0315d6f7783ca2862d88a73c3cd8bd3a4093806b23648f0c69331e1c52a1ec6ea50c44840bff1b27e4385438ecd309510c21cd251ac89e2e0c97423149bbbbf80ea77f0019c25459d6aa851e3e18ef6bd180de8461887cae68126fef91d0991c128812be9f0fa8ca0e8106bcbfa0a23812855cd2f9b13819dc7a6caff354ba8dea0c99ecd427a47fdc8bfb18583ceca319aad03b1ce09b9076ed98ee5504031b483a50d0b521184b676f6bf8fe71628ef9b77b6d2c56379695799c5017c4102e0e2326ffce27c9f8264c829126e9a021b6a24e386b00289742d1a310666399456b451b861161b37c12faace3db833f33d6d794bcfb1bffe27d1253b239bf34fac4549bd3aa75bfd72ddd29b7768f81a56c31532e8d85f2ddb87c6cda3c03a018e1ba2211401afee076ca415501c51fcc85109ecbf3989cb500f5132e456197cd229b106d31f547a823d70946843d5f76214b6bef5c8a91c92c35dc140511b2a135980e3060657e025792bb00a58ce66c2e4efad7183d55b86f503d3300c0d4d93c7860074aa385cacac33411cd07f069d4909b82ef17e9ad7dba0be85287dfd5b864028559eb603835c114d621bff5154e469b30f742da0957a25d72e12e2e05e013b44d59fb83c42ed285b109d46d11d01119621d516d011de809714d3473affee32abb04b56f3ac5f9de38faa84b80302ccb84004044128a5629e2210a56ff730bd8f75c11e0dac6443db69be6efd076874479cf07a09d5e9a2d6e974d9b5adf2a38777fa1ab5b38ea323d31e6d3eabd4314f2c0f9be07e5af0a230b88be47d4da105e067545810a72b98a46b3585a59f6998f8a2cdf34a0d66adbf90719788e3d8323f4b74a39a03d37929ca625a8aa8d12345fb95e9bc956f4f84ac4b622bdd79ab80f2dade542c155ae8629981902ab8732617704eb2172d23f1bc1df5cb25b359766fc7bb2edf179bb04016cab12330958ab42da9eedf3bf4e2bcdaa1daa9c1ba54bb0f10fd032a97ee874c46c731916df52e1f1e6ee96546d82c575514f0d3defb6f5516b6636163eb078bf8ebcd6d9fe5d7c2665001f7bd5663d7ffa88b8f2020e2f4fdbcbf0c2162613e638769660fd64da98d165ab061c4dd681f3eca0734663bc856d13e334c6d733bcabfec3b62728688473de89ad3aa6e5d51371d00d732ada0c14b3445c9c76c58a912440373bfcbbfc7bee0c17123a8a2daf8369fee31e31c85f23e3456cee14e84e64a86f185e5198c9469e55344a8bda3de4863e38e9f6ad00a5d18cbafde6edc831f0c6dd2db61c9792956917d1e340237c91a8d37fded2412e329b8522449e63bdb9dfb4bdfba65acd926ff5947891d99a43465a5d5aacb3cb73f579312dba1050fb35e06f68d4d8e457d65289deb17eaf32205c4e7170e05bac38f054c426f8c6d56dbc0525dddb839c2cf68eac257b0a103c094b65689412774fd02fda71d8de98843862c243cf8fa3d2c226b6766907355b2bfb090540870f220b6af9b5c6ae0833eb255c626d0f21cf330fda55bf8fa03e545a5d7f61c773a6c54bf9cc1ad9556d7c028e2de2a4ebc7cea829090cbdf5340a2c8978a68705305136c9831ae42c59ec55ef118be6f19f06c52bd547808dbbe7cb36ad3fb730aa6a461d7a212430b4fe4eed9faa91eb4aea9c47e728f31d4bcbc8747bc53d21d0d0f965ae9b969db8acdaeb0334b6f859ed1348617c592feac4b0b8dba95faa179d7ec017446f974d6bdf828260ad0f8b496d78773b2a401a2a933bf8f2599b66a71bc0f150ee2dd34642fd8f1b5c87b83d99ef307541f24c6ac6c7e64925ef5400889c2876639850a4fb9ab1b75df64614f0611ecb171681b563b45429e5828d4f7b504a2b16f8e3e48513bc8e8b05fa4407d75becb6e5cdc2b81394e9f819a1aae7ddd0e2357a6da281b31da692dab4e84f8bdb7363cbd6998a1478deec57ad70f183316597c8c0fa76d7e92fe539f125e6b7102322ac2856bb9b9bfb71476c5cc507c66ea1a4cd82c13c9637bb6e5682ebc22f921847d0c28c6aba3d1565742668a76eb38de5071ebb074785e9672b1e731562dbef224092bd67ac2777f1824f73dc0b21769c964c2ff1c86f458a55d9813ae8aca91daf5e05f7c146e4a0599a76b4e3c62d90dd47c9572cd2297a11c3c89623736f5972a714ae9c33e2dbd383c2ef706389dd20f2a05f5b39c395112057b7f825a80612556ebde8972d0b754fb547f4027a7ebdeff44a932230bc8b4a739b7412a7dec89f7a3c4e6fc202ffa5de2e5c066a77d56b87ffd35349f1f6e07a38dd1b5f012ed61725fa56f173610a0e1fae612c1cbc6b70005ce0d6e7f639a5bcf7f13a406f5bd20e3028da89f526a1b96805576f6cb18e44ce2ef68c35356c1eb901062b930f7de311879cf8434468d21429dab01ec46a6367635e0571a61c5f606e5792e00def0206427e7cfce6b88cb35ce9d08098b4729af2294408cbaefa9e19aee587aaf2f161246d0197fbdeba64eb5598e14920128c2ef3c7efdc0b375c16af2e7a795d04a3e158f2850e0537ec2c0db59773e664735e000012413ea4d024ac97c77ae966c70090dc1667500da784cd14357a7067135be34673dd70c9cf51848ec4df1a1d04d14e3719f857a05ccf62afb51b6bc3d6a480191770e24833fc2199f61b69d8ca4d6190e1f0f7e9c7d1dc64e4134cc5befd8e7c1afd5313308b3db951ee871bba48660a933bd7da0b4e47b56ea541007df11f266f69475916f7469e6608a1714c854ad7f611c8f774a4a2f5decde2df977ee6dc2feda89cb7806d45d610187d0b3bfe7702af29985f17963ddab08394504869b0d07a78d9c4073150ca4822ab65dc2668b2c6ac5fc239ea13371aff8aea54967afbeb50a6434d42670013e38c3c69755545ae3197954d140faf815c5c801f1d5d131464fb95e83fe45f3487fbd0fc249f425a1f73934beffbd0095d46a416286300c30b5cce8b8c6fe96e737294fd799573f1efc7b71c67afa61fdd7f4a4d1e8aa5d271da6a3d8882f2bec9cf50d6f58226168be98d099ca158b5691cd24e6714565c52c2f248950598d1c3113f881c92f5c15382373e6c32b18705a52ff5cb39c886e93f6625a3fd35e2cac0c083af6d3445b12de0366a42cee915b178214198c14b5eaed94fa356686506f0fee36ea86d4c3b58c7681c8b0cf0ca2e08057a39ecc48413b45926fd5ad7c405c4ed4dbdcadb32882ece8ee69c9af4e123fc3026ee30ea0c7d1a637c95b7a34a484f33539af4d8f8e19e7e39f8c54d59f4864748570a8d7379f7ab870342c2032998a31d2d5eb6e42e06578db6478a74638f5c9a700d06d5fd3bfa2d70654b8b2ee2f8919278cc81500c013be9c04d18450a4efec50ab8627e975ccbd7d43dddee81d3c89d1f9d838d894c7fcb57885d617966533cecc1a0c4bffd80380e7e736abfd6f67b470cbd46936027462e61688d877de341b98e191af7d09f0445b0393fab2f8ad00efa13fff127e4eb5e718eb76b87dbe0405dbd162a776b7249ff233fc4dfeab6fbe29eecce9739d43236152f83b542385b815c47cce7c82b3c6fca26a504b33afea9cfb6fc5a8df86638ff95b4d134f2983c04ca86cfac3975be70e443428f569f95f0253191db3608ea03d669e3b1f5d298b5fd35f33c73e590919528faf405ca93cf937ca53c5616929c8a72d157c7d33a7179384b8642c34b97f6ea2e5e3b234c9734e50fa88d13d052b9b30821c46c174fc9d2b8ce4d123b58dec26b34a0f3832c998b2b700deed8d524f52852bebf9beeb283c4a0d6e07f2d3a9372ccdfa5203c24af90ecb16eef91d739ed5bd8e53f9876873403a83150fcc6d5c0e61df2be3b9f2a78bd8be030ad63947b62acff05d2c19c066bbe5b111036619a35eb4b75bcbbfd6b44c7223ec26b86846120bdce8d73245a730f2f356e9b1ff5523212eb02d00d4308b24236d48f50304b5cc2d7b8269cf2263c48edd5b7671482f056ba6d2223c0a99593c55a81ef88c465c62906f28f956e837ae2509000e0215db6adaad66d5f5bab82834b09ae274111b814c10032734e3ffd2d1a4979f01ea7d232545fc738004abe944c8047bbd7d9b882ebe3983795a281b587d9dfdf485d776019cb0842659469152bdfee0e1adb01042d379683c5309c757a65a64db989bd4b087374aafc6139ea680d88d06776f7dd6e0e01328ff603fcf7c81a588fb316e580ce746011c3b83c69deff1e5b4a9cbd22c4cc50ecc1c25d7658392ab1aab243b3b4e20171d73aea98d13444088ce21bd47dc77461ad9804bb3cc1181818032a8a0bc1f71456bea772b33213164b9b864f8d45107d82dfb0b71b1ddc80b0a418868833581e92b4a74c2ce68084cced24e1ba873d459e506801128150980e0853fa747e29190b6c3e197d7cfa0328648c1cf3ddd010b5ea5569581bf763eeb20784b7c7324b95c8a9d44f6d3c9b55ac252c5c67ebc7b8c59f55dc92fabae39573c1653d154c7c54be27a94d193b31bb4d4269419cefed68c7c835bdfddb6bb2348ab3491b48e8fa97317c87aebbfc9555fad4eafc090da1524e90e566b6eb502398e60d9b4fd74e7fdc32e1de8effa67f071daa94caf70fe09e79d31d1c390a02e3f3fd80db72db97f40949a648ca983421b57ba816b07ba46f7695c4746ae4af9f60d22a9b1712cb37f29b2e8892550e0e5517cdb5095330e1e01f29150691239a524d921ea74ccd8f7fb660005cfd5f94604a82610f81fc1262ab059911f75e59e4d4270b96f8e1ba8efc366ca9b04b307ad9cd140dc4fd9dbb41ad6e12ea9cc03b31f7cead860dbbf2dd2b2a8d6dc6e5247c79d5bec5f5bff494b6d65c92764b08fab1ab93fc29b109c364e6dcea8dc74bdbc0dc756710d9910093c5cb804e693ba659c32f314cfcb43b071a0eda53f05872982493ea3dd43af19f556ea31df47ca3623e13b4488daa4246ec6e8691394f1f24da6ab7a10a0a3b37f498ed64b5df1913244c573cb7be297bc4055b40119e573a18c5fe3f0701037da1ee15eb4ff65b1606583debf186b4dddf3b645e3d957b028b3ea805b9333413df45ceaa2222ffb3b7d9a20035734dc846129c945799147de181e5ba707fe070bd6f5a3166ebf2933ebfd294e8dc3b9726c939e228b783023938e176e7b83c2c2a9fa68f6eb7d00a5453970a955294284ff7c494d470966b7b5b3c9f46aafa3b1458ef6055bb62fc2bb58a04ea3061bc1f870cd50afab63377aaf50d57536d8bab10f29bc9eb60098276e8fbf47de44528b721a3baf243678d56ddfef67330118146836917333f6db9b6f6e9572edfa10fbca002d112544846018f65380053c4dabd3d69f3956d6bc0863b7f816b34fbd284a0eee07f991d7f8f08bc3ed61116e09a3f08e44b5ac02a7fa951ec9e389315cb43bc78295069e4adc6707a62fedd692fbce8d52226cc03d8708278b7fca25a91c9e354daa98997f9e09f7283571cb089bbd4429eb92f342e95ed95dabdf47d575c27e6fdb8d750d13c4584ab786ff86e031e9202f61be1bd714232e9fac0e0ab8e1b886007e94a3bc40c1e64caeb32c744cf00bc4a1b045dc93ded6217ba0cbb0c74f45f748604f14acb79b01dcd938a4adb65bfae0afc81941e2f02e5604a7150692cf70e496b3a645a5b707dff27182a489dabb2995622e9725760c1aa34054e397480ace3714d39e3c9b1864e6b769ae8104d62e1e601bd15a6427fe7310e08801932438f1a101f54d07f596b1a9ebf44659d37dfc3e870528bab1df2ca251c07c4400ea1b445fc7879a00e52fa675a9264314a9153c862971c3f956e2b5b03b4a92b451eb241f01e0ed24bfd2dec274a7420ac87105f66072e380f489b7ebe83a05076db0d0a2db589f60225e2273034c3f0f2731222c146ab406cc4bce83f338f93f39269586f6b6a52a96eed1918927cb4ed5cc70b15f95d70d56fe2b58927c385755877d98debc448625f4b8931b334b4c396cdd48bbdf0f71a4e10e116be07e6c97d0ed49f858cda1e36b84407df08ccbe117e7ffd969d890a746ce060ef9b45e3c797a96a2ff666044649ee718142649e3997fec104faf4cc722d0e3792601ecdb79b7b59596ed2bf6d8d2571e81e56384b9fb0f94964c7ab9cfb45abcf6ce0d23df0ef5d72617906594ae28a53a3ba4af8dedd5d253a203e632973dc72d542f446b7bef31efa65b3657c4ef0a49cdc47118a6653c884e23e333dfe728b73cdabc2b97d01422637554dd954d1a7c08bf343f636289365c773e0be0956a0cd2e438bae199eea8620545a46f01a191a20159abaaf0464d645333b2d65dec651281564936a78eda88ab8cfc28762cd47e0876cd886d6e53a951ff455ee46deb80eaa3783d915500ae539d5ed1765f166f953722ebc633ae64879859ce6a94709c8984766a71491e3eec6df0991b3b00aeda023c8ecd23b66b1371c0a8684d5a1962558eb0f5eb4c68874319a91ad14eef8f0cb6281d12f6e17fa11c17ebc2f648844fc297f10176c5af84caab679edd100ce31bbfac5b6b806e2b2293da94b8e78bd5ca90a0edf43d2f913852d28709aa1fd7240cfcf97727831c73e07a2b9bcab16f57edafcc57d0fd543ac5489ea39e3f06efcc18fb42bbdf281754be275e4d37a6ce5ccecff7fd62ba2ef671f826b1db296aac8634f7cf0e0c55eb76e5d9f5c8dcb8b6393cee032b4298b7407cdb8191554dac3588ee646a501eef32e97ff78746e311a47117bfdffa8c056c55a2c2e82db67f8439ef758e9126474e7942f13603dc02bf8cd2112d2410f4771449796307aa6aa1fb3ce7317901d17c69b9e31d772dbabed21bd8dac4879f5503818d7974398a1a03ef4c2724f9e658ab8463a9a92bf5082df50f52672d29a8291e15fb3e5ea91b3d68c56eaf9a6ac4f3efb9412fb8a5e0e266991ebaa1962835bf2d4e483dbdd38672d85cf0d3b25533a3541c570b86a884a4c70dc726d1489d188efa090bff228643ac7e095bb7462544e434a9841f8c528d8891482edee1805e4e43764002d56c874e372a7d9ff013dd02b438f15af7cfe3d78ecdfbec1cfbb9101f3a0419470230e9cf51e3ecdb9d020c267e40e53cc6dd4e4404920f9c0633ff2a2b278314221eb69c33fc3ee5a5aacd0c30146a023ae666b69d898d535eeb71956408387e2fe037880fae9ddccd2ebd120cef5c4702ee837da1636f263196ac5fe09b8aab6e0ede4c5d4be2f8d3e4c76db45c07d4312572ec301ca662edbaa164ed54d8da0e276b7b96cf616302186c4fc35171097975e373df3cb4271b4b7eddb0218a5c6e4efdbf7a29f0b7d67326f2707c141ac730854669c13cc07e3918fd65cf45543dd4f5411dd99d9d98451e49302b980813bd00376c5807b4c596b4b92ecfbfdf583efd8a1aec451a666e86ce0ba0b206c7c5b4504ec80373b1f2d34c7883e86d473813b641bbae8ff71f99cb2d800ff9f7319514544b57507019c19d00223f8f8b215acbedf17816c13a244a6bb4c0e916bfdc699e01c8ffa7473f828802c097a3cf62defc2c6ed829ecd2d6023acc247468ead5874bb737fb1913f606e8733ede62b73e1c303b6261eb0282bd5fe047b114ece279fff5538f585e598bc3a8b80a3370d5507c6daaa196b50269bb7cebc35429ad65675144f9819788ad0df732858230ba080ec64810c47b797c66d9f9a02974b5e1d5de3d9ed656106d872736e7e9c0edde89c2cc5015782eaa39b925ac43d7d412b77ae076da1f8e5913df826eefbbd20a50c8ee8c86aef16ba0d41b227acadce5fe497a3079f4f0a848cf975a7e81c8846ef1a91fd5b6f154e83c90ca667e5d6768ffca7c2569cbfb9f10257bba9da1dec74009007f9771b6174fd390a37e632d0ab9c4613ad10029fb6a65e90893974d4875cde21948b36fedeb818090bd77cb4a1b2d96f6b76886a8f03bd1b76bd43b35b7db296a3cd91900b318db97be61d8d53d01c1847acdaec7678f89ccd33c2ae4814c574100164b5ce30041ef84d146182636270184acbc36b9176f080819a56a2c47635179652f7c6fafa13755b2a8091af20514363c7588e8fe9e21b3cab96768b2bda73c5006cb0c1b1e0d9a35199e197afc66077e99402e2ff37dee2939c9f207933113c0eea5b22b25ac06a0323c3cb8d928277dffbb80c943c1a092c55d59ebe456b1448f285be3b7f9ad96f18c1f94f73f8629b8bb1f234c6e33e46e9e783afba20547ba2443ae0832845de20517c4e098d5a08e17b4a8e95387d507e7dbc29fdab9187068145932871cd2a05e021e60142dbbe567930ae2ca9d45c2d34637ab9479dbfafef0f30b371ed888d4672ae47aa9000e0cefe5b51241e7857e12d2bc6187c35a4baa9fa887d1b13373fea22a0c0680577bcaeed783e19bee19bda35099f231ed6c9511016a3558d9464f447d8d89b1b67358d654a193d3c5de04de18ae6acf710dd2bf044f97969e809f02e6548fcf3ac8a79f0ca3615610a3d7d1f8ad905b37571cdd40e5d0cce386820bdcdf71f70460a83217bc910afd7cb917325b98c9018b311ef34f5993625869b1fcf238a4932a91b72a03ead136e9b8e32996a1a4c5795d2a60c55da4bdbc78625dbe829ad2a52f518f02b9a50483c0bb34ac96adb80fb91296f56cc750d8e7f77e41c2c7f9fe5cbe2cd8dabb7f8235f825d4795284dce4862e1152e2e4cad1ed5511de8f4e924c292e8824a78fdabb3500c022a8e7991232acc235bf28a47b8bca88c1a0a743b70be042266622d35d07166719f99da77348039d8d67c3d58f8fa32ff73ff90d5f422f6c787f8cc2fde3328b37cc314daf9642472569dea7288309ddba9c5554e3092d4d002e3b7ce77273b4636cfdd44acd206e780ef62739227814295e6a256c69ea85326fba210bdc7687e595dd36045f7914afd3bb85c12c2f7730c55473d5ff470a266963a100816bc80a93f1f2ddca141fc2edb8c29011a06300e33919aa5a4f723f7a36af51624aa28b15349177f7bb4c40ff8c82d8eb4fe8b28c02696678b8127151d301fb543eda0a6eddd6ffcc740a2c9066f119ff1c77a3f7af4ce007a89cce1a48cca1c925d63776c0b4ae3036ab08abdeed27c4bd90abdd527db98f4f48401c4e3478847f781215a150dfe14645c0406a64995595aba96597f4b09f0310c116c96c554c779308017723b16b9a33552c60599c66ab31e6504ef285dc79d5294e55c85e28420cfd189e472b485d91329de2fd5b8dc1c808359182980c381fc91dcbfa003f7e442d68da27b7d9e2f85a457c069e6f79265893fb7276e9433bd9952f72718e7f4b5f108c5bed7b771fbb2ef77becfb9f9510d449734379e803302a1f0bfdca1c134a4aef5b2bc711c279a11751d9bc381f9f06581f2e9bb20b2ffca55c1ad000005baa9224e6f7e0a83e1ede8f581104c19b028b1cd7907bb755a701e196dbfcdc7a8f1d6c9a638d54cc821561c41ea3669293401e9dc81a6e59f2c50822f3751168be933379cf3fecc1258c216165dee29dd4b1853c4dd4744d2afcd9b45522fd86b2e2600628334b5ba61383bb4eb59568b0cfd1e7676fbe2fbf803117027383f65625294515d64be1b8878a435497e4d3a0b179bc1c66dbba1d159312ed899ccdd3e7bdb04eb03a659bd10132c773a168bb87d90803ebbfe34886d518456bcfe6edd6d03ba728cb2d272bed5e0984fe1ce0f06303e3797603b8352728e0c6e6a1d932747c5d5eb537fb3108b74f6b6ee2e0007474f032280e23563308c6a43cf09ca05305759ba629486ba108ef85120cb9f0f7d2428382279788785619f9fc730a1c50249dd68ebdc899bda233f48d1f1fe989f7e60a88595ffe7ff9d6472eee02d3fd771123b69c968d25ab28deb82696249ec06ce74670e046b47c8ae089a01301a1014507a3c8fc786be79f8e1a989296a969fc87e9091646d4eabd32d24a9433c939cf8cc0a235c94f95b3b0ed198195d0cb5501745ced1a6424d2ca3c0f9dd272e77501d95e9e8bc1433705e50ace5f7aea735c944f027e6b094e86852b657e4864e41724f4fc0692c0e3e7bd6353d107eb5a44afa511937d1c3186c6e103a093f1826549352187dbc5af73746d607a0b5bca5c253bdc2a6a03220924002424755ca8dc5bf5e8b92e0a4fd52a6829b6d5ad2e4ca99ea57183d5041c6af8e35d03690611f9aa423869ab8d2041ab4bbba3e4999cc0dee89834033334183c425365eb81e949ce9dafde3f106665882529da0365e772ad0386145a18f896d0ebd6cf8b025db35860695729d2dd31ba45ec9dbe6865cc14097d4a1f618ecf6e8d1f98a56fc837b40c541031495ae865327e16fcf6e2bdeeefce53415336387d77410f35d7ff74e5ae86133acf9b54da33dcb942fc5cf87611334ba8e6a2e779f52eb2cefa73e16e610f848cf32cff42c048d9d293900665b8651f121b7e731eb49d91dcd8ba63fdfbfde775c5d907ed2ec4de747ec0e09a72bedc04a911d158be1aee32167f6f12be164569d3efbaaf45f30e3379543778b95a621eed9a016b2a6d50f992442133db18d7da859525ecfde554ae5b0bab5aa76b2bc7c69d1e7c93b9e044eecbd0c7f8b403d9f9f23d59a5db6a007b9beca44e5534d4a7f8a8af70dda2c9dae9cb031ceef399179b1e878646b6b0651b5858e1735aa3e4877360cb0b451d9a5cc27fb1136cf905cd2063008cd10adfe3957a91cce1c6df284a1ca5c262cc884c8dad03cde6c4e568008fbc1c4e6570dc49a3c3e5cb4f4da7a89d540b51d81dfd22c6b54c50ab469a9f5fd9f19ed4ca77652c7ee7b75185af0134b88950d5cfd02f05f52989d20f326b9aa866b5052ed3fba17fef2b1fad957304ebf213887b561f1cd7d0cacb9d55d01eda6a434b1f55f1e73a5be225c6b17a4de68a5792a8e4ce3d5110124b7a68253fd09f38e738e7233c40ef7c93e6dbab18b9f35d52135da899310bd621b917b22d245ef5ed0066c1be10707a9c9e6644d07e65fe52e603da3f2da55a92ed318a9d611d1454f361518e6ad7e98201cb2dd4c832dd45a2c3e75e423c881a0cabc91a2006c46208b4bf0a619dfb39c049c400471b2663c1a8daaafa6438f26dcaf4d969571b4415b17a0ac3cba786710b7c77ef22a77defd1d195f095adaeafd6ae43db0d96dcff86c9b5d9c6a82b70ead0a4552d1f300b06fc498bf85434042fb99d499beb5e1d2a78bac3f6ff62f392acfbf3912f56784d41e372a345f1df6840988743bc94448c7bb33c747f522bc3985df3edc2ac57b5f7efa2d5f05cfcd18efb34765ca1f099b38c294d1a2c686ac6b9fec116cf0344e6b1949fa98f0389d1c36978962877ef84d305b1f334c9bf490c96cd82169f4245d54f5535f22ed74e3f9e3c0625ce3c0e48e88a73389a73978f8d8643bdf27bf0af397857f16bdfc6eaa02954a1b9ebdf66a4cb35b906e8d551241b2ec58ee4b3d94b0b8880fe008311f6ecad2eeced7ca34a38ff3304635cf35dd68e7009f1749c978ace261c84f1a7c461ed492261a3415cb30c92290caf51e46c59cfe4ab2974dcb42fc641a168251cd6d2dc2d2a9d90451dc767a955e7ae83c8b239a14a69f740d992a85a1c8aeda3dc916127a854e9898438d47829fc3498c2e321ed7b17e15551a8639005b61cc0c8a92e33bd9e265d1fccf0d814b8d33fcef4d69bb018656dd3d5522a222d729dba8e5f14979b0a0547b73defdf1c392c51b814ac68465697031ada5fe6d19f932cd6f487fd117e14e7aff4a6d0341eba7fc09208187a6dd31bebd49202b1ec24dae93dfb79f945b1bf693ccfffb3b595f8aa506694ad4f17846a105f250606473e1bffa356b24887289d9a50dec167169f126cd7f8836a48789eebc6a71a31148177c2f70d5343b3ce2794a35f6500e632d815cc0c5b414a9f1c245a575a8423429acd0b2206b05c8ba391e3aab30b58332d455c49bcb80e34d1b16a09d71751e77aac82b1922e7a3e0212f5ebe87a27ff168901a65c4a93880c5d91559d21a1119bfcec6895224612cfe972caf462264d59317862194d32664e35093c9c140ef3d189df56a263fb673d1e303392816eb73f89b3f01b1221e982a3fc31529ae3cee0a4d6a91699b987d1cc3cab769c716ed395d0ad0562b725ac6e0d5fa9a305ede1ce5e2b21992d3c71f56bad1ec1b89fca244dbd739aee8985758ca3e8216de887a5ba210ba567738ba905667b83b2e6af7278cb8d628680af80590cac728e3e007ef2ba07e331f4f9c5ae345da328e9559b317340bf3bb6b0538947326df88a8f6adff2e8da390cfa493634b1db95f004655e038a164d14fa17a7b2b095ae19b37546ca2a6ce3d0a77377451c85dc87477e008f9a05cd20ba79edbe64a8bc1ff8c9460c5b87bb2e5df681a10218c7662263c5e35176fd23e65a34a24aae235ff6d387797906538151440385f1c180155d9e3d139e8ca248fa815202036c6a2c4c65dad9d1b896f7bc475fcf7f2cc0038be68bd18a29da6f9f1ea7e8fa2ccf2e43b188da936f236630ec3c6fd08fb890d44eafce8e5c5c6d2b4bee7c24fe73e1c88b6ba3706d3cafbfb97b57e6b61175da49616b7625109e5a034999f595e3b26959baa2b1eee52d7570d98ad8369a7d1b999720122ac287e05289ac02da4ad480168b6f1146fda532bf94d2588e37d72506c88eb0f613f50e0a9e1e93c31ea00a6e615775750e8f9793817e17e9fe3aa7501822d69f758f705c0b4556c115e8654f5d86e6f0da43eb0a5eff0c6b18ba9dd10b9785265fc703511279dae7c2d9d23e02c452cf862a5d2293521266926ea79864cc5f7ba5c35f7131eaf69b186c0f640f32bfb96c48b20ffd6ac6fe451f1b0d92aa32ef59dfc51bd9455897c9f3feb1ca3bf7ecc35516501934e300fc5972aa663eb4498d55990cb8a2e34d3055f833f6cd5bd3e7eb68cb85d3d1a3989c813922205bcc39de46a7af0e7e156748ebb6c70c0e7cfb4c6b74496e609a4241a347659ac14c4bf972d70b38bc70b4d74b15232c50a4e48f4d389f757fd718f3d86ef45b9938af6320b3be870685f289da056b760f8a629911ecc2d5a05d13da3625dbf88686af8cc4334acd4ec2f37ea0b848076c5b3aa7e8da0c283da713d4f222d8d0a87d18096bde6efbc036e5274dd975ad63352a1a5eab7846c3b732874a581f074da3d01dfbee4e9a3a6242470e81c8af2f249aecef0df286bc46c874f6c3be4976ddbca071137c578948a3c8234a5dc4f7214486fefa85e0be919a37f360fd4247c77f7b276a5fa8ec4d90cc6e9c30f5ffb73c291dd4511024b44efa4b9919e80404730cfce5838d31b2ad675ce77b79800443cac522829d3377909aa195543c815f562c147b030a0aad19122e0ef10e219433ef44fd4820d39d9793aea26f58813e058f2d80dd3cbd95754e720bcf814b87b71f8e9c28144d4354f5316db9067130f414acbf98cbd8d4a0b07519a4336fb118f1c823e5af1fec19faed94868e0c1de028c59306744ab7a1c941e218f47f830d94ec5f9dce18f9f560110381ea5a5e24000df24ce4c2df7b149153373790d11eead11443c0a882a95d94e0f62d083a7b283e96c5700ff758dbdcfd874f92269bf04dcb7bf55eefd01993f7735450d6549174f0a9b267a6278e364430fd24d02c40187b718a834f305cee065b708a34a2609ab0eb90e856a8092301e0ad5aecb7b9f7ac71f119b83a15e0d6a576225e1b6984ab50ba36f3eafb16853f821249a6d5ac6a990670eab6f0bfc902dc216ac6c7b8fb791cefc9259ee62eb93244a00e794fa749dd85c834b206bc9a84db8492202aa29d3d1d5cc2484b058a955d3c69a074687bfbf52b41ecbc2eaf2ae727a6947c8a258d1088b69bacad3693051456262529fb8f5ecacb3f997770d3ebdf5439f289a347bd24ff48d02fbf72a8fb9f994eddcfc68cb6af26a092fb4cbe4f8c7ea1ef13bd5e6ab037737834a089759561373c89bf8874553526f4f42369c387bebf64804d062827cdd1e6220ce54b3f8384d42940659b293bef3a2b6067c8bedeafc9fc8ba00579c335fe63f450530292d086d3fae2521a93decd3ad51b269d0da0adf6816fb713601f555caadea50c05c8a15384153daa153ea21d096cde0b8143ec2897ed2bd6f274597489d1d159fd1c33cdee690f3d6f0c52ffc42c2f0181a08ff258fc8313914654f3da9136608e57032499c871d9043fc7e776e96c5ec12bbf890fa8692f3cadcc1ed58e339a91f53c3f477b78d849dc8c3a04bb37dd23f6a8d7ca5d665c6d79129a85c8784bb3fae89268800b8ebdea31deefd16e6a311a0f34f862aec38ef7f1043b61eb6ec490e848968bd6721d7373013197d6bb6e50b760727a7a561e2f0b8693db513991c94ffdaae61eaa15c44293b81e1f8470f4e5bead9659ce497e1a972f4bb3bd08ae91af02edd4c83714308d6ce0a92cb8b2ce6d798f4485238550547c5bb4d36563d988f0174052607264b07fa27f507450292da2bea59f2b174e7b1d8b53915c7ff8bc6429ccc6f3db0253026c9a86e7a4b1b45fa72c1b1448ff16c4bfa2563800a6f7baec3de5a8b0c4b8c69612ad99b97b3770cbfa52f7927b4efd251ed7d52d2ddd339627b82dc8718dace6519346812df46934da81e5c65af4a9e49e21f328085125d75bf0fad9844e3e2f5d4893ce50d9fcb6bbefc42e7a5e46839c94f41788535a90a5ecb57bd4bab0a78fc5e5ce0e2fcfc75d6cbcb2d2ccd52bed5777779c68277bdd4d099fdc0dd45cd838ad331378b62d271ba90db8239c9aa7dc1702ac19a7d821e80c8aa08afdf4beee1c45d5e2629eedde5760edcf8f7e43419ab1642a67c586f0e72ba92335cc730e47e61e1126ff13097afd8594ffa66004e73384f5adc59784a22a9deaf2cfaae7511c2d8dd55b5e8e621c491c0a3310986b7c780dc6f2fe53175418840d34ccaf7dddb6a14741ba5c0302f43a3cc86ac9979cac9b634c725a8776eb2d0601be20c9fbd71fff0f9847c01a8d624db80e050212b4a92274af2cbdedacdd6d3cf59494cacc9e99841791a9321f9a3977d9885da97b95c102df895c9f42a047e5e3e0c6bc1ebc201b28a1544535077b554733509841cc796337ce78cbcddb56e11204c1d2cb3a89109c68b6ecdd560168d6c8c6509ea589347c4cc6093c87c872f02cdbd3f4c0bd99ed83d28c7c1b742c34707f26fd233cbe75a12428c5c602eff844083de040674f9faf69d6f8fee1a08b5b92b59ff781d8cedf2e7fe7f18308289d24ff079992078e691a0f1a24a1b88f10c5818d7431f2b6e4380654f3e5241044f87347ca2b09f08b0b9536d451b0edb3b2ebfcddb948b610cf689eceee2279322d72320a6d432b44e0efe5b52a8c05b9b11a220fd94bdf8c7ce19bfc0194e837a4a2c02d4013c76855e4b9ca2ea604dd6ff3444aec67025e524967de5d5c5565225b3e85099e3cf4fe38a6093e3a5e8c1eb9563fc6e1e43f5c92df7522a61291d414cffba20ff1e69e211d8596c432e6ffa3084d66fba5e62ffedf295071501f04bdec772282e69f473c58ed1a2d6aae6d8a5212f026ae25443e63c4511527d03fc5c9adaf8918ca2c51481539f7b28350bd1cc5a0587dee172bc98b839696fea1b9ff63c3de28b07821352474086c19dee820265df38cc8c4467734bc063e62a198279646487388a27684e33877bad7f99c1ce2a22a8724a932b8add7bd35477f08c5df6d43f53f99b5427165d9422b9e362063ba7b029489771a14f94243b7bfc511999c893d401c3350343cc14e7ba2e3b0c074e53cddb40b853c4bf307a207ebb76e2bd33851088834632d68c0127fb2d2be3f8f4cc303251cf3a5717a7785d1499ada3ba6c9f9c646c4f36e9476e1648204a5c5fcea262aa88465d0663996ce5f6ed85d6cff9af8f46049750651f3add0d6aff2c10df9ff63f5bfa2db0647798c62518fab72a51e2903a9b2b127ee4243c8fb4bf16349e0f51c5c0e1021dc4c2d67cfc0ddcfd40e065259806f11685df62f49c4527d0ad636785614476649e14d52231a243fd266032a0293d961d97eee77efa7e96f7495777d3adb4963cdd96acd094f348e1f3157459f37167de96c080f51e62bc7242f153cb9e87ffc0e92ccab5c024836fb80c42333b32e6275e38bb87b0cc795b0068119af064e83d815f03ace28dac99d57efc67d2dee19d2368b67b39b7e683f5ea67679ae4f147e8234e57f13d115c78a4401dc681ed11b309bd9c6c509e6ee23af7906348a0e4443d1a1d69536b0d1c237bde8a3001f1d62f6e927a02a086b2079046d22066d8041ac0ed9e0f54a75cb4549a7263a91c146f7e860852c56fb5bc209f5d6a80ae6c9e24fa9aaccfa5fb3714c38a56e804f53fb83ecb1106521897a37d8ad6e692e8c038453c319af5dfad40db918e97a39676780e0c3435c838d9e7ecef28a87dd262589791cfafb13c56b00d4ca1c318c275105a944ad89a3d05293cda85ec54845b8fc4f4ee9eff7f5ce45249d1f28144215e6b2583032bfebe61a8d477c9e91b12b06724f603aab1de402cec2dfa8ab3d5e44507936ad10f9efe461fa3ea008eecf7ca881e09597e58816b4c67a538c32fb51182eb601e96481c4428de54b89ebe7b8266d7fd65fd2623853bf70e6e6b6cdc41645a7aad21c5f857846dcfa1821214af60b8267ad58564ed10ac741515a318954e4a3576bc25a8b842cc0a1f2a798fba104c5c71a705ac0390ae5b31c164581730293eb321a9a7f08bc83ff503a13b51e810910e26ac2b73741c19d3169d01bf783539eb75ff31f1ffc1aede28973883d2058545bcc62a9872e3a3e6a7b543095926535d6ca50deecca6b96c04bd7c2180c803c997090354e05535c7ff9a9805180c72d5d5822ff37978052e50dd3041017ae2ab9ae64cdfd521e7e2b03f0feca081f62623032563208a6b25dec1bbe5e78d10ed41620cf88d8d36616e7ce7fd4dcaba87e8dc08f1582065b5cad77bea19bae3f558de1f6a12a9662dd1448abe15d72ba6bf0c4af8fcfef9698967777ddf055644092cbe26f7b2daf949b534c47cb6617b77be8f43c1b7f954594d383104effbca57c9f1764339b8fe4dbb17a007bd334c004c2902c39eea7a6ddebcd27b9ca0f728c7eb0d18540545425564f2ffad4c9d0ac46a8a8f9d0792e8054dd7eaa3f84c5641e976f8785f1e3f38b3f9c7a1b8a9246721ea7a0acfe5617fc14f7b32c6013621eb33f42dffa64f932b0219493b07f2486fad1c3ea62703d9c3775e72c6886374f53fbd2c634773d7bec669ad7d15a02a19917d053c971f4e135db879a1668ffd96a8adfb352a3d2d1edae633100a30cdcf1cec281cb00012441f61b4ed2ce6cb171a0433f01d9b39491eceaa35bd40e6de85a9d4af09ad074ba1e3f7d54d658aa85fafef0a0a4def6a0592cfb24f6c1b27c665833ff458bc53436fc9bd1e13516f9008af511f078dc854a98a1e868be5e0cfd48957cc7b5374716c994990ba9c895cd7a0feaa05ccdf44a83f2de7a5e61104632c524bccafbcfd3431040797576ebbaa966acc2f767f5d33e69458a4df5fc0a849538a142e22ce7a0b3da33238a6a9ee2506b82fea12df8e982776d72f6a98a52cc577ec1fd94e1a67ef4ed60af74be693081abf22705ae4504b7342b1d863c6dd242494723da69ef00908745f472832f0ff81e2baa8d524cc2efad0cc33f7cafb1f5c4d15155b353465497f6ccc1ef976dab084712bdd12b62d2638be08805476ac7d10b9f1c1a01da7a6f99fc01b77c5db9a75f26a600f09c1d69fd2fcdfd74db5342b2afa6a0edd3191ce08a9d6d92791247cf9ad63858fc080658ddc3a38366aecb59621d26c033055441867027df7733e50354787547164f6b3d1d48227251f943e4ec6bed1ff2d0e529f9425ce3dd413daaab28607ef55a48b14860af9c01a149dcf7b1108aef091aefe7de2654b7c02759f75730c867afc87e91d301f0884b888b429500cf44402338af78edfa918fabc5a06d88820a0de830560184947b2c7ad5c92f7764aa2d999d3f83aea7bfc4a59693e087eca15d8811606dd6e66b86afbdd312f34a36a9a272addc701be5ce98d1bebfd7934ccdf3defd7a1c98f031730ca4d064e752bd521a2451b9c00c35ea31274f11b745f589cd877f7e3d1f81cd554d0d281dc5ccfe692bc965e7805cce5b32b06877726fa5f2d119ab94b88098a8a3c9adb24cf91c6b49782ac5e9d781bde593d581a67612862983e4fffbf151f15b3119c647ab7293f6e663b9f3ea317e1cd2f9f30528d5beb0d7697bb7692f3d013620a868d359fe9ee71873e8d1cfe9ee2427dc4ebcc8a03ec85efa3a4c16bbbf0512e715c9ef034b8d61a6786a360de533acceed88feb02a595bed989ac121703bfaa8dd7942d0e927bb977136df77fd32797e07e470c013741e2c0f4d5c5d2fb6d93fc317a2a6ec0195d7d8ae92b88667bb6ab6e0818079a592ad4662a2b8b14b169c08e119510e8bd950b26daf0443deaded0083415240935fe6ab6786c73e3671a30c2239513599cdf4d3bf2786b1f3b2f809d473ef1a6e83380a8cd93f2ed740dd1893bb7e03c40363287ad91203f72a5f370d9901e73e49bf17c6a8ae3c2fc0a60c96eaf56243702ac696323adbf7ee19fb26f6383ab81aa63ca85214a7cc64543a8bc6b11634e2041298cd604f845e35e6698a1771da459d238d02fcb993fea79680b5d7e96665f7093b2bcfbd8387d92f2e4b827036b829674a8a599be817ccb322ac13f10cce231821fa502e085d4a2a7ee570a76c7773ccf6c64cc44f457bb400914113ead1ef0e2c7ad8864d4224ce84eeb6bb18d44cf1640c652e59b52aa6ddc0f03d47ecefd6fd5316d535a55cbe470644a019c88d7a5c6ea9ae5a655a3ddffa969207f35548fd1091934f8e58077be36e1a122c56f444bfcfdfc6fd3fbbc09a7075df0aa71bc7c1e7a5db7515ea875e162f309c4e1f587ecf1cd53a1fbd09b422d273ea4b3abe3bf13983317e20fcd4a1a50aea0d2b256faf55b11f9e62e31ec6423c716676ad20fee608f0827a09e08eac7c9f9f65e7e798930b5a27cf1d291868c017ef3847427354720ec30573a2f4b5ea296f205afbfce9688f3484e2f677ce27d7637e88fe4d73ad55ab1df04420809f8c760bc1a940c23a772c20b4e18e8421741a87d30e1947fe7b51c4de8acdd1744f679e0cac6a19a9c14188cde4eee9737fb683570a80087052c72195420ec505019be0f3efe9dd95650e0ef1a94aa52de84aa9747daf09bdac5df7e776d7e8513c48f650f863c8eecdefa65f968ef4405fd0c3bc2c16eb6bd29ee29bcc42a115f130a9fb33eb46f8e54815a50539201dc9ecc02f53577aabf6ce479faad759ada3dc971502450a9772ad327d519efe2a1e0896a7b58d4d5893d27cc316f2e91a932217bfa3e2a0c7b108385cfe230cd620ac73f748a9dbe215814c1a46b4739e72a72b1665514cc8d134c944e429704501b700feff91bf342347ca46693691a5eed69c8e21a1f90d7e061e6b2b37267a15d96dd8d1f89998bea45619962e6b040aa234b8eaf0726ebed92c0c733ec06369af67d69a44629bde3ce5909a94a20f8408ce609c193283fe7e0f8b60666cd3fccf5ff65a5f5f3a8799e529e9b30a4b2125496c85c67cf95b7cb0e63c9086fe0d89cf9d1c6105a9fcfcc28f45c1ed2b582e1850c5e0a5609b8db22cec58708d45a330aa2bb975bd5e3a0995c6669b5b05ec16c0fb200ee774223d56bf3b73de65525d5088334fd1a34ce9fd866134a1619bc4e4a2d6d59ec28d88e03386cd968ef72d3278801ee8c2a11cd4cc7d3bda63256d9753956513007d4133abe9e1a3f2e96fa5d086670ba283a20f39e204da6ef9b89f4aa65640e78e7faff055948d4e22e7f045a6ea02d2be5a5e7eacbf1f9f692e971a506bae06894574c4a52c64cb72aac46aad20fcc4b3e91bdb35fb2e8d9b0abab28c5cc06512bb515433533e46b09ed194f0f91824c1ef4b7bed65d6b4a9deccaa9491ef58f97f1d0e86668dcd6d722cf25f3134e9f893f8ab4e8bd6fd6c2c840e789553b0f43e7fb5b0e8aa76c13945d044dbff02c46d675a36a8dd61d27ef3b4b418cff7faf42e04995bbd4036025010f0acd3f5cf735e143ea5e0ff19f5116be0783a401dc5c1151f5da28b677dc4caf53873c684f0e2d24a6654d6522dd286e5d6d5b93d87af88c5d2fd421c9b45b340e2922b9807cd3f2a3e560eacfe3fe398a100167acac051bf621532f9db8b1535d49b2a9b00f9f9f7b15fd2ffb162413972f8bc601d82ba3cc507f7a46c50be23721975818ce0381b44e4d8e00c6770183cae4c6207825f0bdd852baf12df952ba6983b4a67bb7b63e54194f4d108781d2251129103c2d60734edc862326bbb4b23bd7ad0c814fdcb67639cfcc5566e09e0496bbbe07c3c7960e0c56b7b9a60646549ac88ac60704d971f80ae8bd2d7918ed34827540f7252e29e976d38f3296bcf6c3234a8964b05ab4af8787d335dc03806a36921f1506a87c754ee9582bc0f88718ec91ddc75f1cd29a8b7210e0a8e7efacc214fbd6d740b0de7ae91b11ce02f9f136fc75de32ce0d89eddb4cdbaa20af5ec43569de5c913d6689459f65361c23b3e2fa9f68cf44c8c8605d5961a92d9a9e5b625bef48e24d47508f1bc161050ba5c99c031f827d13f191f1bd1183f3771ee21c3ecb99d8e0502d195019b78a44488f446046788f4a372be163f478e76cd4bd66f77d0bd7a4155465dc205fc213664c30c863c89df25cd0be4fb308c8cb40a78e6ce7237240786f124d85c18adfdd4fd283c51de1ec43abeb742a5c67a034ae3c0143ee3a87db6e27ef8fe4b7146535256dc7d7b83ee30bd80b66870dda17390637756ff1b15fbe9e3a180e6c6369cfba4764e8c553d3e230aa33f4f3dc63bceb767b93be7bbe3dca1adf23444a9812d0b11f98b0ece3349e68cac14986b685a919c57c9522937e088434d7f194b3984f632ed26feae287b069c95f884bc9197a717cbd10624c459cb1c46ccea5c28f5d659f4969c9ed75a0da16add08258d49d40549412cac48d830c8edb024af274dc18d04dd179d277fc962429d89709ef111bf4bfed67e66fda3e114a009b5d6f77467323bdb79ec0b5ec5a7edd0916c614a9bacbb5e52303228308f75af1afa54bbb4777af171d41b658dc8db98ed053af2e3f14fbda0c1ca4ab2ec563e451f754b985005ff212501b7d6d4ebf6311661618cd4e492ba5a3f0707c3c875f8afbf844d9db0c506201cfb70f4ae6b087cc7fdbc88d65608017749eb794e99f306cf6caba9b81ac70c5e5b924dd8fc2b73eb66037287d7a95640c5943bcc51c701c1ca74ea4675cbad3a715cdbba5a7786a30a878baeeecb9319c12da8c5da47c2fe3f5f4f2d12f816b7efdb6bf0324cb9952cadadb027eafac1ca26d62fedacc4058c1cf12d4043e35949ed483e18684033da29bdf8708a9d12c6d1a04fc4a9a676fe0c87cea8939d53af450b69d7f2348c9ca7cf115e68cc2dc12b2f911c29e37c803299ec87cce7adfcb92016cbf276d0bd0374762738d330e94ef25e41a8b138949b84fd7897873e494d7e13fd053d929b6ae27a966ec33ffde079f69fe44dc1d32a22f5d686707d90a8c8f5237d83cdab7bcc514a6418a4b923b7d65e1d1b1dd915ca746aa0b53eec8f7f8ee528451f84e105947b9bd08253a939b98656eb80be082adcdd0f4a8dea3fcb63fab2e12bd8a468eb72a5b0942003d0bc179a37c06ceb242f5a379ddac2a54a9f1c0a9fe0b9f7616207962ce45b7c631adf05c8ebf7622ee7f70950e9a1990a43387f5c36525ac5f7e96b0381a1e84c6e199154e0637a9d89da44320b011b7fa0a443a2598c38408bf31513a828abed167d66f92a3e96129630400f44a2bc204dfe62a6cc28a71d7835f118593fa4c31ddce12f915e5d52aea095e49f62c7adb878f1de18e71104268c01a8d889a1e4a50a1c0a837d1c8bc62161d5a8e09fa3142edb83a292c79d2778b8068a175d00eb869ff08b6b39c13695a87b3dd29c73907f67ac2486242561b12a7630418ece9dff54dcb6069eb11bf5c99d4b6cf59ab7082f0cf56a0d84ea591c1308fc57ea47063c49efc46d5f8b6d58e6789904b2cadc0219bcb8a19df77a72a3059c26dc243bccd0bc4d63fe8ff0bc5577809c3341a74fcabc52551913676d94a3e25d3c52d04f5dc4cad08737c6a1d802bfb47e01da561ad7556d1b32bc4505e23f96a6d6f8b57dacca14852a8f9ba9cbb233d1675b8dbfccef9a431bc0a0797967ae4e79554b11f83e9ea9c51ced1f6c0d4110501893b8ef9a259c3d569f69aca58f9646b0129901ae3709200ba5de29a2e3449727a72b4fe61a6946ac5b514a5ca896fe0d586e6cde3f3380052823722129feca1abd2aa5f78436358c6284c7139aca784c10f53c0acf57cc107d9f311480343c0f0205f0e2cb0f67cc8ab5ccdb960abf0ca1adac31b58e4c818a83049a27a0824a1f79786b36b355fdc2dad376a1cbfa4aca3388d669af20e6babaa895b6a551f4d9605edba418d59e665772e6bc869e5df67c3674ecbf06d7b793f96201d1a497c25ba891982c51f27e01f5fd11e9bf4e5a370f08baa522080604ed71b7047de3e6c6494e07d557399f2201db79c8c4f3df77889891b4f7e3b618a9efc6f5105d048ddc32057f5329156d7a597f7c9c6ef3064dc0f0435e2bb6ca7de5efaac9c6f94871d76d994da12b7aa973017510b0b25405d0aecdc7996ab8fd7968f7219937da2edebc64b20431d4f1fd84d0c75b7e064222af604a497bd3ec550e1233b2978cc5b50aae87aebd35998120b1b7caca6485d13871e401ff44f9a8da40d2faa84422a21f6623698ae9034d355db6965de65a789985e2bc8b540b44d68f0bed90bf0324f40e577f90ea0af065aa2d3bca83b04b8c3883df5fc74c3a3c4bf3be96218cb0216e37d0365300d557496cfad016f207b883b3243fd2d239b133c92ec91a5b18fb206925083c703b7daa11a4cca2cd5d6597088c178332d9786f28aa753a9804088b451e35e77232d444eadce5a43acab4e907bdc07f511d0a26894917702b37974da5e0fbce16177ea985347b58fb9a56071d1a8282bd4a80c3cbbae64c74fcf9b49cdb3150f206a9aded8b91bd6b26c86271d366af358c344b06b160cbf21187bea9f59cc51a2b1734399b0d91ea0418624078b51ec188673b611f3350dc5a663575b707a5a726ee92eabfdfd992eb1cc68988647f95d35a66a6d93cd33240f572bc89a2f2c3ab88ea422bed8f6d4eeeb7eb7779c7dfff8e33266e18f40004ea1f8cbff26b43f29c5cc565ede7a9f25a918a1124adcab84380f8f786a06aef14c87c1a7df13049b6322c721691866ddda128e70e6dfe51cd66420e567202e8939a11670c9b63e2d96222f4f1883f96a92f36831670c808e5f01f2c124b519eb0ea78c49ba6dd50f4fe3768fb5720008bbbcb9d82c1fef09501d64837e46666819203c99f79edbaa8d6bb20b9ab12c506f6b6bcba3ce26915f16d0a70803598d43c84d4864ad8435feaaf88cadcb0aa71d43f2644ad5dc445f6184fd4aff7dafbaf173532e49cda7c7474a8631a5c6b10e5480da264cde33e3f54c62455acc1cc990d71f949d1003e96dbf520af00fb36bdb46093213ace05a4a164715cca4987e4328e5af78aafb2222937b2b1344f938acfcc46aca2d9876a9dd920bc2601c964146ab18524659e1957f3a5fd406fb01533367e237b015a68051e80c0b254766889273b0828d77a309712faaaa5e8e2279a2a2b1a47035b10d199e194e6f53cf0cd4534be5fa0724cb1d14693695869244a284c35b7c5be47a2334541f1f27d4b68175579781277f335b988a7539694d4391cd3d59f68ae9de186f00b5d58de9527109758d63d603abd1b95a5d703f4472e1741bee88cb08865bc0a735e36e48147f18811838aaa3ba4b088b8c45f99be7d30e398bbe830fd584c2e69c33ceddab19e105ea15c8fea7b4c43a2b3b31184125fb5bfb30fb2fb60cf0a68453ebcd525639c03233d1294e6254822d2e184832380e0c80ad6add705cede2a2d9ad03fe8ac85f863111524d1f7b9d719baca83605c911b713776f9d077359270719f7befd9bd6a8a3bb976387fc8db2af48ce94f61c00fc06a0993702936075634bc4d6290d2d877cca4b9ce03f09b8d8464dddfe4dd92f449bfd9e3bb1f5bd1a05756a684e0082cab506ef3c3c1c16a8ed12ea76465e968c7281af18043848cd7c31964b683328dd9ddb8370eff718644daede24cd14822b1fd1e2bb7917f23b16ee529f531a43c02e62a8fa18ff46a02435b439d2165a2e2078cd3c826d550183cfc3cdaa54f5e60e7c8a849997d0943f2781faf8a4760a016cfca6fb18eff9ea5d085dc82ffe2f2238d13be9c9729bcaf569a695d0ca302507faca614c10241a0d409d267002d1a1d351c696d584ce11bd613a7b5fde35e2096e7680de20605c69bd18d79ce891a45f0fa88cf856f8e5959f47da27f407501e135d7c0075716a12609de4a63dc3398ce4b241304424a92b7df276371ce81ffaf6c0058d1d82a69d29537a45aab9d97f74d1825691afa642e28f0c50d49e50de3e9e4aa3d8155fae111680fac44e4ad991fe8c43b3c933752af6b8ba3358aef61f66e229303e9ba0feea663fc099b41f9cb0418b286814025dc824c245580a67daf73ad9c0d973c1228f32d94631b08c6ea787f64b4f5afbd23b8a64a778ba234d0fbe0a334ab38e5488d044ba751a518857e4948d07792a3af82c354327615caeb7199a22784ab8b0889ded54fe35a2ad011b44525e9a8f6acdc422ab5027f60b10d69e8a830d80809bc577988a68c5f02f4267e3aea1e1b713efd4a9c7bfa92729f62f2bdb20e726a5433a687eb3aa219b7b9a0016cbd95ce653a9a83a91a227067ee911a7a7780dfd5bea42314df193e63eed4f2c0224aa8abf0f3e3d989dc8069e9d969230b72076aae150e808c7376b411edb0d8e29a61b13dc844c93a0499a861430ac6adc31f26174a8a48c97029c7f974417c1ab0f7e9718c8510f14fb3cc2982831cdb0acba84fe5b24a4faa3888656473d9810be38ee74ccf638f43fdd922d2e770bf742a9948c20734339ad691e252d6ff7f59fd7b54a7cba75948553a70b15b5e08511025a3e71b2857fc20166fce586164818012f9dbc3960b2ede9906d63615955b698c3a5b195cb0572488a2960245a35032fd245af19958f6e8d9d2fedba32456e52e82ca58d81df8062b3578bc6b56bfd891d0e3cc8cc9a2956406cc8cc0da6b9d2be5072e4a4283dcd9afad0b0c0c76a0b6af704a16f291b572f7e5d1dbac4b4e3f8331b6887cc5c0c73a04f9872707de990ee4b8b2fd11d358144cb94f8f7b2ddf22a1f11f76ae0fa6c13499a5be0cf2836e6d806b23c5b4c9377a328a1d43f34f1554adf49526c90ba2afa1136d7073df811b26b1e04f35e7fd5dcd55a0c8841ac82134cf08497f8800fcff99e8f9ac33c1b6d0b902fd41059c66471ab9257e6e77e0ba0d8f501f986361798b039a6bfd84e899cb838a11f62489d0cf4792acbba6582345319074e0e94d1d93350236fd687041b373e7130f60a24e42ae16b1e5728361e85ca53747f74a0b5c04dc3f54ae6ab378c98452149ce8ed436b8a2abb161c4aebbce71887527f01647b60cb30170139e68d563b3ab7db07ee4b7d18e1356829745072179405126ea6f1081d6b00bedeb4daa47dff244ca7d25357d33278f74e5031187d9d15c8ddac9f49b55e22f23ca3c5f6b4f0b83faa925d89a20ad6ebb791345a5f16129362b75f09908baeabf5f1e5b7e4ac9bf460872af7da15bd9ef331d994c56816c05f7b2aba83c3608adfead3f85a2c24bb0aea148d4e719950d494f3c53ca9ebad7faa7b52ca0facc8b8c7dbf60c458737f56f75539a41cdf130e00d80fd05af157007bb1d77c76eca73584966fa703dac55b090b4bfedffec533027df1df4e11082b66da6d7aa18c2963c9765c49963b7d26a49d0295e4bf38cd0a9e256d470eced0a88bffed056bc72776b61d1c9243d6a94c2b1f80fac0035b4d20b2b4cf37d7606b822967e02510c04c851ff597a3eac747849c55bfe8120fb0f70e031fa520985aac0ba700a30335cc174ad68ecd18fdb4943460bda57b97b4d065548cde02bbff13256a081f20589e8c95efada3362a778c341595d062930fdfb41665f761d33d4beaba4a4fff0f2a1c15c9dd961eb7183b2c0b61bd5647daa30d0e4a9a18e0ef3672d4ff8fa0fc5c4a24b95d3e2a0177c709e50e6da08b10d2c3c60b18c0d46d3e300e78afd73913bddac7082ce3c2ba0a586a9831d03718d12a8c57cc698295da7782defe8f8a664305748c9bd268954e5848b132c62ae31423f3fcad9a5e77435e1d2dc35cfcbf45d4c81609317f1fab028ae5135dfd2e46f3ecf4c46e1cee0877d1bfc92f2f429ed6f26e565d227325982fa18d825ac7658781c04f77c786f9bb7fba7e5b275ba6f840e87f8051fc5b25f1d5c4d9834d32de094c8cd4c7492a7caa2e60611a7bd1704ac4e4ec45c34df12a4ef4338c8e49c1407041140cbacb10ccd61db264830fc83930acdd19a07a6713d0bc5225b7ad7ebc704858c617325e451a40ad2aa8f114a685c52948102a2c5c221fbc2b68531d5dd9263f28fb3119200ccfd300e252561055e2d68cb1b77ca970eef39fb1bb92a55e3d4f692cb40be9de1ada5a6564577e3f842bb2f5a9035d07d80bf3bd65510298acb55778418397af61dbe5819933c594d3bd4135ff9236501aff59a06cbd5022e071f7caee1998084cbb9ea66a026b0fae1b6bc8146f8f368e0f99f917d54807b404b14c5a43cd0981297858ea7aa64c46f5218de1b08ae031b92c8800260d33b63ebf1cd16663eebecd80f4067776ea7cead40fce183a748587a9e1cdf1be40b842a7fdbe6de3390ee0e78e6c132477d80efa342790e5fbcca0add75c2124b682038b00f5bcb91415d344f697d958036959c47b665ab9a89e16f30683581e4609125695d8af1e27bf96a3b7e5d5f9213f6c0eeb2d37fcc641a27aef038dd34167cad606e53417744b32ebc0babf5f356ed194f7aca00e4d9a0a37c541221fac6207ec2e0d0f388120b805235650eb51f0ff2fd22554b08de84d2e1cd8edafd8c8bdab89ee0b140f5e657ddae0188be41defbc0c360bc9a187a5eed558283433d79731f927b8b406a405918cffff7d821943121f3ba312c0d2d3ee965dc8219de6ba4bd02c6f389a09da47a7381ca0014395b450cc5e08f2ef3edc0c032ae34819242be0ab58c97271ef949ae1bf5bd1f9ab201c1295a888c26b8b483d661d9ac98a56a1590e16c7edfd8a268ddac0d22d77163be7aeb7289fb553ceb71b3baba31adc11138ed37a382db0e4fe181c7797c2395754b0802b12675e41af8453bcd82732e6f31562d5e60a5cc91432da334d87b321867bffc7f069e02f79f2b51f77b8030dcf8d24b521330647d391b836ffed88144a3df5e4af2d903d3f2d47288e0283c88c382d7a1b546ee582ed8c4b6d8688b8a2423a7faaebb556648f3a1cf7aa43ccc8937094a953c69143220f748b7fef7bff9749045b2ebc51c22e3808ac83b61df31caf8810264acbda91a784f2b1d81ba0a00e0b3df942c8c72eb8570990d62c22075615bfdfb38e8c4fa81af3631735a07b98b74784b151acc466ecb3d4b64a4f3a26df5b95d39f67d3a81635fdf8dcf6722bb9d5ebd348d9cf292c3f1fba512f854903bad9fa070f6f1dc6a99afb244949a172a476afeef4730b554b8cd6c1f51b70954526cad5962da06ca917435fdd84ef42eda92e06b066e1f17807a8f533ac96fd4d63ad958d4e3ae8b4dbf63a87ff4130c851eb98ae52ca5f2d25d49c9b608706412422382554d8daeb18ed6d21d213edc68c31681ba9de892bd0f07954f1ccddb469b01f30779e1bc1217cd03670882dc22b246157a34f450d90cab72c4a075bebafc9b569b06765c45476afc770b1da8473e433316dfc5c3fb684a25a2b49ed71fea9408576d012208bc13408ac5b08561bcc926b73cdaffc0ee99b61601cf6a6201252f25addc596bc5115a40e14f9da7807f82cf865a37e37e36efe50b4053bd3045b6caebb14b350e941f72223754f0cc083b8da675f5acdb1735e56f7bec8acf5f5e3db71bdf520a8e14c3c0199b98be94b161a9e6504d5e944c862158632ead31a3921bff5628a0502cad90d9ebf17da7a64813cbe9ebc915760ce36c22f40358ffb44946bdc7317e393c19ef54055a51905fafe817ac6e933ee5b804ac764e4fefaec9d34c972785dc3915350d2ddb2675b76b36d277f7adc73f6728596ce69a9d16f2fbb42d876671c24690d833caeef47f44077962fecfb91410072cbf9e1ec3ee62f02304eff0109c2751257c38734178ab938003b557d866bd77552f38231fe755ba5abc57fa756d336d3f3ecd615c21a6a95045fa54bee552a3d2561977e9f69c8e4c4e3a5d2c7a32fdd6d2e2015363e319ed2123578dd85db62e20ef5a2250be2342cfce65cf747c3e0bfbbb15750a13468204c060e6c5a84aabe7377420b49213e4bb79a13154d3b8fcb16c1852908694bd7b6feb12b4f64491d62199a8a414a31bacd4be3773264ef5d2b3b9184d222b1e3723ec518441d148f9ed20d5e38ddbd50859d4a1ec03f4482cacd67f4b6d0c5f95a6207b39711ecc3be9193d1dda413b38bbcbf6d05b0fae2790958f178ddf36e7c04136b05d302a32db6d15b485095c07a7b7f61794a404ad7b9fb3eb3469118ce159eb4d3a321a6ca4c966a256df0b3f7d4e2e79389cd79cbf83b16cbb92cccb31b713c87f0d72418937664831fb31d636e6fcf1e495818bea9395f171eff3d6a629301a7c2e5475d29bd3baec778e9a1890e0707cc8571b64ba1b0a6a868a4a4e98057ca3f43e14760301c392e2c12ba65214fcb8fc2c588ffeacbd41e62428c2cef40ac24ae6f144395eca282e11265db1459c1166b04317ee1b1f528c65d68d6d1b1968c9dee9abb7d2f80061143b69bdfb5352284028f4b02e991a480068356406bc9ab1744f79a0f766053f93581db7896ef974674f5a0047c63cd8437b903c844602ca9c12207bd2d39a68efe64ba24c95d976a4e971a46ee1fa7a3a00e79ecfb39a46aa811c51faaed2e34f96aba29fc037d7ab59bd9d562e5d90cb90dcf9a0f82b69ea7a1e8ca88c5d33978bee23f125fd518822fb2a99061f55e60d1635e228ebc791f25cd2ec95ea8e1c6a34c4de267c9fe06d1a0b55479c40f65869cdf687bb36bd17983bae2d958648cd8967ab2d625dce5399ce59f3870e1bafc23db9e8017371018e0df58449092c7efa57332292b006c4efc685f4a4fb5dd95900ba25817931d98d677937de80b2a9c40fb2a7cae3bb434c0625c6991e915cee10ff4d29a74c1051b74f66ea51fde240302af246c5d87d90969f94c57456a52dff8e1cfb5a1aaf26dd7ef986fe1a6e8e51d0a60d8ec8e1012c3a2b83e023b5b8f8d331ccecb9e728e343e98d14727784055cfe7e6be2d69dc4e9d9694ddf6ce9ff2323d671a2c0b3ec6ff12fd547845ee4589b47c8b46f7108ebd0b40b27aecccc85ec914df0a09a029d0b13c3c10038f25ac1345887009c4e57b8749a12c16368af26e0f0815efb22fb5678cb4fdf49c36a862fab995e42a61e9ff5ce5b2a3c019cd264f2175f4358d2c8feb6e3da951410e57c9783fdb06726dcdccb4465e377080504b52c18d478a0861524b6d8c54c23817565ee97c0e6e0ad8aa7dd3769533ef01b6717ebb24276f31914eff6ccf239bfbe0b75987f00446fa985e235fe87d5b91c7e864a4ecd11ca81627858c21a5c8b1c9cb27a4c26aea35db3ad528712529683720e1633609685a75bb68ab6d6b2ad6dca18bb0d5c29d76bc0e99ad17fbb7dd2fdb62621b498066140b7f5c5e840012efbd7c9a9a22926172c218796b0060ef7bcdda77de2ae6061a673283740301f756c1b48ea94cd0e9d962c8f4d8af95172ca0b48f123df44bf6bf794962c3f7dc10d46e893453774d96a9123aa4d3fd0945bd210d6619deea7799f3ba96cb1372c4a68ebc17aad527c70230650d28688df7a9ee695a7f6c4b7943d7c32dced9a1d054faa4b2072ef509c92c1dd5220cf40374efa60b556724efaad3d3ed06cb99fe46cc495921bb2208ca0d9be1a68332c850fcedb7f798abbf5288715c59658de341895832dc0aec810be74fa9498f64450fe1447d619d8cf919f90f0184cf244136c869935c022afcf3639d6c6dc8531a80250cb3fe5db69387ce0f1924736f2558ad8c2b95e0d05f759a60797cb9dc7a96b7cbf1542a8e9d546707ab85376ff936d7b39c281137183deb461f2951b4a891cc9a82fcea94afae3af35b5835b52b4c05da3901ac6a0ddff990a6f9a9701ae555a2b20572e085d9f19a9ed33dd3059fdbb9d88b08db0fd5cd7b7b7424039ec5bb71ed244c922a3f1c1fa345fd969cf07bbbdabb2fef2e3446f3829c56a6d4506075cec584a2eeebf1020e0d03cfd376841277aba2c6202984989be24b8cd148ced99858ef868148a0a0c607aaf05ffcbb66a1e395f1a0ee5987c29e912be0cfe70ad240032b98703688a93c8465d084edb48479bfb2e555e232e6061d477628c1c1cff0de704f2f4f08f1b7b90dec3a63c98cc56bc4ff5c1da982de2dc37ffd08e93e226ba73a0eee13cdfd42ec537b9d512400a99039b39c23dc489f9ee6c9a4ddcd6fb993f3ac7a6aaeeeee5dc0a069b7023cb4df6c46b4eba357304422ee0acee2d38f13203eaa5bd6f2c09c178db844610fde5d928b1f53ae11d91c2065131d4f65a96215ef6cf9da9244ffb3842197e61b236cc9ea8cb79f2b7e09b085c56cacdb9b3e401056d0a26e536f59ecdef8a292f15b06618f5a3ef569d86825c1d0e416401ba869f8e5a6b9660d64fa37ce9c6853e50c3f9f8f59ea7d550a47a3299ed937e5a1386d95b6588fa95b4633539749fd42680183b3754209ed6def8e45b9e0c7230bfabb373f3c9ebefc4a7aabb4369d5fce6d387c34e764857fe4d7540efacb03664fea07de324659dec4aed911437785cd398f8de8b20429ada71b430a1b34e7283a24ae23afd34a9da91a47999e71bbb5944a99b55b40f6de1733dea218e17698868fca75a5fe79337d33d67eab8eff80cde6f9ffbf4db88c933d45f6f8401b74bccd18674a76fb49ce62fec96ede7a10e8e713898fab58d9bb2a8867d7489e982a492baff75be3e86e0a58e94d47cd5b61cbc21f9f28b0a7affd71ac99a861ed824e108f3619c07427f25455394663d92c37140ec0db34d55d7d108f4bca9e05006dd436ad0b4c552dcf782b388705b9430d63bbea0416da784139f5c65aac3557a065208199a6152fbae27525b135b4b685fb1d452d5c4ee67e05c4538261975171e0d6a318ab61791602d28491faee3f0cf4eec34aa84aae5cbe282f20c6829e5bcad6da78fc9f56b2b877c60b3e97a03323adf1e38b0cc63dbba59fb6d34558c72d65d4f156770696ab495e2cfccd410e20ba08ad1f2a6d128853ef9190a0b0bf3ea2b986abcc544c9043873f16952e9553d83e9f22f4a1845a8663e18f74a2c95f6f2807b66122ae7daaf15831dc0c3b5a11dcfa7883f7d4627b8a015c5ec4263f9ec24860f8509066f4151791c12cdf4be3f3321e146be30d0c02b057eee46fb00d7db5cb45c747a3b76401c30d2f408a9a497f2a931174e2acb188257168e2170a30f8f55afb988d44a570b40ab75b85b9f90887eccba4074fb27e0bf4e151a3f2afad68ffca0f2d8e1a5c30f8a6ca80635acf9c55473f98214128c85966e1a705784c308912494e13fe7ba1c8047631037b65cdc6313f2df1efc9dd847139a200f80a4190873353ecceb4983fefaa57105357de1c37ccb42f9d5ae485eaf2d70fb462c752cce25c152ba14e7007271e078a995dd04adf68b3a01cf8e428357cc10aa1b8e9014435507aa030c081e5725c5e463be13d5426b5d13dd07252983aa9aefc6d50cb98093369c52646caa54b577d03f38d38addf0c0e61821260788cce5bf0dc3719b6c2bb7a104156b8b1a8230d61497b26ccb5d01a3ff46a28cf32adabc00ed7c8547572cb05248a0760e25da81e7c902a2e52bbc37ae33605d72632c358383ef685a7811b16336b7e1cd476683a5f6ddeb9c5b549f16ec29ec422db0e4b5e554569d9ff11191783dc5e6971999e19f252dd77716a4520c1fd298474711cf69aefbf5496c889256eabbc3d9e846e51d32b51bbd92d89b5eae5b8557cc4775d80164acdbe40b7cdae2e29bf36e513c9cebe9a6a38ba37757a7a847203fef77e85055c9a63bc67315f2ca8833e4f7eaa71d94d0148a0dcc7710811b15383d9417fbf4ec603b20c0ad91ddd459e2be0852ef3cbc0e5234796dfa2ee46049ca4facf440e8d27ebe446707636ac5af3bf5ba6179547ca85a612b6b204579e15543db92911668fc1d9dbf1a3b93af67ab8fb38dce2180195ed987ab40f7872a64183d86caf2767bd5270decb80d415719055e1556b557161abffa2e28304f0d7667f18628a1371938435b62f9c03408bc8421d71266e7f366fc780331b958cbe3bc0fc3947a3eb7973c1af6cef8147079d25077c8758641e12dfa3975115c6c0d66f7002faedb5c368a0c76fc35bd49f9d55aabde6d8a03b645e89c6bafd167096acc34098bc1ad617dc9e1a1966b94ffa19e52306ea5e8b5e125a162293a017474ac11cb6eedf457e952883dbe820d17c465ab5b882177bb70ab3cfbd578fd8baa2d001d4b4d3e619336ead3d800c133af9670e50bf3b6219e6ba144bad8b22447f8a0d188869b099f2bdc46af430028795948102e9425f7b642508fd4472c6b18c347c65d10d775b52d150feb68d00829b1d546692f9b2c618ccac9ccfa26bb72d4de6089be4ca3f55573a61ecd0065dd5906b487991a149fed9a1469c6df7439907c2965c22896adf5cb79d60eb476afdd1f091a6b2eda3f333102cbc78b50796e085db7871ab40bc35c858c879a0cf3ffbbccfe337719a04a4fd23436a8b9e8214edf5e2b23719322f69fd24143e0ba0060a828b63b9578a8ff1628b384b7da051446a9e80e210b2466a42d9d0928a94321edd245db202b1c17aeea102b466a1ab6f1b645090b763a36c9e7e1de99def8ae21e4bac066bb5e8293b7dac38e677c611c834d8442c7d0bd3adde4b907804a960b96c43f90141168dde93532eb93938d36c6c11c50776fbd4f0d4c1e2bde85101e31226e9fdf01747e18bcd51f609230f1d64f18e4f75981ba28e68d85b5620308090e74167e8a40373f18be6b9b478500497b4501b453a17f6c686c522bc4f85f077c55acd2fb6d0f47b5d827956436e6297060590e3a07bdf675cb247db1086303e992562928b383d21aaec83fe14b899edbbdc80411897a1b78aaf097b96379f798e2c6dab4db9caf13807984bfef10ee0c31819ad99c6f15e4af2f6df56577fa37b88be03230ba27e249abb237a38c40ebe74ff7a4622bd05cecb52e14d3198c299959c36365bce59fff920ea43b39451df69648eaeb79173add78eb4b8275bc4f3b544e0f5c4b7e51e212496e4e42eefec9bcae93fcfd1478bccc6accc3bf9f913b57f11aa3fe09f58b8e8407d8cb2b00d46794129e31ad4b1c10ebfe2685a60d194e863a134ec166577c0e1f533646015f0c0cc65d4abca5d99f977e5bd94c1161980852e647570a05432ee82cb0cf8cef9090a1848f1e838e6aaabaf57402039a0ba2712738254d178ad47001717a101086b915eae8ec06d90653fa1bb07397627d9ee7fb1af8ce71c2f6f3edd6e44e834b0cdb1c7b6fcc049021f5fbae554c69f268bdcb21499fe9a44c53aaaa18fa4c5af0c191bef7ee459f4958e6e98f5f9bcf573e18feffa2cf2130d6d6db3837fdaed4fe264b9f7cf0384bb193ebe8d824143a36b5b4481af7404c333287133dba57a7f338dda3478de7ee7ad25714670a3671a4e3a83853ca1b219b4f73dd59da4e31c71e018611169f0b8e92891b5c98867ed4df38099528d295e53e78a87882efcdc72950ec9d44f26943ee8b7a44cf93ac7599729c96e565ef922adf28d60c112c2fa5e8824904443f3a09f743d7aec1136acb667eeb23975ca7e1c29de87928fab806581ec1432346aad9e10fdd6b41ec77cdfa0bbde1981ebdede5c1a00368e45e1ee8f8264015e93ee0293189befc53665e855855996eda0530a805fc27084be39875ae942854bba6cd896a7af5ad811f23aa5a81f0167d50cdce5c73f223c6ced242b93794ea4bbce87f32ea438a9de0410fe88aca4f12fb7f425147f971dee6481546c1c0be670fd94b9170df9b5336d9693d983ad93807ec1cf538173d28c2931eede3603174308915128167a44daf0128b01bfda3e3be3010b13ea233dcf2896c383c5cb29aef837244344f3ec7f8fe16d566858b617b0e864e079d0d102d6941e5f549abee753d33517e5daf5778bc6932c289d2ac4d3a6c7bc92efbd9cbfecba62eee1c6fa74bfa3c4367b84b0473e9b95d651a7b6c4895c48b347607140e714430b4e7d729750525714bf81c10f81f328aad4345b568b24592f5a39177acf8f662a66341c7017f58c15379b45eed4c9e1910ce68d28d3f68da881ceb03d8df0f5661f74b861264929dfffcadf477efe5419e8058b358dc2a924a98ddeacf62176327e059d4c56be539094bb9ad8eea1f50dcf4a7ad18124310ba2232e134cf67290ddc0cea754c2034704f383cda76504db6c5f3635a24532e1cd22b55efc9c48cc62131671954de5c1e672eb6d294461e77add858c5b7377c6d194665c4c29e9ada393dffd7343dedad73fa5b130f77f9eb592ccac095b584b7b9c01ad105abc50c6aafe0a849520316d00d96c5b6bd46c8fa15a58c1e96f30d46ba30b21392b57a554ea623d589b8ab9999fec056cbb15e89963987facd3a2634506c2edf2209a03a62026adffcce9605f8c84d3ecc98b6c868145993dc4c8a8116928fc6b9a1ffa027ef2f44b021d9057bf91adddfed0927657aadf0709bc43f4af1ea34a01d6a2ed86321c5097a5f49eea7dfcde510debd7867a4c33f68184a0baee41f3cf0d5374aee5909285e01a1a20e7a010805ac225f4cc2d4ab010a350828472291ec300a21bf5b92d25e2e4688beda552b9853d84710846197f3990c8a73ec6739eaa108eedf49cc2404012ec70bbc2ee79ee73bdbd44c5d4162d54127b8916c3760b78ec5a6343a0e807b78f22115ab130c211eb8ded3540c14bfa69f0ecec510d23a61036cb24000c9018a1af9f7e6c9dffd8b33c667d47dc848639f6615e3c8537b7793f75c2546d2aaf30e950df5577ec93ed7ec5e38a74d9b725eadcc4e75eb11631cd8d87d0c60670a9f8edfbb07b1e8992d7221aef5fc2fea1b5695d106c84e553be22f0a7514043427ec2f01d055cd60625e6678bdb548b8a93c397695e7e0330c2f79f94f41733cc57bd4b17a2e6376c4b1c1509bcf87d211e4f9d2a414b55c22cce75c8504854659c0f78b1513d6b6e84c3fb4dc5e7d00c837fd1a2fbdd3e28587cfc0b1fccdcb05ad1c9d9cfe062c24d465aaf4435c97c0075fe39d4e7e32ffbb4f0e781433680b61f0ad5ef987494c3d8ee903c42ba2a2af82dfbf2e34d27125fb98900c148d2a2833eb2fa73e580f24be0660d50a8e411577b3707218181d1be315d59922e91b825c790b439ae2c8bcf8ba9bd3910fc7140fb993f49d9d404bb0d61bce30f9933e9cfc429152f4919d697b8664c9e40457bf1679498b4631d641a1ceba56787d51ab50b1a173c6fd55d718c63bbccaf6f67b804b85ffad9a66e57012eb4b75175187a8a1498dd955c2966a07991b1607b4614a2501383203aae4997ce839db90fa4693dc1da520b622b70e84eeca153e3e91017d046d5d8332069243dc4c116851f26a3515a5618aa4d46e3b7e9e433b52427b6e827404a152424914f197423e5e28488193d65d1920c24caf077af9a40975251c31b4c5c374960bfe372155aac1b3f2fd74c9af3845133c63ec5a8aa7144c720204f2a581c8e912191e69ee0ded18c46de0b07253e09c682b290efe620be17f883982b9e30da1540c79981d7d5a7b9db6c35b74da7133ddd3a52169d501186e0fe51cd81c7c86c94e78742f68394060710d0914beb427b64cb0b22245b33bf80b0a3d4604ea13de704217b7f01c1e751e0a266e5870b114e44d08b10a465dc0a05e36e92058d4fb3440ff29ab8b6473d90f512285ccc80753def96d3a586161b9ff495a89ab8bd8191e329590234f24c45d1871090b36cae25af60a9d93635d16fe0f7a7904e0026283187aa36790aa24bea06811ac57e7c34509c2439037033866360938ee88be4a337da1a301af98b93b27138a2119f2c6547ffe7ac9f7ffb7c927d8a2c4d44de13be41d69e173060a713b3f067598b580a89edbf79a02efcd68f89d25179b3cec2730f3bd8de5ac51441d919178c08f9fd8ffb6c248a9f0653a861f6886b58b2bc3ac75d4a84f854696fc03421ed4b10b136bcce5dccb5d0a5de4ef4843024ead08edd33bc568011c81cb858202a4ef5f99008b7801a7b0b3df29e228c9d9f59fc7b8be14b904b85237b68527eebe08542e35a810972088cbcbd24b9c081e4e7b0b4ae7fa5da0e9e977dbd37da7af464ae9fb44c0662ca75d13001aa3dbc4eb30597292326c82742b8632ec2575ac43df31d048dded4cd94c7e3a99ac2ba359b2d163a5402522e451b391e1f9f19857cb50f6ae9fb80e919158d908ee47bda8ce64df2d238ec089f87273f6efee372a3bee9fba608e262f0e6dc20a881083bf3c2a266320f6a79a918100d73902479494dcce1ed90b3941e0c94bf7486b9071abde8d1ba5b504c483b68fad6cfa8c6234c680345a00ff4906cf13dd3b3d8e5c2a6f1054e8ec8200a04c52e9ec1447c25938e39904ebfc1c2c3e621672eb802e2d0d564adb20c555cc32557d8fb104f68eaafe6dc632cb2a444e1770de6d0c0f74fcccfb7b8b9b2168edc7d229296d9981279c364fd54d7afd9f83a2d38f26e06f4ae770a77f4a407b9fbe68e8d8c76a4b265a382c97af4a83bff06c8a06cab1fca8f922f939fd4cd161f39aa3ecbb516a646e57fba8532af2a0a784edc5dbff1ed31e0826455075d44763245c3deb6e666d4bb5f50052150d0bdcd4de57ba80f496e70e6e5d33ac62124aaa3c21d43fa7a1369f6ea5d0e29a5afd12fd9f4853dd1185b15b4505cb4d4a21749ded5891bc031535512d515fea15e4784b92e1a8f6550bbb095c5bac9dbfa675aed9bd7a9a6c9f5045e40072a80359e527e98342db8d3c753df7022cf63c805d765d0ff345071368f134952d3f415a8af73f92ae82ce39fd2b2b3e066bd6020257e7a93ed091094541136792fbdcc6c1a8c9a6eaa7760afbd85de6f4ba67be576d95ad6cf0cb5f2e4fe0540b3c8e58eca40fb036682df53b83542947b553f26ad1db8f3543c3ccd4fb6a2f30b96e99b53e116ea128eb01c1bbda8e7c57896e0eb3e23a6f02a1048342e87ca0ec6fc7ba2497f825d6241835e1ed3c43dd9a1b7abc547200da9b340bc715bbb914d3fcd2a76d3e078476ddd9e1b4f4fb67bcadaf62668220abf425998bbbf1b3293edbf917d2a012f8895add43b477457954b2d0511935e6a35f562cbb14e25c56589cec25bf557d850effbda77b1187aff6cba2fc81cd623903adfe020f9e34bf27186c1af13215e88614f5f62b3214b25dd829a1e34d88337953a04219f9ea2b4361774adb4ea41dbb1fadaeb2cf973dad5fa130c850487ffe18b07aaa0dd338697f10cf68486f2b124a32396fcd97e95b5b3a632a032abe9a3ba4014d9187edf77275d23c3b54113d79fa6067b7831953a97074e5d8115d39f6e7cef2ea32283d46b8c85c1ac559f3c2fbbfaa427d79f12e9372de4de3edccd822f953a3644daf0a3a71f87a1601d5d61b1acba37e0b166160e5363d9138fa9a75aa21432099ddaa3bc919a3a303775d603adbc6e0cbefedad5602b93c7334df60af6873377085cba5863e2cc2e5d1f23060d2d5efc62fa280efa332887c4a088e339a7a06bad7dec8c3c3fbd20f50b69fc6d7ddd3ef0c45cd9abd839751fe5d81fcb95bfa7958b7ca7c70a8c95de40bde2776622a98f509e48b10ffdb65f4bd43f668e89629f28e3e8f4a4b630a9f88ae9781028eeb70f5d9c169516b0b86d2ac3baf5d87a6a6f3b5b08032bb31bf9a9a83e1ef6c83caaf779b907e079ac0646a795f042a25d814e0c86eeb68282c9aa1d07e0bec4749ee0a3ff7cd5fd584e9aa99c99dfed8299aed0459b331ff031c945495e27381684ce3a4927b2af906d89f5737cb48d55ceef240f21e30ca38bda2ba3c460203829df013a3f3fde9d875ac27195c32234d49633e3058d8694ae8e52634a8e7a0f3bf7df51b755d0b57b9bc1110af29ceff79098a146d6fb184320b1bc3b6efb7bef2c1bda621947102989d5ed0a12a5e810a798faba56cac46d5aba4e2a21c37a34f995527caad633b5bf1307eef1e2c14482cd87129a0c2dabff91a1b3cfe272562651ddbcdb829a6b7ba671115463a3903e20ba470355f9a914b57594b62280e469bf18dbfd735b1f55ab6045b1c87736530eb232f3544c0a3ca5efd3bd0997a4aa8daa15148afd954d62d05a6ad31f1182b48c135e6e737dd8e2035a35647bf688e735ab64d5a2d4c36fbf5ecb3ce0437cb90db59de3c2c29120c1ef319c9e8a581613c6758f8ae44902065c9ed74e2b34283135410078dc578eb82cf027c795dcdff13900addf85d84325f699d92bb474afa070f558b8abad1850a01355e5d67c169929d97c484edcbe98da59e1671ae757a1b333ff8e5b068222a0a85f60ade7647c121e7f8a997e2b8c10a451931ffaafbcad0e0fd75afb7336dcc63bcb5190d496a95c329d129f3f932ea76c0c210431a13a9e5198c21ced0eaf8fa1f1ce0152d03638ee93b515538a5f383b071eb6b7870018f62165ac189245bb187d30566781e055e4a6ed6e683eedf9461b72f0fa97e93ad5e63b43e1cf793ad89dcca3702daad071d5fbd90b232321d84b1521dff7aa490c0cb9f2e8702cb445d8797888e5d7274aec678873a5f8dfe5f4987a2a26ab528936ab4383f6e729f8609e01d2e40da570b5a831f8b04874d1a957f5ac46998a207f7ba4ea725487b79709a25d635b953e3fe14a76b3a85dda1743eab7b4613f7f7f3406cd0e4c9fa554247d9ddd3f5c80b2218d0e4b624017c97b08f4668791163c88de4306e2e56094de673d7ae60bb6f599598afd1d30e0dc1b41ec195a58fbe2537642eafc507e78444c2ce76cf9beedbd0bc3e71ec19db8985eac79f99006f1ceee86caf6293bbc3d5b5e2409d47aaddf9a5e6e93f59d2d2ba9adc73804826ef4ad6495ae52a2cc1f40f2ed9140b144018004d45eeafcd56fc7e2c88893d0447ac9d71d2ec3850952cc1b2f895f449c00276aa4eaccd19f03f2224f1f3de4c32af9c1ee8f9ccd3a29bf9ba6956019c20abba9dc35678ea215ed476d438ab33c119fc4c64c4d392a079afb9dbd9f687a48296bb75c938280fdc007999a79f8efb70d9ffa98b58d55d89e30f5bcce7f3b827af39a67e9bbad0e927ceed5ff60d36b30d8dc997d7b3de92b184978cf3a9eb0b79eefbeb0afe06a888cd051d28d7563c85f4e981492cac6dc7bfc47ba1d25d86cf7b349902fd703313cc477bf0c48fee2419118ccd1a2c58ca764d4a624efdf93c4398c9ab35825340ea1771910b5f3e2f56c737885a7268c03d063a9d50531b06fab9f65f3156c0d0b3855d6cf543908b385f53a4b3b51e8efa5f381c2e925748e1c35e002c1a6ae2d3152da0c6baa24fbb20cff995c48999129eaba00b59c2e1201fb9774c9ee0157363214dddeb790cecc4f9c032121639617ce51cabab17e0caa57896e390ead4133d70a28e9c5e80224ff555e5030fa40b952569c1eb64a6efbe215b4044ef09cdd8bf8ee7309a0a01154c27326f016db34b70d2d783af7497a9fd583ce09632401dba3c06ed12ea448252086080ea8fc6728c13d25bbdefabb19c31a628ee7010d568785a7883ae2612be86698ffdb03980c90e03101b282dbb42d4507b328ad461ab4eec22c41443c7798bd8f161bfb660ee06ad743daa0b1b747546eb601ccd19b3439fde38186783f2c0a54bc1aa4bb9c645c47cdd139178b3413ff393d99cd8481f011e6b47d38bd702e4d13cc5e4c3c82c74c437d486900c7a581307264270e5c2b24e6840009b5d9ead87b8c19af2fdb7436d1c36cdfde58297e08e13b2fadcf99fd9d9c05bd1b8b7bcf7d794eb3b5479732abedcac1efed1ead6fc93cf2a6ec5a6ddcf8ee43d8aa1f415eaf361bb8a716fd77049608ea0c465f14574688d4c988ade8a647c59c046f4a34a0d6f22abe785b532e4558c6eebec9507eef403a81c5b8d9099203989fd142f9f47da82902fff041bb3369b2976fd3df48b30978ec8ef9ed325471ed515b50326f9152c5a02994363436265dd350dc1052b60d2ada0591228eda97fac86019edb78443bffb96af0aa3ad9100497f5fad76edf583b43d89252b813959f1d0ca6bef2662b8993bdd7d3ee4ff390406613df43f48916f4c33ecf3b34607a1f6d27d75dc6bf81cac517f79bd8887f216c2eaba6143f3cf38a4a3bca5474caef8defab1a5815dd3c59a1990553f1b52399364305eb024d093832de9e3b25671980184b5a1cf0d32da16008de718018536e6c0929effb3b742e0d125d98040629de6b85eb741e8d520f3f098f7f067f507aa94d46e58dfcae005b755198ca60f090617918dad3c59736cb01cbd6a39e504b9ca0a6dc0a22687cc20de7c199ecc887106146e2749f3c84c63889077c96913c63bc6e79ad6f4ac370e3438470612ffd1566f69d6633690461e98453c553d63d2e75627ecce55d9070bbb87d3fdcf102849d606b9170e03d3bf601221a016b642502f525ab3066a6fabf3b5bea7a8874dfaf3ab3ef1464985dbd3c7faa3a73f5295bbb0e59aea0a7a79d9fc0974db1d86a9804859e0407eb88a011d6afa521e5711351a8ee51fd7b0010bbcf0def539e1b5ad2c470784faeb1f415865c26394a18146739737e4355129f404b4ae49def46cff6fb099e439452173b13bf978593f6fc006b4601dbda7a13df57a7a582965e4e2acfff3f068e7c74d985b5b7de42a8df8e0eed1ca974820a5321612375b1efeb792accc954fa627746b0052803f2061256c9f3f32c33347b8b2235e66494e85377c1841a5d56126a354e9a663401528725e485f2aa68277e8214a8144dc9bf913a290c67f51fd0c66e89d459633038e9dbe44047c407b9f85eb42d5189ab29650fb84b375e905ecb6cb01312fd94ab29f6bdcf45a892ab34de8dd21cac2ef8c563a3325e1ebca8b8c1d80f0e558e92ac78d1fd9d4bb00d7c498990c4d6a769608d20b94f24de6e0bc25a867a40aa8e73da0a026c2a58186e6b7a7e8c3ce9f53bfb92ee47d38e5de59cb73bf2e7feb20b68a2baafac114c74c320c86c9a109f52f754989798177ad4b58aa339f64d77e9c91b1ed5ecfa7c184735082b246feaa305f9cd69e2e710f98e28750e0181fdb49f59737070bd50e116343c79365a9458ebd98b9fa3114aeb1a43477fc14350aaafe2ba57ba514c5b2ee36085caec48b3d4add7d86e5bb040f0cae885a00297b30781a8ea78217d0cea21e0eb1d6663eaa6357674d6662b1bcfba5dfc2d3a433a924319178465c2df52d4da4d3a162b2ddbfea6488982a71d62e8220582a06739d3db7638fb161de7c5e944d8db3609957a37a18988e1532e0faa7d1fa89f93bbe8159d51e2b274259879df334dba68b7d071a37847180924c657a5ba56f16c16b1ad974ea1b746184d3c1b2192f1ecbb82068dbc38e048a1b1759aac6d8897c5501194fd3ea7526cc43eac521053cdbcd02be4aba0ab886aa4dfe847e5c44e20995f682a344c05e1cf70072667d52e455b07ac953a1360fa5ba00d2d11a37c484b57c9fe35c7b41d0fb17a025a1094a76f0a28d1825cec00d8e42e013d36ab979acd7b656c0bf027a9c2be0405a8eb15443aa8cddc013ae8e41a0ce4ed630149936705440d1a61f14765e04a9ddcbcb13c08fa8b1c81e491b5e7cb59e5fe5ba5aedb45872c7a5f88333efaa91487e9141348a574068dcf8347e4888ebd9be00ed6c6c17b85c08941d633a5e9777c77ca0fea3be391d21ea015bcd9a827e96e5c58451d510ad57bb53df97ee53b5604ad672d9525aa1b8b43d6bd14b08e796aa16f91550f784ee45eebafe87c405288c4a3dd0ceceac358ef31e16a7ffde48c3ca20a65ed86c1c1a03032cc242960d5daab36d26048d370e90038377d893882191b4230cf14f57e3bfc29fca1a506d50287bd9aecd52a91f44be32bd3b89015036edf3c8ce44a7bd963d00ac84758eb0d6ae1456f6075407b9177dee208128fa364170f759f76937c1f903003f3eecd7b2cc22f4b8a7fdc294a431fba267977fd9d2483ffc83ec65a36816a7b13fec2fd1f998d2f2cbe10e826e30572e9681df6c9829b1253d8c4f77aa33720e8b4f081c23694424f3bffae1576d9d4a1244704296ca0204db14d1cc9e9859ece91f567030114ae342c4aa509b8140e711dc1406f17adeb42a76b741802034b868747a9ffc2bd4a4114b7fbbabd2a80294d8adf300d77ca154af5413041592967ef8e572e488e70d4433697e91e79f460b29d5fc7015b5c81502f66ee5ffdcdab094395a41b11ada72c2a4e3696fec45ef260492d01760ffa47f721b8e3dd2756ac4146469110fee7f44cbe22480da299d560e42966e4f0a626f9afec0a7a8bd65d7cc260d766f62560630396112ef2f71a707175329be0296d5d3c77ec21aaa138e5cf9640fc3f112d4cd7ebdb15191e4e8d70aa268c397f6df083c9983f027486583f6ae2f03c4ea9906dfbe2e825adc742f4fbf56558e46d0ff5901cc7cd0d0b753f9adf0c703ebf73a8f449ad06f0d100a4bbea3a9a6b0b4e244fb21e4679b5c5f3c5a4db3dca4fff3b7a4dff7fc0db1c48340887a8af38186d226739c12dcfc920644a46f3f120c9be70035b034f3f11e310fb7d254cd7a3c0235737b627909b9829cae07f639bc285705fd489046963011aa4a0715ab6eaba8481711e059f1d40d27dc864cf7841a9ba434b5b0c4fb49665f3f0be6f33af3fe4365deac9d5de525dbcb3d42946b263591ae6ccb24d41e035ba9dae3bf71c65d5610c5be6cdb3c2bf3cbdfac24e37f121c9a846fdc16472a93c334dd4a685c3b6ece223e5f889f1ca5438b94a6091ec91cc2ac924292b55f1a39e5fe5c1722c0a1dedd3e6c59ccb499bce2c065358c5b55e8e6727652911696b0ec36ad7e16f8127041a739a2d364d4d11bd57d0e7568728e4e9b50694782e9cc7925788124d41aaf8a756a8f9160b299bfdc9a66b2111ac621d8bb9ab00a9ff9994f9bfa8d9d92aade7071a39738089803d85427e3810df3407d50f528d29c849e10033b22e488e2cfed00d0a3506a68e6e902874c46876df3b7d53bd37134f048ef73bf9ba54dea3366c9d6892bbb9e1aff62eb84b0c78619499cfed693e7d61009d0120397da74456eaf816d6d64f005ff180099ca3506d95085f2ea24025a718089ae555c3a8d42c7c9b75621fafcce057b89603b5d74181f413f6b7e47f100103ca30fb1c55d092827022c1fef9afced7329c17085f90a90c45c425d11ad802b247329924c669fdbb92fcde5809afd2f93629340e5cc331d9a95a236d0814fb74b0338f819bbe18e5f0c134427e8637cd445177373b569c84ce8a36e27d890779cfdff3075b4d28323db887c6979731e53fd811247c870b3d6b65237cbb25fec1e203173420723b7db6878b8dcae0f0559046bcb4fd12d70fb1dbadbccf68c10d8058160031011955d02f92b50110eedbd87c4577fb6b28399a6d2d52913d172648876c852711b76c36d3edd2231ea413fd3694ef6cd530a48a341df957e1e206dedf9ff6783d38e6f4449352d91ac5402243dd9744c6e31a143450668aea8dc51101ce734fd32903c4c85104c8c0f5f79565c463e5221240f26e3e6c1d4bfc85d52e64f3af7dc632531aee93577c66cfbbcef29b413478644264e58c6b42d9ad23acd2347a138b62b563351d911e3aa4a2954b0db9d9925598e9582f32e7730ae35973f1d842f4af9bb20cea2d333779351e4b65aaeab99b01ffd6b6b4883097ebd0138fc3d6dd67e603fdddf34640db226fc38b7959033ee0daf4731b08cc3cd2880855e793e054299c7ae295bd0bd5b1eb328def90a358815e5c6d0176f917f1467d6053bb9551ccc7d4a3cd1cc6b15fe005ee031cfc130976efa95def6f1db65aaca7e83b3756f18beb63bdae97c7636da8ab4ae0009bd59c1b8527e775fc3adf9e5eb3ab107452141d25c62b5e501e8667987af49be774a6de8896a18ab652fe60a7766b26657210aad6770a93e2cf4d3ae1760b643e83ba97c29d379df2bf14f01cde0b72a83fbe5bd4ff1eb3e04e21b99ba400e948d6431a62554497660246ab94201591e61bc7cf16a1cbc17180df4ecf364db4c7ab5384ae6d563bae291f56891457393c218a39e7bf4034d50bd8a4df59f5dbc718ec348029d3fea104dc86add8909d7367dca4a2f0e806bc05fe15897be7618abd96ebd993c11e202d9ef2aaa7111d1d3f9a890ba648673bf7f8d12aefd2988dd4dd89c700fcb25222b261e3f95830980d627bfce000861230606eea260b4adaaf2c351cbab984c2a94149cf3f8071e6e21cfc4305d3a5b17397a7e039344316c65daebec92e8145a3dc8f1d44d5effa5e6d3ce03b5e15cf27ba083cf673757c7b6b4ca76cba3a7636f8a811d34ff1ad62dc0e3a680c0b4aa8a94f48a631d7ed48cf5b95238ba7459d9e862e329cdd7f8152f26349038460eb4ac3daae39ba7e92b0209b25818d3c7f59800de1c5b7897adc8370f40655d2e8685f6ac29449664a1e960ea8f75d6e3ea367863fc37285d628baa122dbb067637cc3b9007aaf79142f28a1895b2dab4eaf1935ab7ab291e6bdf8c7c96806a745cb569c32177abdb00637cc89530a719ef9c034190087e6ebe92e102b6a1f49f5e80e61524fd5c67aea73682e89bc032431dca05d55146120e71d0d96cdf09f7df318fdc7f5ad5460b3902926b1680374423dfe66fafb6e762014b2e1b9e0633e289e4e28a56c62b615fc3028bc5f4b29643a878ab979c225a2d974b916b6034ddc9c958c32ac515ece022320e551b02232aac69a922f5be43f9094839e294c8a551d5a69a5b2296f19519eb86363dfab0b23d9a6e25c523ba5870fb5ed11e3c3a8c885b9cfe208e5018cda2d29d29dc967e459eb7255374cf14497f5caca9f068eb7a0556b711d52849629a52b8c209d92e827802130510fde48f7bc1cc46b20ac012ebce7840f503a38ffea59b17d87decaa6ee40849c30e4e4ba26afd1c88c48603c8123455eabbcf75bc0de26151856fbe87913c9d5a44965c5122b77e476ce6171f476c9c633d8f4b29fd690e26331eb12b23199e1823d9b5de3332db1bb6d65205b46edff809578359a4c1769e810fcac6b8f51fc627784a6c685f628b02f475f78b5fb017bef0d2de4e64af5fc3185ba9bd3b561b97df90c21a823016ba67b50a13c58ad3609a0ff94676dda18ce44fc3dc8afb292d407584e069283400e0e233794ef9f4316cf76f11cab365f0f6bf1b06dee3e4b438ff78570e59d5a344d321b6db9e40c7d609a0fab945e5856cb822c6d35f4b94385c9ffc7bc88b5452b1244043901337578aa137d337917982352cb70e684bf963edfe31cd198858441280630ee7bd334a31d32da7e402513e849cb3f924156b34115e3ac06cd8e97875dfcd5116bf0db47327cbaf210746258c09bef34560031be8d7c414cc65b377e53a99ade93e5fe3a039b7bdb797e03d740174b49d33f7d6eafcf605397db32190b4e503c89f92e2e31a9bcae87b1dc524202db8a2b4dbceddb78b75dfb2208cf6d06064ef33f2ec6a8f5666acfaaf78b2f4c25b27b42ef125ec9e2a3e28ac11130694d6208a169e14fdbc310f74ea6b0ab7981944b912b1eabd6c0f0bb4ae4145ef22b4d8931b2c285e87f70f3137b83398ff2c16b9e776c2d5545256878844cf333722376e724c1494686977bef5db7ecc981632e9d4a4deb3941cb691cbf5eb87e8b5fe3f33f64a46c586e9bc59ab3e9ec20ccb9057879230d4af8d2001b257259dc30ae38710a279ab1bd81b2d9452bc6bfad424b82dcdb8942d09fe4e55cca8fb2d63750504a00de042f1c70e6c91fd54991bd0a2afa9e833ab4a536b759472e907aadda15a269584c6d856084e9b958c47c09fedbf6d7b019251e554713e3cd552b99a549d676cc4e4b693c834195cfbc473214c1b0db677e8e51dd20043e5ac5a0741ed5fbe15b244fe92a3b1e93eefc4b33536883fdfd4dc6e437d468bae6d1111b484161cb108e658c9fa28f07fb020714cc3ede4bd5609e0356268de1731b21fa1b1bf055b6d127fdce46296d17dc2c5f250df8893e280c18844a32a4f2a1c29260dbaa0b555b5c8cfdae98a8eabf6ee0da73183bb48060b559a7e9b810bf26892b482a4c091b659a8e9d5d263dea50d69b12f52a4893277dd90112aefafa2fc964965bab1e93febc2a65aeb29381652f878dd24bb1fffa94183b417ef410b960fb503906ebc84004937df0570f617a32b837cd4a5f59e98c2f24ae5962a54697d6c2b1b30e8b1612e247369cca7a41b74c66221d7a8607195bffa1a85e69ef57e1c4356daf4dcbd845683faab57d2f023e570861d721899590e9d64cf0032cf3107bde3ac3fdbf3a59ac096d4e76e273b26607cc422c7a898af814d8ba3823a0ec897273beafab349321b1824a7c41e1c401cac8d193bb38fc65a8a0f953df0c8a12a0af87913538308f7cd66f4d6f3f6cd338c6c72c37cea54ed61c6b214b34b0427066e5090ed539ef39a859ed8dc7edc599f3dcbaa40235e8bf589ff30b11d0348f7a4b6d3f30ccee39ad72103d8bf18ed52a756d9f54f6b6382c3a077c66fe9894f79fae70fff28dae372f03ecd2856f0d95b0f10ed0c787655b6f1716e70a4dc880f1594a780f50610df4987ad834915241f8fc956a510f4b155392e8cea4f735eabf6800d38eba3d50c2104049e448f287087a463df2cca0266b208490af268e08f722177c703aa19973745aa689a8fe28778f637b352677aa1c95e0514133d60305dd965d3016692970b3f208b50776771568a3a61ed14196653bf9ecb141468efa077d0a9b910a49d9b9b988044d6316add3bdd3b6a45b3615f0e45b77d496e9ab7140d432e2b92e540e4fb3a119c1c05e827a70e263539d39e9e55b0493bf404aa9c590a04b9aef014f968af52086e98fba2a20109ca32b5c2e51d0bf7d79323e784f54d762ca4ea08bcf31c2bc4df3c178ad9732845bb3e507435eb4a0452f31211f6fc92f7b772ed64b6170f9fcd3ec04e7f0c46b5fdbe82054436943752f0b3feead8b3dfc815692cbb25683135172ccbf3cb6e049a2c30a6b281e81e4d31862fd91fbacd9d9e430404ad796aa3c608986acdebea4c295e635aacbb59a646924cfc2f22649e912a64518f41e31575f052efd4473a67fb99693c67e451f87196aba7ed30069aee21e951e13106a0f0f1c053f749df575a8afdc7ae563a42affb41dca844aef8430997233912f663bc11dc5cf6ae2ac1f81d76522775ec9c0ed0c251ed8254032de1cdf9855a5000df6541d457a9b08d5b631df3ddabc04f472e8bbcf0c01f2ea9f717e74696500884853637052e35003e055c879beff84e865848f80164e89be068e7d42225693b8d9649050c17318249d130c713d7dc51c2be39458c7619938d781a064f20ca84651be2a1d93b68b44aa6f7e16f30a9064c3a366b622eee14dfd763aaf3a545fc467cf8d7bd40ff102d09378a34cb92bbea18df843e3bba2beb81942f1fb4c2dd2e5584b3123fb12fbb8c5ae4830c3e4b4d4e74c1863b38a4182d5e97c6f595f46b80239967649f265854f7e78343d9206e7b25d752b8058247ff170ddbf43d26849c7bb06cb5ac73b79bc700def14203ddf88b2e4fc67a9d810103647c0668296b5d71cf7fd1ee338f1e3bd34c00feef723edaf45d841f2827ac41972001ab59bd18b69cce7002c40bfe38c4fc870d820ef5aac56a4be2be769a4ee599aef513589315b0ab0b0abf3f4117d101422805e977fdabf795b652bc7303b2015baf354f00f7e863ffb0874a4dcbfdbc2fe83c459f5df6692dae852737375f4a725e21918b2d6ca8592ec84d9ad44e20732c742ab15d47f3d212227e8f40dc15eeb6465640cfd9beca0d785afd1909d629456433d4d17507b84d598d7ecdee1076df7d0f914e40ad4c0242ed3ed95d9797ecc3f42fc6472b1f7051d0cf6364da9090164894c6d8cf56219e85e34cd048b2d0e2ec99e38ef7ffcdfdd69119e17ccd6e99fe5a91e8cb9f40a652682ccada3427f6636336b4cadbcbda6b6056e7b39f5ee92b1e09689e396b5516b0fba9a26c0f13d5b41785f940f90bb34f08e6fc0b22bdcb624c0322728786a8a3c0a0913845b40e87c1d7d56ad501eceb2dfcd7142d5b89b9642604b7271ef42caf1be9535b21e7389de76fe5d691d4c6d38d6886bb86cf31ff71f2b764e9650c73ac3ded7059a9f34ad2b2dc3d46bf0c55f5c7d9f9b82459833051bbef66a84cac991c6f1fd9a303f5fb18226077e3b7f1a5e952b4eb2e9d8d86b6368013d174c4286edcc10f0391356dbe374993bc0d226a5c14a3f4a4b8bee34acfd01c26a9d47ec440539c8c176b96b5c747731fac033b554a1c3a9e35594bb4905163b6707cd9723ed281eb9fdedb265710208c16a4aa8b68c66712c32e18c31f087187adeeec60848d7c6d59fe19653af3d762468b2204f40170b1401eff34777e98fdc4aa452128796fdd91681e1632e7fcb14030c3152b9c01ac88127b891dab756ff42525655cf7e4aa8b8bc27911ca2902720ff2e1951b3d962170f47bde6129db7b30fb326506ca10287813605f9434393d622c189d7389ab5af9df3caff64484ec8f8cd06286ced52a4f60a16619dc48edee3c64cb7f10f5673900736e9bbc2f3cf075bf504729cf1c3166e87c4c43a6a50fe7e55cf4c463f65927c8f15e2406282258d8031670f97198182a9e17bc740c335d3eda61102c29314f1ac6822ed75e31f5ae23de5f07ba3570947ca0407415f5fc6368545fc2e2be577a39539e7da52e56e0bb8e4f2dc4a398ec1e04a588bf493365167a98bd16c2cc87a2f0b009826e6c9df173e15743d500518c979fd5c850869803e8252e9f36283314114ea8e60d906e6d1c93b1cecb06db13d04b19bebce52e804170a2b48dfba5cb4e096a8f2c1255516b92e8ddf32434a4a3b1e30e79aebd7e2dba6c026aa0b776b428fddff3b5eb6f622cd7907c2ce3cfb7c0b6de075513d811748694dce71ba2d434459d3104a22431519c8089ed15a3d7fbe88b4122b3662d66b198f12e88d1f3cb0d3eeff194c9a6f9267bcecf17bd45c1b5b57b4be6553a990451d82b62500f5246e4dd5dbff0c7ab795258b4cde0f389994d75045251e3d37fd4f8051c33d2887ead9caea4c044202b0063e86f1006fb1729536d78b42c3c367a084f827f9e9ad72297044e5afd3e1b99d766cb02796bd41b1d1fd2d3cfb0a200cef10a9344fdcb7ee78cc2c1103a8673512f79243f4c660dbff27363060149a9720adbc2cd2331998487168bced1bcc8560928ab03768c2ee231eab6965a18f6c3beb4ed4b6c44d5f34771770fb429c4148400d588e298ceb60ff8059f61b92e3a12a2769dc7b6d6ba1967c5a00803ffca5ff20f4c91b503a212d68d60417ee57140797de16d41c3d253ce42a1a08fa2c12251fcdebbc0a5367736aa4eb32ecfc70ca297defc856f31d858e21b82c2510fc2f4d880616cafeaf5a67e492e59a373c4cf252f76dda180acd7eebb8019d39a9928e976db25c077cd5569faa7e6f4d3de7571f45f80a04a8d90a308ac2513b26327e7cfd7795ed27efe3d905748fbf2875a0e5ea18c9d286d7972c129c83f5a2b5cff4714f5f58935ef47ec615e7b2312241ffca3e4a3434d7af7d88d4c0e76282cb9daeb1b6c24d4e48d44b93d976c6d70d550727e99b1484624a6473d3f0fcfedf22f65f9b081dc2fc9ec631e2ed64a56936fe5ee19c4b988fb5e0f4b0954d215e28a4743cbc812b1b3fcb681686fba3cfded6680211e1d82429f6941bc2f61bd5dd1a9bdf2f61ed3a26ce622763c24e7e231d7d20ec8b2b88269ade9985dfba412f51d873e2554cacd50a88d5f1ef686ba706e44dc550eaf766450e4e162b1a1d1b66ff17abe4efda5f78e7966869d61a5ecd8e5a436f907a2978cecde186c338e85bfe84156f12851d9fcf4a8c360fd5ed85facb0d8beb13201b388ed9f15cfe8b18da0113fbe45b9c1c0c8b4b2019c504f89cd95f591f579c927f9209a3a5235ba363b3985a1de8b06165e51791fde41ddd103e0bb1bd9567733054acd6cce99afaf991b84203bebdc5f40aafdfdb75ae41e38c3b024566b9888a91d805283c782bf06cba1912ea71b0c1f3146196b3321b2f32c89b5937d3ffc2bd981e76170a79dafd3d8a208ced4310a239487e7c3a4f093a911ff3cefe267d1b4c216dc763de3d09de82983347602b31d211f8701dfcdab3626459ba2ac6d65115ee6e38ed5a44d3ed126c57b9312fc74d7fbc27136686a84b3ad9ec45261c8842b66bc549b994df2cf643ac5ff4f46c3c7db55d9e7419f25fdd22b27e528fdcf21d94ce9f70234471149733152f26c6307f8a6539903b4e5cb7300e047e855736ad71e7b9351ae606ea70aec4ee7c1efabcb6b663681b8c2f128935fe578bb6330108ebb5ea2d63fd735360b975a7fb8048e8fa598c6fd5cf2a091b7d2b88ee0d408fb79f6fead493c8c491cb8e7cc310f3121302cb623f895cde0fca0358d1e4082411e2e130085d8b63d0cafaf26d9bcf6a71a9b9208a0d797a56a1e0441dab06d57fa40ab0282ccd6832f14e801caa2cb722ead51405a4f1933e1517e922707e7bd2d29c00e9558b62f3f2ef5bbd2925129aaacc97f907590845711a8c758d67feebafd6fcbbfb9f40d654b96bc66091b02d0b845f90397369d661a6668a5dc6ce93a9a4a19b9c5402b83f1e2ddd8f4892973b40c2a77a3ce603e37c18ea3de900c6a37c90ebe4ba88bf9af1cf5f07c3d74454ed98e2d68f25f2fd922b43530889ff0566a74fd7f57540cefb7c8bce3be7d6faa0e20438aacb50fee44b5357b78f0b9b7b5886fb791ac4c6dcee4ccf926a1a650f1b217416ec279a1227b158cd48d9eccfb3405fc65007106b1bac753d18ecdbdf147bf39e5156e69eb3d6e8eb4bc093ba70c828d05bd75647aac03e4c411ef6a5a4095e7d0e08189e06c2f708de7794e27b342854c54ce014c48f28a774338d96821f34ee324c7cd64cfe207720f5849c6ae39bb4effc336fa138cecd10f6db9015537d1d059d16a973a0d3cb008504c5a60896e93652842507357637d238f738f47bdb22245726abf53081ac029f6e0e6dd88e226d5f4f0b7f0efbf95a8a38279e4e2837446510eeb1481f1192105377f0b0fec689790b3f292a03922502fe88c68fbe9a46566d46a7ad8cdd1c3985124f95f817580d2fad434b493058663c94397b80a708c2dde0efc1e81f9f656ac98d9d4dcc3274b51b42261a8d8d6eb09adf26300d7f3b51172ecf14b04691560a5493761c46037ada750b337f96ec7524cc05b9a239944439833e5b2b405e309883864b2dd94e128659525128dd05f214e28b192c6ec1bf458f169a142f4d08d51aeb6d227</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">gem5复现论文实验</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="学术论文" scheme="http://okeyia.github.io/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Gem5" scheme="http://okeyia.github.io/tags/Gem5/"/>
    
    <category term="非易失性内存" scheme="http://okeyia.github.io/tags/%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>杂记</title>
    <link href="http://okeyia.github.io/2022/03/01/%E6%9D%82%E8%AE%B0/"/>
    <id>http://okeyia.github.io/2022/03/01/%E6%9D%82%E8%AE%B0/</id>
    <published>2022-03-01T06:12:56.000Z</published>
    <updated>2022-08-10T07:21:42.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><p>本篇博客记录一些容易忘记的技巧, 或是一些解决常见问题的方法</p><h3 id="一-终端命令行参数"><a href="#一-终端命令行参数" class="headerlink" title="一 终端命令行参数"></a>一 终端命令行参数</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/argc_argv.png" class="" title="argc_argv"><h3 id="二-cmake-添加-h链接库"><a href="#二-cmake-添加-h链接库" class="headerlink" title="二 cmake 添加.h链接库"></a>二 cmake 添加.h链接库</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/target.png" class="" title="target"><h3 id="三-git代理"><a href="#三-git代理" class="headerlink" title="三 git代理"></a>三 git代理</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/git%E4%BB%A3%E7%90%86.png" class="" title="git 设置"><h3 id="四-cmake配置MPI和”-lm”参数"><a href="#四-cmake配置MPI和”-lm”参数" class="headerlink" title="四 cmake配置MPI和”-lm”参数"></a>四 cmake配置MPI和”-lm”参数</h3><p><img src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202203241229563.png" alt="Clion带参数配置"></p><h3 id="五-md插入pdf文件"><a href="#五-md插入pdf文件" class="headerlink" title="五 md插入pdf文件"></a>五 md插入pdf文件</h3><p><object data="1.pdf" type="application/pdf" width="100%" height="877px"> </object></p><h3 id="六-双屏变单屏解决办法"><a href="#六-双屏变单屏解决办法" class="headerlink" title="六 双屏变单屏解决办法"></a>六 双屏变单屏解决办法</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/image-20220421153609068.png" class="" title="image-20220421153609068"><h3 id="七-学习git网站"><a href="#七-学习git网站" class="headerlink" title="七 学习git网站"></a>七 学习git网站</h3><p><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解Git</a></p><p><a href="http://onlywei.github.io/explain-git-with-d3/">Explain Git with D3 (onlywei.github.io)</a></p><h3 id="八-图工具"><a href="#八-图工具" class="headerlink" title="八 图工具"></a>八 图工具</h3><p>Gremlify is a free tool that provides an interface for querying a Graph database using the <a href="http://tinkerpop.apache.org/gremlin.html">Gremlin</a> query language.</p><p><a href="https://gremlify.com/">gremlifyy</a></p><h3 id="九-ubuntu下zsh设置永久环境变量"><a href="#九-ubuntu下zsh设置永久环境变量" class="headerlink" title="九 ubuntu下zsh设置永久环境变量"></a>九 ubuntu下zsh设置永久环境变量</h3><p>以git的仓库目录为例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat .bash_profile</span><br><span class="line">export DBG_ROOT=/home/server2/grasp</span><br><span class="line">export PATH=/bin:/usr/bin:/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure><h3 id="十-Lambda-表示用法"><a href="#十-Lambda-表示用法" class="headerlink" title="十 Lambda 表示用法"></a>十 Lambda 表示用法</h3><p>lambda表达式可以理解为一个匿名的内联函数, 语法：[capture list] (parameter list) -&gt; return type {function body} </p><p>capture list：表示捕获列表，是一个lambda所在函数中定义的局部变量列表<br>parameter list：表示参数列表<br>return type：返回类型<br>function body：函数体</p><p>我们<strong>可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</strong>，</p><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/Clip_20220810_143813.png" class="" title="Clip_20220810_143813"><p>lambda 表达式本质: <strong>我们编写了一个lambda之后，编译器将该表达式翻译成一个未命名类的未命名对象</strong>。<strong>该类含有一个重载的函数调用运算符</strong>。</p><p>参考:  <a href="https://blog.csdn.net/sgh666666/article/details/89000215">C++ lambda表达式及其原理</a></p><h3 id="十一-c-类注释"><a href="#十一-c-类注释" class="headerlink" title="十一 c++类注释"></a>十一 c++类注释</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/image-20220804155226015.png" class="" title="image-20220804155226015"><h3 id="十二-C-优化等级"><a href="#十二-C-优化等级" class="headerlink" title="十二 C++ 优化等级"></a>十二 C++ 优化等级</h3><p>-O<br>接下来是-O变量。这个选项控制所有的优化等级。使用优化选项会使编译过程耗费更多的时间，并且占用更多的内存，尤其是在提高优化等级的时候。<br>-O设置一共有五种：-O0、-O1、-O2、-O3和-Os。你只能在/etc/make.conf里面设置其中的一种。<br>除了-O0以外，每一个-O设置都会多启用几个选项，请查阅gcc手册的优化选项章节，以便了解每个-O等级启用了哪些选项及它们有何作用。<br>让我们来逐一考察各个优化等级：<br>-O0<br>这个等级（字母“O”后面跟个零）关闭所有优化选项，也是CFLAGS或CXXFLAGS中没有设置-O等级时的默认等级。这样就不会优化代码，这通常不是我们想要的。<br>-O1<br>这是最基本的优化等级。编译器会在不花费太多编译时间的同时试图生成更快更小的代码。这些优化是非常基础的，但一般这些任务肯定能顺利完成。<br>-O2<br>-O1的进阶。这是推荐的优化等级，除非你有特殊的需求。-O2会比-O1启用多一些标记。设置了-O2后，编译器会试图提高代码性能而不会增大体积和大量占用的编译时间。<br>-O3<br>这是最高最危险的优化等级。用这个选项会延长编译代码的时间，并且在使用gcc4.x的系统里不应全局启用。自从3.x版本以来gcc的行为已经有了极大地改变。在3.x，-O3生成的代码也只是比-O2快一点点而已，而gcc4.x中还未必更快。用-O3来编译所有的软件包将产生更大体积更耗内存的二进制文件，大大增加编译失败的机会或不可预知的程序行为（包括错误）。这样做将得不偿失，记住过犹不及。在gcc 4.x.中使用-O3是不推荐的。<br>-Os<br>这个等级用来优化代码尺寸。其中启用了-O2中不会增加磁盘空间占用的代码生成选项。这对于磁盘空间极其紧张或者CPU缓存较小的机器非常有用。但也可能产生些许问题，因此软件树中的大部分ebuild都过滤掉这个等级的优化。使用-Os是不推荐的。<br>正如前面所提到的，-O2是推荐的优化等级。如果编译软件出现错误，请先检查是否启用了-O3。再试试把CFLAGS和CXXFLAGS倒回到较低的等级，如-O1甚或-O0 -g2 -ggdb（用来报告错误和检查可能存在的问题），再重新编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;杂记&quot;&gt;&lt;a href=&quot;#杂记&quot; class=&quot;headerlink&quot; title=&quot;杂记&quot;&gt;&lt;/a&gt;杂记&lt;/h3&gt;&lt;p&gt;本篇博客记录一些容易忘记的技巧, 或是一些解决常见问题的方法&lt;/p&gt;
&lt;h3 id=&quot;一-终端命令行参数&quot;&gt;&lt;a href=&quot;#一-终端命令</summary>
      
    
    
    
    
    <category term="cmake" scheme="http://okeyia.github.io/tags/cmake/"/>
    
    <category term="git代理" scheme="http://okeyia.github.io/tags/git%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>机房预约系统</title>
    <link href="http://okeyia.github.io/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://okeyia.github.io/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-29T15:16:08.000Z</published>
    <updated>2022-04-17T08:52:21.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机房预约系统"><a href="#机房预约系统" class="headerlink" title="./机房预约系统"></a>./机房预约系统</h1><h2 id="1、-机房预约系统需求"><a href="#1、-机房预约系统需求" class="headerlink" title="1、./机房预约系统需求"></a>1、./机房预约系统需求</h2><h3 id="1-1-系统简介"><a href="#1-1-系统简介" class="headerlink" title="1.1 系统简介"></a>1.1 系统简介</h3><ul><li>学校现有几个规格不同的机房，由于使用时经常出现”撞车”现象,现开发一套./机房预约系统，解决这一问题。</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682783885.png" class="" width="1548682783885"><h3 id="1-2-身份简介"><a href="#1-2-身份简介" class="headerlink" title="1.2 身份简介"></a>1.2 身份简介</h3><p>分别有三种身份使用该程序</p><ul><li><strong>学生代表</strong>：申请使用机房</li><li><strong>教师</strong>：审核学生的预约申请</li><li><strong>管理员</strong>：给学生、教师创建账号</li></ul><h3 id="1-3-机房简介"><a href="#1-3-机房简介" class="headerlink" title="1.3 机房简介"></a>1.3 机房简介</h3><p>机房总共有3间</p><ul><li>1号机房   — 最大容量20人</li><li>2号机房   — 最多容量50人</li><li>3号机房   — 最多容量100人</li></ul><h3 id="1-4-申请简介"><a href="#1-4-申请简介" class="headerlink" title="1.4 申请简介"></a>1.4 申请简介</h3><ul><li>申请的订单每周由管理员负责清空。</li><li>学生可以预约未来一周内的机房使用，预约的日期为周一至周五，预约时需要选择预约时段（上午、下午）</li><li>教师来审核预约，依据实际情况审核预约通过或者不通过</li></ul><h3 id="1-5-系统具体需求"><a href="#1-5-系统具体需求" class="headerlink" title="1.5 系统具体需求"></a>1.5 系统具体需求</h3><ul><li>首先进入登录界面，可选登录身份有：<ul><li>学生代表</li><li>老师</li><li>管理员</li><li>退出</li></ul></li><li>每个身份都需要进行验证后，进入子菜单<ul><li>学生需要输入 ：学号、姓名、登录密码</li><li>老师需要输入：职工号、姓名、登录密码</li><li>管理员需要输入：管理员姓名、登录密码</li></ul></li><li>学生具体功能<ul><li>申请预约    —   预约机房</li><li>查看自身的预约    —  查看自己的预约状态</li><li>查看所有预约   —   查看全部预约信息以及预约状态</li><li>取消预约    —   取消自身的预约，预约成功或审核中的预约均可取消</li><li>注销登录    —   退出登录</li></ul></li><li>教师具体功能<ul><li>查看所有预约   —   查看全部预约信息以及预约状态</li><li>审核预约    —   对学生的预约进行审核</li><li>注销登录    —   退出登录</li></ul></li><li>管理员具体功能<ul><li>添加账号    —   添加学生或教师的账号，需要检测学生编号或教师职工号是否重复</li><li>查看账号    —   可以选择查看学生或教师的全部信息</li><li>查看机房    —   查看所有机房的信息</li><li>清空预约    —   清空所有预约记录</li><li>注销登录    —   退出登录</li></ul></li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682206670.png" class="" width="1548682206670"><h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p><ul><li>创建新项目</li><li>添加文件</li></ul><h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><ul><li>打开vs2017后，点击创建新项目，创建新的C++项目</li></ul><p>如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682413343.png" class="" width="1548682413343"><ul><li>填写项目名称以及选取项目路径，点击确定生成项目</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682522544.png" class="" width="1548682522544"><h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><ul><li>右键源文件，进行添加文件操作</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682597721.png" class="" width="1548682597721"><ul><li>填写文件名称，点击添加</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682679989.png" class="" width="1548682679989"><ul><li>生成文件成功，效果如下图</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682733912.png" class="" width="1548682733912"><h2 id="3、创建主菜单"><a href="#3、创建主菜单" class="headerlink" title="3、创建主菜单"></a>3、创建主菜单</h2><p><strong>功能描述：</strong></p><ul><li>设计主菜单，与用户进行交互</li></ul><h3 id="3-1-菜单实现"><a href="#3-1-菜单实现" class="headerlink" title="3.1 菜单实现"></a>3.1 菜单实现</h3><ul><li>在主函数main中添加菜单提示，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客./机房预约系统  =====================&quot;</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548557945611.png" class="" width="1548557945611"><h3 id="3-2-搭建接口"><a href="#3-2-搭建接口" class="headerlink" title="3.2 搭建接口"></a>3.2 搭建接口</h3><ul><li>接受用户的选择，搭建接口</li><li>在main中添加代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客./机房预约系统  =====================&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select; <span class="comment">//接受用户选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (select)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//学生身份</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//老师身份</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//管理员身份</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出系统</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新选择！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，输入0、1、2、3会重新回到界面，输入其他提示输入有误，清屏后重新选择</p><p>效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548558694230.png" class="" width="1548558694230"><p>至此，界面搭建完毕</p><h2 id="4、-退出功能实现"><a href="#4、-退出功能实现" class="headerlink" title="4、 退出功能实现"></a>4、 退出功能实现</h2><h3 id="4-1-退出功能实现"><a href="#4-1-退出功能实现" class="headerlink" title="4.1 退出功能实现"></a>4.1 退出功能实现</h3><p>在main函数分支 0 选项中，添加退出程序的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎下一次使用&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548558992754.png" class="" width="1548558992754"><h3 id="4-2-测试退出功能"><a href="#4-2-测试退出功能" class="headerlink" title="4.2 测试退出功能"></a>4.2 测试退出功能</h3><p>运行程序，效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548559026436.png" class="" width="1548559026436"><p>至此，退出程序功能实现</p><h2 id="5、-创建身份类"><a href="#5、-创建身份类" class="headerlink" title="5、 创建身份类"></a>5、 创建身份类</h2><h3 id="5-1-身份的基类"><a href="#5-1-身份的基类" class="headerlink" title="5.1 身份的基类"></a>5.1 身份的基类</h3><ul><li>在整个系统中，有三种身份，分别为：学生代表、老师以及管理员</li><li>三种身份有其共性也有其特性，因此我们可以将三种身份抽象出一个身份基类<strong>identity</strong></li><li>在头文件下创建Identity.h文件</li></ul><p>Identity.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//身份抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Identity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作菜单</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name; <span class="comment">//用户名</span></span><br><span class="line"><span class="built_in">string</span> m_Pwd;  <span class="comment">//密码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548573329273.png" class="" width="1548573329273"><h3 id="5-2-学生类"><a href="#5-2-学生类" class="headerlink" title="5.2 学生类"></a>5.2 学生类</h3><h4 id="5-2-1-功能分析"><a href="#5-2-1-功能分析" class="headerlink" title="5.2.1 功能分析"></a>5.2.1 功能分析</h4><ul><li><p>学生类主要功能是可以通过类中成员函数，实现预约实验室操作</p></li><li><p>学生类中主要功能有：</p><ul><li>显示学生操作的菜单界面</li><li>申请预约</li><li>查看自身预约</li><li>查看所有预约</li><li>取消预约</li></ul></li></ul><h4 id="5-2-2-类的创建"><a href="#5-2-2-类的创建" class="headerlink" title="5.2.2 类的创建"></a>5.2.2 类的创建</h4><ul><li>在头文件以及源文件下创建 student.h 和 student.cpp文件</li></ul><p>student.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生学号</span></span><br><span class="line"><span class="keyword">int</span> m_Id;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>student.cpp中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student::Student()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-老师类"><a href="#5-3-老师类" class="headerlink" title="5.3 老师类"></a>5.3 老师类</h3><h4 id="5-3-1-功能分析"><a href="#5-3-1-功能分析" class="headerlink" title="5.3.1 功能分析"></a>5.3.1 功能分析</h4><ul><li><p>教师类主要功能是查看学生的预约，并进行审核</p></li><li><p>教师类中主要功能有：</p><ul><li><p>显示教师操作的菜单界面</p></li><li><p>查看所有预约</p></li><li><p>审核预约</p></li></ul></li></ul><h4 id="5-3-2-类的创建"><a href="#5-3-2-类的创建" class="headerlink" title="5.3.2 类的创建"></a>5.3.2 类的创建</h4><ul><li>在头文件以及源文件下创建 teacher.h 和 teacher.cpp文件</li></ul><p>teacher.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_EmpId; <span class="comment">//教师编号</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>teacher.cpp中添加如下代码:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;teacher.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher::Teacher()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-管理员类"><a href="#5-4-管理员类" class="headerlink" title="5.4 管理员类"></a>5.4 管理员类</h3><h4 id="5-4-1-功能分析"><a href="#5-4-1-功能分析" class="headerlink" title="5.4.1 功能分析"></a>5.4.1 功能分析</h4><ul><li><p>管理员类主要功能是对学生和老师账户进行管理，查看机房信息以及清空预约记录</p></li><li><p>管理员类中主要功能有：</p><ul><li><p>显示管理员操作的菜单界面</p></li><li><p>添加账号</p></li><li><p>查看账号</p></li><li><p>查看机房信息</p></li><li><p>清空预约记录</p></li></ul></li></ul><h4 id="5-4-2-类的创建"><a href="#5-4-2-类的创建" class="headerlink" title="5.4.2 类的创建"></a>5.4.2 类的创建</h4><ul><li>在头文件以及源文件下创建 manager.h 和 manager.cpp文件</li></ul><p>manager.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造  管理员姓名，密码</span></span><br><span class="line">Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showComputer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>manager.cpp中添加如下代码:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager::Manager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，所有身份类创建完毕，效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548574390768.png" class="" width="1548574390768"><h2 id="6、-登录模块"><a href="#6、-登录模块" class="headerlink" title="6、  登录模块"></a>6、  登录模块</h2><h3 id="6-1-全局文件添加"><a href="#6-1-全局文件添加" class="headerlink" title="6.1 全局文件添加"></a>6.1 全局文件添加</h3><p>功能描述：</p><ul><li>不同的身份可能会用到不同的文件操作，我们可以将所有的文件名定义到一个全局的文件中</li><li>在头文件中添加 <strong>globalFile.h</strong> 文件</li><li>并添加如下代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理员文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADMIN_FILE     <span class="meta-string">&quot;admin.txt&quot;</span></span></span><br><span class="line"><span class="comment">//学生文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENT_FILE   <span class="meta-string">&quot;student.txt&quot;</span></span></span><br><span class="line"><span class="comment">//教师文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEACHER_FILE   <span class="meta-string">&quot;teacher.txt&quot;</span></span></span><br><span class="line"><span class="comment">//机房信息文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPUTER_FILE  <span class="meta-string">&quot;computerRoom.txt&quot;</span></span></span><br><span class="line"><span class="comment">//订单文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORDER_FILE     <span class="meta-string">&quot;order.txt&quot;</span></span></span><br></pre></td></tr></table></figure><p>并且在同级目录下，创建这几个文件</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548575650130.png" class="" width="1548575650130"><h3 id="6-2-登录函数封装"><a href="#6-2-登录函数封装" class="headerlink" title="6.2  登录函数封装"></a>6.2  登录函数封装</h3><p>功能描述：</p><ul><li>根据用户的选择，进入不同的身份登录</li></ul><p>在预约系统的.cpp文件中添加全局函数 <code>void LoginIn(string fileName, int type)</code></p><p>参数：</p><ul><li>fileName  — 操作的文件名</li><li>type      —  登录的身份  （1代表学生、2代表老师、3代表管理员）</li></ul><p>LoginIn中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//登录功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoginIn</span><span class="params">(<span class="built_in">string</span> fileName, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Identity * person = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(fileName, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件不存在情况</span></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)<span class="comment">//学生登录</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你的学号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="comment">//教师登录</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你的职工号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入用户名：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//学生登录验证</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//教师登录验证</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//管理员登录验证</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;验证登录失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在main函数的不同分支中，填入不同的登录接口</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548575945985.png" class="" width="1548575945985"><h3 id="6-3-学生登录实现"><a href="#6-3-学生登录实现" class="headerlink" title="6.3 学生登录实现"></a>6.3 学生登录实现</h3><p>在student.txt文件中添加两条学生信息，用于测试</p><p>添加信息:   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 张三 <span class="number">123</span></span><br><span class="line"><span class="number">2</span> 李四 <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>第一列  代表  <strong>学号</strong></li><li>第二列  代表  <strong>学生姓名</strong></li><li>第三列  代表  <strong>密码</strong></li></ul><p>效果图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583693555.png" class="" width="1548583693555"><p>在Login函数的学生分支中加入如下代码，验证学生身份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生登录验证</span></span><br><span class="line"><span class="keyword">int</span> fId;</span><br><span class="line"><span class="built_in">string</span> fName;</span><br><span class="line"><span class="built_in">string</span> fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;学生验证登录成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">person = <span class="keyword">new</span> Student(id, name, pwd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加代码效果图</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583915819.png" class="" width="1548583915819"><p>测试：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583950828.png" class="" width="1548583950828"><h3 id="6-4-教师登录实现"><a href="#6-4-教师登录实现" class="headerlink" title="6.4 教师登录实现"></a>6.4 教师登录实现</h3><p>在teacher.txt文件中添加一条老师信息，用于测试</p><p>添加信息:   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 老王 <span class="number">123</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>第一列  代表  <strong>教师职工编号</strong></li><li>第二列  代表  <strong>教师姓名</strong></li><li>第三列  代表  <strong>密码</strong></li></ul><p>效果图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584030522.png" class="" width="1548584030522"><p>在Login函数的教师分支中加入如下代码，验证教师身份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//教师登录验证</span></span><br><span class="line"><span class="keyword">int</span> fId;</span><br><span class="line"><span class="built_in">string</span> fName;</span><br><span class="line"><span class="built_in">string</span> fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;教师验证登录成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">person = <span class="keyword">new</span> Teacher(id, name, pwd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加代码效果图</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584158339.png" class="" width="1548584158339"><p>测试：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584177003.png" class="" width="1548584177003"><h3 id="6-5-管理员登录实现"><a href="#6-5-管理员登录实现" class="headerlink" title="6.5 管理员登录实现"></a>6.5 管理员登录实现</h3><p>在admin.txt文件中添加一条管理员信息，由于我们只有一条管理员，因此本案例中没有添加管理员的功能</p><p>添加信息:   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin <span class="number">123</span></span><br></pre></td></tr></table></figure><p>其中：<code>admin</code>代表管理员用户名，<code>123</code>代表管理员密码</p><p>效果图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548577855190.png" class="" width="1548577855190"><p>在Login函数的管理员分支中加入如下代码，验证管理员身份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理员登录验证</span></span><br><span class="line"><span class="built_in">string</span> fName;</span><br><span class="line"><span class="built_in">string</span> fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;验证登录成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//登录成功后，按任意键进入管理员界面</span></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="comment">//创建管理员对象</span></span><br><span class="line">person = <span class="keyword">new</span> Manager(name,pwd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548588322712.png" class="" width="1548588322712"><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583245072.png" class="" width="1548583245072"><p>至此，所有身份的登录功能全部实现！</p><h2 id="7、-管理员模块"><a href="#7、-管理员模块" class="headerlink" title="7、 管理员模块"></a>7、 管理员模块</h2><h3 id="7-1-管理员登录和注销"><a href="#7-1-管理员登录和注销" class="headerlink" title="7.1  管理员登录和注销"></a>7.1  管理员登录和注销</h3><h4 id="7-1-1-构造函数"><a href="#7-1-1-构造函数" class="headerlink" title="7.1.1 构造函数"></a>7.1.1 构造函数</h4><ul><li>在Manager类的构造函数中，初始化管理员信息，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-2-管理员子菜单"><a href="#7-1-2-管理员子菜单" class="headerlink" title="7.1.2  管理员子菜单"></a>7.1.2  管理员子菜单</h4><ul><li>在./机房预约系统.cpp中，当用户登录的是管理员，添加管理员菜单接口</li><li>将不同的分支提供出来<ul><li>添加账号</li><li>查看账号</li><li>查看机房</li><li>清空预约</li><li>注销登录</li></ul></li><li>实现注销功能</li></ul><p>添加全局函数 <code>void managerMenu(Identity * &amp;manager)</code>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理员菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">managerMenu</span><span class="params">(Identity * &amp;manager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//管理员菜单</span></span><br><span class="line">manager-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Manager* man = (Manager*)manager;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)  <span class="comment">//添加账号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;添加账号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;addPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看账号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查看账号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;showPerson(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看机房</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查看机房&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;showComputer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//清空预约</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;清空预约&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;cleanFile();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> manager;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-3-菜单功能实现"><a href="#7-1-3-菜单功能实现" class="headerlink" title="7.1.3 菜单功能实现"></a>7.1.3 菜单功能实现</h4><ul><li>在实现成员函数<code>void Manager::operMenu()</code> 代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎管理员：&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.添加账号            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.查看账号            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.查看机房            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          4.清空预约            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-4-接口对接"><a href="#7-1-4-接口对接" class="headerlink" title="7.1.4 接口对接"></a>7.1.4 接口对接</h4><ul><li>管理员成功登录后，调用管理员子菜单界面</li><li>在管理员登录验证分支中，添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入管理员子菜单</span></span><br><span class="line">managerMenu(person);</span><br></pre></td></tr></table></figure><p>添加效果如：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589297779.png" class="" width="1548589297779"><p>测试对接，效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589344206.png" class="" width="1548589344206"><p>登录成功</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589328710.png" class="" width="1548589328710"><p>注销登录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589416576.png" class="" width="1548589416576"><p>至此，管理员身份可以成功登录以及注销</p><h3 id="7-2-添加账号"><a href="#7-2-添加账号" class="headerlink" title="7.2 添加账号"></a>7.2 添加账号</h3><p>功能描述：</p><ul><li>给学生或教师添加新的账号</li></ul><p>功能要求：</p><ul><li>添加时学生学号不能重复、教师职工号不能重复</li></ul><h4 id="7-2-1-添加功能实现"><a href="#7-2-1-添加功能实现" class="headerlink" title="7.2.1 添加功能实现"></a>7.2.1 添加功能实现</h4><p>在Manager的<strong>addPerson</strong>成员函数中，实现添加新账号功能，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入添加账号的类型&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、添加学生&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、添加老师&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fileName;</span><br><span class="line"><span class="built_in">string</span> tip;</span><br><span class="line">ofstream ofs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fileName = STUDENT_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fileName = TEACHER_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofs.open(fileName, ios::out | ios::app);</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;tip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入姓名： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pwd &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;添加成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试添加学生：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641024216.png" class="" width="1548641024216"><p>成功在学生文件中添加了一条信息</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641141027.png" class="" width="1548641141027"><p>测试添加教师：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641195834.png" class="" width="1548641195834"><p>成功在教师文件中添加了一条信息</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641237513.png" class="" width="1548641237513"><h4 id="7-2-2-去重操作"><a href="#7-2-2-去重操作" class="headerlink" title="7.2.2 去重操作"></a>7.2.2 去重操作</h4><p>功能描述：添加新账号时，如果是重复的学生编号，或是重复的教师职工编号，提示有误</p><h5 id="7-2-2-1-读取信息"><a href="#7-2-2-1-读取信息" class="headerlink" title="7.2.2.1 读取信息"></a>7.2.2.1 读取信息</h5><ul><li>要去除重复的账号，首先要先将学生和教师的账号信息获取到程序中，方可检测</li><li>在manager.h中，添加两个容器，用于存放学生和教师的信息</li><li>添加一个新的成员函数  <code>void initVector()</code> 初始化容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initVector</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; vStu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Teacher&gt; vTea;</span><br></pre></td></tr></table></figure><p>添加位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644354561.png" class="" width="1548644354561"><p>在Manager的有参构造函数中，获取目前的学生和教师信息</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::initVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取学生文件中信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(STUDENT_FILE, ios::in);</span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件读取失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">vStu.clear();</span><br><span class="line">     vTea.clear();</span><br><span class="line">    </span><br><span class="line">Student s;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; s.m_Id &amp;&amp; ifs &gt;&gt; s.m_Name &amp;&amp;  ifs &gt;&gt; s.m_Pwd)</span><br><span class="line">&#123;</span><br><span class="line">vStu.push_back(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前学生数量为： &quot;</span> &lt;&lt; vStu.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ifs.close(); <span class="comment">//学生初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取老师文件信息</span></span><br><span class="line">ifs.open(TEACHER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">Teacher t;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; t.m_EmpId &amp;&amp; ifs &gt;&gt; t.m_Name &amp;&amp;  ifs &gt;&gt; t.m_Pwd)</span><br><span class="line">&#123;</span><br><span class="line">vTea.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前教师数量为： &quot;</span> &lt;&lt; vTea.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有参构造函数中，调用初始化容器函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initVector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，运行代码可以看到测试代码获取当前学生和教师数量</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548642488049.png" class="" width="1548642488049"><h5 id="7-2-2-2-去重函数封装"><a href="#7-2-2-2-去重函数封装" class="headerlink" title="7.2.2.2 去重函数封装"></a>7.2.2.2 去重函数封装</h5><p>在manager.h文件中添加成员函数<code> bool checkRepeat(int id, int type);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测重复 参数:(传入id，传入类型) 返回值：(true 代表有重复，false代表没有重复)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkRepeat</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><p>在manager.cpp文件中实现成员函数  <code> bool checkRepeat(int id, int type);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Manager::checkRepeat</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = vStu.begin(); it != vStu.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == it-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Teacher&gt;::iterator it = vTea.begin(); it != vTea.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == it-&gt;m_EmpId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-2-3-添加去重操作"><a href="#7-2-2-3-添加去重操作" class="headerlink" title="7.2.2.3 添加去重操作"></a>7.2.2.3 添加去重操作</h5><p>在添加学生编号或者教师职工号时，检测是否有重复，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> errorTip; <span class="comment">//重复错误提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fileName = STUDENT_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">errorTip = <span class="string">&quot;学号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fileName = TEACHER_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">errorTip = <span class="string">&quot;职工号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">ofs.open(fileName, ios::out | ios::app);</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;tip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ret = <span class="keyword">this</span>-&gt;checkRepeat(id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret) <span class="comment">//有重复</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; errorTip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548643909979.png" class="" width="1548643909979"><p>检测效果：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644151974.png" class="" width="1548644151974"><h5 id="7-2-2-4-bug解决"><a href="#7-2-2-4-bug解决" class="headerlink" title="7.2.2.4 bug解决"></a>7.2.2.4 bug解决</h5><p>bug描述：</p><ul><li>虽然可以检测重复的账号，但是刚添加的账号由于没有更新到容器中，因此不会做检测</li><li>导致刚加入的账号的学生号或者职工编号，再次添加时依然可以重复</li></ul><p>解决方案：</p><ul><li>在每次添加新账号时，重新初始化容器</li></ul><p>在添加完毕后，加入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initVector();</span><br></pre></td></tr></table></figure><p>位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644779578.png" class="" width="1548644779578"><p>再次测试，刚加入的账号不会重复添加了！</p><h3 id="7-3-显示账号"><a href="#7-3-显示账号" class="headerlink" title="7.3  显示账号"></a>7.3  显示账号</h3><p>功能描述：显示学生信息或教师信息</p><h4 id="7-3-1-显示功能实现"><a href="#7-3-1-显示功能实现" class="headerlink" title="7.3.1 显示功能实现"></a>7.3.1 显示功能实现</h4><p>在Manager的<strong>showPerson</strong>成员函数中，实现显示账号功能，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;学号： &quot;</span> &lt;&lt; s.m_Id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; s.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; s.m_Pwd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTeacher</span><span class="params">(Teacher &amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;职工号： &quot;</span> &lt;&lt; t.m_EmpId &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; t.m_Pwd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择查看内容：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、查看所有学生&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、查看所有老师&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;所有学生信息如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(vStu.begin(), vStu.end(), printStudent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;所有老师信息如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(vTea.begin(), vTea.end(), printTeacher);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-2-测试"><a href="#7-3-2-测试" class="headerlink" title="7.3.2 测试"></a>7.3.2 测试</h4><p>测试查看学生效果</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548646791248.png" class="" width="1548646791248"><p>测试查看教师效果</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548646833665.png" class="" width="1548646833665"><p>至此，显示账号功能实现完毕</p><h3 id="7-4-查看机房"><a href="#7-4-查看机房" class="headerlink" title="7.4 查看机房"></a>7.4 查看机房</h3><h4 id="7-4-1-添加机房信息"><a href="#7-4-1-添加机房信息" class="headerlink" title="7.4.1 添加机房信息"></a>7.4.1 添加机房信息</h4><p>案例需求中，机房一共有三个，其中1号机房容量20台机器，2号50台，3号100台</p><p>我们可以将信息录入到computerRoom.txt中</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548647538570.png" class="" width="1548647538570"><h4 id="7-4-2-机房类创建"><a href="#7-4-2-机房类创建" class="headerlink" title="7.4.2 机房类创建"></a>7.4.2 机房类创建</h4><p>在头文件下，创建新的文件 computerRoom.h</p><p>并添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//机房类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputerRoom</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_ComId; <span class="comment">//机房id号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_MaxNum; <span class="comment">//机房最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-4-3-初始化机房信息"><a href="#7-4-3-初始化机房信息" class="headerlink" title="7.4.3 初始化机房信息"></a>7.4.3 初始化机房信息</h4><p>在Manager管理员类下，添加机房的容器,用于保存机房信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure><p>在Manager有参构造函数中，追加如下代码，初始化机房信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line"></span><br><span class="line">ifs.open(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">vCom.push_back(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前机房数量为： &quot;</span> &lt;&lt; vCom.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure><p>位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548647976462.png" class="" width="1548647976462"><p>因为机房信息目前版本不会有所改动，如果后期有修改功能，最好封装到一个函数中，方便维护</p><h4 id="7-4-4-显示机房信息"><a href="#7-4-4-显示机房信息" class="headerlink" title="7.4.4 显示机房信息"></a>7.4.4 显示机房信息</h4><p>在Manager类的showComputer成员函数中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;机房信息如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;ComputerRoom&gt;::iterator it = vCom.begin(); it != vCom.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;机房编号： &quot;</span> &lt;&lt; it-&gt;m_ComId &lt;&lt; <span class="string">&quot; 机房最大容量： &quot;</span> &lt;&lt; it-&gt;m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试显示机房信息功能：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548648276929.png" class="" width="1548648276929"><h3 id="7-5-清空预约"><a href="#7-5-清空预约" class="headerlink" title="7.5 清空预约"></a>7.5 清空预约</h3><p>功能描述：</p><p>清空生成的<code>order.txt</code>预约文件</p><h4 id="7-5-1-清空功能实现"><a href="#7-5-1-清空功能实现" class="headerlink" title="7.5.1 清空功能实现"></a>7.5.1 清空功能实现</h4><p>在Manager的cleanFile成员函数中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::trunc)</span></span>;</span><br><span class="line">ofs.close();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试清空，可以随意写入一些信息在order.txt中，然后调用cleanFile清空文件接口，查看是否清空干净</p><h2 id="8、-学生模块"><a href="#8、-学生模块" class="headerlink" title="8、 学生模块"></a>8、 学生模块</h2><h3 id="8-1-学生登录和注销"><a href="#8-1-学生登录和注销" class="headerlink" title="8.1 学生登录和注销"></a>8.1 学生登录和注销</h3><h4 id="8-1-1-构造函数"><a href="#8-1-1-构造函数" class="headerlink" title="8.1.1 构造函数"></a>8.1.1 构造函数</h4><ul><li>在Student类的构造函数中，初始化学生信息，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-2-管理员子菜单"><a href="#8-1-2-管理员子菜单" class="headerlink" title="8.1.2  管理员子菜单"></a>8.1.2  管理员子菜单</h4><ul><li>在./机房预约系统.cpp中，当用户登录的是学生，添加学生菜单接口</li><li>将不同的分支提供出来<ul><li>申请预约</li><li>查看我的预约</li><li>查看所有预约</li><li>取消预约</li><li>注销登录</li></ul></li><li>实现注销功能</li></ul><p>添加全局函数 <code>void studentMenu(Identity * &amp;manager)</code> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">studentMenu</span><span class="params">(Identity * &amp;student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//学生菜单</span></span><br><span class="line">student-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Student* stu = (Student*)student;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//申请预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;applyOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看自身预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;showMyOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看所有预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;showAllOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//取消预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;cancelOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> student;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-3-菜单功能实现"><a href="#8-1-3-菜单功能实现" class="headerlink" title="8.1.3 菜单功能实现"></a>8.1.3 菜单功能实现</h4><ul><li>在实现成员函数<code>void Student::operMenu()</code> 代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎学生代表：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.申请预约              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.查看我的预约          |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.查看所有预约          |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          4.取消预约              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-4-接口对接"><a href="#8-1-4-接口对接" class="headerlink" title="8.1.4 接口对接"></a>8.1.4 接口对接</h4><ul><li>学生成功登录后，调用学生的子菜单界面</li><li>在学生登录分支中，添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入学生子菜单</span></span><br><span class="line">studentMenu(person);</span><br></pre></td></tr></table></figure><p>添加效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659552298.png" class="" width="1548659552298"><p>测试对接，效果如图：</p><p>登录验证通过：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659590221.png" class="" width="1548659590221"><p>学生子菜单：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659670651.png" class="" width="1548659670651"><p>注销登录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659682402.png" class="" width="1548659682402"><h3 id="8-2-申请预约"><a href="#8-2-申请预约" class="headerlink" title="8.2 申请预约"></a>8.2 申请预约</h3><h4 id="8-2-1-获取机房信息"><a href="#8-2-1-获取机房信息" class="headerlink" title="8.2.1 获取机房信息"></a>8.2.1 获取机房信息</h4><ul><li>在申请预约时，学生可以看到机房的信息，因此我们需要让学生获取到机房的信息</li></ul><p>在student.h中添加新的成员函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure><p>在学生的有参构造函数中追加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">vCom.push_back(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure><p>追加位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548661562158.png" class="" width="1548661562158"><p>至此，vCom容器中保存了所有机房的信息</p><h4 id="8-2-2-预约功能实现"><a href="#8-2-2-预约功能实现" class="headerlink" title="8.2.2 预约功能实现"></a>8.2.2 预约功能实现</h4><p>在student.cpp中实现成员函数 <code>void Student::applyOrder()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;机房开放时间为周一至周五！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入申请预约的时间：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、周一&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、周二&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3、周三&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4、周四&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5、周五&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> date = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> interval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> room = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line"><span class="keyword">if</span> (date &gt;= <span class="number">1</span> &amp;&amp; date &lt;= <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入申请预约的时间段：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、上午&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、下午&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; interval;</span><br><span class="line"><span class="keyword">if</span> (interval &gt;= <span class="number">1</span> &amp;&amp; interval &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择机房：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">0</span>].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">1</span>].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">2</span>].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; room;</span><br><span class="line"><span class="keyword">if</span> (room &gt;= <span class="number">1</span> &amp;&amp; room &lt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约成功！审核中&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::app)</span></span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; date &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; interval &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; room &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ofs.close();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，测试代码:</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548728936052.png" class="" width="1548728936052"><p>在order.txt文件中生成如下内容：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548662281801.png" class="" width="1548662281801"><h3 id="8-3-显示预约"><a href="#8-3-显示预约" class="headerlink" title="8.3 显示预约"></a>8.3 显示预约</h3><h4 id="8-3-1-创建预约类"><a href="#8-3-1-创建预约类" class="headerlink" title="8.3.1 创建预约类"></a>8.3.1 创建预约类</h4><p>功能描述：显示预约记录时，需要从文件中获取到所有记录，用来显示，创建预约的类来管理记录以及更新</p><p>在头文件以及源文件下分别创建<strong>orderFile.h</strong> 和 <strong>orderFile.cpp</strong>文件</p><p>orderFile.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">OrderFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录的容器  key --- 记录的条数  value --- 具体记录的键值对信息</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; m_orderData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预约记录条数</span></span><br><span class="line"><span class="keyword">int</span> m_Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong>中获取所有信息，并存放在容器中，添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">OrderFile::OrderFile()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(ORDER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> date;      <span class="comment">//日期</span></span><br><span class="line"><span class="built_in">string</span> interval;  <span class="comment">//时间段</span></span><br><span class="line"><span class="built_in">string</span> stuId;     <span class="comment">//学生编号</span></span><br><span class="line"><span class="built_in">string</span> stuName;   <span class="comment">//学生姓名</span></span><br><span class="line"><span class="built_in">string</span> roomId;    <span class="comment">//机房编号</span></span><br><span class="line"><span class="built_in">string</span> status;    <span class="comment">//预约状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>; <span class="comment">//预约记录个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; date &amp;&amp; ifs &gt;&gt; interval &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; roomId &amp;&amp;  ifs &gt;&gt; status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cout &lt;&lt; date &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; interval &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; stuId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; stuName &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; roomId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; status &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> key;</span><br><span class="line"><span class="built_in">string</span> value;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = date.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = date.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = date.substr(pos + <span class="number">1</span>, date.size() - pos <span class="number">-1</span>);</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = interval.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = interval.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = interval.substr(pos + <span class="number">1</span>, interval.size() - pos <span class="number">-1</span> );</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = stuId.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = stuId.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = stuId.substr(pos + <span class="number">1</span>, stuId.size() - pos <span class="number">-1</span> );</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = stuName.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = stuName.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = stuName.substr(pos + <span class="number">1</span>, stuName.size() - pos <span class="number">-1</span>);</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = roomId.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = roomId.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = roomId.substr(pos + <span class="number">1</span>, roomId.size() - pos <span class="number">-1</span> );</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = status.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = status.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = status.substr(pos + <span class="number">1</span>, status.size() - pos <span class="number">-1</span>);</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_orderData.insert(<span class="built_in">make_pair</span>(<span class="keyword">this</span>-&gt;m_Size, m));</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//for (map&lt;int, map&lt;string, string&gt;&gt;::iterator it = m_orderData.begin(); it != m_orderData.end();it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for (map&lt;string, string&gt;::iterator mit = it-&gt;second.begin(); mit != it-&gt;second.end(); mit++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; mit-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; mit-&gt;second &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更新预约记录的成员函数updateOrder代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OrderFile::updateOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::out | ios::trunc)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_Size;i++)</span><br><span class="line">&#123;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;date&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;interval&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuName&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;roomId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;status&quot;</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-2-显示自身预约"><a href="#8-3-2-显示自身预约" class="headerlink" title="8.3.2 显示自身预约"></a>8.3.2 显示自身预约</h4><p>首先我们先添加几条预约记录，可以用程序添加或者直接修改order.txt文件</p><p>order.txt文件内容如下： 比如我们有三名同学分别产生了3条预约记录</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667534747.png" class="" width="1548667534747"><p>在Student类的<code>void Student::showMyOrder()</code>成员函数中，添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (atoi(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].c_str()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667252474.png" class="" width="1548667252474"><h4 id="8-3-3-显示所有预约"><a href="#8-3-3-显示所有预约" class="headerlink" title="8.3.3 显示所有预约"></a>8.3.3 显示所有预约</h4><p>在Student类的<code>void Student::showAllOrder()</code>成员函数中，添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667591734.png" class="" width="1548667591734"><h3 id="8-4-取消预约"><a href="#8-4-取消预约" class="headerlink" title="8.4 取消预约"></a>8.4 取消预约</h3><p>在Student类的<code>void Student::cancelOrder()</code>成员函数中，添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;审核中或预约成功的记录可以取消，请输入取消的记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (atoi(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].c_str()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span> || of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  index ++  &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入取消的记录,0代表返回&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"><span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;记录所在位置： &quot; &lt;&lt; v[select - 1] &lt;&lt; endl;</span></span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">of.updateOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;已取消预约&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试取消预约：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669551036.png" class="" width="1548669551036"><p>再次查看个人预约记录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669728023.png" class="" width="1548669728023"><p>查看所有预约</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669753496.png" class="" width="1548669753496"><p>查看order.txt预约文件</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669798037.png" class="" width="1548669798037"><p>至此，学生模块功能全部实现</p><h2 id="9、-教师模块"><a href="#9、-教师模块" class="headerlink" title="9、 教师模块"></a>9、 教师模块</h2><h3 id="9-1-教师登录和注销"><a href="#9-1-教师登录和注销" class="headerlink" title="9.1 教师登录和注销"></a>9.1 教师登录和注销</h3><h4 id="9-1-1-构造函数"><a href="#9-1-1-构造函数" class="headerlink" title="9.1.1 构造函数"></a>9.1.1 构造函数</h4><ul><li>在Teacher类的构造函数中，初始化教师信息，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpId = empId;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-2-教师子菜单"><a href="#9-1-2-教师子菜单" class="headerlink" title="9.1.2  教师子菜单"></a>9.1.2  教师子菜单</h4><ul><li>在./机房预约系统.cpp中，当用户登录的是教师，添加教师菜单接口</li><li>将不同的分支提供出来<ul><li>查看所有预约</li><li>审核预约</li><li>注销登录</li></ul></li><li>实现注销功能</li></ul><p>添加全局函数 <code>void TeacherMenu(Person * &amp;manager)</code> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//教师菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TeacherMenu</span><span class="params">(Identity * &amp;teacher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//教师菜单</span></span><br><span class="line">teacher-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Teacher* tea = (Teacher*)teacher;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line">tea-&gt;showAllOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line">tea-&gt;validOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> teacher;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-3-菜单功能实现"><a href="#9-1-3-菜单功能实现" class="headerlink" title="9.1.3 菜单功能实现"></a>9.1.3 菜单功能实现</h4><ul><li>在实现成员函数<code>void Teacher::operMenu()</code> 代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//教师菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎教师：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.查看所有预约          |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.审核预约              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-4-接口对接"><a href="#9-1-4-接口对接" class="headerlink" title="9.1.4 接口对接"></a>9.1.4 接口对接</h4><ul><li>教师成功登录后，调用教师的子菜单界面</li><li>在教师登录分支中，添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入教师子菜单</span></span><br><span class="line">TeacherMenu(person);</span><br></pre></td></tr></table></figure><p>添加效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670866708.png" class="" width="1548670866708"><p>测试对接，效果如图：</p><p>登录验证通过：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670949885.png" class="" width="1548670949885"><p>教师子菜单：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670958602.png" class="" width="1548670958602"><p>注销登录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670966988.png" class="" width="1548670966988"><h3 id="9-2-查看所有预约"><a href="#9-2-查看所有预约" class="headerlink" title="9.2 查看所有预约"></a>9.2 查看所有预约</h3><h4 id="9-2-1-所有预约功能实现"><a href="#9-2-1-所有预约功能实现" class="headerlink" title="9.2.1 所有预约功能实现"></a>9.2.1 所有预约功能实现</h4><p>该功能与学生身份的查看所有预约功能相似，用于显示所有预约记录</p><p>在Teacher.cpp中实现成员函数 <code>void Teacher::showAllOrder()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-2-测试功能"><a href="#9-2-2-测试功能" class="headerlink" title="9.2.2 测试功能"></a>9.2.2 测试功能</h4><p>运行测试教师身份的查看所有预约功能</p><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548676922678.png" class="" width="1548676922678"><h3 id="9-3-审核预约"><a href="#9-3-审核预约" class="headerlink" title="9.3 审核预约"></a>9.3 审核预约</h3><h4 id="9-3-1-审核功能实现"><a href="#9-3-1-审核功能实现" class="headerlink" title="9.3.1 审核功能实现"></a>9.3.1 审核功能实现</h4><p>功能描述：教师审核学生的预约，依据实际情况审核预约</p><p>在Teacher.cpp中实现成员函数 <code>void Teacher::validOrder()</code></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;待审核的预约记录如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ++index &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入审核的预约记录,0代表返回&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"><span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入审核结果&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、通过&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、不通过&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">of.updateOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;审核完毕！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-2-测试审核预约"><a href="#9-3-2-测试审核预约" class="headerlink" title="9.3.2 测试审核预约"></a>9.3.2 测试审核预约</h4><p>测试 - 审核通过</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677286679.png" class="" width="1548677286679"><p>审核通过情况</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677383681.png" class="" width="1548677383681"><p>测试-审核未通过</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677402705.png" class="" width="1548677402705"><p>审核未通过情况：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677632792.png" class="" width="1548677632792"><p>学生身份下查看记录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677798815.png" class="" width="1548677798815"><p>审核预约成功！</p><p>至此本案例制作完毕！  <code>^_^</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机房预约系统&quot;&gt;&lt;a href=&quot;#机房预约系统&quot; class=&quot;headerlink&quot; title=&quot;./机房预约系统&quot;&gt;&lt;/a&gt;./机房预约系统&lt;/h1&gt;&lt;h2 id=&quot;1、-机房预约系统需求&quot;&gt;&lt;a href=&quot;#1、-机房预约系统需求&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>基于STL的演讲比赛流程管理系统</title>
    <link href="http://okeyia.github.io/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
    <id>http://okeyia.github.io/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-27T14:38:13.000Z</published>
    <updated>2022-04-17T08:52:41.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="演讲比赛流程管理系统"><a href="#演讲比赛流程管理系统" class="headerlink" title="演讲比赛流程管理系统"></a>演讲比赛流程管理系统</h1><h2 id="1、-演讲比赛程序需求"><a href="#1、-演讲比赛程序需求" class="headerlink" title="1、 演讲比赛程序需求"></a>1、 演讲比赛程序需求</h2><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154762048.png" class="" width="1548154762048"><h3 id="1-1-比赛规则"><a href="#1-1-比赛规则" class="headerlink" title="1.1 比赛规则"></a>1.1 比赛规则</h3><ul><li>学校举行一场演讲比赛，共有<strong>12个人</strong>参加。<strong>比赛共两轮</strong>，第一轮为淘汰赛，第二轮为决赛。</li><li>比赛方式：<strong>分组比赛，每组6个人</strong>；选手每次要随机分组，进行比赛</li><li>每名选手都有对应的<strong>编号</strong>，如 10001 ~ 10012 </li><li>第一轮分为两个小组，每组6个人。 整体按照选手编号进行<strong>抽签</strong>后顺序演讲。</li><li>当小组演讲完后，淘汰组内排名最后的三个选手，<strong>前三名晋级</strong>，进入下一轮的比赛。</li><li>第二轮为决赛，<strong>前三名胜出</strong></li><li>每轮比赛过后需要<strong>显示晋级选手的信息</strong></li></ul><h3 id="1-2-程序功能"><a href="#1-2-程序功能" class="headerlink" title="1.2 程序功能"></a>1.2 程序功能</h3><ul><li>开始演讲比赛：完成整届比赛的流程，每个比赛阶段需要给用户一个提示，用户按任意键后继续下一个阶段</li><li>查看往届记录：查看之前比赛前三名结果，每次比赛都会记录到文件中，文件用.csv后缀名保存</li><li>清空比赛记录：将文件中数据清空</li><li>退出比赛程序：可以退出当前程序</li></ul><h3 id="1-3-程序效果图："><a href="#1-3-程序效果图：" class="headerlink" title="1.3 程序效果图："></a>1.3 程序效果图：</h3><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548155966702.png" class="" width="1548155966702"><h2 id="2、-项目创建"><a href="#2、-项目创建" class="headerlink" title="2、 项目创建"></a>2、 项目创建</h2><p>创建项目步骤如下：</p><ul><li>创建新项目</li><li>添加文件</li></ul><h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><ul><li>打开vs2017后，点击创建新项目，创建新的C++项目</li></ul><p>如图：</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548121881969.png" class="" width="1548121881969"><ul><li>填写项目名称以及选取项目路径，点击确定生成项目</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122271773.png" class="" width="1548122271773"><h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><ul><li>右键源文件，进行添加文件操作</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122420253.png" class="" width="1548122420253"><ul><li>填写文件名称，点击添加</li></ul><ul><li>生成文件成功，效果如下图</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122619712.png" class="" width="1548122619712"><ul><li>至此，项目已创建完毕</li></ul><h2 id="3、-创建管理类"><a href="#3、-创建管理类" class="headerlink" title="3、 创建管理类"></a>3、 创建管理类</h2><p><strong>功能描述：</strong></p><ul><li>提供菜单界面与用户交互</li><li>对演讲比赛流程进行控制</li><li>与文件的读写交互</li></ul><h3 id="3-1创建文件"><a href="#3-1创建文件" class="headerlink" title="3.1创建文件"></a>3.1创建文件</h3><ul><li>在头文件和源文件的文件夹下分别创建speechManager.h 和 speechManager.cpp文件</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548123402593.png" class="" width="1548123402593"><h3 id="3-2-头文件实现"><a href="#3-2-头文件实现" class="headerlink" title="3.2 头文件实现"></a>3.2 头文件实现</h3><p>在speechManager.h中设计管理类</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演讲管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpeechManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">SpeechManager();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~SpeechManager();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-源文件实现"><a href="#3-3-源文件实现" class="headerlink" title="3.3 源文件实现"></a>3.3 源文件实现</h3><p>在speechManager.cpp中将构造和析构函数空实现补全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;speechManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SpeechManager::SpeechManager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SpeechManager::~SpeechManager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>至此演讲管理类以创建完毕</li></ul><h2 id="4、-菜单功能"><a href="#4、-菜单功能" class="headerlink" title="4、 菜单功能"></a>4、 菜单功能</h2><p>功能描述：与用户的沟通界面</p><h3 id="4-1-添加成员函数"><a href="#4-1-添加成员函数" class="headerlink" title="4.1 添加成员函数"></a>4.1 添加成员函数</h3><p>在管理类speechManager.h中添加成员函数  <code>void show_Menu();</code></p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548123942072.png" class="" width="1548123942072"><h3 id="4-2-菜单功能实现"><a href="#4-2-菜单功能实现" class="headerlink" title="4.2 菜单功能实现"></a>4.2 菜单功能实现</h3><ul><li>在管理类speechManager.cpp中实现 show_Menu()函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::show_Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  欢迎参加演讲比赛 ************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  1.开始演讲比赛  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  2.查看往届记录  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  3.清空比赛记录  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  0.退出比赛程序  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-测试菜单功能"><a href="#4-3-测试菜单功能" class="headerlink" title="4.3 测试菜单功能"></a>4.3 测试菜单功能</h3><ul><li>在演讲比赛流程管理系统.cpp中测试菜单功能</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;speechManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SpeechManager sm;</span><br><span class="line"></span><br><span class="line">sm.show_Menu();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行效果如图：</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548124599641.png" class="" width="1548124599641"><ul><li>菜单界面搭建完毕</li></ul><h2 id="5、-退出功能"><a href="#5、-退出功能" class="headerlink" title="5、 退出功能"></a>5、 退出功能</h2><h3 id="5-1-提供功能接口"><a href="#5-1-提供功能接口" class="headerlink" title="5.1  提供功能接口"></a>5.1  提供功能接口</h3><ul><li>在main函数中提供分支选择，提供每个功能接口</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SpeechManager sm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> choice = <span class="number">0</span>; <span class="comment">//用来存储用户的选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">sm.show_Menu();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入您的选择： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; choice; <span class="comment">// 接受用户的选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//开始比赛</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//查看记录</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//清空记录</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出系统</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>); <span class="comment">//清屏</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-实现退出功能"><a href="#5-2-实现退出功能" class="headerlink" title="5.2 实现退出功能"></a>5.2 实现退出功能</h3><p>在speechManager.h中提供退出系统的成员函数 <code>    void exitSystem();</code></p><p>在speechManager.cpp中提供具体的功能实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::exitSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3测试功能"><a href="#5-3测试功能" class="headerlink" title="5.3测试功能"></a>5.3测试功能</h3><p>在main函数分支 0  选项中，调用退出程序的接口</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548124853576.png" class="" width="1548124853576"><p>运行测试效果如图：</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548124888578.png" class="" width="1548124888578"><h2 id="6、演讲比赛功能"><a href="#6、演讲比赛功能" class="headerlink" title="6、演讲比赛功能"></a>6、演讲比赛功能</h2><h3 id="6-1-功能分析"><a href="#6-1-功能分析" class="headerlink" title="6.1 功能分析"></a>6.1 功能分析</h3><p>比赛流程分析：</p><p>抽签 → 开始演讲比赛 → 显示第一轮比赛结果 → </p><p>抽签 → 开始演讲比赛 → 显示前三名结果 → 保存分数</p><h3 id="6-2-创建选手类"><a href="#6-2-创建选手类" class="headerlink" title="6.2 创建选手类"></a>6.2 创建选手类</h3><ul><li>选手类中的属性包含：选手姓名、分数</li><li>头文件中创建 speaker.h文件，并添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speaker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">double</span> m_Score[<span class="number">2</span>]; <span class="comment">//分数  最多有两轮得分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-3-比赛"><a href="#6-3-比赛" class="headerlink" title="6.3 比赛"></a>6.3 比赛</h3><h4 id="6-3-1-成员属性添加"><a href="#6-3-1-成员属性添加" class="headerlink" title="6.3.1 成员属性添加"></a>6.3.1 成员属性添加</h4><ul><li>在speechManager.h中添加属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比赛选手 容器  12人</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一轮晋级容器  6人</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//胜利前三名容器  3人</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vVictory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放编号 以及对应的 具体选手 容器</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Speaker&gt; m_Speaker;</span><br></pre></td></tr></table></figure><h4 id="6-3-2-初始化属性"><a href="#6-3-2-初始化属性" class="headerlink" title="6.3.2 初始化属性"></a>6.3.2 初始化属性</h4><ul><li>在speechManager.h中提供开始比赛的的成员函数 <code>void initSpeech();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSpeech</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现<code>void initSpeech();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::initSpeech</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//容器保证为空</span></span><br><span class="line"><span class="keyword">this</span>-&gt;v1.clear();  </span><br><span class="line"><span class="keyword">this</span>-&gt;v2.clear();</span><br><span class="line"><span class="keyword">this</span>-&gt;vVictory.clear();</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Speaker.clear();</span><br><span class="line"><span class="comment">//初始化比赛轮数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Index = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SpeechManager构造函数中调用<code>void initSpeech();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SpeechManager::SpeechManager()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initSpeech();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-3-创建选手"><a href="#6-3-3-创建选手" class="headerlink" title="6.3.3 创建选手"></a>6.3.3 创建选手</h4><ul><li>在speechManager.h中提供开始比赛的的成员函数 <code>void createSpeaker();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化创建12名选手</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createSpeaker</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现<code>void createSpeaker();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::createSpeaker</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDEFGHIJKL&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nameSeed.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">Speaker sp;</span><br><span class="line">sp.m_Name = name;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">sp.m_Score[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12名选手编号</span></span><br><span class="line"><span class="keyword">this</span>-&gt;v1.push_back(i + <span class="number">10001</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选手编号 以及对应的选手 存放到map容器中</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Speaker.insert(<span class="built_in">make_pair</span>(i + <span class="number">10001</span>, sp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SpeechManager类的 构造函数中调用<code>void createSpeaker();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SpeechManager::SpeechManager()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initSpeech();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//创建选手</span></span><br><span class="line"><span class="keyword">this</span>-&gt;createSpeaker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试 在main函数中，可以在创建完管理对象后，使用下列代码测试12名选手初始状态</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Speaker&gt;::iterator it = sm.m_Speaker.begin(); it != sm.m_Speaker.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>  &lt;&lt; <span class="string">&quot;选手编号：&quot;</span> &lt;&lt; it-&gt;first </span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; it-&gt;second.m_Name </span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩： &quot;</span> &lt;&lt; it-&gt;second.m_Score[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548141605742.png" class="" width="1548141605742"><ul><li>测试效果如图：</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548141560164.png" class="" width="1548141560164"><ul><li>测试完毕后，可以将测试代码删除或注释。</li></ul><h4 id="6-3-4-开始比赛成员函数添加"><a href="#6-3-4-开始比赛成员函数添加" class="headerlink" title="6.3.4 开始比赛成员函数添加"></a>6.3.4 开始比赛成员函数添加</h4><ul><li>在speechManager.h中提供开始比赛的的成员函数 <code>void startSpeech();</code></li><li>该函数功能是主要控制比赛的流程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始比赛 - 比赛流程控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpeech</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中将startSpeech的空实现先写入</li><li>我们可以先将整个比赛的流程 写到函数中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始比赛</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::startSpeech</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一轮比赛</span></span><br><span class="line"><span class="comment">//1、抽签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、比赛</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、显示晋级结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二轮比赛</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、抽签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、比赛</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、显示最终结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、保存分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-3-5-抽签"><a href="#6-3-5-抽签" class="headerlink" title="6.3.5 抽签"></a>6.3.5 抽签</h4><p><strong>功能描述：</strong></p><ul><li>正式比赛前，所有选手的比赛顺序需要打乱，我们只需要将存放选手编号的容器  打乱次序即可</li></ul><ul><li>在speechManager.h中提供抽签的的成员函数 <code>void speechDraw();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽签</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speechDraw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void speechDraw();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::speechDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第 &lt;&lt; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot; &gt;&gt; 轮比赛选手正在抽签&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;抽签后演讲顺序如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">random_shuffle(v1.begin(), v1.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v1.begin(); it != v1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">random_shuffle(v2.begin(), v2.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v2.begin(); it != v2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在startSpeech比赛流程控制的函数中，调用抽签函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548143871202.png" class="" width="1548143871202"><ul><li>在main函数中，分支1选项中，调用开始比赛的接口</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548143543475.png" class="" width="1548143543475"><ul><li>测试</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548143610682.png" class="" width="1548143610682"><h4 id="6-3-6-开始比赛"><a href="#6-3-6-开始比赛" class="headerlink" title="6.3.6 开始比赛"></a>6.3.6 开始比赛</h4><ul><li>在speechManager.h中提供比赛的的成员函数 <code>void speechContest();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比赛</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speechContest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void speechContest();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::speechContest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------- 第&quot;</span>&lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮正式比赛开始：------------- &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; groupScore; <span class="comment">//临时容器，保存key分数 value 选手编号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录人员数，6个为1组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;v_Src;   <span class="comment">//比赛的人员容器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">v_Src = v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v_Src = v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有参赛选手</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v_Src.begin(); it != v_Src.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//评委打分</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt;d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> score = (rand() % <span class="number">401</span> + <span class="number">600</span>) / <span class="number">10.f</span>;  <span class="comment">// 600 ~ 1000</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; score &lt;&lt; &quot; &quot;;</span></span><br><span class="line">d.push_back(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(d.begin(), d.end(), greater&lt;<span class="keyword">double</span>&gt;());<span class="comment">//排序</span></span><br><span class="line">d.pop_front();<span class="comment">//去掉最高分</span></span><br><span class="line">d.pop_back();<span class="comment">//去掉最低分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> sum = accumulate(d.begin(), d.end(), <span class="number">0.0f</span>);<span class="comment">//获取总分</span></span><br><span class="line"><span class="keyword">double</span> avg = sum / (<span class="keyword">double</span>)d.size();<span class="comment">//获取平均分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个人平均分</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;编号： &quot; &lt;&lt; *it  &lt;&lt; &quot; 选手： &quot; &lt;&lt; this-&gt;m_Speaker[*it].m_Name &lt;&lt; &quot; 获取平均分为： &quot; &lt;&lt; avg &lt;&lt; endl;  //打印分数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Speaker[*it].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] = avg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6个人一组，用临时容器保存</span></span><br><span class="line">groupScore.insert(<span class="built_in">make_pair</span>(avg, *it));</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">6</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; num / <span class="number">6</span> &lt;&lt; <span class="string">&quot;小组比赛名次：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multimap</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = groupScore.begin(); it != groupScore.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;编号: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Speaker[it-&gt;second].m_Name &lt;&lt; <span class="string">&quot; 成绩： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Speaker[it-&gt;second].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//取前三名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multimap</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = groupScore.begin(); it != groupScore.end() &amp;&amp; count &lt; <span class="number">3</span>; it++, count++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back((*it).second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">vVictory.push_back((*it).second);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">groupScore.clear();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------- 第&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮比赛完毕  ------------- &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在startSpeech比赛流程控制的函数中，调用比赛函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548144491984.png" class="" width="1548144491984"><ul><li>再次运行代码，测试比赛</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548144765146.png" class="" width="1548144765146"><h4 id="6-3-7-显示比赛分数"><a href="#6-3-7-显示比赛分数" class="headerlink" title="6.3.7 显示比赛分数"></a>6.3.7 显示比赛分数</h4><ul><li>在speechManager.h中提供比赛的的成员函数 <code>void showScore();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示比赛结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showScore</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void  showScore();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::showScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------第&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮晋级选手信息如下：-----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">v = v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v = vVictory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;选手编号：&quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; m_Speaker[*it].m_Name &lt;&lt; <span class="string">&quot; 得分： &quot;</span> &lt;&lt; m_Speaker[*it].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;show_Menu(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在startSpeech比赛流程控制的函数中，调用显示比赛分数函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548146903960.png" class="" width="1548146903960"><ul><li>运行代码，测试效果</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548146961550.png" class="" width="1548146961550"><h4 id="6-3-8-第二轮比赛"><a href="#6-3-8-第二轮比赛" class="headerlink" title="6.3.8 第二轮比赛"></a>6.3.8 第二轮比赛</h4><p>第二轮比赛流程同第一轮，只是比赛的轮是+1，其余流程不变</p><ul><li>在startSpeech比赛流程控制的函数中，加入第二轮的流程</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548148593215.png" class="" width="1548148593215"><p>测试，将整个比赛流程都跑通</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548148536395.png" class="" width="1548148536395"><h3 id="6-4-保存分数"><a href="#6-4-保存分数" class="headerlink" title="6.4 保存分数"></a>6.4 保存分数</h3><p><strong>功能描述：</strong></p><ul><li>将每次演讲比赛的得分记录到文件中</li></ul><p><strong>功能实现：</strong></p><ul><li>在speechManager.h中添加保存记录的成员函数 <code>void saveRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveRecord</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void saveRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::saveRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(<span class="string">&quot;speech.csv&quot;</span>, ios::out | ios::app); <span class="comment">// 用输出的方式打开文件  -- 写文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将每个人数据写入到文件中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vVictory.begin(); it != vVictory.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">ofs &lt;&lt; *it &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">&lt;&lt; m_Speaker[*it].m_Score[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">ofs &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">ofs.close();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;记录已经保存&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在startSpeech比赛流程控制的函数中，最后调用保存记录分数函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548149937860.png" class="" width="1548149937860"><ul><li>测试，整个比赛完毕后记录保存情况</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548149912863.png" class="" width="1548149912863"><p>利用记事本打开文件 speech.csv，里面保存了前三名选手的编号以及得分</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548150047975.png" class="" width="1548150047975"><p>至此，整个演讲比赛功能制作完毕！</p><h2 id="7、-查看记录"><a href="#7、-查看记录" class="headerlink" title="7、 查看记录"></a>7、 查看记录</h2><h3 id="7-1-读取记录分数"><a href="#7-1-读取记录分数" class="headerlink" title="7.1 读取记录分数"></a>7.1 读取记录分数</h3><ul><li>在speechManager.h中添加保存记录的成员函数 <code>void loadRecord();</code></li><li>添加判断文件是否为空的标志  <code>bool fileIsEmpty;</code></li><li>添加往届记录的容器<code>map&lt;int, vector&lt;string&gt;&gt; m_Record;</code>   </li></ul><p>其中m_Record 中的key代表第几届，value记录具体的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadRecord</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件为空的标志</span></span><br><span class="line"><span class="keyword">bool</span> fileIsEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往届记录</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m_Record;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void loadRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::loadRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;speech.csv&quot;</span>, ios::in)</span></span>; <span class="comment">//输入流对象 读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ifs &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (ifs.eof())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件不为空</span></span><br><span class="line"><span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">ifs.putback(ch); <span class="comment">//读取的单个字符放回去</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; data &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos = data.find(<span class="string">&quot;,&quot;</span>, start); <span class="comment">//从0开始查找 &#x27;,&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//找不到break返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> tmp = data.substr(start, pos - start); <span class="comment">//找到了,进行分割 参数1 起始位置，参数2 截取长度</span></span><br><span class="line">v.push_back(tmp);</span><br><span class="line">start = pos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Record.insert(<span class="built_in">make_pair</span>(index, v));</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在SpeechManager构造函数中调用获取往届记录函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548151977242.png" class="" width="1548151977242"><h3 id="7-2-查看记录功能"><a href="#7-2-查看记录功能" class="headerlink" title="7.2 查看记录功能"></a>7.2 查看记录功能</h3><ul><li>在speechManager.h中添加保存记录的成员函数 <code>void showRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示往届得分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showRecord</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void showRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::showRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Record.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;届 &quot;</span> &lt;&lt;</span><br><span class="line"><span class="string">&quot;冠军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="string">&quot;亚军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">2</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">3</span>] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="string">&quot;季军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">4</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">5</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-测试功能"><a href="#7-3-测试功能" class="headerlink" title="7.3 测试功能"></a>7.3 测试功能</h3><p>在main函数分支 2  选项中，调用查看记录的接口</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548152359604.png" class="" width="1548152359604"><p>显示效果如图：（本次测试添加了4条记录）</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548152394715.png" class="" width="1548152394715"><h3 id="7-4-bug解决"><a href="#7-4-bug解决" class="headerlink" title="7.4 bug解决"></a>7.4 bug解决</h3><p>目前程序中有几处bug未解决：</p><ol><li>查看往届记录，若文件不存在或为空，并未提示</li></ol><p>解决方式：在showRecord函数中，开始判断文件状态并加以判断</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548152803116.png" class="" width="1548152803116"><ol start="2"><li>若记录为空或不存在，比完赛后依然提示记录为空</li></ol><p>解决方式：saveRecord中更新文件为空的标志</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548153005042.png" class="" width="1548153005042"><ol start="3"><li>比完赛后查不到本届比赛的记录，没有实时更新</li></ol><p>解决方式：比赛完毕后，所有数据重置</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548153319587.png" class="" width="1548153319587"><ol start="4"><li>在初始化时，没有初始化记录容器</li></ol><p>解决方式：initSpeech中添加 初始化记录容器</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154340974.png" class="" width="1548154340974"><ol start="5"><li>每次记录都是一样的</li></ol><p>解决方式：在main函数一开始 添加随机数种子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure><p>所有bug解决后 测试：</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548153571603.png" class="" width="1548153571603"><h2 id="8、-清空记录"><a href="#8、-清空记录" class="headerlink" title="8、 清空记录"></a>8、 清空记录</h2><h3 id="8-1-清空记录功能实现"><a href="#8-1-清空记录功能实现" class="headerlink" title="8.1 清空记录功能实现"></a>8.1 清空记录功能实现</h3><ul><li>在speechManager.h中添加保存记录的成员函数 <code>void clearRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearRecord</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void clearRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::clearRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;确认清空？&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、确认&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、返回&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打开模式 ios::trunc 如果存在删除文件并重新创建</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;speech.csv&quot;</span>, ios::trunc)</span></span>;</span><br><span class="line">ofs.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initSpeech();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建选手</span></span><br><span class="line"><span class="keyword">this</span>-&gt;createSpeaker();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取往届记录</span></span><br><span class="line"><span class="keyword">this</span>-&gt;loadRecord();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-测试清空"><a href="#8-2-测试清空" class="headerlink" title="8.2 测试清空"></a>8.2 测试清空</h3><p>在main函数分支 3  选项中，调用清空比赛记录的接口</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154674242.png" class="" width="1548154674242"><p>运行程序，测试清空记录：</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154004738.png" class="" width="1548154004738"><p>speech.csv中记录也为空</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154508831.png" class="" width="1548154508831"><ul><li>至此本案例结束！ <code>^_^</code></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;演讲比赛流程管理系统&quot;&gt;&lt;a href=&quot;#演讲比赛流程管理系统&quot; class=&quot;headerlink&quot; title=&quot;演讲比赛流程管理系统&quot;&gt;&lt;/a&gt;演讲比赛流程管理系统&lt;/h1&gt;&lt;h2 id=&quot;1、-演讲比赛程序需求&quot;&gt;&lt;a href=&quot;#1、-演讲比赛程序需</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>C++ 提高编程</title>
    <link href="http://okeyia.github.io/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/"/>
    <id>http://okeyia.github.io/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-24T14:35:40.000Z</published>
    <updated>2022-04-17T08:49:34.806Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C-提高编程"><a href="#C-提高编程" class="headerlink" title="C++提高编程"></a>C++提高编程</h1><ul><li>本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用</li></ul><h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p><p>例如生活中的模板</p><p>一寸照片模板：</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547105026929.png" class="" width="1547105026929"><p>PPT模板：</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547103297864.png" class="" width="1547103297864"><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547103359158.png" class="" width="1547103359158"><p>模板的特点：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul><li>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</li></ul><ul><li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li></ul><h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapDouble</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板实现交换</span></span><br><span class="line"><span class="comment">//1、自动类型推导</span></span><br><span class="line">mySwap(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、显示指定类型</span></span><br><span class="line">mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>函数模板利用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p><ul><li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li></ul><ul><li>模板必须要确定出T的数据类型，才可以使用</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mySwap(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line"><span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">&#123;</span><br><span class="line">mySwap(arr[max], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试char数组</span></span><br><span class="line"><span class="keyword">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="keyword">sizeof</span>(charArr) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">mySort(charArr, num);</span><br><span class="line">printArray(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试int数组</span></span><br><span class="line"><span class="keyword">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> num = <span class="keyword">sizeof</span>(intArr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">mySort(intArr, num);</span><br><span class="line">printArray(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：模板可以提高代码复用，需要熟练掌握</p><h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAdd01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myAdd01(a, c) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">myAdd02&lt;<span class="keyword">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p><h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line"><span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">myPrint(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">myPrint(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">myPrint(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p><h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p><ul><li>模板的通用性并不是万能的</li></ul><p><strong>例如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line"><span class="keyword">bool</span> ret = myCompare(a, b);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line"><span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line"><span class="keyword">bool</span> ret = myCompare(p1, p2);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul><h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul><p><strong>语法：</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;P1(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">P1.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">Person &lt;<span class="built_in">string</span> ,<span class="keyword">int</span>&gt;p(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>&gt; p(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul><h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.showPerson1(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.showPerson2(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyClass&lt;Person1&gt; m;</span><br><span class="line"></span><br><span class="line">m.fun1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式：</p><ol><li>指定传入的类型   — 直接显示对象的数据类型</li><li>参数模板化           — 将对象中的参数变为模板进行传递</li><li>整个类模板化       — 将这个对象类型 模板化进行传递</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">printPerson1(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.showPerson();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p.showPerson();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">printPerson3(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line">test03();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span><span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son2()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p><h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//成员函数类内声明</span></span><br><span class="line">Person(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::showPerson() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);</span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p><h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p><ul><li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li></ul><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p><strong>示例：</strong></p><p>person.hpp中代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::showPerson() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板分文件编写.cpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, int&gt; p(&quot;Tom&quot;, 10);</span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p><h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p><ul><li>掌握类模板配合友元函数的类内和类外实现</li></ul><p>全局函数类内实现 - 直接在类内声明友元即可</p><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">printPerson(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p><h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p><strong>示例：</strong></p><p>myArray.hpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">MyArray(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">MyArray(<span class="keyword">const</span> MyArray &amp; arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line"><span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">MyArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">T&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_back</span><span class="params">(<span class="keyword">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~MyArray()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line"><span class="keyword">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line"><span class="keyword">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类模板案例—数组类封装.cpp中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">array1.Push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">array2.Pop_back();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person() &#123;&#125; </span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personArr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">pArray.Push_back(p1);</span><br><span class="line">pArray.Push_back(p2);</span><br><span class="line">pArray.Push_back(p3);</span><br><span class="line">pArray.Push_back(p4);</span><br><span class="line">pArray.Push_back(p5);</span><br><span class="line"></span><br><span class="line">printPersonArray(pArray);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>能够利用所学知识点实现通用的数组</p><h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pBegin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.begin(), v.end(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">mName = name;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> mName;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(&amp;p1);</span><br><span class="line">v.push_back(&amp;p2);</span><br><span class="line">v.push_back(&amp;p3);</span><br><span class="line">v.push_back(&amp;p4);</span><br><span class="line">v.push_back(&amp;p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">Person * p = (*it);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">v2.push_back(i + <span class="number">2</span>);</span><br><span class="line">v3.push_back(i + <span class="number">3</span>);</span><br><span class="line">v4.push_back(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line">v.push_back(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p>*<em>string和char * 区别：*</em></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code>                          //创建一个空的字符串 例如: string str;<br>   <code>string(const char* s);</code>            //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line">str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line">str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3;</span><br><span class="line">str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str4;</span><br><span class="line">str4.assign(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str5;</span><br><span class="line">str5.assign(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str6;</span><br><span class="line">str6.assign(str5);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str7;</span><br><span class="line">str7.assign(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​    string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p><h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li><li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">str3.append(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">str3.append(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//str3.append(str2);</span></span><br><span class="line">str3.append(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = str1.find(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pos = str1.rfind(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">str1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = s1.compare(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li><li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">str.at(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 </li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.insert(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str.erase(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p><h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> subStr = str.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> pos = email.find(<span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> username = email.substr(<span class="number">0</span>, pos);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002.jpg" class="" title="说明: 2015-11-10_151152"><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v; </code>                            //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">v3.assign(v1.begin(), v1.end());</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">v4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                          //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​                              //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.resize(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.resize(<span class="number">5</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空  — empty</li><li>返回元素个数  — size</li><li>返回容器容量  — capacity</li><li>重新指定大小  —  resize</li></ul><h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.push_back(<span class="number">10</span>);</span><br><span class="line">v1.push_back(<span class="number">20</span>);</span><br><span class="line">v1.push_back(<span class="number">30</span>);</span><br><span class="line">v1.push_back(<span class="number">40</span>);</span><br><span class="line">v1.push_back(<span class="number">50</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.pop_back();</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.insert(v1.begin(), <span class="number">100</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">v1.insert(v1.begin(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.erase(v1.begin());</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.erase(v1.begin(), v1.end());</span><br><span class="line">v1.clear();</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插  — push_back</li><li>尾删  — pop_back</li><li>插入  — insert    (位置迭代器)</li><li>删除  — erase  （位置迭代器）</li><li>清空  —  clear  </li></ul><h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>       //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v1.swap(v2);</span><br><span class="line">printVector(v1);</span><br><span class="line">printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v.resize(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line">v.reserve(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">p = &amp;v[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547547642923.jpg" class="" title="说明: 2015-11-19_204101"><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547547896341.jpg" class="" title="clip_image002-1547547896341"><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li><li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d3(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d4 = d3;</span><br><span class="line">printDeque(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d3;</span><br><span class="line">d3.assign(d1.begin(), d1.end());</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d4;</span><br><span class="line">d4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printDeque(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="keyword">if</span> (d1.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//统计大小</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">d1.resize(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">d1.resize(<span class="number">5</span>);</span><br><span class="line">printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">d.pop_back();</span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">d.pop_front();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), <span class="number">1000</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2.push_back(<span class="number">1</span>);</span><br><span class="line">d2.push_back(<span class="number">2</span>);</span><br><span class="line">d2.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), d2.begin(), d2.end());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin(), d.end());</span><br><span class="line">d.clear();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    test03();</span><br><span class="line">    </span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —  push_back</li><li>尾删   —  pop_back</li><li>头插   —  push_front</li><li>头删   —  pop_front</li></ul><h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>      //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line">sort(d.begin(), d.end());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p><h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol><li>创建五名选手，放到vector中</li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name; <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createPerson</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">name += nameSeed[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">v.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> score = rand() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">d.push_back(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">sort(d.begin(), d.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除最高和最低分</span></span><br><span class="line">d.pop_back();</span><br><span class="line">d.pop_front();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取平均分</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span><br><span class="line">&#123;</span><br><span class="line">sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> avg = sum / d.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">it-&gt;m_Score = avg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showScore</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数种子</span></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建5名选手</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">createPerson(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、给5名选手打分</span></span><br><span class="line">setScore(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、显示最后得分</span></span><br><span class="line">showScore(v);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p><h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547604555425.jpg" class="" title="说明: 2015-11-15_195707"><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p><p>生活中的栈：</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002.png" class="" title="img"><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547605111510.jpg" class="" title="img"><h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top(); </code>                //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">s.push(<span class="number">10</span>);</span><br><span class="line">s.push(<span class="number">20</span>);</span><br><span class="line">s.push(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line"><span class="comment">//输出栈顶元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈   — push</li><li>出栈   — pop</li><li>返回栈顶   — top</li><li>判断栈是否为空   — empty</li><li>返回栈大小   — size</li></ul><h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547606475892.jpg" class="" title="说明: 2015-11-15_214429"><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p><p>生活中的队列：</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547606785041.png" class="" width="1547606785041"><h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front(); </code>                                  //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">q.push(p1);</span><br><span class="line">q.push(p2);</span><br><span class="line">q.push(p3);</span><br><span class="line">q.push(p4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="comment">//输出队头元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.front().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.front().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.back().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.back().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//弹出队头元素</span></span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入队   — push</li><li>出队   — pop</li><li>返回队头元素   — front</li><li>返回队尾元素   — back</li><li>判断队是否为空   — empty</li><li>返回队列大小   — size</li></ul><h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547608564071.jpg" class="" title="说明: 2015-11-15_225145"><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2(L1.begin(),L1.end());</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3(L2);</span><br><span class="line">printList(L3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L4(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li><li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2 = L1;</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">L3.assign(L2.begin(), L2.end());</span><br><span class="line">printList(L3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L4;</span><br><span class="line">L4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printList(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">L1.swap(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list赋值和交换操作能够灵活运用即可</p><h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size(); </code>                             //返回容器中元素的个数</p></li><li><p><code>empty(); </code>                           //判断容器是否为空</p></li><li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><pre><code>                                           //如果容器变短，则末尾超出容器长度的元素被删除。</code></pre></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">L1.resize(<span class="number">10</span>);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line">L1.resize(<span class="number">2</span>);</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">L.push_back(<span class="number">10</span>);</span><br><span class="line">L.push_back(<span class="number">20</span>);</span><br><span class="line">L.push_back(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">L.push_front(<span class="number">100</span>);</span><br><span class="line">L.push_front(<span class="number">200</span>);</span><br><span class="line">L.push_front(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">L.pop_back();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">L.pop_front();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L.begin();</span><br><span class="line">L.insert(++it, <span class="number">1000</span>);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">it = L.begin();</span><br><span class="line">L.erase(++it);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">printList(L);</span><br><span class="line">L.remove(<span class="number">10000</span>);</span><br><span class="line">printList(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">L.clear();</span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插   — push_back</li><li>尾删   — pop_back</li><li>头插   — push_front</li><li>头删   — pop_front</li><li>插入   — insert</li><li>删除   — erase</li><li>移除   — remove</li><li>清空   — clear</li></ul><h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code>        //返回第一个元素。</li><li><code>back();</code>         //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L1.begin();</span><br><span class="line"><span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素   — front</li><li>返回最后一个元素   — back</li></ul><h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code>   //反转链表</li><li><code>sort();</code>        //链表排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1 , <span class="keyword">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">L.push_back(<span class="number">90</span>);</span><br><span class="line">L.push_back(<span class="number">30</span>);</span><br><span class="line">L.push_back(<span class="number">20</span>);</span><br><span class="line">L.push_back(<span class="number">70</span>);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转容器的元素</span></span><br><span class="line">L.reverse();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">L.sort(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">L.sort(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>反转   — reverse</li><li>排序   — sort （成员函数）</li></ul><h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age , <span class="keyword">int</span> height) &#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">m_Height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="keyword">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line"><span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">L.push_back(p1);</span><br><span class="line">L.push_back(p2);</span><br><span class="line">L.push_back(p3);</span><br><span class="line">L.push_back(p4);</span><br><span class="line">L.push_back(p5);</span><br><span class="line">L.push_back(p6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">L.sort(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li></ul><ul><li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li></ul><h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li><li><code>set(const set &amp;st);</code>       //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s2(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s3;</span><br><span class="line">s3 = s2;</span><br><span class="line">printSet(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.insert(<span class="number">100</span>);</span><br><span class="line">s2.insert(<span class="number">300</span>);</span><br><span class="line">s2.insert(<span class="number">200</span>);</span><br><span class="line">s2.insert(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s1.swap(s2);</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">s1.erase(s1.begin());</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">s1.erase(<span class="number">30</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">s1.clear();</span><br><span class="line">printSet(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入   — insert</li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.find(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != s1.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="keyword">int</span> num = s1.count(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于set，结果为0或者1）</li></ul><h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt;  ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//multiset</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">ms.insert(<span class="number">10</span>);</span><br><span class="line">ms.insert(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>   set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序规则</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>,MyCompare&gt; s2;</span><br><span class="line">s2.insert(<span class="number">10</span>);</span><br><span class="line">s2.insert(<span class="number">40</span>);</span><br><span class="line">s2.insert(<span class="number">20</span>);</span><br><span class="line">s2.insert(<span class="number">30</span>);</span><br><span class="line">s2.insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line"><span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2(m); <span class="comment">//拷贝构造</span></span><br><span class="line">printMap(m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m3;</span><br><span class="line">m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">printMap(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printMap(m);</span><br><span class="line">printMap(m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">m.swap(m2);</span><br><span class="line">printMap(m);</span><br><span class="line">printMap(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="comment">//第一种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种插入方式</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.erase(m.begin());</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line">m.erase(<span class="number">3</span>);</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.erase(m.begin(),m.end());</span><br><span class="line">m.clear();</span><br><span class="line">printMap(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li></ul><ul><li>插入   — insert </li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m; </span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.find(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != m.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="keyword">int</span> num = m.count(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于map，结果为0或者1）</li></ul><h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//默认从小到大排序</span></span><br><span class="line"><span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createWorker</span><span class="params">(<span class="built_in">vector</span>&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Worker worker;</span><br><span class="line">worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">worker.m_Salary = rand() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line"><span class="comment">//将员工放入到容器中</span></span><br><span class="line">v.push_back(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGroup</span><span class="params">(<span class="built_in">vector</span>&lt;Worker&gt;&amp;v,<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//产生随机部门编号</span></span><br><span class="line"><span class="keyword">int</span> deptId = rand() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将员工插入到分组中</span></span><br><span class="line"><span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showWorkerByGourp</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;::iterator pos = m.find(CEHUA);</span><br><span class="line"><span class="keyword">int</span> count = m.count(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pos = m.find(MEISHU);</span><br><span class="line">count = m.count(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pos = m.find(YANFA);</span><br><span class="line">count = m.count(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建员工</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Worker&gt;vWorker;</span><br><span class="line">createWorker(vWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、员工分组</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, Worker&gt;mWorker;</span><br><span class="line">setGroup(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、分组显示员工</span></span><br><span class="line">showWorkerByGourp(mWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">////测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul><h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd myAdd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myAdd(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyPrint()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">count++; <span class="comment">//统计使用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , <span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">doPrint(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line">test03();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">sort(v.begin(), v.end(), MyCompare());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n(<span class="number">50</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现仿函数</span></span><br><span class="line"><span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line"><span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v.begin();it!= v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">v2.resize(v.size());</span><br><span class="line">transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.begin(); it != v2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：逻辑仿函数实际应用较少，了解即可</p><h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li></ul><ul><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li></ul><h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code>     //遍历容器</li><li><code>transform</code>   //搬运容器到另一个容器中</li></ul><h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);  </code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.begin(), v.end(), print01);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), print02());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">vTarget.resize(v.size()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">transform(v.begin(), v.end(), vTarget.begin(), TransForm());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), MyPrint());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     //查找元素</li><li><code>find_if</code>               //按条件查找元素</li><li><code>adjacent_find</code>    //查找相邻重复元素</li><li><code>binary_search</code>    //二分查找法</li><li><code>count</code>                   //统计元素个数</li><li><code>count_if</code>             //按条件统计元素个数</li></ul><h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(v.begin(), v.end(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());</span><br><span class="line"><span class="keyword">if</span> (it == v.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);  </code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相邻重复元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = adjacent_find(v.begin(), v.end());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p><p>// 查找指定的元素，查到 返回true  否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">bool</span> ret = binary_search(v.begin(), v.end(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);  </code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.begin(), v.end(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.begin(), v.end(), p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.begin(), v.end(), Greater4());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.begin(), v.end(), AgeLess35());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p><h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code>             //对容器内元素进行排序</li><li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li><li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code>       // 反转指定范围的元素</li></ul><h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//  beg    开始迭代器</p><p>//  end    结束迭代器</p><p>// _Pred  谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort默认从小到大排序</span></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌   指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);  </code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打乱顺序</span></span><br><span class="line">random_shuffle(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line"><span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">vtarget.resize(v1.size() + v2.size());</span><br><span class="line"><span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());</span><br><span class="line">for_each(vtarget.begin(), vtarget.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p><h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);  </code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">reverse(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p><h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>                     // 互换两个容器的元素</li></ul><h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg  开始迭代器</p><p>// end  结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.resize(v1.size());</span><br><span class="line">copy(v1.begin(), v1.end(), v2.begin());</span><br><span class="line"></span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">replace(v.begin(), v.end(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>replace会替换区间内满足条件的元素</p><h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">replace_if(v.begin(), v.end(), ReplaceGreater30(), <span class="number">3000</span>);</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);  </code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(v1, v2);</span><br><span class="line">for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p><h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code>      // 计算容器元素累计总和</p></li><li><p><code>fill</code>                 // 向容器中添加元素</p></li></ul><h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li> 计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);  </code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = accumulate(v.begin(), v.end(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);  </code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.resize(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line">fill(v.begin(), v.end(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p><h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code>          // 求两个容器的交集</p></li><li><p><code>set_union</code>                       // 求两个容器的并集</p></li><li><p><code>set_difference </code>              // 求两个容器的差集</p></li></ul><h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">vTarget.resize(min(v1.size(), v2.size()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">vTarget.resize(v1.size() + v2.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">vTarget.resize( max(v1.size() , v2.size()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());</span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;C-提高编程&quot;&gt;&lt;a href=&quot;#C-提高编程&quot; class=&quot;headerlink&quot; title=&quot;C++提高编程&quot;&gt;&lt;/a&gt;C++提高编程&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用&lt;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
</feed>
