<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>okeyia</title>
  
  
  <link href="http://okeyia.github.io/atom.xml" rel="self"/>
  
  <link href="http://okeyia.github.io/"/>
  <updated>2023-03-27T01:40:23.280Z</updated>
  <id>http://okeyia.github.io/</id>
  
  <author>
    <name>okeyia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sylar服务器开发</title>
    <link href="http://okeyia.github.io/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    <id>http://okeyia.github.io/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/</id>
    <published>2023-03-27T01:38:49.000Z</published>
    <updated>2023-03-27T01:40:23.280Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sylar服务器开发"><a href="#sylar服务器开发" class="headerlink" title="sylar服务器开发"></a>sylar服务器开发</h2><h3 id="〇-开发环境"><a href="#〇-开发环境" class="headerlink" title="〇 开发环境"></a>〇 开发环境</h3><p>cmake </p><p>clang++</p><p>clion + ubuntu</p><p>参考链接: </p><ol><li> <a href="https://www.midlane.top/wiki/pages/viewpage.action?pageId=10060952">从零开始重写sylar C++高性能分布式服务器框架</a> 的copy, 原因有二,  一是怕作者的网站什么时候挂了,  二是写下来加深一下自己的理解。</li></ol><h3 id="一-日志系统"><a href="#一-日志系统" class="headerlink" title="一 日志系统"></a>一 日志系统</h3><p>日志模块概述</p><p>用于格式化输出程序日志，方便从日志中定位程序运行过程中出现的问题。这里的日志除了日志内容本身之外，还应该包括文件名/行号，时间戳，线程/协程号，模块名称，日志级别等额外信息，甚至在打印致命的日志时，还应该附加程序的栈回溯信息，以便于分析和排查问题。</p><p>从设计上看，一个完整的日志模块应该具备以下功能：</p><ol><li><p>区分不同的级别，比如常的DEBUG/INFO/WARN/ERROR等级别。日志模块可以通过指定级别实现只输出某个级别以上的日志，这样可以灵活开关一些不重要的日志输出，比如程序在调试阶段可以设置一个较低的级别，以便看到更多的调度日志信息，程序发布之后可以设置一个较高的级别，以减少日志输出，提高性能。</p></li><li><p>区分不同的输出地。不同的日志可以输出到不同的位置，比如可以输出到标准输出，输出到文件，输出到syslog，输出到网络上的日志服务器等，甚至同一条日志可以同时输出到多个输出地。</p></li><li><p>区分不同的类别。日志可以分类并命名，一个程序的各个模块可以使用不同的名称来输出日志，这样可以很方便地判断出当前日志是哪个程序模块输出的。</p></li><li><p>日志格式可灵活配置。可以按需指定每条日志是否包含文件名/行号、时间戳、线程/协程号、日志级别、启动时间等内容。</p></li><li><p>可通过配置文件的方式配置以上功能。</p></li></ol><h4 id="1-1-日志模块设计"><a href="#1-1-日志模块设计" class="headerlink" title="1.1 日志模块设计"></a>1.1 日志模块设计</h4><p>首先是日志级别，这个参考log4cpp即可，一共定义以下几个级别：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Level</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    FATAL  = <span class="number">0</span>,<span class="comment">/// 致命情况，系统不可用</span></span><br><span class="line">    ALERT  = <span class="number">100</span>,<span class="comment">/// 高优先级情况，例如数据库系统崩溃</span></span><br><span class="line">    CRIT   = <span class="number">200</span>,<span class="comment">/// 严重错误，例如硬盘错误</span></span><br><span class="line">    ERROR  = <span class="number">300</span>,<span class="comment">/// 错误</span></span><br><span class="line">    WARN   = <span class="number">400</span>,<span class="comment">/// 警告 </span></span><br><span class="line">    NOTICE = <span class="number">500</span>,<span class="comment">/// 正常但值得注意</span></span><br><span class="line">    INFO   = <span class="number">600</span>,<span class="comment">/// 一般信息 </span></span><br><span class="line">    DEBUG  = <span class="number">700</span>,<span class="comment">/// 调试信息</span></span><br><span class="line">    NOTSET = <span class="number">800</span>,<span class="comment">/// 未设置</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是关键的几个类: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogFormatter</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogAppender</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogEvent</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogEventWrap</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogManager</span>;</span></span><br></pre></td></tr></table></figure><ul><li><p><code>LogFormatter</code>: 日志格式器，与log4cpp的PatternLayout对应，用于格式化一个日志事件。该类构建时可以指定pattern，表示如何进行格式化。提供format方法，用于将日志事件格式化成字符串。</p></li><li><p><code>LogAppender</code>: 日志输出器，用于将一个日志事件输出到对应的输出地。该类内部包含一个LogFormatter成员和一个log方法，日志事件先经过LogFormatter格式化后再输出到对应的输出地。从这个类可以派生出不同的Appender类型，比如StdoutLogAppender和FileLogAppender，分别表示输出到终端和文件。</p></li><li><p><code>Logger</code>: 日志器，负责进行日志输出。一个Logger包含多个LogAppender和一个日志级别，提供log方法，<strong>传入日志事件，判断该日志事件的级别高于日志器本身的级别之后调用LogAppender将日志进行输出</strong>，否则该日志被抛弃。</p></li><li><p><code>LogEvent</code>: 日志事件，用于记录日志现场，比如该日志的级别，文件名/行号，日志消息，线程/协程号，所属日志器名称等。</p></li><li><p><code>LogEventWrap</code>: 日志事件包装类，其实就是将日志事件和日志器包装到一起，因为一条日志只会在一个日志器上进行输出。将日志事件和日志器包装到一起后，方便通过宏定义来简化日志模块的使用。另外，LogEventWrap还负责在构建时指定日志事件和日志器，在析构时调用日志器的log方法将日志事件进行输出。</p></li><li><p><code>LogManager</code>: 日志器管理类，单例模式，用于统一管理所有的日志器，提供日志器的创建与获取方法。LogManager自带一个root Logger，用于为日志模块提供一个初始可用的日志器。</p><blockquote><p>单例模式(Singleton Pattern，也称为单件模式)，使用最广泛的设计模式之一。其意图是保证一个类仅有一个实例，并提供一个访问它的全局访问点，该实例被所有程序模块共享。</p></blockquote></li></ul><h4 id="1-2-日志模块工作流程"><a href="#1-2-日志模块工作流程" class="headerlink" title="1.2 日志模块工作流程"></a>1.2 日志模块工作流程</h4><p>至此，日志模块的设计就基本结束了，总结一下日志模块的工作流程：</p><ol><li><p>初始化LogFormatter，LogAppender, Logger。</p></li><li><p>通过宏定义提供<strong>流式风格和格式化风格</strong>的日志接口。每次写日志时，通过宏自动生成对应的日志事件LogEvent，并且将日志事件和日志器Logger包装到一起，生成一个LogEventWrap对象。</p></li><li><p>日志接口执行结束后，LogEventWrap对象析构，在析构函数里调用Logger的log方法将日志事件进行输出。</p></li></ol><h4 id="1-3-日志关键模块实现"><a href="#1-3-日志关键模块实现" class="headerlink" title="1.3 日志关键模块实现"></a>1.3 日志关键模块实现</h4><h5 id="1-3-1-LogEvent"><a href="#1-3-1-LogEvent" class="headerlink" title="1.3.1 LogEvent"></a>1.3.1 LogEvent</h5><p>日志事件, 用来记录日志现场, 具体包含以下内容:</p><ul><li>日志内容</li><li>日志器名称</li><li>日志级别</li><li>文件名, 对应 <code>__FILE_</code>_ 宏</li><li>行号, 对应 <code>__LINE__</code> 宏</li><li>程序运行时间，通过sylar::GetElapsedMS()获取</li><li>线程ID</li><li>协程ID</li><li>UTC时间戳, 对应time(0) : 是指格林威治时间1970年01月01日00时00分00秒起至现在的总秒数</li><li>线程名称</li></ul><p>日志事件的构造需要通过宏来简化，否则，每次生成一个日志事件时都要对上面这些内容进行赋值，够麻烦的。</p><h5 id="1-3-2-LogFormatter"><a href="#1-3-2-LogFormatter" class="headerlink" title="1.3.2 LogFormatter"></a>1.3.2 LogFormatter</h5><p><strong>日志格式器，用于格式化一个日志事件，将其转化成一串字符串。</strong> </p><p>由于一个日志事件包括了很多的内容（这里将每个内容称为一个item），但实际上用户并不希望每次输出日志时都将这些items全部进行输出，而是希望可以自由地选择要输出的item。并且，用户还可能需要在每条日志里增加一些指定的字符，比如在文件名和行号之间加上一个冒号的情况。为了实现这项功能，LogFormatter使用了一个模板字符串来指定格式化的方式，这个模板字符串是一串像下面这样的字符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;%d&#123;%Y-%m-%d %H:%M:%S&#125; [%rms]%T%t%T%N%T%F%T[%p]%T[%c]%T%f:%l%T%m%n&quot;</span></span><br></pre></td></tr></table></figure><p>模板字符串由普通字符和转义字符构成，转义字符以%开头，比如%m，%p等。除了转义字符，剩下的全部都是普通字符，包括空格。</p><p>LogFormatter根据模板字符串来格式化日志事件。首先，在构造LogFormatter对象时会指定一串模板字符，LogFormatter会首先解析该模板字符串，将其中的转义字符和普通字符解析出来。然后，在格式化日志事件时，根据模板字符串，将其中的转义字符替换成日志事件的具体内容，普通字符保持不变。</p><p>当前实现支持以下转义字符：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">%m 消息</span><br><span class="line">%p 日志级别</span><br><span class="line">%c 日志器名称</span><br><span class="line">%d 日期时间，后面可跟一对括号指定时间格式，比如%d&#123;%Y-%m-%d %H:%M:%S&#125;，这里的格式字符与C语言strftime一致</span><br><span class="line">%r 该日志器创建后的累计运行毫秒数</span><br><span class="line">%f 文件名</span><br><span class="line">%l 行号</span><br><span class="line">%t 线程id</span><br><span class="line">%F 协程id</span><br><span class="line">%N 线程名称</span><br><span class="line">%% 百分号</span><br><span class="line">%T 制表符</span><br><span class="line">%n 换行</span><br></pre></td></tr></table></figure><p>举例说明:  假设一个LogFormatter的模板字符串为 <code>[%c] [%p] %t %F %f:%l %m%n</code> ，那么它输出的日志可能是像下面这样的一行字符串：LogFormatter的模板字符串为 <code>[%c] [%p] %t %F %f:%l %m%n</code>，那么它输出的日志可能是像下面这样的一行字符串：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root] [info] <span class="number">1000</span> <span class="number">0</span> main.cpp:<span class="number">12</span> hello world</span><br></pre></td></tr></table></figure><h5 id="1-3-3-LogAppender"><a href="#1-3-3-LogAppender" class="headerlink" title="1.3.3 LogAppender"></a>1.3.3 LogAppender</h5><p>日志输出器，用于输出一个日志事件。这是一个虚类，可以派生出不同的具体实现，比如<strong>往输出到终端的StdoutLogAppender</strong>，以及<strong>输出到文件的FileLogAppender</strong>。</p><p>LogAppender的实现包含了一个用户指定的LogFormatter和一个默认的LogFormatter，以及log方法，不同类型的Appender通过重载log方法来实现往不同的目的地进行输出，这部分直接阅读源码即可，不难理解。</p><h5 id="1-3-4-Logger"><a href="#1-3-4-Logger" class="headerlink" title="1.3.4 Logger"></a>1.3.4 Logger</h5><p>日志器，用于输出日志。这个类是直接与用户进行交互的类，提供log方法用于输出日志事件。</p><p>Logger的实现包含了日志级别，日志器名称，创建时间，以及一个LogAppender数组，日志事件由log方法输出，log方法首先判断日志级别是否达到本Logger的级别要求，是则将日志传给各个LogAppender进行输出，否则抛弃这条日志。</p><h5 id="1-3-5-LogEventWrap"><a href="#1-3-5-LogEventWrap" class="headerlink" title="1.3.5 LogEventWrap"></a>1.3.5 LogEventWrap</h5><p>日志事件包装类，在日志现场构造，包装了日志器和日志事件两个对象，<strong>在日志记录结束后, LogEventWrap析构时，调用日志器的log方法输出日志事件。</strong></p><h5 id="1-3-6-LogManager"><a href="#1-3-6-LogManager" class="headerlink" title="1.3.6 LogManager"></a>1.3.6 LogManager</h5><p>日志器管理类，单例模式，用于统一管理全部的日志器，提供getLogger()方法用于创建/获取日志器。内部维护一个名称到日志器的map，当获取的日志器存在时，直接返回对应的日志器指针，否则创建对应的日志器并返回。</p><h4 id="1-4-工具宏"><a href="#1-4-工具宏" class="headerlink" title="1.4 工具宏"></a>1.4 工具宏</h4><p>sylar定义了一系列工具宏用于简化编码以及实现流式风格的日志输出和格式化风格的日志输出，下面以流式风格的实现为例分析一下宏的设计：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 使用流式方式将日志级别level的日志写入到logger</span></span><br><span class="line"><span class="comment"> * @details 构造一个LogEventWrap对象，包裹包含日志器和日志事件，在对象析构时调用日志器写日志事件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_LEVEL(logger , level) \</span></span><br><span class="line">    <span class="keyword">if</span>(level &lt;= logger-&gt;getLevel()) \</span><br><span class="line">        sylar::LogEventWrap(logger, sylar::LogEvent::ptr(<span class="keyword">new</span> sylar::LogEvent(logger-&gt;getName(), \</span><br><span class="line">            level, __FILE__, __LINE__, sylar::GetElapsedMS() - logger-&gt;getCreateTime(), \</span><br><span class="line">            sylar::GetThreadId(), sylar::GetFiberId(), time(<span class="number">0</span>), sylar::GetThreadName()))).getLogEvent()-&gt;getSS()</span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_FATAL(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::FATAL)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_ALERT(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::ALERT)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_CRIT(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::CRIT)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_ERROR(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::ERROR)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_WARN(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::WARN)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_NOTICE(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::NOTICE)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_INFO(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::INFO)</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SYLAR_LOG_DEBUG(logger) SYLAR_LOG_LEVEL(logger, sylar::LogLevel::DEBUG)</span></span><br></pre></td></tr></table></figure><p>调用语句如下: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sylar::Logger::ptr g_logger = SYLAR_LOG_ROOT();</span><br><span class="line">SYLAR_LOG_INFO(g_logger) &lt;&lt; <span class="string">&quot;info msg&quot;</span>;</span><br></pre></td></tr></table></figure><p>这里要实现通过g_logger打印一条INFO级别的消息。那么，首先判断INFO级别是否高于g_logger本身的日志级别（这里的设计与原版sylar相反，数字越小，优先级越高），如果不高于，那if语句执行不到，这条日志也不会打印，否则，临时构造一个LogEventWrap对象，传入日志器g_logger，以及现场构造的日志事件。通过LogEventWrap的getLogEvent()方法拿到日志事件，再用日志事件的流式日志消息成员输出日志消息。由于LogEventWrap是在if语句内部构建的，一旦if语句执行结束，LogEventWrap对象就会析构，日志事件也就会被g_logger进行输出，这个设计可以说是非常巧妙。</p><h3 id="二-配置系统"><a href="#二-配置系统" class="headerlink" title="二 配置系统"></a>二 配置系统</h3><h4 id="2-1-概述"><a href="#2-1-概述" class="headerlink" title="2.1 概述"></a>2.1 概述</h4><p>提供程序运行时的环境变量管理功能。这里的环境变量不仅包括<strong>系统环境变量</strong>，还包括程<strong>序自定义环境变量</strong>，<strong>命令行参数</strong>，<strong>帮助选项与描述</strong>，以及<strong>程序运行路径相关的信息</strong>。</p><p>所谓环境变量就是程序运行时可直接获取和设置的一组变量，它们往往代表一些特定的含义。所有的环境变量都以key-value的形式存储，key和value都是字符串形式。</p><blockquote><p>这里可以参考系统环境变量来理解，在程序运行时，可以通过调用<code>getenv()/setenv()</code>接口来获取/设置系统环境变量，比如<code>getenv(&quot;PWD&quot;)</code>来获取当前路径。在<strong>shell中可以通过<code>printenv</code>命令来打印当前所有的环境变量</strong>，并且在当前shell中运行的所有程序都共享这组环境变量值。</p></blockquote><p>其他类型的环境变量也可以类比系统环境变量，只不过系统环境变量由shell来保存，而<strong>其他类型的环境变量由程序自己内部存储</strong>，但两者效果是一样的。具体地，sylar定义了以下几类环境变量：</p><ul><li><strong>系统环境变量</strong>，由shell保存，sylar环境变量模块提供getEnv()/setEnv()方法用于操作系统环境变量。</li><li><strong>程序自定义环境变量</strong>，对应get()/add()/has()/del()接口，自定义环境变量保存在程序自己的内存空间中，在内部实现为一个<code>std::map&lt;std::string, std::string&gt;</code>结构。</li><li><strong>命令行参数</strong>，通过解析main函数的参数得到。所有参数都被解析成选项-选项值的形式，选项只能以<code>-</code>开头，后面跟选项值。如果一个参数只有选项没有值，那么值为空字符串。命令行参数也保存在程序自定义环境变量中。</li><li><strong>帮助选项与描述</strong>。这里是为了统一生成程序的命令行帮助信息，在执行程序时如果指定了<code>-h</code>选项，那么就打印这些帮助信息。帮助选项与描述也是存储在程序自己的内存空间中，在内部实现为一个<code>std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;</code>结构。</li><li>与程序运行路径相关的信息，包括记录程序名，程序路径，当前路径，这些由单独的成员变量来存储。</li></ul><h4 id="2-2-环境变量模块设计"><a href="#2-2-环境变量模块设计" class="headerlink" title="2.2 环境变量模块设计"></a>2.2 环境变量模块设计</h4><p><strong>与环境变量相关的类只有一个<code>class Env</code>，并且这个类被包装成了单例模式。通过单例可以保证程序的环境变量是全局唯一的，便于统一管理。</strong></p><p>Env类提供以下方法：</p><ol><li><p><strong>init:</strong> 环境变量模块初始化，需要将main函数的参数原样传入init接口中，以便于从main函数参数中提取命令行选项与值，以及通过argv[0]参数获取命令行程序名称。</p></li><li><p><strong>add/get/has/del：</strong>用于操作程序自定义环境变量，参数为key-value，get操作支持传入默认值，在对应的环境变量不存在时，返回这个默认值。</p></li><li><p><strong>setEnv/getEnv:</strong> 用于操作系统环境变量，对应标准库的setenv/getenv操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setenv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name, <span class="keyword">const</span> <span class="keyword">char</span> * value,<span class="keyword">int</span> overwrite)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>setenv()用来改变或增加环境变量的内容。</p></li><li><p>参数name为环境变量名称字符串。</p></li><li><p>参数 value则为变量内容</p></li><li><p>参数overwrite用来决定是否要改变已存在的环境变量。若环境变量存在，当<strong>overwrite不为0时，原内容会被改为参数value所指的变量内容；</strong>当overwrite为0时，则参数value会被忽略。</p></li></ul></li></ol>   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">getenv</span><span class="params">(<span class="keyword">char</span> *envvar)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>参数envvar为环境变量的名称，如果该变量存在则会返回指向该内容的指针。</p></li><li><p>找不到符合的环境变量名称则返回NULL。</p></li></ul><ol start="4"><li><p><strong>addHelp/removeHelp/printHelp:</strong> 用于操作帮助选项和描述信息。</p></li><li><p><strong>getExe/getCwd/getAbsolutePath:</strong> 用于获取程序名称，程序路径，绝对路径。</p></li><li><p><strong>getConfigPath:</strong> 获取配置文件夹路径，配置文件夹路径由命令行-c选项传入。</p></li></ol><h4 id="2-3-环境变量模块实现"><a href="#2-3-环境变量模块实现" class="headerlink" title="2.3 环境变量模块实现"></a>2.3 环境变量模块实现</h4><p>这里只描述环境变量环境的一些实现细节。</p><ol><li><p>获取<strong>程序的bin文件绝对路径</strong>是通过/proc/$pid/目录下exe软链接文件指向的路径来确定的, 用到了用到了<code>readlink</code>系统调用。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">readlink</span><br><span class="line">Follow symlinks and get symlink information.</span><br><span class="line"></span><br><span class="line"> - Get the actual file to which the symlink points:</span><br><span class="line">   readlink &#123;&#123;filename&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Get the absolute path to a file:</span><br><span class="line">   readlink -f &#123;&#123;filename&#125;&#125;</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">ssize_t readlink(const char *path, char *buf, size_t bufsiz);</span><br><span class="line">readlink()会将参数path的符号链接内容存储到参数buf所指的内存空间。若参数bufsiz小于符号连接的内容长度，过长的内容会被截断，</span><br></pre></td></tr></table></figure></li><li><p>通过bin文件绝对路径可以<strong>得到bin文件所在的目录</strong>，只需要将最后的文件名部分去掉即可。</p></li><li><p>通过argv[0]获得命令行输入的<strong>程序路径</strong>，注意这里的路径可能是以./开头的相对路径。</p></li><li><p>通过<strong>setenv/getenv操作系统环境变量</strong>，参考setenv, getenv。</p></li><li><p>提供getAbsolutePath方法，<strong>传入一个相对于bin文件的路径，返回这个路径的绝对路径</strong>。比如默认的配置文件路径就是通过getAbsolutePath(get(“c”, “conf”))来获取的，也就是配置文件夹默认在bin文件所在目录的conf文件夹。</p></li><li><p>按使用惯例，<strong>main函数执行的第一条语句应该就是调用Env的init方法初始化命令行参数。</strong></p></li></ol><h3 id="三-配置模块"><a href="#三-配置模块" class="headerlink" title="三 配置模块"></a>三 配置模块</h3><h4 id="3-1-概述"><a href="#3-1-概述" class="headerlink" title="3.1 概述"></a>3.1 概述</h4><p>用于定义/声明配置项，并且从配置文件中加载用户配置。</p><p>一般而言，一项配置应该包括以下要素：</p><ol><li><p>名称，对应一个字符串，必须唯一，不能与其他配置项产生冲突。</p></li><li><p> 类型，可以是基本类型，但也应该支持复杂类型和自定义类型。</p></li><li><p> 值。默认值，考虑到用户不一定总是会显式地给配置项赋值，所以配置项最好有一个默认值。</p></li><li><p>配置变更通知，一旦用户更新了配置值，那么应该通知所有使用了这项配置的代码，以便于进行一些具体的操作，比如重新打开文件，重新起监听端口等。</p></li><li><p>校验方法，更新配置时会调用校验方法进行校验，以保证用户不会给配置项设置一个非法的值。</p></li></ol><p>一个配置模块应具备的基本功能：</p><ol><li><strong>支持定义/声明配置项</strong>，也就是在提供配置名称、类型以及可选的默认值的情况下生成一个可用的配置项。由于一项配置可能在多个源文件中使用，所以配置模块还应该支持跨文件声明配置项的方法。</li><li><strong>支持更新配置项的值</strong>。这点很好理解，配置项刚被定义时可能有一个初始默认值，但用户可能会有新的值来覆盖掉原来的值。</li><li><strong>支持从预置的途径中加载配置项，一般是配置文件，也可以是命令行参数，或是网络服务器</strong>。这里不仅应该支持基本数据类型的加载，也应该支持复杂数据类型的加载，比如直接从配置文件中加载一个map类型的配置项，或是直接从一个预定格式的配置文件中加载一个自定义结构体。</li><li><strong>支持给配置项注册配置变更通知。</strong>配置模块应该提供方法让程序知道某项配置被修改了，以便于进行一些操作。比如对于网络服务器而言，如果服务器端口配置变化了，那程序应该重新起监听端口。这个功能一般是通过注册回调函数来实现的，配置使用方预先给配置项注册一个配置变更回调函数，配置项发生变化时，触发对应的回调函数以通知调用方。由于一项配置可能在多个地方引用，所以配置变更回调函数应该是一个数组的形式。</li><li><strong>支持给配置项设置校验方法。</strong>配置项在定义时也可以指定一个校验方法，以保证该项配置不会被设置成一个非法的值，比如对于文件路径类的配置，可以通过校验方法来确保该路径一定存在。</li><li><strong>支持导出当前配置。</strong></li></ol><h4 id="3-2-配置模块设计"><a href="#3-2-配置模块设计" class="headerlink" title="3.2 配置模块设计"></a>3.2 配置模块设计</h4><p>采用约定优于配置的思想, 简单来说，约定优于配置的背景条件是，一般来说，<strong>程序所依赖的配置项都有一个公认的默认值，也就是所谓的约定。</strong> 这点有可许多可以参考的例子，比如对于一个http网络服务器，服务端口通常都是80端口。对于这些具有公认约定的配置，可以初始时就将配置项设置成对应的值。这样，程序员就可以只修改那些约定之外的配置项，然后<strong>以最小的代价让程序跑起来。</strong></p><p>在代码上，约定优于配置的思路体现为所有的配置项在定义时都带一个的默认值，以下是一个sylar配置项的示例，这是一个int类型的配置项，名称为<code>tcp.connect.timeout</code>，初始值为5000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> sylar::ConfigVar&lt;<span class="keyword">int</span>&gt;::ptr g_tcp_connect_timeout = sylar::Config::Lookup(<span class="string">&quot;tcp.connect.timeout&quot;</span>, <span class="number">5000</span>, <span class="string">&quot;tcp connect timeout&quot;</span>);</span><br></pre></td></tr></table></figure><blockquote><p>sylar的配置项定义之后即可使用，比如上面的配置项可以直接使用<code>g_tcp_connect_timeout-&gt;getValue()</code>获取参数的值，这里获取的为默认值5000。</p><p>sylar使用YAML做为配置文件，配置名称大小写不敏感，并且支持级别格式的数据类型，比如上面的配置项对应的YAML配置文件内容如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">tcp:</span></span><br><span class="line">    <span class="attr">connect:</span></span><br><span class="line">        <span class="attr">timeout:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>这里指定了配置名称为 <code>tcp.connect.timeout</code>的配置项的值为10000。<strong>由于配置文件指定的值与默认值不一样，当配置文件加载后，对应的配置项值会被自动更新为10000，如果配置项还注册了配置变更回调函数的话，会一并调用配置变更回调函数以通知配置使用方。</strong></p><p>sylar支持STL容器（vector, list, set, map等等），支持自定义类型（需要<strong>实现序列化和反序列化方法)。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义类型举例, 实现自定义配置的YAML序列化与反序列化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, Person&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Person <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;v)</span> </span>&#123;</span><br><span class="line">        YAML::Node node = YAML::Load(v);</span><br><span class="line">        Person p;</span><br><span class="line">        p.m_name = node[<span class="string">&quot;name&quot;</span>].as&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;();</span><br><span class="line">        p.m_age = node[<span class="string">&quot;age&quot;</span>].as&lt;<span class="keyword">int</span>&gt;();</span><br><span class="line">        p.m_sex = node[<span class="string">&quot;sex&quot;</span>].as&lt;<span class="keyword">bool</span>&gt;();</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span>Person, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span> </span>&#123;</span><br><span class="line">        YAML::Node node;</span><br><span class="line">        node[<span class="string">&quot;name&quot;</span>] = p.m_name;</span><br><span class="line">        node[<span class="string">&quot;age&quot;</span>] = p.m_age;</span><br><span class="line">        node[<span class="string">&quot;sex&quot;</span>] = p.m_sex;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></blockquote><p>与配置模块相关的类:</p><ul><li><p><code>ConfigVarBase</code>: <strong>配置项基类，虚基类，定义了配置项公有的成员和方法。</strong>sylar对每个配置项都包括名称和描述两项成员，以及toString/fromString两个纯虚函数方法。ConfigVarBase并不包含配置项类型和值，这些由继承类实现，由<strong>继承类实现的还包括具体类型的toString/fromString方法，用于和YAML字符串进行相互转换。</strong></p></li><li><p><code>ConfigVar</code>:  <strong>具体的配置参数类，继承自ConfigVarBase，并且是一个模板类，有3个模板参数。</strong>第一个模板参数是类型T，表示配置项的类型。另外两个模板参数是FromStr和ToStr，这两个参数是仿函数，FromStr用于将YAML字符串转类型T，ToStr用于将T转YAML字符串。这两个模板参数具有默认值<code>LexicalCast&lt;std::string, T&gt;</code>和<code>LexicalCast&lt;T, std::string&gt;</code>，根据不同的类型T，FromStr和ToStr具有不同的偏特化实现。  可以理解为:   <strong>所有的偏特化实现都是为configVar服务的</strong>。</p><p><strong>ConfigVar类在ConfigVarBase上基础上包含了一个T类型的成员和一个变更回调函数数组</strong>，此外，ConfigVar还提供了setValue/getValue方法用于获取/更新配置值（更新配置时会一并触发全部的配置变更回调函数），以及addListener/delListener方法用于添加或删除配置变更回调函数。</p></li><li><p><code>Config</code>: <strong>ConfigVar的管理类，负责托管全部的ConfigVar对象，单例模式。</strong> 提供Lookup方法，用于根据配置名称查询配置项。如果调用Lookup查询时同时提供了默认值和配置项的描述信息，那么在未找到对应的配置时，会自动创建一个对应的配置项，这样就保证了配置模块定义即可用的特性。除此外，Config类还提供了LoadFromYaml和LoadFromConfDir两个方法，用于从YAML对象或从命令行-c选项指定的配置文件路径中加载配置。<strong>Config的全部成员变量和方法都是static类型，保证了全局只有一个实例。</strong></p></li></ul><h4 id="3-3-配置模块实现"><a href="#3-3-配置模块实现" class="headerlink" title="3.3 配置模块实现"></a>3.3 配置模块实现</h4><p>sylar的配置模块使用了yaml-cpp作为YAML解析库，关于yaml-cpp的编译和使用可参考GitHub链接：<a href="https://github.com/jbeder/yaml-cpp">jbeder/yaml-cpp: A YAML parser and emitter in C++</a>，关于YAML格式的介绍可参考<a href="https://www.runoob.com/w3cnote/yaml-intro.html">YAML 入门教程 | 菜鸟教程</a>。</p><p><strong>配置模块实现的一大难点是类型转换类（仿函数）的偏特化实现。</strong> 对于每种类型的配置，在对应的ConfigVar模板类实例化时都要提供其FromStr和ToStr两个仿函数，用于实现该类型和YAML字符串的相互转换。</p><p>配置项的类型众多，包括全部的基本数据类型（int, float, double, string等），以及vector/list/set/unordered_set/map/unordered_map这几个复杂数据类型，还有用户自定义的类型。</p><h5 id="3-3-1-转换简单类"><a href="#3-3-1-转换简单类" class="headerlink" title="3.3.1 转换简单类"></a>3.3.1 转换简单类</h5><p>为了简化代码编写，sylar从一个基本类型的转换类开始，特化出了剩余类型的转换类，这个基本类型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 类型转换模板类(F 源类型, T 目标类型)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">F</span>, <span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 类型转换</span></span><br><span class="line"><span class="comment">     * @param[in] v 源类型值</span></span><br><span class="line"><span class="comment">     * @return 返回v转换后的目标类型</span></span><br><span class="line"><span class="comment">     * @exception 当类型不可转换时抛出异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">T <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> F &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> boost::lexical_cast&lt;T&gt;(v);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>这里的LexicalCast类是一个仿函数，它支持<code>LexicalCast&lt;F, T&gt;()(const F &amp;v)</code>调用，可将传入的F类型的参数v进行转换，并返回T类型的结果。实际的转换语句是<code>boost::lexical_cast&lt;T&gt;(v)</code>。</p><blockquote><p>仿函数（Functor）又称为函数对象（Function Object）是一个能行使函数功能的类。仿函数的语法几乎和我们普通的函数调用一样，不过作为仿函数的类，都必须重载 operator() 运算符。因为调用仿函数，实际上就是通过类对象调用重载后的 operator() 运算符。</p></blockquote><p>但是，受限于<code>boost::lexical_cast</code>, <strong>LexicalCast当前只能实现基本数据类型和std::string的相互转换</strong>，不能实现复杂类型的转换，下面的代码可用于演示当前LexicalCast的功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str1 = LexicalCast&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(<span class="number">123</span>);     <span class="comment">// ok, str1等于&quot;123&quot;</span></span><br><span class="line"><span class="keyword">int</span> int1 = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">int</span>&gt;()(<span class="string">&quot;123&quot;</span>);           <span class="comment">// ok, int1等于123</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> str2 = LexicalCast&lt;<span class="keyword">float</span>, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(<span class="number">3.14</span>);  <span class="comment">// ok，str2等于&quot;3.14&quot;</span></span><br><span class="line"><span class="keyword">float</span> float2 = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="keyword">float</span>&gt;()(<span class="string">&quot;3.14&quot;</span>);    <span class="comment">// ok，float2等于3.14</span></span><br><span class="line"> </span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;()(...); <span class="comment">// 错误，LexicalCast目前还不支持实例化T类型为vector&lt;int&gt;的模板参数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = LexicalCast&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(...); <span class="comment">// 错误，同上</span></span><br></pre></td></tr></table></figure></blockquote><h5 id="3-3-2-复杂类型转换"><a href="#3-3-2-复杂类型转换" class="headerlink" title="3.3.2 复杂类型转换"></a>3.3.2 复杂类型转换</h5><p>为了实现YAML字符串和vector/list/set/unordered_set/map/unordered_map的相互转换，就要对每个类型都进行特化，分别实现其转换类，下面是YAML字符串和vector的相互转换实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 类型转换模板类片特化(YAML String 转换成 std::vector&lt;T&gt;)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;v)</span> </span>&#123;</span><br><span class="line">        YAML::Node node = YAML::Load(v);</span><br><span class="line">        <span class="keyword">typename</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; vec;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; node.size(); ++i) &#123;</span><br><span class="line">            ss.str(<span class="string">&quot;&quot;</span>);</span><br><span class="line">            ss &lt;&lt; node[i];</span><br><span class="line">            vec.push_back(LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, T&gt;()(ss.str()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> vec;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 类型转换模板类片特化(std::vector&lt;T&gt; 转换成 YAML String)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LexicalCast</span>&lt;</span><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt; &amp;v)</span> </span>&#123;</span><br><span class="line">        <span class="function">YAML::Node <span class="title">node</span><span class="params">(YAML::NodeType::Sequence)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : v) &#123;</span><br><span class="line">            node.push_back(YAML::Load(LexicalCast&lt;T, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(i)));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> ss;</span><br><span class="line">        ss &lt;&lt; node;</span><br><span class="line">        <span class="keyword">return</span> ss.str();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>上面分别实现了<code>LexicalCast&lt;std::string, std::vector&lt;T&gt;&gt;</code>和<code>LexicalCast&lt;std::vector&lt;T&gt;, std::string&gt;</code>，其中在转换单个的数组元素时，再次用到了<code>LexicalCast&lt;std::string, T&gt;</code>和<code>LexicalCast&lt;T, std::string&gt;</code>，如果这里T是基本数据类型，那么就可以用最开始的基本类型的转换类进行模板实例化并完成转换了，</p><p>下面是针对vector和YAML字符串相互转换的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;()(<span class="string">&quot;[1, 2, 3]&quot;</span>);  <span class="comment">// ok,     v等于[1, 2, 3]</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> s = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;); <span class="comment">// ok，  s等于YAML格式的数组[1,2,3],如下:</span></span><br><span class="line">                                                                                         <span class="comment">// - 1                                                                         // - 2                                                                         // - 3</span></span><br></pre></td></tr></table></figure><p>另外，由于这里的模板实例化是可以嵌套的，由vector和vector组合出来的全部类型都可以顺利地实现和YAML的转化，以下是一个二维数组的示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vv = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>, <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt;()(<span class="string">&quot;[[1,2,3],[4,5,6]]&quot;</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> ss = LexicalCast&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;()(vv);</span><br></pre></td></tr></table></figure><p>上面的代码运行之后，vv将具有二维数组<code>&#123;&#123;1,2,3&#125;,&#123;4,5,6&#125;&#125;</code>的值，而字符串ss则是与之对应YAML格式的二维数组，如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">1</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">2</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">3</span></span><br><span class="line"><span class="bullet">-</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">4</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">5</span></span><br><span class="line">  <span class="bullet">-</span> <span class="number">6</span></span><br></pre></td></tr></table></figure></blockquote><p>其他复杂类型的偏特化与vector类型，参考源码理解即可。</p><p>每实现一个新类型的转换，那这个类型和之前已实现的类型组合出的数据类型也可以顺利实现转换，比如<code>vector&lt;set&gt;, set&lt;vector&gt;，set&lt;map&gt;, map&lt;set&gt;, map&lt;map&gt;</code>这种。这种基于偏特化实现类型转换的方法可以说是非常巧妙了，代码可以做到高度简化，但功能却非常强大，这也变相展示了泛型程序设计的强大之处吧。</p><h3 id="四-线程模块"><a href="#四-线程模块" class="headerlink" title="四 线程模块"></a>四 线程模块</h3><p>提供线程类和线程同步类，基于pthread实现，包括以下类：</p><p><code>Thread</code>：线程类，构造函数传入线程入口函数和线程名称，线程入口函数类型为void()，如果带参数，则需要用 <code>std::bind</code> 进行绑定。线程类构造之后线程即开始运行，构造函数在线程真正开始运行之后返回。</p><p>线程同步类（这部分被拆分到mutex.h)中：</p><ul><li><p><code>Semaphore</code>: 计数信号量，基于<code>sem_t</code>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Semaphore::Semaphore(<span class="keyword">uint32_t</span> count) &#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_init(&amp;m_semaphore, <span class="number">0</span>, count)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;sem_init error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Semaphore::~Semaphore() &#123;</span><br><span class="line">    sem_destroy(&amp;m_semaphore);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_wait(&amp;m_semaphore)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;sem_wait error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Semaphore::notify</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sem_post(&amp;m_semaphore)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="built_in">std</span>::logic_error(<span class="string">&quot;sem_post error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>Mutex</code>: 互斥锁，基于<code>pthread_mutex_t</code>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 互斥量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mutex</span> :</span> Noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 局部锁</span></span><br><span class="line">    <span class="keyword">typedef</span> ScopedLockImpl&lt;Mutex&gt; Lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Mutex() &#123;</span><br><span class="line">        pthread_mutex_init(&amp;m_mutex, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~Mutex() &#123;</span><br><span class="line">        pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 加锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// mutex</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> m_mutex&#123;&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>RWMutex</code>: 读写锁，基于<code>pthread_rwlock_t</code>实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 读写互斥量</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RWMutex</span> :</span> Noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 局部读锁</span></span><br><span class="line">    <span class="keyword">typedef</span> ReadScopedLockImpl&lt;RWMutex&gt; ReadLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// 局部写锁</span></span><br><span class="line">    <span class="keyword">typedef</span> WriteScopedLockImpl&lt;RWMutex&gt; WriteLock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    RWMutex() &#123;</span><br><span class="line">        pthread_rwlock_init(&amp;m_lock, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~RWMutex() &#123;</span><br><span class="line">        pthread_rwlock_destroy(&amp;m_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 上读锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rdlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_rwlock_rdlock(&amp;m_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 上写锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">wrlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_rwlock_wrlock(&amp;m_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_rwlock_unlock(&amp;m_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 读写锁</span></span><br><span class="line">    <span class="keyword">pthread_rwlock_t</span> m_lock;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>Spinlock</code>: 自旋锁，基于<code>pthread_spinlock_t</code>实现,   自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁已经被另外一个线程占有了，那么此线程就无法获取这把锁，该线程会等待，间隔一段时间后再次尝试获取。这种采用循环加锁,等待锁释放的机制就称为自旋锁。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 自旋锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Spinlock</span> :</span> Noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 局部锁</span></span><br><span class="line">    <span class="keyword">typedef</span> ScopedLockImpl&lt;Spinlock&gt; Lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Spinlock() &#123;</span><br><span class="line">        pthread_spin_init(&amp;m_mutex, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~Spinlock() &#123;</span><br><span class="line">        pthread_spin_destroy(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_spin_lock(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pthread_spin_unlock(&amp;m_mutex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 自旋锁</span></span><br><span class="line">    <span class="keyword">pthread_spinlock_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>CASLock</code>: 原子锁，基于<code>std::atomic_flag</code>实现， 不常用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 原子锁</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CASLock</span> :</span> Noncopyable &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 局部锁</span></span><br><span class="line">    <span class="keyword">typedef</span> ScopedLockImpl&lt;CASLock&gt; Lock;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    CASLock() &#123;</span><br><span class="line">        m_mutex.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~CASLock() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 上锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">std</span>::atomic_flag_test_and_set_explicit(&amp;m_mutex, <span class="built_in">std</span>::memory_order_acquire))</span><br><span class="line">            ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 解锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">std</span>::atomic_flag_clear_explicit(&amp;m_mutex, <span class="built_in">std</span>::memory_order_release);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 原子状态</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="built_in">std</span>::atomic_flag m_mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>线程模块总体比较简单，在对pthread相关的接口有一定了解的情况下，参考源码应该不难理解，这里说几个重点：</p><ol><li><p>为什么不直接使用C++11提供的thread类。按sylar的描述，因为<strong>thread其实也是基于pthread实现的</strong>。并且C++11里面没有提供读写互斥量，RWMutex，Spinlock等，在高并发场景，这些对象是经常需要用到的，所以选择自己封装pthread。</p></li><li><p>关于线程入口函数。sylar的线程只支持void(void)类型的入口函数，不支持给线程传参数，但实际使用时可以结合std::bind来绑定参数，这样就相当于支持任何类型和数量的参数。</p></li><li><p>关于子线程的执行时机。<strong>sylar的线程类可以保证在构造完成之后线程函数一定已经处于运行状态</strong>，这是通过一个信号量来实现的，构造函数在创建线程后会一直阻塞，直到线程函数运行并且通知信号量，构造函数才会返回，而构造函数一旦返回，就说明线程函数已经在执行了。</p></li><li><p>关于线程局部变量。sylar的每个线程都有两个线程局部变量，一个用于存储当前线程的Thread指针，另一个存储线程名称，通过Thread::GetThis()可以拿到当前线程的指针。</p></li><li><p>关于范围锁。sylar大量使用了范围锁来实现互斥，范围锁是指用类的构造函数来加锁，用析造函数来释放锁。这种方式可以简化锁的操作，也可以避免忘记解锁导致的死锁问题，以下是一个范围锁的示例和说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sylar::Mutex mutex;</span><br><span class="line"> </span><br><span class="line">&#123;</span><br><span class="line">    sylar::<span class="function">Mutex::Lock <span class="title">lock</span><span class="params">(mutex)</span></span>; <span class="comment">// 定义lock对象，类型为sylar::Mutex::Lock，传入互斥量，在构造函数中完成加锁操作，如果该锁已经被持有，那构造lock时就会阻塞，直到锁被释放</span></span><br><span class="line">    <span class="comment">//临界区操作</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">// 大括号范围结束，所有在该范围内定义的自动变量都会被回收，lock对象被回收时触发析构函数，在析构函数中释放锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="五-线程模块"><a href="#五-线程模块" class="headerlink" title="五 线程模块"></a>五 线程模块</h3><h4 id="5-1-协程概述"><a href="#5-1-协程概述" class="headerlink" title="5.1 协程概述"></a>5.1 协程概述</h4><p>最简单的理解，可以将协程当成一种看起来花里胡哨，并且使用起来也花里胡哨的函数。</p><p>每个协程在创建时都会指定一个入口函数，这点可以类比线程。协程的本质就是函数和函数运行状态的组合 。</p><p>协程和函数的不同之处是，函数一旦被调用，只能从头开始执行，直到函数执行结束退出，而协程则可以执行到一半就退出（称为yield），但此时协程并未真正结束，只是<strong>暂时让出CPU执行权，在后面适当的时机协程可以重新恢复运行</strong>（称为resume），在这段时间里其他的协程可以获得CPU并运行，所以协程也称为轻量级线程。</p><blockquote><p>协程能够半路yield、再重新resume的关键是<strong>协程存储了函数在yield时间点的执行状态，这个状态称为协程上下文</strong>。协程上下文包含了函数在当前执行状态下的全部CPU寄存器的值，这些寄存器值记录了函数栈帧、代码的执行位置等信息，如果将这些寄存器的值重新设置给CPU，就相当于重新恢复了函数的运行。在Linux系统里这个上下文用ucontext_t结构体来表示，通getcontext()来获取。</p></blockquote><p><strong>搞清楚协程和线程的区别。</strong> <strong>协程虽然被称为轻量级线程，但在单线程内，协程并不能并发执行，只能是一个协程结束或yield后，再执行另一个协程，而线程则是可以真正并发执行的。</strong>其实这点也好理解，毕竟协程只是以一种花里胡哨的方式去运行一个函数，不管实现得如何巧妙，也不可能在单线程里做到同时运行两个函数，否则还要多线程有何用？</p><p>因为单线程下协程并不是并发执行，而是顺序执行的，所以<strong>不要在协程里使用线程级别的锁来做协程同步，比如pthread_mutex_t。</strong> 如果一个协程在持有锁之后让出执行，那么同线程的其他任何协程一旦尝试再次持有这个锁，整个线程就锁死了，这和单线程环境下，连续两次对同一个锁进行加锁导致的死锁道理完全一样。</p><p>同样是单线程环境下，协程的yield和resume一定是同步进行的，一个协程的yield，必然对应另一个协程的resume，因为线程不可能没有执行主体。并且，协程的yield和resume是完全由应用程序来控制的。与线程不同，线程创建之后，线程的运行和调度也是由操作系统自动完成的，但协程创建后，协程的运行和调度都要由应用程序来完成，就和调用函数一样，所以协程也被称为用户态线程。</p><p>所谓<strong>创建协程</strong>，其实就是把一个函数包装成一个协程对象，然后再用协程的方式把这个函数跑起来；所谓<strong>协程调度</strong>，其实就是创建一批的协程对象，然后再创建一个调度协程，通过调度协程把这些协程对象一个一个消化掉（协程可以在被调度时继续向调度器添加新的调度任务）；所谓<strong>IO协程调度</strong>，其实就是在调度协程时，如果发现这个协程在等待IO就绪，那就先让这个协程让出执行权，等对应的IO就绪后再重新恢复这个协程的运行；所谓<strong>定时器</strong>，就是给调度协程预设一个协程对象，等定时时间到了就恢复预设的协程对象。</p><h4 id="5-2-ucontext-t-接口"><a href="#5-2-ucontext-t-接口" class="headerlink" title="5.2 ucontext_t 接口"></a>5.2 ucontext_t 接口</h4><p>sylar的协程模块基于ucontext_t实现，在学习之前，必须对ucontext_t和ucontext_t的操作函数非常熟悉。关于ucontext_t的定义和相关的接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 上下文结构体定义, 这个结构体是平台相关的，因为不同平台的寄存器不一样</span></span><br><span class="line"><span class="comment">// 下面列出的是所有平台都至少会包含的4个成员</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> &#123;</span></span><br><span class="line">    <span class="comment">// 当前上下文结束后，下一个激活的上下文对象的指针，只在当前上下文是由makecontext创建时有效</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ucontext_t</span> *<span class="title">uc_link</span>;</span></span><br><span class="line">    <span class="comment">// 当前上下文的信号屏蔽掩码</span></span><br><span class="line">    <span class="keyword">sigset_t</span>          uc_sigmask;</span><br><span class="line">    <span class="comment">// 当前上下文使用的栈内存空间，只在当前上下文是由makecontext创建时有效</span></span><br><span class="line">    <span class="keyword">stack_t</span>           uc_stack;</span><br><span class="line">    <span class="comment">// 平台相关的上下文具体内容，包含寄存器的值</span></span><br><span class="line">    <span class="keyword">mcontext_t</span>        uc_mcontext;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">ucontext_t</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 获取当前的上下文</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 恢复ucp指向的上下文，这个函数不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于变相调用了函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setcontext</span><span class="params">(<span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 修改由getcontext获取到的上下文指针ucp，将其与一个函数func进行绑定，支持指定func运行时的参数，</span></span><br><span class="line"><span class="comment">// 在调用makecontext之前，必须手动给ucp分配一段内存空间，存储在ucp-&gt;uc_stack中，这段内存空间将作为func函数运行时的栈空间，</span></span><br><span class="line"><span class="comment">// 同时也可以指定ucp-&gt;uc_link，表示函数运行结束后恢复uc_link指向的上下文，</span></span><br><span class="line"><span class="comment">// 如果不赋值uc_link，那func函数结束时必须调用setcontext或swapcontext以重新指定一个有效的上下文，否则程序就跑飞了</span></span><br><span class="line"><span class="comment">// makecontext执行完后，ucp就与函数func绑定了，调用setcontext或swapcontext激活ucp时，func就会被运行</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makecontext</span><span class="params">(<span class="keyword">ucontext_t</span> *ucp, <span class="keyword">void</span> (*func)(), <span class="keyword">int</span> argc, ...)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 恢复ucp指向的上下文，同时将当前的上下文存储到oucp中，</span></span><br><span class="line"><span class="comment">// 和setcontext一样，swapcontext也不会返回，而是会跳转到ucp上下文对应的函数中执行，相当于调用了函数</span></span><br><span class="line"><span class="comment">// swapcontext是sylar非对称协程实现的关键，线程主协程和子协程用这个接口进行上下文切换</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swapcontext</span><span class="params">(<span class="keyword">ucontext_t</span> *oucp, <span class="keyword">const</span> <span class="keyword">ucontext_t</span> *ucp)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="5-3-协程模块设计"><a href="#5-3-协程模块设计" class="headerlink" title="5.3 协程模块设计"></a>5.3 协程模块设计</h4><p>sylar使用非对称协程模型，也就是子协程只能和线程主协程切换，而不能和另一个子协程切换，并且在程序结束时，一定要再切回主协程，以保证程序能正常结束，像下面这样：</p><img src="sylar服务器开发/image-20230318192033881.png" alt="image-20230318192033881" style="zoom:50%;" /><p><strong>非对称协程:</strong>  是跟一个特定的调用者绑定的，协程让出 CPU 时，只能让回给原调用者。非对称在于程序控制流转移到被调协程时使用的是 call/resume 操作，而当被调协程让出 CPU 时使用的却是 return/yield 操作。此外，协程间的地位也不对等，caller 与 callee 关系是确定的，不可更改的，非对称协程只能返回最初调用它的协程。</p><p><strong>对称协程（symmetric coroutines）：</strong>  对称协程则不一样，启动之后就跟启动之前的协程没有任何关系了。协程的切换操作，一般而言只有一个操作 — yield，用于将程序控制流转移给另外的协程。对称协程机制一般需要一个调度器的支持，按一定调度算法去选择 yield 的目标协程。</p><p>sylar借助了线程局部变量的功能来实现协程模块。<strong>线程局部变量与全局变量类似，不同之处在于声明的线程局部变量在每个线程都独有一份，而全局变量是全部线程共享一份。</strong></p><p>sylar使用线程局部变量（C++11 thread_local变量）来保存协程上下文对象，这点很好理解，因为协程是在线程里运行的，不同线程的协程相互不影响，每个线程都要独自处理当前线程的协程切换问题。</p><p>对于每个线程的协程上下文，sylar设计了两个线程局部变量来存储上下文信息（对应源码的t_fiber和t_thread_fiber），也就是说，一个线程在任何时候最多只能知道两个协程的上下文。又由于sylar只使用swapcontext来做协程切换，那就意味着，<strong>这两个线程局部变量必须至少有一个是用来保存线程主协程的上下文的，</strong>如果这两个线程局部变量存储的都是子协程的上下文，那么不管怎么调用swapcontext，都没法恢复主协程的上下文，也就意味着程序最终无法回到主协程去执行，程序也就跑飞了。</p><p>如果将线程的局部变量设置成一个类似链表的数据结构，那理论上应该也可以实现对称协程，也就是子协程可以直接和子协程切换，但代码复杂度上肯定会增加不少，因为要考虑多线程和公平调度的问题。</p><p>sylar的非对称协程代码实现简单，并且在后面实现协程调度时可以做到公平调度，缺点是子协程只能和线程主协程切换，意味着子协程无法创建并运行新的子协程，并且在后面实现协程调度时，完成一次子协程调度需要额外多切换一次上下文。</p><h4 id="5-4-协程模块实现"><a href="#5-4-协程模块实现" class="headerlink" title="5.4 协程模块实现"></a>5.4 协程模块实现</h4><h5 id="5-4-1-协程状态"><a href="#5-4-1-协程状态" class="headerlink" title="5.4.1 协程状态"></a>5.4.1 协程状态</h5><p>这里在sylar的基础上进行简化，对每个协程，只设计了3种状态，分别是READY，代表就绪态，RUNNING，代表正在运行，TERM，代表运行结束。</p><p>sylar的INIT状态是协程对象刚创建时的状态，这个状态可以直接归到READY状态里，sylar的HOLD状态和READY状态与协程调度有关，READY状态的协程会被调度器自动重新调度，而HOLD状态的协程需要显式地再次将协程加入调度，这两个状态也可以归到READY状态里，反正都表示可执行状态。sylar还给协程设计了一个EXCEPT状态，表示协程入口函数执行时出现异常的状态，这个状态可以不管，具体到协程调度模块再讨论。</p><p>去掉这几个状态后，协程的状态模型就简单得一目了然了，一个协程要么正在运行（RUNNING），要么准备运行（READY），要运行结束（TERM）。</p><img src="sylar服务器开发/image-20230318194016768.png" alt="image-20230318194016768" style="zoom:67%;" /><p><strong>状态简化后，唯一的缺陷是无法区分一个READY状态的协程对象是刚创建，还是已经运行到一半yield了，这在重置协程对象时有影响。</strong></p><p>重置协程时，如果协程对象只是刚创建但一次都没运行过，那应该是允许重置的，但如果协程的状态是运行到一半yield了，那应该不允许重置。虽然可以把INIT状态加上以区分READY状态，但既然简化了状态，那就简化到底，让协程只有在TERM状态下才允许重置，问题迎刃而解。</p><h5 id="5-4-2-协程原语"><a href="#5-4-2-协程原语" class="headerlink" title="5.4.2 协程原语"></a>5.4.2 协程原语</h5><p>对于非对称协程来说，协程除了创建语句外，只有两种操作，一种是resume，表示恢复协程运行，一种是yield，表示让出执行。协程的结束没有专门的操作，协程函数运行结束时协程即结束，协程结束时会自动调用一次yield以返回主协程。</p><h5 id="5-4-3-协程类实现"><a href="#5-4-3-协程类实现" class="headerlink" title="5.4.3 协程类实现"></a>5.4.3 协程类实现</h5><p>sylar的协程通过Fiber类来表示，这个类包含以下成员变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 协程id</span></span><br><span class="line"><span class="keyword">uint64_t</span> m_id        = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// 协程栈大小</span></span><br><span class="line"><span class="keyword">uint32_t</span> m_stacksize = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// 协程状态</span></span><br><span class="line">State m_state        = READY;</span><br><span class="line"><span class="comment">/// 协程上下文</span></span><br><span class="line"><span class="keyword">ucontext_t</span> m_ctx;</span><br><span class="line"><span class="comment">/// 协程栈地址</span></span><br><span class="line"><span class="keyword">void</span> *m_stack = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">/// 协程入口函数</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; m_cb;</span><br></pre></td></tr></table></figure><p>接下来是与协程有关的全局变量和线程局部变量。</p><p>Fiber的源码定义了两个全局静态变量，用于生成协程id和统计当前的协程数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 全局静态变量，用于生成协程id</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; s_fiber_id&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/// 全局静态变量，用于统计当前的协程数</span></span><br><span class="line"><span class="keyword">static</span> <span class="built_in">std</span>::atomic&lt;<span class="keyword">uint64_t</span>&gt; s_fiber_count&#123;<span class="number">0</span>&#125;;</span><br></pre></td></tr></table></figure><p>然后是线程局部变量，对于每个线程，sylar设计了以下两个线程局部变量用于保存协程上下文信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 线程局部变量，当前线程正在运行的协程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber *t_fiber = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">/// 线程局部变量，当前线程的主协程，切换到这个协程，就相当于切换到了主线程中运行，智能指针形式</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber::ptr t_thread_fiber = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><ul><li><code>t_fiber</code>：保存当前正在运行的协程指针，必须时刻指向当前正在运行的协程对象。协程模块初始化时，t_fiber指向线程主协程对象。</li><li><code>t_thread_fiber</code>：保存线程主协程指针，智能指针形式。协程模块初始化时，t_thread_fiber指向线程主协程对象。当子协程resume时，通过swapcontext将主协程的上下文保存到t_thread_fiber的ucontext_t成员中，同时激活子协程的ucontext_t上下文。当子协程yield时，从t_thread_fiber中取得主协程的上下文并恢复运行。</li></ul><p>接下来是协程类Fiber的成员方法。</p><p>首先是协程的构建函数。Fiber类提供了两个构造函数，带参数的构造函数用于构造子协程，初始化子协程的ucontext_t上下文和栈空间，要求必须传入协程的入口函数，以及可选的协程栈大小。不带参的构造函数用于初始化当前线程的协程功能，构造线程主协程对象，以及对t_fiber和t_thread_fiber进行赋值。这个构造函数被定义成私有方法，不允许在类外部调用，只能通过GetThis()方法，在返回当前正在运行的协程时，如果发现当前线程的主协程未被初始化，那就用不带参的构造函数初始化线程主协程。因为GetThis()兼具初始化主协程的功能，在使用协程之前必须显式调用一次GetThis()。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 构造函数</span></span><br><span class="line"><span class="comment"> * @attention 无参构造函数只用于创建线程的第一个协程，也就是线程主函数对应的协程，</span></span><br><span class="line"><span class="comment"> * 这个协程只能由GetThis()方法调用，所以定义成私有方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Fiber::Fiber()&#123;</span><br><span class="line">    SetThis(<span class="keyword">this</span>);</span><br><span class="line">    m_state = RUNNING;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (getcontext(&amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;getcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    ++s_fiber_count;</span><br><span class="line">    m_id = s_fiber_id++; <span class="comment">// 协程id从0开始，用完加1</span></span><br><span class="line"> </span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;Fiber::Fiber() main id = &quot;</span> &lt;&lt; m_id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 构造函数，用于创建用户协程</span></span><br><span class="line"><span class="comment"> * @param[] cb 协程入口函数</span></span><br><span class="line"><span class="comment"> * @param[] stacksize 栈大小，默认为128k</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Fiber::Fiber(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb, <span class="keyword">size_t</span> stacksize)</span><br><span class="line">    : m_id(s_fiber_id++)</span><br><span class="line">    , m_cb(cb) &#123;</span><br><span class="line">    ++s_fiber_count;</span><br><span class="line">    m_stacksize = stacksize ? stacksize : g_fiber_stack_size-&gt;getValue();</span><br><span class="line">    m_stack     = StackAllocator::Alloc(m_stacksize);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (getcontext(&amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;getcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_ctx.uc_link          = <span class="literal">nullptr</span>;</span><br><span class="line">    m_ctx.uc_stack.ss_sp   = m_stack;</span><br><span class="line">    m_ctx.uc_stack.ss_size = m_stacksize;</span><br><span class="line"> </span><br><span class="line">    makecontext(&amp;m_ctx, &amp;Fiber::MainFunc, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;Fiber::Fiber() id = &quot;</span> &lt;&lt; m_id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 返回当前线程正在执行的协程</span></span><br><span class="line"><span class="comment"> * @details 如果当前线程还未创建协程，则创建线程的第一个协程，</span></span><br><span class="line"><span class="comment"> * 且该协程为当前线程的主协程，其他协程都通过这个协程来调度，也就是说，其他协程</span></span><br><span class="line"><span class="comment"> * 结束时,都要切回到主协程，由主协程重新选择新的协程进行resume</span></span><br><span class="line"><span class="comment"> * @attention 线程如果要创建协程，那么应该首先执行一下Fiber::GetThis()操作，以初始化主函数协程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">Fiber::ptr <span class="title">GetThis</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (t_fiber) &#123;</span><br><span class="line">        <span class="keyword">return</span> t_fiber-&gt;shared_from_this();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Fiber::ptr <span class="title">main_fiber</span><span class="params">(<span class="keyword">new</span> Fiber)</span></span>;</span><br><span class="line">    SYLAR_ASSERT(t_fiber == main_fiber.get());</span><br><span class="line">    t_thread_fiber = main_fiber;</span><br><span class="line">    <span class="keyword">return</span> t_fiber-&gt;shared_from_this();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>个人感觉这里的GetThis()方法设计得不太好，用函数的副作用掩盖了线程协程初始化这一重要的操作步骤，更好的设计应该是把线程协程初始化和GetThis()分开，让用户知道自己真正在做的事。</p><p>接下来是协程原语的实现，也就是resume和yield。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 将当前协程切到到执行状态</span></span><br><span class="line"><span class="comment"> * @details 当前协程和正在运行的协程进行交换，前者状态变为RUNNING，后者状态变为READY</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_ASSERT(m_state != TERM &amp;&amp; m_state != RUNNING);</span><br><span class="line">    SetThis(<span class="keyword">this</span>);</span><br><span class="line">    m_state = RUNNING;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (swapcontext(&amp;(t_thread_fiber-&gt;m_ctx), &amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 当前协程让出执行权</span></span><br><span class="line"><span class="comment"> * @details 当前协程与上次resume时退到后台的协程进行交换，前者状态变为READY，后者状态变为RUNNING</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::yield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 协程运行完之后会自动yield一次，用于回到主协程，此时状态已为结束状态</span></span><br><span class="line">    SYLAR_ASSERT(m_state == RUNNING || m_state == TERM);</span><br><span class="line">    SetThis(t_thread_fiber.get());</span><br><span class="line">    <span class="keyword">if</span> (m_state != TERM) &#123;</span><br><span class="line">        m_state = READY;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (swapcontext(&amp;m_ctx, &amp;(t_thread_fiber-&gt;m_ctx))) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在非对称协程里，执行resume时的当前执行环境一定是位于线程主协程里，所以这里的swapcontext操作的结果把主协程的上下文保存到<code>t_thread_fiber-&gt;m_ctx</code>中，并且激活子协程的上下文；而执行yield时，当前执行环境一定是位于子协程里，所以这里的swapcontext操作的结果是把子协程的上下文保存到协程自己的m_ctx中，同时从t_thread_fiber获得主协程的上下文并激活。</p><p>接下来是协程入口函数，sylar在用户传入的协程入口函数上进行了一次封装，这个封装类似于线程模块的对线程入口函数的封装。通过封装协程入口函数，可以实现协程在结束自动执行yield的操作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 协程入口函数</span></span><br><span class="line"><span class="comment"> * @note 这里没有处理协程函数出现异常的情况，同样是为了简化状态管理，并且个人认为协程的异常不应该由框架处理，应该由开发者自行处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::MainFunc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Fiber::ptr cur = GetThis(); <span class="comment">// GetThis()的shared_from_this()方法让引用计数加1</span></span><br><span class="line">    SYLAR_ASSERT(cur);</span><br><span class="line"> </span><br><span class="line">    cur-&gt;m_cb(); <span class="comment">// 这里真正执行协程的入口函数</span></span><br><span class="line">    cur-&gt;m_cb    = <span class="literal">nullptr</span>;</span><br><span class="line">    cur-&gt;m_state = TERM;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">auto</span> raw_ptr = cur.get(); <span class="comment">// 手动让t_fiber的引用计数减1</span></span><br><span class="line">    cur.reset();</span><br><span class="line">    raw_ptr-&gt;yield(); <span class="comment">// 协程结束时自动yield，以回到主协程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是协程的重置，重置协程就是重复利用已结束的协程，复用其栈空间，创建新协程，实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这里为了简化状态管理，强制只有TERM状态的协程才可以重置，但其实刚创建好但没执行过的协程也应该允许重置的</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::reset</span><span class="params">(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb)</span> </span>&#123;</span><br><span class="line">    SYLAR_ASSERT(m_stack);</span><br><span class="line">    SYLAR_ASSERT(m_state == TERM);</span><br><span class="line">    m_cb = cb;</span><br><span class="line">    <span class="keyword">if</span> (getcontext(&amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;getcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_ctx.uc_link          = <span class="literal">nullptr</span>;</span><br><span class="line">    m_ctx.uc_stack.ss_sp   = m_stack;</span><br><span class="line">    m_ctx.uc_stack.ss_size = m_stacksize;</span><br><span class="line"> </span><br><span class="line">    makecontext(&amp;m_ctx, &amp;Fiber::MainFunc, <span class="number">0</span>);</span><br><span class="line">    m_state = READY;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-4-4-其他实现细节"><a href="#5-4-4-其他实现细节" class="headerlink" title="5.4.4 其他实现细节"></a>5.4.4 其他实现细节</h5><p>关于协程id。sylar通过全局静态变量s_fiber_id的自增来生成协程id，每创建一个新协程，s_fiber_id自增1，并作为新协程的id（实际是先取值，再自增1）。</p><p>关于线程主协程的构建。线程主协程代表线程入口函数或是main函数所在的协程，这两种函数都不是以协程的手段创建的，所以它们只有ucontext_t上下文，但没有入口函数，也没有分配栈空间。</p><p>关于协程切换。子协程的resume操作一定是在主协程里执行的，主协程的resume操作一定是在子协程里执行的，这点完美和swapcontext匹配，参考上面协程原语的实现。</p><p>关于智能指针的引用计数，由于t_fiber和t_thread_fiber一个是原始指针一个是智能指针，混用时要注意智能指针的引用计数问题，不恰当的混用可能导致协程对象已经运行结束，但未析构问题。关于协程对象的智能指针引用计数跟踪可参考test_fiber.cc。</p><h4 id="5-5-shared-from-this"><a href="#5-5-shared-from-this" class="headerlink" title="5.5 shared_from_this()"></a>5.5 shared_from_this()</h4><p>使用场景</p><ul><li>当类被 <code>share_ptr</code> 管理</li><li>调用类的成员函数时</li><li>需要把当前对象指针作为参数传给其他函数时</li><li>需要传递一个指向自身的share_ptr</li></ul><p>使用前提</p><ul><li>继承enable_shared_from_this</li></ul><p>通过 shared_ptr 的构造函数，可以让 shared_ptr 对象托管一个 new 运算符返回的指针，写法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">ptr</span><span class="params">(<span class="keyword">new</span> T)</span></span>; <span class="comment">// T 可以是 int、char、类等各种类型</span></span><br></pre></td></tr></table></figure><h3 id="六-协程调度模块"><a href="#六-协程调度模块" class="headerlink" title="六 协程调度模块"></a>六 协程调度模块</h3><p>实现了一个N-M的协程调度器，N个线程运行M个协程，协程可以在线程之间进行切换，也可以绑定到指定线程运行。</p><p><strong>实现协程调度之后，可以解决前一章协程模块中子协程不能运行另一个子协程的缺陷，子协程可以通过向调度器添加调度任务的方式来运行另一个子协程。</strong></p><p>协程调度最难理解的地方是当caller线程也参与调度时调度协程和主线程切换的情况，注意对照源码进行理解。</p><h4 id="6-1-协程调度概述"><a href="#6-1-协程调度概述" class="headerlink" title="6.1 协程调度概述"></a>6.1 协程调度概述</h4><p>**协程调度定义: ** 当你有很多协程时，如何把这些协程都消耗掉。</p><p>在前面的协程模块中，对于每个协程，都需要用户手动调用协程的resume方法将协程运行起来，然后等协程运行结束并返回，再运行下一个协程。这种运行协程的方式其实是用户自己在挑选协程执行，<strong>相当于用户在充当调度器</strong>，显然不够灵活.</p><p>引入协程调度后，则可以先创建一个协程调度器，然后把这些要调度的协程传递给调度器，由调度器负责把这些协程一个一个消耗掉。</p><p>从某种程度来看，协程调度其实非常简单，简单到用下面的代码就可以实现一个调度器，这个调度器可以添加调度任务，运行调度任务，并且还是完全公平调度的，先添加的任务先执行，后添加的任务后执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @file simple_fiber_scheduler.cc</span></span><br><span class="line"><span class="comment"> * @brief 一个简单的协程调度器实现</span></span><br><span class="line"><span class="comment"> * @version 0.1</span></span><br><span class="line"><span class="comment"> * @date 2021-07-10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;sylar/sylar.h&quot;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 简单协程调度类，支持添加调度任务以及运行调度任务</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Scheduler</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加协程调度任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">schedule</span><span class="params">(sylar::Fiber::ptr task)</span> </span>&#123;</span><br><span class="line">        m_tasks.push_back(task);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 执行调度任务</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sylar::Fiber::ptr task;</span><br><span class="line">        <span class="keyword">auto</span> it = m_tasks.begin();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">while</span>(it != m_tasks.end()) &#123;</span><br><span class="line">            task = *it;</span><br><span class="line">            m_tasks.erase(it++);</span><br><span class="line">            task-&gt;resume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 任务队列</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;sylar::Fiber::ptr&gt; m_tasks;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_fiber</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;hello world &quot;</span> &lt;&lt; i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 初始化当前线程的主协程</span></span><br><span class="line">    sylar::Fiber::GetThis();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 创建调度器</span></span><br><span class="line">    Scheduler sc;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 添加调度任务</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        sylar::<span class="function">Fiber::ptr <span class="title">fiber</span><span class="params">(<span class="keyword">new</span> sylar::Fiber(<span class="built_in">std</span>::bind(test_fiber, i)))</span></span>;</span><br><span class="line">        sc.schedule(fiber);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 执行调度任务</span></span><br><span class="line">    sc.run();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>不要觉得上面这个调度器扯淡，除了不支持多线程，sylar的协程调度器和它的设计思路完全相同，甚至，上面的实现可以看成是sylar的协程调度器的一个特例，当sylar的协程调度器只使用main函数所在线程进行调度时，它的工作原理和上面的完全一样，只不过代码看起来更花里胡哨一些。</p></blockquote><p><strong>接下来将从上面这个调度器开始，来分析一些和协程调度器相关的概念。</strong></p><p>首先是关于调度任务的定义，对于协程调度器来说，协程当然可以作为调度任务，但实际上，函数也应可以，因为函数也是可执行的对象，调度器应当支持直接调度一个函数。这在代码实现上也很简单，只需要<strong>将函数包装成协程即可，协程调度器的实现重点还是以协程为基础。</strong></p><p>接下来是多线程，通过前面协程模块的知识我们可以知道，一个线程同一时刻只能运行一个协程，所以，作为<strong>协程调度器，势必要用到多线程来提高调度的效率，</strong>因为有多个线程就意味着有多个协程可以同时执行，这显然是要好过单线程的。</p><p>既然多线程可以提高协程调度的效率，那么，能不能把调度器所在的线程（称为caller线程）也加入进来作为调度线程呢？比如典型地，在main函数中定义的调度器，能不能把main函数所在的线程也用来执行调度任务呢？答案是肯定的，在实现相同调度能力的情况下（指能够同时调度的协程数量），线程数越小，线程切换的开销也就越小，效率就更高一些，所以，调度器所在的线程，也应该支持用来执行调度任务。甚至，调度器完全可以不创建新的线程，而只使用caller线程来进行协程调度，比如只使用main函数所在的线程来进行协程调度。</p><p>接下来是调度器如何运行，这里可以简单地认为，<strong>调度器创建后，内部首先会创建一个调度线程池，调度开始后，所有调度线程按顺序从任务队列里取任务执行，调度线程数越多，能够同时调度的任务也就越多，当所有任务都调度完后，调度线程就停下来等新的任务进来。</strong></p><p>接下来是添加调度任务，添加调度任务的本质就是往调度器的任务队列里塞任务，但是，只添加调度任务是不够的，还应该有一种方式用于通知调度线程有新的任务加进来了，因为调度线程并不一定知道有新任务进来了。当然调度线程也可以不停地轮询有没有新任务，但是这样CPU占用率会很高。</p><p>接下来是调度器的停止。调度器应该支持停止调度的功能，以便回收调度线程的资源，只有当所有的调度线程都结束后，调度器才算真正停止。</p><p>通过上面的描述，一个协程调度器的大概设计也就出炉了：</p><p><strong>调度器内部维护一个任务队列和一个调度线程池。开始调度后，线程池从任务队列里按顺序取任务执行。调度线程可以包含caller线程。当全部任务都执行完了，线程池停止调度，等新的任务进来。添加新任务后，通知线程池有新的任务进来了，线程池重新开始运行调度。停止调度时，各调度线程退出，调度器停止工作。</strong></p><h4 id="6-2-协程调度模块设计"><a href="#6-2-协程调度模块设计" class="headerlink" title="6.2 协程调度模块设计"></a>6.2 协程调度模块设计</h4><p>sylar的协程调度模块支持多线程，支持使用caller线程进行调度，支持添加函数或协程作为调度对象，并且支持将函数或协程绑定到一个具体的线程上执行。</p><ul><li><strong>首先是协程调度器的初始化。</strong> sylar的协程调度器在初始化时支持传入线程数和一个布尔型的use_caller参数，表示是否使用caller线程。在使用caller线程的情况下，线程数自动减一，并且调度器内部会初始化一个属于caller线程的调度协程并保存起来（比如，在main函数中创建的调度器，如果use_caller为true，那调度器会初始化一个属于main函数线程的调度协程）。</li></ul><p>调度器创建好后，即可调用调度器的schedule方法向调度器添加调度任务，但此时调度器并不会立刻执行这些任务，而是将它们保存到内部的一个任务队列中。</p><ul><li><p><strong>接下来是调用start方法启动调度。</strong>start方法调用后会创建调度线程池，线程数量由初始化时的线程数和use_caller确定。调度线程一旦创建，就会立刻从任务队列里取任务执行。比较特殊的一点是，如果初始化时指定线程数为1且use_caller为true，那么start方法什么也不做，因为不需要创建新线程用于调度。并且，由于没有创建新的调度线程，那只能由caller线程的调度协程来负责调度协程，而caller线程的调度协程的执行时机与start方法并不在同一个地方。</p></li><li><p><strong>接下来是调度协程，对应run方法。</strong>调度协程负责从调度器的任务队列中取任务执行。取出的任务即子协程，这里调度协程和子协程的切换模型即为前一章介绍的非对称模型，每个子协程执行完后都必须返回调度协程，由调度协程重新从任务队列中取新的协程并执行。如果任务队列空了，那么调度协程会切换到一个idle协程，这个idle协程什么也不做，等有新任务进来时，idle协程才会退出并回到调度协程，重新开始下一轮调度。</p></li></ul><p>在非caller线程里，调度协程就是调度线程的主线程，但在caller线程里，调度协程并不是caller线程的主协程，而是相当于caller线程的子协程，这在协程切换时会有大麻烦（这点是sylar协程调度模块最难理解的地方），如何处理这个问题将在下面的章节专门进行讨论。</p><ul><li><strong>接下来是添加调度任务，对应schedule方法，</strong>这个方法支持传入协程或函数，并且支持一个线程号参数，表示是否将这个协程或函数绑定到一个具体的线程上执行。如果任务队列为空，那么在添加任务之后，要调用一次tickle方法以通知各调度线程的调度协程有新任务来了。</li></ul><p>在执行调度任务时，还可以通过调度器的GetThis()方法获取到当前调度器，再通过schedule方法继续添加新的任务，这就变相实现了在子协程中创建并运行新的子协程的功能。</p><ul><li><strong>接下来是调度器的停止。</strong>调度器的停止行为要分两种情况讨论，首先是use_caller为false的情况，这种情况下，由于没有使用caller线程进行调度，那么只需要简单地等各个调度线程的调度协程退出就行了。如果use_caller为true，表示caller线程也要参于调度，这时，调度器初始化时记录的属于caller线程的调度协程就要起作用了，在调度器停止前，应该让这个caller线程的调度协程也运行一次，让caller线程完成调度工作后再退出。如果调度器只使用了caller线程进行调度，那么所有的调度任务要在调度器停止时才会被调度。</li></ul><h4 id="6-3-调度协程切换问题"><a href="#6-3-调度协程切换问题" class="headerlink" title="6.3 调度协程切换问题"></a>6.3 调度协程切换问题</h4><p>这里分两种典型情况来讨论一下调度协程的切换情况，其他情况可以看成以下两种情况的组合，原理是一样的。</p><ol><li><p>线程数为1，且use_caller为true，对应只使用main函数线程进行协程调度的情况。</p></li><li><p>线程数为1，且use_caller为false，对应额外创建一个线程进行协程调度、main函数线程不参与调度的情况。</p></li></ol><p>这里先说情况2。情况2比较好理解，因为有单独的线程用于协程调度，那<strong>只需要让新线程的入口函数作为调度协程，从任务队列里取任务执行就行了，main函数与调度协程完全不相关，main函数只需要向调度器添加任务，然后在适当的时机停止调度器即可</strong>。当调度器停止时，main函数要等待调度线程结束后再退出，参考下面的图示：</p><img src="sylar服务器开发/image-20230319203546110.png" alt="image-20230319203546110" style="zoom:50%;" /><p><strong>情况1则比较复杂，因为没有额外的线程进行协程调度，那只能用main函数所在的线程来进行调度，而梳理一下main函数线程要运行的协程，会发现有以下三类协程：</strong></p><ol><li><p>main函数对应的主协程</p></li><li><p>调度协程</p></li><li><p>待调度的任务协程</p></li></ol><p>在main函数线程里这三类协程运行的顺序是这样的：</p><ol><li><p>main函数主协程运行，创建调度器</p></li><li><p>仍然是main函数主协程运行，向调度器添加一些调度任务</p></li><li><p>开始协程调度，main函数主协程让出执行权，切换到调度协程，调度协程从任务队列里按顺序执行所有的任务</p></li><li><p>每次执行一个任务，调度协程都要让出执行权，再切到该任务的协程里去执行，任务执行结束后，还要再切回调度协程，继续下一个任务的调度</p></li><li><p>所有任务都执行完后，调度协程还要让出执行权并切回main函数主协程，以保证程序能顺利结束。</p></li></ol><p>上面的过程也可以总结为：main函数先攒下一波协程，然后切到调度协程里去执行，等把这些协程都消耗完后，再从调度协程切回来，像下面这样第一幅图：</p><img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230319212526038.png" class="" title="image-20230319212526038"><img src="sylar服务器开发/image-20230319204322600.png" alt="image-20230319204322600" style="zoom: 50%;" /><p>然而，回顾一下前面协程模块就会发现，上面这种协程切换实际是有问题的，参考上面第二幅图：</p><blockquote><p><strong>在非对称协程里，子协程只能和线程主协程切换，而不能和另一个子协程切换。</strong> 在上面的情况1中，线程主协程是main函数对应的协程，另外的两类协程，也就是调度协程和任务协程，都是子协程，也就是说，调度协程不能直接和任务协程切换，一旦切换，程序的main函数协程就跑飞了。</p></blockquote><p>==解决单线程环境下caller线程主协程-调度协程-任务协程之间的上下文切换，是sylar协程调度实现的关键。==</p><blockquote><p>其实，子协程和子协程切换导致线程主协程跑飞的<strong>关键原因在于，每个线程只有两个线程局部变量用于保存当前的协程上下文信息。也就是说线程任何时候都最多只能知道两个协程的上下文，其中一个是当前正在运行协程的上下文，另一个是线程主协程的上下文，如果子协程和子协程切换，那这两个上下文都会变成子协程的上下文，线程主协程的上下文丢失了，程序也就跑飞了。</strong> 如果不改变这种局部，就只能线程主协程去充当调度协程，这就相当于又回到了让用户充当调度器的情况。</p></blockquote><p>那么，如何改变这种情况呢？其实非常简单，<strong>只需要给每个线程增加一个线程局部变量用于保存调度协程的上下文就可以了</strong>，这样，每个线程可以同时保存三个协程的上下文，一个是当前正在执行的协程上下文，另一个是线程主协程的上下文，最后一个是调度协程的上下文。有了这三个上下文，协程就可以根据自己的身份来选择和每次和哪个协程进行交换，具体操作如下：</p><ul><li>给协程类增加一个bool类型的成员m_runInScheduler，用于记录该协程是否通过调度器来运行。</li><li>  创建协程时，根据协程的身份指定对应的协程类型，具体来说，只有想让调度器调度的协程的m_runInScheduler值为true，线程主协程和线程调度协程的m_runInScheduler都为false。</li><li>resume一个协程时，如果如果这个协程的m_runInScheduler值为true，表示这个协程参与调度器调度，那它应该和三个线程局部变量中的调度协程上下文进行切换，同理，在协程yield时，也应该恢复调度协程的上下文，表示从子协程切换回调度协程；</li><li>如果协程的m_runInScheduler值为false，表示这个协程不参与调度器调度，那么在resume协程时，直接和线程主协程切换就可以了，yield也一样，应该恢复线程主协程的上下文。m_runInScheduler值为false的协程上下文切换完全和调度协程无关，可以脱离调度器使用。</li></ul><p>经过上面的改造了，就可以解决单线程环境下caller线程主协程-调度协程-任务协程之间的上下文切换问题了，假设caller线程主协程的上下文为main_ctx，调度协程的上下文为scheduler_ctx，任务协程上下文为child_ctx，那么单线程下的协程切换将像下面这样</p><img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230319212615489.png" class="" title="image-20230319212615489"><h4 id="6-4-其他情况的讨论"><a href="#6-4-其他情况的讨论" class="headerlink" title="6.4 其他情况的讨论"></a>6.4 其他情况的讨论</h4><ol><li><strong>调度器的退出问题</strong>。调度器内部有一个协程任务队列，调度器调度的实质就是内部的线程池从这个任务队列拿任务并执行，那么，停止调度时，如果任务队列还有任务剩余，要怎么处理？这里可以简化处理，强制规定只有所有的任务都完成调度时，调度器才可以退出，如果有一个任务没有执行完，那调度器就不能退出。</li><li><strong>任务协程执行过程中主动调用yield让出了执行权，调度器要怎么处理？</strong>协程在主动执行yield前，必须先将自己重新添加到调度器的任务队列中。如果协程不顾后果地执行yield，最后的后果就是协程将永远无法再被执行，也就是所说的逃逸状态。（sylar的处理方法比较折衷一些，sylar定义了两种yield操作，一种是yield to ready，这种yield调度器会再次将协程加入任务队列并等待调度，另一种是yield to hold，这种yield调度器不会再将协程加入任务队列，协程在yield之前必须自己先将自己加入到协程的调度队列中，否则协程就处于逃逸状态。再说一点，sylar定义的yield to ready，在整个sylar框架内一次都没用到，看来sylar也同意，一个成熟的协程要学会自我管理。）</li><li>只使用调度器所在的线程进行调度，典型的就是main函数中定义调度器并且只使用main函数线程执行调度任务。这种场景下，可以认为是main函数先攒下一波协程，然后切到调度协程，把这些协程消耗完后再从调度协程切回main函数协程。每个协程在运行时也可以继续创建新的协程并加入调度。如果所有协程都调度完了，并且没有创建新的调度任务，那么下一步就是讨论idle(闲置)该如何处理。</li><li><strong>idle如何处理，也就是当调度器没有协程可调度时，调度协程该怎么办。</strong> 直觉上来看这里应该有一些同步手段，比如，没有调度任务时，调度协程阻塞住，比如阻塞在一个idle协程上，等待新任务加入后退出idle协程，恢复调度。然而这种方案是无法实现的，因为每个线程同一时间只能有一个协程在执行，如果调度线程阻塞在idle协程上，那么除非idle协程自行让出执行权，否则其他的协程都得不到执行，这里就造成了一个先有鸡还是先有蛋的问题：只有创建新任务idle协程才会退出，只有idle协程退出才能创建新任务。<strong>为了解决这个问题，sylar采取了一个简单粗暴的办法，如果任务队列空了，调度协程会不停地检测任务队列，看有没有新任务，俗称忙等待，CPU使用率爆表。</strong> 这点可以从sylar的源码上发现，一是Scheduler的tickle函数什么也不做，因为根本不需要通知调度线程是否有新任务，二是idle协程在协程调度器未停止的情况下只会yield to hold，而调度协程又会将idle协程重新swapIn，相当于idle啥也不做直接返回。这个问题在sylar框架内无解，只有一种方法可以规避掉，那就是设置autostop标志，这个标志会使得调度器在调度完所有任务后自动退出。在后续的IOManager中，上面的问题会得到一定的改善，并且tickle和idle可以实现得更加巧妙一些，以应对IO事件。</li><li><strong>只有main函数线程参与调度时的调度执行时机。</strong> 前面说过，当只有main函数线程参与调度时，可以认为是主线程先攒下一波协程，然后切到调度协程开始调度这些协程，等所有的协程都调度完了，调度协程进idle状态，这个状态下<strong>调度器只能执行忙等待，啥也做不了。</strong> 这也就是说，主线程main函数一旦开启了协程调度，就无法回头了，位于开始调度点之后的代码都执行不到。对于这个问题，<strong>sylar把调度器的开始点放在了stop方法中，也就是，调度开始即结束，干完活就下班(这样的话 就可以理解上面的那副图了)。</strong>IOManager也是类似，除了可以调用stop方法外，IOManager类的析构函数也有一个stop方法，可以保证所有的任务都会被调度到。</li><li><strong>额外创建了调度线程时的调度执行时机。</strong> 如果不额外创建线程，也就是线程数为1并且use caller，那所有的调度任务都在stop()时才会进行调度。但如果额外创建了线程，那么，在添加完调度任务之后任务马上就可以在另一个线程中调度执行。归纳起来，如果只使用caller线程进行调度，那所有的任务协程都在stop之后排队调度，如果有额外线程，那任务协程在刚添加到任务队列时就可以得到调度。</li><li>协程中的异常要怎么处理，子协程抛出了异常该怎么办？这点其实非常好办，类比一下线程即可，你会在线程外面处理线程抛出的异常吗？答案是不会，所以协程抛出的异常我们也不处理，直接让程序按默认的处理方式来处理即可。一个成熟的协程应该自己处理掉自己的异常，而不是让调度器来帮忙。顺便说一下，sylar的协程调度器处理了协程抛出的异常，并且给异常结束的协程设置了一个EXCEPT状态，这看似贴心，但从长远的角度来看，其实是非常不利于协程的健康成长的。</li><li>关于协程调度器的优雅停止。sylar停止调度器的策略如下：<ul><li>设置m_stopping标志，该标志表示正在停止</li><li>检测是否使用了caller线程进行调度，如果使用了caller线程进行调度，那要保证stop方法是由caller线程发起的</li><li>通知其他调度线程的调度协程退出调度</li><li>通知当前线程的调度协程退出调度</li><li>如果使用了caller线程进行调度，那执行一次caller线程的调度协程（只使用caller线程时的协程调度全仰仗这个操作）</li><li>等caller线程的调度协程返回</li><li>等所有调度线程结束</li></ul></li></ol><h4 id="6-5-调度模块实现"><a href="#6-5-调度模块实现" class="headerlink" title="6.5 调度模块实现"></a>6.5 调度模块实现</h4><h5 id="6-5-1-协程模块改造"><a href="#6-5-1-协程模块改造" class="headerlink" title="6.5.1 协程模块改造"></a>6.5.1 协程模块改造</h5><p>首先是对协程模块的改造，<strong>增加m_runInScheduler成员，表示当前协程是否参与调度器调度，在协程的resume和yield时，根据协程的运行环境确定是和线程主协程进行交换还是和调度协程进行交换：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">Fiber::Fiber(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb, <span class="keyword">size_t</span> stacksize, <span class="keyword">bool</span> run_in_scheduler)</span><br><span class="line">    : m_id(s_fiber_id++)</span><br><span class="line">    , m_cb(cb)</span><br><span class="line">    , m_runInScheduler(run_in_scheduler) &#123;</span><br><span class="line">    ++s_fiber_count;</span><br><span class="line">    m_stacksize = stacksize ? stacksize : g_fiber_stack_size-&gt;getValue();</span><br><span class="line">    m_stack     = StackAllocator::Alloc(m_stacksize);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (getcontext(&amp;m_ctx)) &#123;</span><br><span class="line">        SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;getcontext&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    m_ctx.uc_link          = <span class="literal">nullptr</span>;</span><br><span class="line">    m_ctx.uc_stack.ss_sp   = m_stack;</span><br><span class="line">    m_ctx.uc_stack.ss_size = m_stacksize;</span><br><span class="line"> </span><br><span class="line">    makecontext(&amp;m_ctx, &amp;Fiber::MainFunc, <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;Fiber::Fiber() id = &quot;</span> &lt;&lt; m_id;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_ASSERT(m_state != TERM &amp;&amp; m_state != RUNNING);</span><br><span class="line">    SetThis(<span class="keyword">this</span>);</span><br><span class="line">    m_state = RUNNING;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果协程参与调度器调度，那么应该和调度器的主协程进行swap，而不是线程主协程</span></span><br><span class="line">    <span class="keyword">if</span> (m_runInScheduler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (swapcontext(&amp;(Scheduler::GetMainFiber()-&gt;m_ctx), &amp;m_ctx)) &#123;</span><br><span class="line">            SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (swapcontext(&amp;(t_thread_fiber-&gt;m_ctx), &amp;m_ctx)) &#123;</span><br><span class="line">            SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Fiber::yield</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/// 协程运行完之后会自动yield一次，用于回到主协程，此时状态已为结束状态</span></span><br><span class="line">    SYLAR_ASSERT(m_state == RUNNING || m_state == TERM);</span><br><span class="line">    SetThis(t_thread_fiber.get());</span><br><span class="line">    <span class="keyword">if</span> (m_state != TERM) &#123;</span><br><span class="line">        m_state = READY;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 如果协程参与调度器调度，那么应该和调度器的主协程进行swap，而不是线程主协程</span></span><br><span class="line">    <span class="keyword">if</span> (m_runInScheduler) &#123;</span><br><span class="line">        <span class="keyword">if</span> (swapcontext(&amp;m_ctx, &amp;(Scheduler::GetMainFiber()-&gt;m_ctx))) &#123;</span><br><span class="line">            SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (swapcontext(&amp;m_ctx, &amp;(t_thread_fiber-&gt;m_ctx))) &#123;</span><br><span class="line">            SYLAR_ASSERT2(<span class="literal">false</span>, <span class="string">&quot;swapcontext&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="6-5-2-调度任务"><a href="#6-5-2-调度任务" class="headerlink" title="6.5.2 调度任务"></a>6.5.2 调度任务</h5><p>然后是对调度任务的定义，如下，这里任务类型可以是协程/函数二选一，并且可指定调度线程。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 调度任务，协程/函数二选一，可指定在哪个线程上调度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ScheduleTask</span> &#123;</span></span><br><span class="line">    Fiber::ptr fiber;</span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb;</span><br><span class="line">    <span class="keyword">int</span> thread;</span><br><span class="line"> </span><br><span class="line">    ScheduleTask(Fiber::ptr f, <span class="keyword">int</span> thr) &#123;</span><br><span class="line">        fiber  = f;</span><br><span class="line">        thread = thr;</span><br><span class="line">    &#125;</span><br><span class="line">    ScheduleTask(Fiber::ptr *f, <span class="keyword">int</span> thr) &#123;</span><br><span class="line">        fiber.swap(*f);</span><br><span class="line">        thread = thr;</span><br><span class="line">    &#125;</span><br><span class="line">    ScheduleTask(<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; f, <span class="keyword">int</span> thr) &#123;</span><br><span class="line">        cb     = f;</span><br><span class="line">        thread = thr;</span><br><span class="line">    &#125;</span><br><span class="line">    ScheduleTask() &#123; thread = <span class="number">-1</span>; &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        fiber  = <span class="literal">nullptr</span>;</span><br><span class="line">        cb     = <span class="literal">nullptr</span>;</span><br><span class="line">        thread = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是调度器的成员变量，包括以下成员：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 协程调度器名称</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> m_name;</span><br><span class="line"><span class="comment">/// 互斥锁</span></span><br><span class="line">MutexType m_mutex;</span><br><span class="line"><span class="comment">/// 线程池</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Thread::ptr&gt; m_threads;</span><br><span class="line"><span class="comment">/// 任务队列</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;ScheduleTask&gt; m_tasks;</span><br><span class="line"><span class="comment">/// 线程池的线程ID数组</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m_threadIds;</span><br><span class="line"><span class="comment">/// 工作线程数量，不包含use_caller的主线程</span></span><br><span class="line"><span class="keyword">size_t</span> m_threadCount = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// 活跃线程数</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; m_activeThreadCount = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/// idle线程数</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; m_idleThreadCount = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 是否use caller</span></span><br><span class="line"><span class="keyword">bool</span> m_useCaller;</span><br><span class="line"><span class="comment">/// use_caller为true时，调度器所在线程的调度协程</span></span><br><span class="line">Fiber::ptr m_rootFiber;</span><br><span class="line"><span class="comment">/// use_caller为true时，调度器所在线程的id</span></span><br><span class="line"><span class="keyword">int</span> m_rootThread = <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 是否正在停止</span></span><br><span class="line"><span class="keyword">bool</span> m_stopping = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><h5 id="6-5-3-三个协程上下文信息"><a href="#6-5-3-三个协程上下文信息" class="headerlink" title="6.5.3 三个协程上下文信息"></a>6.5.3 三个协程上下文信息</h5><p>接下来是协程调度模块的全局变量和线程局部变量，这里只有以下两个线程局部变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 当前线程的调度器，同一个调度器下的所有线程指同同一个调度器实例</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Scheduler *t_scheduler = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/// 当前线程的调度协程，每个线程都独有一份，包括caller线程</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">thread_local</span> Fiber *t_scheduler_fiber = <span class="literal">nullptr</span>;</span><br></pre></td></tr></table></figure><p>t_scheduler_fiber保存当前线程的调度协程，加上Fiber模块的t_fiber和t_thread_fiber，每个线程总共可以记录三个协程的上下文信息。</p><h5 id="6-5-4-调度器的构造方法"><a href="#6-5-4-调度器的构造方法" class="headerlink" title="6.5.4 调度器的构造方法"></a>6.5.4 调度器的构造方法</h5><p>调度器的构造方法，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 创建调度器</span></span><br><span class="line"><span class="comment"> * @param[in] threads 线程数</span></span><br><span class="line"><span class="comment"> * @param[in] use_caller 是否将当前线程也作为调度线程</span></span><br><span class="line"><span class="comment"> * @param[in] name 名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">Scheduler::Scheduler(<span class="keyword">size_t</span> threads, <span class="keyword">bool</span> use_caller, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name) &#123;</span><br><span class="line">    SYLAR_ASSERT(threads &gt; <span class="number">0</span>);</span><br><span class="line"> </span><br><span class="line">    m_useCaller = use_caller;</span><br><span class="line">    m_name      = name;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (use_caller) &#123;</span><br><span class="line">        --threads;</span><br><span class="line">        sylar::Fiber::GetThis();</span><br><span class="line">        SYLAR_ASSERT(GetThis() == <span class="literal">nullptr</span>);</span><br><span class="line">        t_scheduler = <span class="keyword">this</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 在user_caller为true的情况下，初始化caller线程的调度协程</span></span><br><span class="line"><span class="comment">         * caller线程的调度协程不会被调度器调度，而且，caller线程的调度协程停止时，应该返回caller线程的主协程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        m_rootFiber.reset(<span class="keyword">new</span> Fiber(<span class="built_in">std</span>::bind(&amp;Scheduler::run, <span class="keyword">this</span>), <span class="number">0</span>, <span class="literal">false</span>));</span><br><span class="line"> </span><br><span class="line">        sylar::Thread::SetName(m_name);</span><br><span class="line">        t_scheduler_fiber = m_rootFiber.get();</span><br><span class="line">        m_rootThread      = sylar::GetThreadId();</span><br><span class="line">        m_threadIds.push_back(m_rootThread);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        m_rootThread = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_threadCount = threads;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Scheduler *<span class="title">Scheduler::GetThis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_scheduler;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">接下来是两个get方法，用于获取当前线程的调度器的调度协程，这两个都是静态方法：</span><br><span class="line"></span><br><span class="line"><span class="function">Scheduler *<span class="title">Scheduler::GetThis</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_scheduler;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">Fiber *<span class="title">Scheduler::GetMainFiber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t_scheduler_fiber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是协程调度器的start方法实现，这里主要初始化调度线程池，如果只使用caller线程进行调度，那这个方法啥也不做：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;start&quot;</span>;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (m_stopping) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;Scheduler is stopped&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SYLAR_ASSERT(m_threads.empty());</span><br><span class="line">    m_threads.resize(m_threadCount);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_threadCount; i++) &#123;</span><br><span class="line">        m_threads[i].reset(<span class="keyword">new</span> Thread(<span class="built_in">std</span>::bind(&amp;Scheduler::run, <span class="keyword">this</span>),</span><br><span class="line">                                      m_name + <span class="string">&quot;_&quot;</span> + <span class="built_in">std</span>::to_string(i)));</span><br><span class="line">        m_threadIds.push_back(m_threads[i]-&gt;getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来判断调度器是否已经停止的方法，只有当所有的任务都被执行完了，调度器才可以停止：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Scheduler::stopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> m_stopping &amp;&amp; m_tasks.empty() &amp;&amp; m_activeThreadCount == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是调度器的tickle和idle实现，可以看到这两个方法并没有什么卵用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::tickle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;ticlke&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::idle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;idle&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (!stopping()) &#123;</span><br><span class="line">        sylar::Fiber::GetThis()-&gt;yield();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是调度协程的实现，内部有一个while(true)循环，不停地从任务队列取任务并执行，由于Fiber类改造过，每个被调度器执行的协程在结束时都会回到调度协程，所以这里不用担心跑飞问题，当任务队列为空时，代码会进idle协程，但idle协程啥也不做直接就yield了，状态还是READY状态，所以这里其实就是个忙等待，CPU占用率爆炸，只有当调度器检测到停止标志时，idle协程才会真正结束，调度协程也会检测到idle协程状态为TERM，并且随之退出整个调度协程。这里还可以看出一点，对于一个任务协程，只要其从resume中返回了，那不管它的状态是TERM还是READY，调度器都不会自动将其再次加入调度，因为前面说过，一个成熟的协程是要学会自我管理的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;run&quot;</span>;</span><br><span class="line">    setThis();</span><br><span class="line">    <span class="keyword">if</span> (sylar::GetThreadId() != m_rootThread) &#123;</span><br><span class="line">        t_scheduler_fiber = sylar::Fiber::GetThis().get();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function">Fiber::ptr <span class="title">idle_fiber</span><span class="params">(<span class="keyword">new</span> Fiber(<span class="built_in">std</span>::bind(&amp;Scheduler::idle, <span class="keyword">this</span>)))</span></span>;</span><br><span class="line">    Fiber::ptr cb_fiber;</span><br><span class="line"> </span><br><span class="line">    ScheduleTask task;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        task.reset();</span><br><span class="line">        <span class="keyword">bool</span> tickle_me = <span class="literal">false</span>; <span class="comment">// 是否tickle其他线程进行任务调度</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">            <span class="keyword">auto</span> it = m_tasks.begin();</span><br><span class="line">            <span class="comment">// 遍历所有调度任务</span></span><br><span class="line">            <span class="keyword">while</span> (it != m_tasks.end()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;thread != <span class="number">-1</span> &amp;&amp; it-&gt;thread != sylar::GetThreadId()) &#123;</span><br><span class="line">                    <span class="comment">// 指定了调度线程，但不是在当前线程上调度，标记一下需要通知其他线程进行调度，然后跳过这个任务，继续下一个</span></span><br><span class="line">                    ++it;</span><br><span class="line">                    tickle_me = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 找到一个未指定线程，或是指定了当前线程的任务</span></span><br><span class="line">                SYLAR_ASSERT(it-&gt;fiber || it-&gt;cb);</span><br><span class="line">                <span class="keyword">if</span> (it-&gt;fiber) &#123;</span><br><span class="line">                    <span class="comment">// 任务队列时的协程一定是READY状态，谁会把RUNNING或TERM状态的协程加入调度呢？</span></span><br><span class="line">                    SYLAR_ASSERT(it-&gt;fiber-&gt;getState() == Fiber::READY);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 当前调度线程找到一个任务，准备开始调度，将其从任务队列中剔除，活动线程数加1</span></span><br><span class="line">                task = *it;</span><br><span class="line">                m_tasks.erase(it++);</span><br><span class="line">                ++m_activeThreadCount;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 当前线程拿完一个任务后，发现任务队列还有剩余，那么tickle一下其他线程</span></span><br><span class="line">            tickle_me |= (it != m_tasks.end());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (tickle_me) &#123;</span><br><span class="line">            tickle();</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">if</span> (task.fiber) &#123;</span><br><span class="line">            <span class="comment">// resume协程，resume返回时，协程要么执行完了，要么半路yield了，总之这个任务就算完成了，活跃线程数减一</span></span><br><span class="line">            task.fiber-&gt;resume();</span><br><span class="line">            --m_activeThreadCount;</span><br><span class="line">            task.reset();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (task.cb) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cb_fiber) &#123;</span><br><span class="line">                cb_fiber-&gt;reset(task.cb);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cb_fiber.reset(<span class="keyword">new</span> Fiber(task.cb));</span><br><span class="line">            &#125;</span><br><span class="line">            task.reset();</span><br><span class="line">            cb_fiber-&gt;resume();</span><br><span class="line">            --m_activeThreadCount;</span><br><span class="line">            cb_fiber.reset();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 进到这个分支情况一定是任务队列空了，调度idle协程即可</span></span><br><span class="line">            <span class="keyword">if</span> (idle_fiber-&gt;getState() == Fiber::TERM) &#123;</span><br><span class="line">                <span class="comment">// 如果调度器没有调度任务，那么idle协程会不停地resume/yield，不会结束，如果idle协程结束了，那一定是调度器停止了</span></span><br><span class="line">                SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;idle fiber term&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++m_idleThreadCount;</span><br><span class="line">            idle_fiber-&gt;resume();</span><br><span class="line">            --m_idleThreadCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;Scheduler::run() exit&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后是调度器的stop方法，在使用了caller线程的情况下，调度器依赖stop方法来执行caller线程的调度协程，如果调度器只使用了caller线程来调度，那调度器真正开始执行调度的位置就是这个stop方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Scheduler::stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;stop&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> (stopping()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_stopping = <span class="literal">true</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 如果use caller，那只能由caller线程发起stop</span></span><br><span class="line">    <span class="keyword">if</span> (m_useCaller) &#123;</span><br><span class="line">        SYLAR_ASSERT(GetThis() == <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        SYLAR_ASSERT(GetThis() != <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_threadCount; i++) &#123;</span><br><span class="line">        tickle();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> (m_rootFiber) &#123;</span><br><span class="line">        tickle();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 在use caller情况下，调度器协程结束时，应该返回caller协程</span></span><br><span class="line">    <span class="keyword">if</span> (m_rootFiber) &#123;</span><br><span class="line">        m_rootFiber-&gt;resume();</span><br><span class="line">        SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;m_rootFiber end&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Thread::ptr&gt; thrs;</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        thrs.swap(m_threads);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;i : thrs) &#123;</span><br><span class="line">        i-&gt;join();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-6-注意事项"><a href="#6-6-注意事项" class="headerlink" title="6.6 注意事项"></a>6.6 注意事项</h4><p>sylar的协程调度模块因为存任务队列空闲时调度线程忙等待的问题，所以<strong>实际上并不实用，真正实用的是后面基于Scheduler实现的IOManager。</strong>由于任务队列的任务是按顺序执行的，如果有一个任务占用了比较长时间，那其他任务的执行会受到影响，如果任务执行的是像while(1)这样的循环，那线程数不够时，后面的任务都不会得到执行。另外，当前还没有实现hook功能，像sleep和等待IO就绪这样的操作也会阻塞协程调度。</p><h3 id="七-IO协程调度模块"><a href="#七-IO协程调度模块" class="headerlink" title="七 IO协程调度模块"></a>七 IO协程调度模块</h3><p>继承自协程调度器，封装了epoll，支持为socket fd注册读写事件回调函数。</p><p><strong>IO协程调度还解决了调度器在idle状态下忙等待导致CPU占用率高的问题。</strong> IO协程调度器使用一对管道fd来tickle调度协程，当调度器空闲时，idle协程通过epoll_wait阻塞在管道的读描述符上，等管道的可读事件。添加新任务时，tickle方法写管道，idle协程检测到管道可读后退出，调度器执行调度。</p><h4 id="7-1-IO协程调度概述"><a href="#7-1-IO协程调度概述" class="headerlink" title="7.1 IO协程调度概述"></a>7.1 IO协程调度概述</h4><p>IO协程调度可以看成是增强版的协程调度。</p><blockquote><p>在前面的协程调度模块中，调度器对协程的调度是无条件执行的，在调度器已经启动调度的情况下，任务一旦添加成功，就会排队等待调度器执行。调度器不支持删除调度任务，并且调度器在正常退出之前一定会执行完全部的调度任务，所以在某种程度上可以认为，把一个协程添加到调度器的任务队列，就相当于调用了协程的resume方法。</p></blockquote><p>IO协程调度支持协程调度的全部功能，因为IO协程调度器是直接继承协程调度器实现的。除了协程调度，<strong>IO协程调度还增加了IO事件调度的功能，这个功能是针对描述符（一般是套接字描述符）的。</strong> IO协程调度支持为描述符注册可读和可写事件的回调函数，当描述符可读或可写时，执行对应的回调函数。（这里可以直接把回调函数等效成协程，所以这个功能被称为IO协程调度）</p><p>IO事件调度功能对服务器开发至关重要，因为服务器通常需要处理大量来自客户端的socket fd，<strong>使用IO事件调度可以将开发者从判断socket fd是否可读或可写的工作中解放出来，使得程序员只需要关心socket fd的IO操作。</strong> 后续的socket api hook模块也依赖IO协程调度。</p><blockquote><p>很多的库都可以实现类似的工作，比如libevent，libuv，libev等，这些库被称为异步事件库或异步IO库，从网上可以很容易地找到大把的资料介绍这类库。有的库不仅可以处理socket fd事件，还可以处理定时器事件和信号事件。</p><p>这些事件库的实现原理基本类似，都是先将套接字设置成非阻塞状态，然后将套接字与回调函数绑定，接下来进入一个基于IO多路复用的事件循环，等待事件发生，然后调用对应的回调函数。这里可以参考一个基于epoll实现的简单事件库：<a href="https://www.kancloud.cn/aceld/libevent_aceld/1858559">3.2 epoll的反应堆模式实现 · libevent深入浅出 · 看云</a>，sylar的IO调度和这种写法类似。</p></blockquote><h4 id="7-2-IO协程调度模块设计"><a href="#7-2-IO协程调度模块设计" class="headerlink" title="7.2 IO协程调度模块设计"></a>7.2 IO协程调度模块设计</h4><p>sylar的IO协程调度模块基于epoll实现，只支持Linux平台。<strong>对每个fd，sylar支持两类事件，一类是可读事件，对应<code>EPOLLIN</code>，一类是可写事件，对应<code>EPOLLOUT</code>，sylar的事件枚举值直接继承自epoll。</strong></p><p>当然epoll本身除了支持了EPOLLIN和EPOLLOUT两类事件外，还支持其他事件，比如EPOLLRDHUP, EPOLLERR, EPOLLHUP等，对于这些事件，sylar的做法是将其进行归类，分别对应到EPOLLIN和EPOLLOUT中，也就是所有的事件都可以表示为可读或可写事件，甚至有的事件还可以同时表示可读及可写事件，比如EPOLLERR事件发生时，fd将同时触发可读和可写事件。</p><p>对于IO协程调度来说，每次调度都包含一个三元组信息，分别是<strong>描述符-事件类型（可读或可写）-回调函数</strong>，调度器记录全部需要调度的三元组信息，其中描述符和事件类型用于epoll_wait，回调函数用于协程调度。这个三元组信息在源码上通过<code>FdContext</code>结构体来存储，在执行epoll_wait时通过epoll_event的私有数据指针data.ptr来保存FdContext结构体信息。</p><p>IO协程调度器在idle时会epoll_wait所有注册的fd，如果有fd满足条件，epoll_wait返回，从私有数据中拿到fd的上下文信息，并且执行其中的回调函数。（<strong>实际是idle协程只负责收集所有已触发的fd的回调函数并将其加入调度器的任务队列，真正的执行时机是idle协程退出后，调度器在下一轮调度时执行</strong>）</p><p>与协程调度器不一样的是，IO协程调度器支持取消事件。取消事件表示不关心某个fd的某个事件了，如果某个fd的可读或可写事件都被取消了，那这个fd会从调度器的epoll_wait中删除。</p><h4 id="7-3-IO协程调度器实现"><a href="#7-3-IO协程调度器实现" class="headerlink" title="7.3 IO协程调度器实现"></a>7.3 IO协程调度器实现</h4><h5 id="7-3-1-IOManger类"><a href="#7-3-1-IOManger类" class="headerlink" title="7.3.1 IOManger类"></a>7.3.1 IOManger类</h5><p>sylar的IO协程调度器对应IOManager，这个类直接继承自Scheduler：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOManager</span> :</span> <span class="keyword">public</span> Scheduler &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;IOManager&gt; ptr;</span><br><span class="line">    <span class="keyword">typedef</span> RWMutex RWMutexType;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先是读写事件的定义，这里直接继承epoll的枚举值，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief IO事件，继承自epoll对事件的定义</span></span><br><span class="line"><span class="comment"> * @details 这里只关心socket fd的读和写事件，其他epoll事件会归类到这两类事件中</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Event</span> &#123;</span></span><br><span class="line">    <span class="comment">/// 无事件</span></span><br><span class="line">    NONE = <span class="number">0x0</span>,</span><br><span class="line">    <span class="comment">/// 读事件(EPOLLIN)</span></span><br><span class="line">    READ = <span class="number">0x1</span>,</span><br><span class="line">    <span class="comment">/// 写事件(EPOLLOUT)</span></span><br><span class="line">    WRITE = <span class="number">0x4</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>接下来是IOManager的成员变量。IOManager包含一个epoll实例的句柄m_epfd以及用于tickle的一对pipe fd，还有全部的fd上下文m_fdContexts，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// epoll 文件句柄</span></span><br><span class="line"><span class="keyword">int</span> m_epfd = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/// pipe 文件句柄，fd[0]读端，fd[1]写端</span></span><br><span class="line"><span class="keyword">int</span> m_tickleFds[<span class="number">2</span>];</span><br><span class="line"><span class="comment">/// 当前等待执行的IO事件数量</span></span><br><span class="line"><span class="built_in">std</span>::atomic&lt;<span class="keyword">size_t</span>&gt; m_pendingEventCount = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="comment">/// IOManager的Mutex</span></span><br><span class="line">RWMutexType m_mutex;</span><br><span class="line"><span class="comment">/// socket事件上下文的容器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FdContext *&gt; m_fdContexts;</span><br></pre></td></tr></table></figure><h5 id="7-3-2-fd上下文"><a href="#7-3-2-fd上下文" class="headerlink" title="7.3.2 fd上下文"></a>7.3.2 fd上下文</h5><p>接下来是对描述符-事件类型-回调函数三元组的定义，这个三元组也称为fd上下文，使用结构体FdContext来表示。<strong>由于fd有可读和可写两种事件，每种事件的回调函数也可以不一样，所以每个fd都需要保存两个事件类型-回调函数组合。</strong> FdContext结构体定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief socket fd上下文类</span></span><br><span class="line"><span class="comment"> * @details 每个socket fd都对应一个FdContext，包括fd的值，fd上的事件，以及fd的读写事件上下文</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FdContext</span> &#123;</span></span><br><span class="line">    <span class="keyword">typedef</span> Mutex MutexType;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 事件上下文类</span></span><br><span class="line"><span class="comment">     * @details fd的每个事件都有一个事件上下文，保存这个事件的回调函数以及执行回调函数的调度器</span></span><br><span class="line"><span class="comment">     *       sylar对fd事件做了简化，只预留了读事件和写事件，所有的事件都被归类到这两类事件中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">EventContext</span> &#123;</span></span><br><span class="line">        <span class="comment">/// 执行事件回调的调度器</span></span><br><span class="line">        Scheduler *scheduler = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">/// 事件回调协程</span></span><br><span class="line">        Fiber::ptr fiber;</span><br><span class="line">        <span class="comment">/// 事件回调函数</span></span><br><span class="line">        <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb;</span><br><span class="line">    &#125;;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取事件上下文类</span></span><br><span class="line"><span class="comment">     * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment">     * @return 返回对应事件的上下文</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">EventContext &amp;<span class="title">getEventContext</span><span class="params">(Event event)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重置事件上下文</span></span><br><span class="line"><span class="comment">     * @param[in, out] ctx 待重置的事件上下文对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">resetEventContext</span><span class="params">(EventContext &amp;ctx)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 触发事件</span></span><br><span class="line"><span class="comment">     * @details 根据事件类型调用对应上下文结构中的调度器去调度回调协程或回调函数</span></span><br><span class="line"><span class="comment">     * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">triggerEvent</span><span class="params">(Event event)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/// 读事件上下文</span></span><br><span class="line">    EventContext read;</span><br><span class="line">    <span class="comment">/// 写事件上下文</span></span><br><span class="line">    EventContext write;</span><br><span class="line">    <span class="comment">/// 事件关联的句柄</span></span><br><span class="line">    <span class="keyword">int</span> fd = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// 该fd添加了哪些事件的回调函数，或者说该fd关心哪些事件</span></span><br><span class="line">    Event events = NONE;</span><br><span class="line">    <span class="comment">/// 事件的Mutex</span></span><br><span class="line">    MutexType mutex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="7-3-3-改造协程调度器"><a href="#7-3-3-改造协程调度器" class="headerlink" title="7.3.3 改造协程调度器"></a>7.3.3 改造协程调度器</h5><p>接下来是在继承类IOManager中改造协程调度器，使其支持epoll，并重载tickle和idle，实现通知调度协程和IO协程调度功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 构造函数</span></span><br><span class="line"><span class="comment"> * @param[in] threads 线程数量</span></span><br><span class="line"><span class="comment"> * @param[in] use_caller 是否将调用线程包含进去</span></span><br><span class="line"><span class="comment"> * @param[in] name 调度器的名称</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">IOManager::IOManager(<span class="keyword">size_t</span> threads, <span class="keyword">bool</span> use_caller, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;name)</span><br><span class="line">    : Scheduler(threads, use_caller, name) &#123;</span><br><span class="line">    <span class="comment">// 创建epoll实例</span></span><br><span class="line">    m_epfd = epoll_create(<span class="number">5000</span>);</span><br><span class="line">    SYLAR_ASSERT(m_epfd &gt; <span class="number">0</span>);</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// 创建pipe，获取m_tickleFds[2]，其中m_tickleFds[0]是管道的读端，m_tickleFds[1]是管道的写端</span></span><br><span class="line">    <span class="keyword">int</span> rt = pipe(m_tickleFds);</span><br><span class="line">    SYLAR_ASSERT(!rt);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 注册pipe读句柄的可读事件，用于tickle调度协程，通过epoll_event.data.fd保存描述符</span></span><br><span class="line">    epoll_event event;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;event, <span class="number">0</span>, <span class="keyword">sizeof</span>(epoll_event));</span><br><span class="line">    event.events  = EPOLLIN | EPOLLET;</span><br><span class="line">    event.data.fd = m_tickleFds[<span class="number">0</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 非阻塞方式，配合边缘触发</span></span><br><span class="line">    rt = fcntl(m_tickleFds[<span class="number">0</span>], F_SETFL, O_NONBLOCK);</span><br><span class="line">    SYLAR_ASSERT(!rt);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将管道的读描述符加入epoll多路复用，如果管道可读，idle中的epoll_wait会返回</span></span><br><span class="line">    rt = epoll_ctl(m_epfd, EPOLL_CTL_ADD, m_tickleFds[<span class="number">0</span>], &amp;event);</span><br><span class="line">    SYLAR_ASSERT(!rt);</span><br><span class="line"> </span><br><span class="line">    contextResize(<span class="number">32</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 这里直接开启了Schedluer，也就是说IOManager创建即可调度协程</span></span><br><span class="line">    start();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 通知调度器有任务要调度</span></span><br><span class="line"><span class="comment"> * @details 写pipe让idle协程从epoll_wait退出，待idle协程yield之后Scheduler::run就可以调度其他任务</span></span><br><span class="line"><span class="comment"> * 如果当前没有空闲调度线程，那就没必要发通知</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IOManager::tickle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;tickle&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!hasIdleThreads()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> rt = write(m_tickleFds[<span class="number">1</span>], <span class="string">&quot;T&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    SYLAR_ASSERT(rt == <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief idle协程</span></span><br><span class="line"><span class="comment"> * @details 对于IO协程调度来说，应阻塞在等待IO事件上，idle退出的时机是epoll_wait返回，对应的操作是tickle或注册的IO事件就绪</span></span><br><span class="line"><span class="comment"> * 调度器无调度任务时会阻塞idle协程上，对IO调度器而言，idle状态应该关注两件事，一是有没有新的调度任务，对应Schduler::schedule()，</span></span><br><span class="line"><span class="comment"> * 如果有新的调度任务，那应该立即退出idle状态，并执行对应的任务；二是关注当前注册的所有IO事件有没有触发，如果有触发，那么应该执行</span></span><br><span class="line"><span class="comment"> * IO事件对应的回调函数</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IOManager::idle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;idle&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一次epoll_wait最多检测256个就绪事件，如果就绪事件超过了这个数，那么会在下轮epoll_wati继续处理</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> MAX_EVNETS = <span class="number">256</span>;</span><br><span class="line">    epoll_event *events       = <span class="keyword">new</span> epoll_event[MAX_EVNETS]();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;epoll_event&gt; <span class="title">shared_events</span><span class="params">(events, [](epoll_event *ptr) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">delete</span>[] ptr;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(stopping()) &#123;</span><br><span class="line">            SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; getName() &lt;&lt; <span class="string">&quot;idle stopping exit&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 阻塞在epoll_wait上，等待事件发生</span></span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line">        <span class="keyword">int</span> rt = epoll_wait(m_epfd, events, MAX_EVNETS, MAX_TIMEOUT);</span><br><span class="line">        <span class="keyword">if</span>(rt &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_wait(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;) (rt=&quot;</span></span><br><span class="line">                                      &lt;&lt; rt &lt;&lt; <span class="string">&quot;) (errno=&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (errstr:&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 遍历所有发生的事件，根据epoll_event的私有指针找到对应的FdContext，进行事件处理</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rt; ++i) &#123;</span><br><span class="line">            epoll_event &amp;event = events[i];</span><br><span class="line">            <span class="keyword">if</span> (event.data.fd == m_tickleFds[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// ticklefd[0]用于通知协程调度，这时只需要把管道里的内容读完即可，本轮idle结束Scheduler::run会重新执行协程调度</span></span><br><span class="line">                <span class="keyword">uint8_t</span> dummy[<span class="number">256</span>];</span><br><span class="line">                <span class="keyword">while</span> (read(m_tickleFds[<span class="number">0</span>], dummy, <span class="keyword">sizeof</span>(dummy)) &gt; <span class="number">0</span>)</span><br><span class="line">                    ;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">             </span><br><span class="line">            <span class="comment">// 通过epoll_event的私有指针获取FdContext</span></span><br><span class="line">            FdContext *fd_ctx = (FdContext *)event.data.ptr;</span><br><span class="line">            FdContext::<span class="function">MutexType::Lock <span class="title">lock</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * EPOLLERR: 出错，比如写读端已经关闭的pipe</span></span><br><span class="line"><span class="comment">             * EPOLLHUP: 套接字对端关闭</span></span><br><span class="line"><span class="comment">             * 出现这两种事件，应该同时触发fd的读和写事件，否则有可能出现注册的事件永远执行不到的情况</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (event.events &amp; (EPOLLERR | EPOLLHUP)) &#123;</span><br><span class="line">                event.events |= (EPOLLIN | EPOLLOUT) &amp; fd_ctx-&gt;events;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> real_events = NONE;</span><br><span class="line">            <span class="keyword">if</span> (event.events &amp; EPOLLIN) &#123;</span><br><span class="line">                real_events |= READ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (event.events &amp; EPOLLOUT) &#123;</span><br><span class="line">                real_events |= WRITE;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">if</span> ((fd_ctx-&gt;events &amp; real_events) == NONE) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 剔除已经发生的事件，将剩下的事件重新加入epoll_wait，</span></span><br><span class="line">            <span class="comment">// 如果剩下的事件为0，表示这个fd已经不需要关注了，直接从epoll中删除</span></span><br><span class="line">            <span class="keyword">int</span> left_events = (fd_ctx-&gt;events &amp; ~real_events);</span><br><span class="line">            <span class="keyword">int</span> op          = left_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">            event.events    = EPOLLET | left_events;</span><br><span class="line"> </span><br><span class="line">            <span class="keyword">int</span> rt2 = epoll_ctl(m_epfd, op, fd_ctx-&gt;fd, &amp;event);</span><br><span class="line">            <span class="keyword">if</span> (rt2) &#123;</span><br><span class="line">                SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                          &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd_ctx-&gt;fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)event.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                          &lt;&lt; rt2 &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 处理已经发生的事件，也就是让调度器调度指定的函数或协程</span></span><br><span class="line">            <span class="keyword">if</span> (real_events &amp; READ) &#123;</span><br><span class="line">                fd_ctx-&gt;triggerEvent(READ);</span><br><span class="line">                --m_pendingEventCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (real_events &amp; WRITE) &#123;</span><br><span class="line">                fd_ctx-&gt;triggerEvent(WRITE);</span><br><span class="line">                --m_pendingEventCount;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="comment">// end for</span></span><br><span class="line"> </span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 一旦处理完所有的事件，idle协程yield，这样可以让调度协程(Scheduler::run)重新检查是否有新任务要调度</span></span><br><span class="line"><span class="comment">         * 上面triggerEvent实际也只是把对应的fiber重新加入调度，要执行的话还要等idle协程退出</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Fiber::ptr cur = Fiber::GetThis();</span><br><span class="line">        <span class="keyword">auto</span> raw_ptr   = cur.get();</span><br><span class="line">        cur.reset();</span><br><span class="line"> </span><br><span class="line">        raw_ptr-&gt;yield();</span><br><span class="line">    &#125; <span class="comment">// end while(true)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-4-事件回调函数"><a href="#7-3-4-事件回调函数" class="headerlink" title="7.3.4 事件回调函数"></a>7.3.4 事件回调函数</h5><p>接下来是注册事件回调addEvent，删除事件回调delEvent，取消事件回调cancelEvent，以及取消全部事件cancelAll：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 添加事件</span></span><br><span class="line"><span class="comment"> * @details fd描述符发生了event事件时执行cb函数</span></span><br><span class="line"><span class="comment"> * @param[in] fd socket句柄</span></span><br><span class="line"><span class="comment"> * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment"> * @param[in] cb 事件回调函数，如果为空，则默认把当前协程作为回调执行体</span></span><br><span class="line"><span class="comment"> * @return 添加成功返回0,失败返回-1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IOManager::addEvent</span><span class="params">(<span class="keyword">int</span> fd, Event event, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到fd对应的FdContext，如果不存在，那就分配一个</span></span><br><span class="line">    FdContext *fd_ctx = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_fdContexts.size() &gt; fd) &#123;</span><br><span class="line">        fd_ctx = m_fdContexts[fd];</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">        <span class="function">RWMutexType::WriteLock <span class="title">lock2</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">        contextResize(fd * <span class="number">1.5</span>);</span><br><span class="line">        fd_ctx = m_fdContexts[fd];</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 同一个fd不允许重复添加相同的事件</span></span><br><span class="line">    FdContext::<span class="function">MutexType::Lock <span class="title">lock2</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (SYLAR_UNLIKELY(fd_ctx-&gt;events &amp; event)) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;addEvent assert fd=&quot;</span> &lt;&lt; fd</span><br><span class="line">                                  &lt;&lt; <span class="string">&quot; event=&quot;</span> &lt;&lt; (EPOLL_EVENTS)event</span><br><span class="line">                                  &lt;&lt; <span class="string">&quot; fd_ctx.event=&quot;</span> &lt;&lt; (EPOLL_EVENTS)fd_ctx-&gt;events;</span><br><span class="line">        SYLAR_ASSERT(!(fd_ctx-&gt;events &amp; event));</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 将新的事件加入epoll_wait，使用epoll_event的私有指针存储FdContext的位置</span></span><br><span class="line">    <span class="keyword">int</span> op = fd_ctx-&gt;events ? EPOLL_CTL_MOD : EPOLL_CTL_ADD;</span><br><span class="line">    epoll_event epevent;</span><br><span class="line">    epevent.events   = EPOLLET | fd_ctx-&gt;events | event;</span><br><span class="line">    epevent.data.ptr = fd_ctx;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                  &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                  &lt;&lt; rt &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;) fd_ctx-&gt;events=&quot;</span></span><br><span class="line">                                  &lt;&lt; (EPOLL_EVENTS)fd_ctx-&gt;events;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 待执行IO事件数加1</span></span><br><span class="line">    ++m_pendingEventCount;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 找到这个fd的event事件对应的EventContext，对其中的scheduler, cb, fiber进行赋值</span></span><br><span class="line">    fd_ctx-&gt;events                     = (Event)(fd_ctx-&gt;events | event);</span><br><span class="line">    FdContext::EventContext &amp;event_ctx = fd_ctx-&gt;getEventContext(event);</span><br><span class="line">    SYLAR_ASSERT(!event_ctx.scheduler &amp;&amp; !event_ctx.fiber &amp;&amp; !event_ctx.cb);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 赋值scheduler和回调函数，如果回调函数为空，则把当前协程当成回调执行体</span></span><br><span class="line">    event_ctx.scheduler = Scheduler::GetThis();</span><br><span class="line">    <span class="keyword">if</span> (cb) &#123;</span><br><span class="line">        event_ctx.cb.swap(cb);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        event_ctx.fiber = Fiber::GetThis();</span><br><span class="line">        SYLAR_ASSERT2(event_ctx.fiber-&gt;getState() == Fiber::RUNNING, <span class="string">&quot;state=&quot;</span> &lt;&lt; event_ctx.fiber-&gt;getState());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 删除事件</span></span><br><span class="line"><span class="comment"> * @param[in] fd socket句柄</span></span><br><span class="line"><span class="comment"> * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment"> * @attention 不会触发事件</span></span><br><span class="line"><span class="comment"> * @return 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IOManager::delEvent</span><span class="params">(<span class="keyword">int</span> fd, Event event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到fd对应的FdContext</span></span><br><span class="line">    <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_fdContexts.size() &lt;= fd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FdContext *fd_ctx = m_fdContexts[fd];</span><br><span class="line">    lock.unlock();</span><br><span class="line"> </span><br><span class="line">    FdContext::<span class="function">MutexType::Lock <span class="title">lock2</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (SYLAR_UNLIKELY(!(fd_ctx-&gt;events &amp; event))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 清除指定的事件，表示不关心这个事件了，如果清除之后结果为0，则从epoll_wait中删除该文件描述符</span></span><br><span class="line">    Event new_events = (Event)(fd_ctx-&gt;events &amp; ~event);</span><br><span class="line">    <span class="keyword">int</span> op           = new_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">    epoll_event epevent;</span><br><span class="line">    epevent.events   = EPOLLET | new_events;</span><br><span class="line">    epevent.data.ptr = fd_ctx;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                  &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                  &lt;&lt; rt &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 待执行事件数减1</span></span><br><span class="line">    --m_pendingEventCount;</span><br><span class="line">    <span class="comment">// 重置该fd对应的event事件上下文</span></span><br><span class="line">    fd_ctx-&gt;events                     = new_events;</span><br><span class="line">    FdContext::EventContext &amp;event_ctx = fd_ctx-&gt;getEventContext(event);</span><br><span class="line">    fd_ctx-&gt;resetEventContext(event_ctx);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 取消事件</span></span><br><span class="line"><span class="comment"> * @param[in] fd socket句柄</span></span><br><span class="line"><span class="comment"> * @param[in] event 事件类型</span></span><br><span class="line"><span class="comment"> * @attention 如果该事件被注册过回调，那就触发一次回调事件</span></span><br><span class="line"><span class="comment"> * @return 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IOManager::cancelEvent</span><span class="params">(<span class="keyword">int</span> fd, Event event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到fd对应的FdContext</span></span><br><span class="line">    <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_fdContexts.size() &lt;= fd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FdContext *fd_ctx = m_fdContexts[fd];</span><br><span class="line">    lock.unlock();</span><br><span class="line"> </span><br><span class="line">    FdContext::<span class="function">MutexType::Lock <span class="title">lock2</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (SYLAR_UNLIKELY(!(fd_ctx-&gt;events &amp; event))) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除事件</span></span><br><span class="line">    Event new_events = (Event)(fd_ctx-&gt;events &amp; ~event);</span><br><span class="line">    <span class="keyword">int</span> op           = new_events ? EPOLL_CTL_MOD : EPOLL_CTL_DEL;</span><br><span class="line">    epoll_event epevent;</span><br><span class="line">    epevent.events   = EPOLLET | new_events;</span><br><span class="line">    epevent.data.ptr = fd_ctx;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                  &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                  &lt;&lt; rt &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除之前触发一次事件</span></span><br><span class="line">    fd_ctx-&gt;triggerEvent(event);</span><br><span class="line">    <span class="comment">// 活跃事件数减1</span></span><br><span class="line">    --m_pendingEventCount;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 取消所有事件</span></span><br><span class="line"><span class="comment"> * @details 所有被注册的回调事件在cancel之前都会被执行一次</span></span><br><span class="line"><span class="comment"> * @param[in] fd socket句柄</span></span><br><span class="line"><span class="comment"> * @return 是否删除成功</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IOManager::cancelAll</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 找到fd对应的FdContext</span></span><br><span class="line">    <span class="function">RWMutexType::ReadLock <span class="title">lock</span><span class="params">(m_mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> ((<span class="keyword">int</span>)m_fdContexts.size() &lt;= fd) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    FdContext *fd_ctx = m_fdContexts[fd];</span><br><span class="line">    lock.unlock();</span><br><span class="line"> </span><br><span class="line">    FdContext::<span class="function">MutexType::Lock <span class="title">lock2</span><span class="params">(fd_ctx-&gt;mutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!fd_ctx-&gt;events) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 删除全部事件</span></span><br><span class="line">    <span class="keyword">int</span> op = EPOLL_CTL_DEL;</span><br><span class="line">    epoll_event epevent;</span><br><span class="line">    epevent.events   = <span class="number">0</span>;</span><br><span class="line">    epevent.data.ptr = fd_ctx;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = epoll_ctl(m_epfd, op, fd, &amp;epevent);</span><br><span class="line">    <span class="keyword">if</span> (rt) &#123;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;epoll_ctl(&quot;</span> &lt;&lt; m_epfd &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">                                  &lt;&lt; (EpollCtlOp)op &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; (EPOLL_EVENTS)epevent.events &lt;&lt; <span class="string">&quot;):&quot;</span></span><br><span class="line">                                  &lt;&lt; rt &lt;&lt; <span class="string">&quot; (&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot;) (&quot;</span> &lt;&lt; strerror(errno) &lt;&lt; <span class="string">&quot;)&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 触发全部已注册的事件</span></span><br><span class="line">    <span class="keyword">if</span> (fd_ctx-&gt;events &amp; READ) &#123;</span><br><span class="line">        fd_ctx-&gt;triggerEvent(READ);</span><br><span class="line">        --m_pendingEventCount;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fd_ctx-&gt;events &amp; WRITE) &#123;</span><br><span class="line">        fd_ctx-&gt;triggerEvent(WRITE);</span><br><span class="line">        --m_pendingEventCount;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    SYLAR_ASSERT(fd_ctx-&gt;events == <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-3-5-IOManager析构函数"><a href="#7-3-5-IOManager析构函数" class="headerlink" title="7.3.5 IOManager析构函数"></a>7.3.5 IOManager析构函数</h5><p>接下来是IOManager的析构函数实现和stopping重载。对于IOManager的析构，首先要等Scheduler调度完所有的任务，然后再关闭epoll句柄和pipe句柄，然后释放所有的FdContext；对于stopping，IOManager在判断是否可退出时，还要加上所有IO事件都完成调度的条件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">IOManager::~IOManager() &#123;</span><br><span class="line">    stop();</span><br><span class="line">    close(m_epfd);</span><br><span class="line">    close(m_tickleFds[<span class="number">0</span>]);</span><br><span class="line">    close(m_tickleFds[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; m_fdContexts.size(); ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m_fdContexts[i]) &#123;</span><br><span class="line">            <span class="keyword">delete</span> m_fdContexts[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">IOManager::stopping</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 对于IOManager而言，必须等所有待调度的IO事件都执行完了才可以退出</span></span><br><span class="line">    <span class="keyword">return</span> m_pendingEventCount == <span class="number">0</span> &amp;&amp; Scheduler::stopping();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-4-IO协程调度的几点总结"><a href="#7-4-IO协程调度的几点总结" class="headerlink" title="7.4 IO协程调度的几点总结"></a>7.4 IO协程调度的几点总结</h4><p>总得来说，sylar的IO协程调度模块可分为两部分，<strong>第一部分是对协程调度器的改造，将epoll与协程调度融合，重新实现tickle和idle，并保证原有的功能不变。第二部分是基于epoll实现IO事件的添加、删除、调度、取消等功能。</strong></p><ol><li> IO协程调度关注的是FdContext信息，也就是描述符-事件-回调函数三元组，IOManager需要保存所有关注的三元组，并且在epoll_wait检测到描述符事件就绪时执行对应的回调函数。</li><li>epoll是线程安全的，即使调度器有多个调度线程，它们也可以共用同一个epoll实例，而不用担心互斥。由于空闲时所有线程都阻塞的epoll_wait上，所以也不用担心CPU占用问题。</li><li>addEvent是一次性的，比如说，注册了一个读事件，当fd可读时会触发该事件，但触发完之后，这次注册的事件就失效了，后面fd再次可读时，并不会继续执行该事件回调，如果要持续触发事件的回调，那每次事件处理完都要手动再addEvent。这样在应对fd的WRITE事件时会比较好处理，因为fd可写是常态，如果注册一次就一直有效，那么可写事件就必须在执行完之后就删除掉。</li><li>cancelEvent和cancelAll都会触发一次事件，但delEvent不会。</li><li>FdContext的寻址问题，sylar直接使用fd的值作为FdContext数组的下标，这样可以快速找到一个fd对应的FdContext。由于关闭的fd会被重复利用，所以这里也不用担心FdContext数组膨胀太快，或是利用率低的问题。</li><li> IO协程调度器的退出，不但所有协程要完成调度，所有IO事件也要完成调度。</li><li> sylar的IO协程调度器应该配合非阻塞IO来使用，如果使用阻塞模式，可能会阻塞进程，参考<a href="https://www.zhihu.com/question/37271342">为什么 IO 多路复用要搭配非阻塞 IO? - 知乎</a>。</li></ol><h3 id="八-定时器模块"><a href="#八-定时器模块" class="headerlink" title="八 定时器模块"></a>八 定时器模块</h3><p>基于epoll超时实现定时器功能，精度毫秒级，支持在指定超时时间结束之后执行回调函数。</p><h4 id="8-1-定时器概述"><a href="#8-1-定时器概述" class="headerlink" title="8.1 定时器概述"></a>8.1 定时器概述</h4><p><strong>通过定时器可以实现给服务器注册定时事件</strong>，这是服务器上经常要处理的一类事件，比如3秒后关闭一个连接，或是定期检测一个客户端的连接状态。</p><p>定时事件依赖于Linux提供的定时机制，它是驱动定时事件的原动力，目前Linux提供了以下几种可供程序利用的定时机制：</p><ol><li><p>alarm()或setitimer()，这俩的本质都是先设置一个超时时间，然后等SIGALARM信号触发，通过捕获信号来判断超时</p></li><li><p>套接字超时选项，对应SO_RECVTIMEO和SO_SNDTIMEO，通过errno来判断超时</p></li><li><p>多路复用超时参数，select/poll/epoll都支持设置超时参数，通过判断返回值为0来判断超时</p></li><li><p>timer_create系统接口，实质也是借助信号，参考man 2 timer_create</p></li><li><p>timerfd_create系列接口，通过判断文件描述符可读来判断超时，可配合IO多路复用，参考man 2 timerfd_create</p></li></ol><p>服务器程序通常需要处理众多定时事件，如何有效地组织与管理这些定时事件对服务器的性能至关重要。<strong>为此，我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构，比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定时事件的统一管理。</strong></p><p>每个定时器通常至少包含两个成员：一个超时时间（相对时间或绝对时间）和一个任务回调函数。除此外，定时器还可以包括回调函数参数及是否自动重启等信息。</p><p>有两种高效管理定时器的容器：时间轮和时间堆，<strong>sylar使用时间堆的方式管理定时器。</strong></p><h4 id="8-2-几种定时器实现"><a href="#8-2-几种定时器实现" class="headerlink" title="8.2 几种定时器实现"></a>8.2 几种定时器实现</h4><h5 id="8-2-1-基于升序链表的定时器"><a href="#8-2-1-基于升序链表的定时器" class="headerlink" title="8.2.1 基于升序链表的定时器"></a>8.2.1 基于升序链表的定时器</h5><ol><li><p> 所有定时器组织成链表结构，链表成员包含超时时间，回调函数，回调函数参数，以及链表指针域。</p></li><li><p>定时器在链表中按超时时间进行升序排列，超时时间短的在前，长的在后。每次添加定时器时，都要按超时时间将定时器插入到链表的指定位置。</p></li><li><p>程序运行后维护一个周期性触发的tick信号，比如利用alarm函数周期性触发ALARM信号，在信号处理函数中从头遍历定时器链表，判断定时器是否超时。如果定时器超时，则记录下该定时器，然后将其从链表中删除。</p></li><li><p>执行所有超时的定时器的回调函数。</p></li></ol><p>以上就是一个基于升序链表的定时器实现，这种方式添加定时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)(<strong>双向链表</strong>)，执行定时任务的时间复杂度是O(1)。</p><p>tick信号的周期对定时器的性能有较大的影响，当tick信号周期较小时，定时器精度高，但CPU负担较高，因为要频繁执行信号处理函数；当tick信号周期较大时，CPU负担小，但定时精度差。</p><p>当定时器数量较多时，链表插入操作开销比较大。</p><h5 id="8-2-2-时间轮"><a href="#8-2-2-时间轮" class="headerlink" title="8.2.2 时间轮"></a>8.2.2 时间轮</h5><p>与上面的升序链表实现方式类似，也需要维护一个周期性触发的tick信号，但不同的是，定时器不再组织成单链表结构，而是按照超时时间，通过散列分布到不同的时间轮上，像下面这样：</p><img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230305172536051.png" class="" title="image-20230305172536051"><p>上图所示的时间轮内，（实线）指针指向轮子上的一个槽 （slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽 （虚线指针指向的槽），每次转动称为一个滴答（tick）。一个滴答的 时间称为时间轮的槽间隔si（slot interval），它实际上就是心搏时间。该时间轮共有N个槽，因此它运转一周的时间是<code>N*si</code>。每个槽指向一条定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间 相差<code>N*si</code>的整数倍。</p><p>时间轮正是利用这个关系将定时器散列到不同的 链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时 器，则该定时器将被插入槽ts（timer slot）对应的链表中：</p><p><strong>ts = (cs + (ti / si)) % N</strong></p><p>很显然，对时间轮而言，要提高定时精度，就要使si值足够小；要 提高执行效率，则要求N值足够大。</p><h5 id="8-2-3-时间堆"><a href="#8-2-3-时间堆" class="headerlink" title="8.2.3 时间堆"></a>8.2.3 时间堆</h5><p><strong>上面的两种定时器设计都依赖一个固定周期触发的tick信号。</strong> <strong>设计定时器的另一种实现思路是直接将超时时间当作tick周期，具体操作是每次都取出所有定时器中超时时间最小的超时值作为一个tick，这样，一旦tick触发，超时时间最小的定时器必然到期</strong>。处理完已超时的定时器后，再从剩余的定时器中找出超时时间最小的一个，并将这个最小时间作为下一个tick，如此反复，就可以实现较为精确的定时。</p><p>最小堆很适合处理这种定时方案，将所有定时器按最小堆来组织，可以很方便地获取到当前的最小超时时间，sylar采取的即是这种方案。</p><h4 id="8-3-定时器设计"><a href="#8-3-定时器设计" class="headerlink" title="8.3 定时器设计"></a>8.3 定时器设计</h4><p>sylar的定时器采用最小堆设计，<strong>所有定时器根据绝对的超时时间点进行排序</strong>，每次取出离当前时间最近的一个超时时间点，计算出超时需要等待的时间，然后等待超时。超时时间到后，获取当前的绝对时间点，然后把最小堆里超时时间点小于这个时间点的定时器都收集起来，执行它们的回调函数。</p><p>注意，在注册定时事件时，一般提供的是相对时间，比如相对当前时间3秒后执行。sylar会根据传入的相对时间和当前的绝对时间计算出定时器超时时的绝对时间点，然后根据这个绝对时间点对定时器进行最小堆排序。因为依赖的是系统绝对时间，所以需要考虑校时因素，这点会在后面讨论。</p><p>sylar定时器的超时等待基于epoll_wait，精度只支持毫秒级，因为epoll_wait的超时精度也只有毫秒级。</p><p>关于定时器和IO协程调度器的整合。IO协程调度器的idle协程会在调度器空闲时阻塞在epoll_wait上，等待IO事件发生。在之前的代码里，epoll_wait具有固定的超时时间，这个值是5秒钟。<strong>加入定时器功能后，epoll_wait的超时时间改用当前定时器的最小超时时间来代替。epoll_wait返回后，根据当前的绝对时间把已超时的所有定时器收集起来，执行它们的回调函数。</strong></p><p>由于epoll_wait的返回并不一定是超时引起的，也有可能是IO事件唤醒的，所以在epoll_wait返回后不能想当然地假设定时器已经超时了，而是要再判断一下定时器有没有超时，这时绝对时间的好处就体现出来了，通过比较当前的绝对时间和定时器的绝对超时时间，就可以确定一个定时器到底有没有超时。</p><h4 id="8-4-定时器实现"><a href="#8-4-定时器实现" class="headerlink" title="8.4 定时器实现"></a>8.4 定时器实现</h4><h5 id="8-4-1-Timer-类"><a href="#8-4-1-Timer-类" class="headerlink" title="8.4.1 Timer 类"></a>8.4.1 Timer 类</h5><p>sylar的定时器对应Timer类，这个类的成员变量包括定时器的绝对超时时间点，是否重复执行，回调函数，以及一个指向TimerManager的指针，提供cancel/reset/refresh方法用于操作定时器。构造Timer时可以传入超时时间，也可以直接传入一个绝对时间。<strong>Timer的构造函数被定义成私有方式，只能通过TimerManager类来创建Timer对象。</strong>除此外，Timer类还提供了一个仿函数Comparator，用于比较两个Timer对象，比较的依据是绝对超时时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerManager</span>;</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;Timer&gt; &#123;</span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">TimerManager</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 定时器的智能指针类型</span></span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Timer&gt; ptr;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 取消定时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">cancel</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 刷新设置定时器的执行时间</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">refresh</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 重置定时器时间</span></span><br><span class="line"><span class="comment">     * @param[in] ms 定时器执行间隔时间(毫秒)</span></span><br><span class="line"><span class="comment">     * @param[in] from_now 是否从当前时间开始计算</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">reset</span><span class="params">(<span class="keyword">uint64_t</span> ms, <span class="keyword">bool</span> from_now)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     * @param[in] ms 定时器执行间隔时间</span></span><br><span class="line"><span class="comment">     * @param[in] cb 回调函数</span></span><br><span class="line"><span class="comment">     * @param[in] recurring 是否循环</span></span><br><span class="line"><span class="comment">     * @param[in] manager 定时器管理器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Timer(<span class="keyword">uint64_t</span> ms, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb,</span><br><span class="line">          <span class="keyword">bool</span> recurring, TimerManager* manager);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     * @param[in] next 执行的时间戳(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Timer(<span class="keyword">uint64_t</span> next);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 是否循环定时器</span></span><br><span class="line">    <span class="keyword">bool</span> m_recurring = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/// 执行周期</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_ms = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// 精确的执行时间</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_next = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/// 回调函数</span></span><br><span class="line">    <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; m_cb;</span><br><span class="line">    <span class="comment">/// 定时器管理器</span></span><br><span class="line">    TimerManager* m_manager = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 定时器比较仿函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Comparator</span> &#123;</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * @brief 比较定时器的智能指针的大小(按执行时间排序)</span></span><br><span class="line"><span class="comment">         * @param[in] lhs 定时器智能指针</span></span><br><span class="line"><span class="comment">         * @param[in] rhs 定时器智能指针</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Timer::ptr&amp; lhs, <span class="keyword">const</span> Timer::ptr&amp; rhs)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="8-4-2-TimerManager类"><a href="#8-4-2-TimerManager类" class="headerlink" title="8.4.2 TimerManager类"></a>8.4.2 TimerManager类</h5><p>所有的Timer对象都由TimerManager类进行管理，TimerManager包含一个std::set类型的Timer集合，这个集合就是定时器的最小堆结构，因为set里的元素总是排序过的，所以总是可以很方便地获取到当前的最小定时器。TimerManager提供创建定时器，获取最近一个定时器的超时时间，以及获取全部已经超时的定时器回调函数的方法，并且提供了一个onTimerInsertedAtFront()方法，这是一个虚函数，由IOManager继承时实现，当新的定时器插入到Timer集合的首部时，TimerManager通过该方法来通知IOManager立刻更新当前的epoll_wait超时。TimerManager还负责检测是否发生了校时，由detectClockRollover方法实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 定时器管理器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TimerManager</span> &#123;</span></span><br><span class="line"><span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Timer</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 读写锁类型</span></span><br><span class="line">    <span class="keyword">typedef</span> RWMutex RWMutexType;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    TimerManager();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">virtual</span> ~TimerManager();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加定时器</span></span><br><span class="line"><span class="comment">     * @param[in] ms 定时器执行间隔时间</span></span><br><span class="line"><span class="comment">     * @param[in] cb 定时器回调函数</span></span><br><span class="line"><span class="comment">     * @param[in] recurring 是否循环定时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timer::ptr <span class="title">addTimer</span><span class="params">(<span class="keyword">uint64_t</span> ms, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb</span></span></span><br><span class="line"><span class="function"><span class="params">                        ,<span class="keyword">bool</span> recurring = <span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 添加条件定时器</span></span><br><span class="line"><span class="comment">     * @param[in] ms 定时器执行间隔时间</span></span><br><span class="line"><span class="comment">     * @param[in] cb 定时器回调函数</span></span><br><span class="line"><span class="comment">     * @param[in] weak_cond 条件</span></span><br><span class="line"><span class="comment">     * @param[in] recurring 是否循环</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">Timer::ptr <span class="title">addConditionTimer</span><span class="params">(<span class="keyword">uint64_t</span> ms, <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; cb</span></span></span><br><span class="line"><span class="function"><span class="params">                        ,<span class="built_in">std</span>::weak_ptr&lt;<span class="keyword">void</span>&gt; weak_cond</span></span></span><br><span class="line"><span class="function"><span class="params">                        ,<span class="keyword">bool</span> recurring = <span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 到最近一个定时器执行的时间间隔(毫秒)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">uint64_t</span> <span class="title">getNextTimer</span><span class="params">()</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取需要执行的定时器的回调函数列表</span></span><br><span class="line"><span class="comment">     * @param[out] cbs 回调函数数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">listExpiredCb</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt; &gt;&amp; cbs)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 是否有定时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasTimer</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 当有新的定时器插入到定时器的首部,执行该函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">onTimerInsertedAtFront</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 将定时器添加到管理器中</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addTimer</span><span class="params">(Timer::ptr val, RWMutexType::WriteLock&amp; lock)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 检测服务器时间是否被调后了</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">detectClockRollover</span><span class="params">(<span class="keyword">uint64_t</span> now_ms)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// Mutex</span></span><br><span class="line">    RWMutexType m_mutex;</span><br><span class="line">    <span class="comment">/// 定时器集合</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">set</span>&lt;Timer::ptr, Timer::Comparator&gt; m_timers;</span><br><span class="line">    <span class="comment">/// 是否触发onTimerInsertedAtFront</span></span><br><span class="line">    <span class="keyword">bool</span> m_tickled = <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">/// 上次执行时间</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_previouseTime = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="8-4-3-IOManager类"><a href="#8-4-3-IOManager类" class="headerlink" title="8.4.3 IOManager类"></a>8.4.3 IOManager类</h5><p>IOManager通过继承的方式获得TimerManager类的所有方法，这种方式相当于给IOManager外挂了一个定时器管理模块。为支持定时器功能，需要重新改造idle协程的实现，epoll_wait应该根据下一个定时器的超时时间来设置超时参数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IOManager</span> :</span> <span class="keyword">public</span> Scheduler, <span class="keyword">public</span> TimerManager &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">IOManager::idle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;idle&quot;</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 一次epoll_wait最多检测256个就绪事件，如果就绪事件超过了这个数，那么会在下轮epoll_wati继续处理</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">uint64_t</span> MAX_EVNETS = <span class="number">256</span>;</span><br><span class="line">    epoll_event *events       = <span class="keyword">new</span> epoll_event[MAX_EVNETS]();</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;epoll_event&gt; <span class="title">shared_events</span><span class="params">(events, [](epoll_event *ptr) &#123;</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">delete</span>[] ptr;</span></span></span><br><span class="line"><span class="function"><span class="params">    &#125;)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="comment">// 获取下一个定时器的超时时间，顺便判断调度器是否停止</span></span><br><span class="line">        <span class="keyword">uint64_t</span> next_timeout = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>( SYLAR_UNLIKELY(stopping(next_timeout))) &#123;</span><br><span class="line">            SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;name=&quot;</span> &lt;&lt; getName() &lt;&lt; <span class="string">&quot;idle stopping exit&quot;</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 阻塞在epoll_wait上，等待事件发生或定时器超时</span></span><br><span class="line">        <span class="keyword">int</span> rt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">do</span>&#123;</span><br><span class="line">            <span class="comment">// 默认超时时间5秒，如果下一个定时器的超时时间大于5秒，仍以5秒来计算超时，避免定时器超时时间太大时，epoll_wait一直阻塞</span></span><br><span class="line">            <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_TIMEOUT = <span class="number">5000</span>;</span><br><span class="line">            <span class="keyword">if</span>(next_timeout != ~<span class="number">0ull</span>) &#123;</span><br><span class="line">                next_timeout = <span class="built_in">std</span>::min((<span class="keyword">int</span>)next_timeout, MAX_TIMEOUT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                next_timeout = MAX_TIMEOUT;</span><br><span class="line">            &#125;</span><br><span class="line">            rt = epoll_wait(m_epfd, events, MAX_EVNETS, (<span class="keyword">int</span>)next_timeout);</span><br><span class="line">            <span class="keyword">if</span>(rt &lt; <span class="number">0</span> &amp;&amp; errno == EINTR) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 收集所有已超时的定时器，执行回调函数</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::function&lt;<span class="keyword">void</span>()&gt;&gt; cbs;</span><br><span class="line">        listExpiredCb(cbs);</span><br><span class="line">        <span class="keyword">if</span>(!cbs.empty()) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cb : cbs) &#123;</span><br><span class="line">                schedule(cb);</span><br><span class="line">            &#125;</span><br><span class="line">            cbs.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-5-注意事项"><a href="#8-5-注意事项" class="headerlink" title="8.5 注意事项"></a>8.5 注意事项</h4><ol><li><p>创建定时器时只传入了相对超时时间，内部要先进行转换，根据当前时间把相对时间转化成绝对时间。</p></li><li><p>sylar支持创建条件定时器，也就是在创建定时器时绑定一个变量，在定时器触发时判断一下该变量是否仍然有效，如果变量无效，那就取消触发。</p></li><li><p>关于onTimerInsertedAtFront()方法的作用。这个方法是IOManager提供给TimerManager使用的，当TimerManager检测到新添加的定时器的超时时间比当前最小的定时器还要小时，TimerManager通过这个方法来通知IOManager立刻更新当前的epoll_wait超时，否则新添加的定时器的执行时间将不准确。实际实现时，只需要在onTimerInsertedAtFront()方法内执行一次tickle就行了，tickle之后，epoll_wait会立即退出，并重新从TimerManager中获取最近的超时时间，这时拿到的超时时间就是新添加的最小定时器的超时时间了。</p></li><li><p>关于校时问题。sylar的定时器以gettimeofday()来获取绝对时间点并判断超时，所以依赖于系统时间，如果系统进行了校时，比如NTP时间同步，那这套定时机制就失效了。sylar的解决办法是设置一个较小的超时步长，比如3秒钟，也就是epoll_wait最多3秒超时，假设最近一个定时器的超时时间是10秒以后，那epoll_wait需要超时3次才会触发。每次超时之后除了要检查有没有要触发的定时器，还顺便检查一下系统时间有没有被往回调。如果系统时间往回调了1个小时以上，那就触发全部定时器。个人感觉这个办法有些粗糙，其实只需要换个时间源就可以解决校时问题，换成clock_gettime(CLOCK_MONOTONIC_RAW)的方式获取系统的单调时间，就可以解决这个问题了。</p></li></ol><h3 id="九-hook模块"><a href="#九-hook模块" class="headerlink" title="九 hook模块"></a>九 hook模块</h3><p>hook系统底层和socket相关的API，socket IO相关的API，以及sleep系列的API。hook的开启控制是线程粒度的，可以自由选择。通过hook模块，可以使一些不具异步功能的API，展现出异步的性能，如MySQL。</p><p>注意：本篇提到的系统调用接口实际是指C标准函数库提供的接口，而不是单指Linux提供的系统调用，比如malloc和free就不是系统调用，它们是C标准函数库提供的接口。</p><h4 id="9-1-hook概述"><a href="#9-1-hook概述" class="headerlink" title="9.1 hook概述"></a>9.1 hook概述</h4><h5 id="9-1-1-理解hook"><a href="#9-1-1-理解hook" class="headerlink" title="9.1.1 理解hook"></a>9.1.1 理解hook</h5><p>hook实际上就是对系统调用API进行一次封装，将其封装成一个与原始的系统调用API同名的接口，应用在调用这个接口时，会先执行封装中的操作，再执行原始的系统调用API。</p><p>hook技术可以使应用程序在执行系统调用之前进行一些隐藏的操作，比如可以对系统提供malloc()和free()进行hook，在真正进行内存分配和释放之前，统计内存的引用计数，以排查内存泄露问题。</p><p>还可以用C++的子类重载来理解hook。在C++中，子类在重载父类的同名方法时，一种常见的实现方式是子类先完成自己的操作，再调用父类的操作，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is Base&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/// 子类重载时先实现自己的操作，再调用父类的操作</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;This is Child&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        Base::Print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在上面的代码实现中，调用子类的Print方法，会先执行子类的语句，然后再调用父类的Print方法，这就相当于子类hook了父类的Print方法。 </p><p>由于hook之后的系统调用与原始的系统系统调用同名，所以对于程序开发者来说也很方便，不需要重新学习新的接口，只需要按老的接口调用惯例直接写代码就行了。</p><h5 id="9-1-2-hook功能"><a href="#9-1-2-hook功能" class="headerlink" title="9.1.2 hook功能"></a>9.1.2 hook功能</h5><p>hook的目的是在不重新编写代码的情况下，把老代码中的socket IO相关的API都转成异步，以提高性能。hook和IO协程调度是密切相关的，如果不使用IO协程调度器，那hook没有任何意义。</p><blockquote><p>考虑IOManager要在一个线程上按顺序调度以下协程：</p><ol><li>协程1：sleep(2) 睡眠两秒后返回。</li><li>协程2：在scoket fd1 上send 100k数据。</li><li>协程3：在socket fd2 上recv直到数据接收成功。</li></ol><p>在未hook的情况下，IOManager要调度上面的协程，流程是下面这样的：</p><ol><li>调度协程1，协程阻塞在sleep上，等2秒后返回，这两秒内调度线程是被协程1占用的，其他协程无法在当前线程上调度。</li><li>调度协徎2，协程阻塞send 100k数据上，这个操作一般问题不大，因为send数据无论如何都要占用时间，但如果fd迟迟不可写，那send会阻塞直到套接字可写，同样，在阻塞期间，其他协程也无法在当前线程上调度。</li><li>调度协程3，协程阻塞在recv上，这个操作要直到recv超时或是有数据时才返回，期间调度器也无法调度其他协程。</li></ol><p>上面的调度流程最终总结起来就是，协程只能按顺序调度，一旦有一个协程阻塞住了，那整个调度线程也就阻塞住了，其他的协程都无法在当前线程上执行。</p></blockquote><p>像这种一条路走到黑的方式其实并不是完全不可避免，<strong>以sleep为例，调度器完全可以在检测到协程sleep后，将协程yield以让出执行权，同时设置一个定时器，2秒后再将协程重新resume。</strong>这样，调度器就可以在这2秒期间调度其他的任务，同时还可以顺利的实现sleep 2秒后再继续执行协程的效果，send/recv与此类似。</p><p>在完全实现hook后，IOManager的执行流程将变成下面的方式：</p><ol><li>调度协程1，检测到协程sleep，那么先添加一个2秒的定时器，定时器回调函数是在调度器上继续调度本协程，接着协程yield，等定时器超时。</li><li>因为上一步协程1已经yield了，所以协徎2并不需要等2秒后才可以执行，而是立刻可以执行。同样，调度器检测到协程send，由于不知道fd是不是马上可写，所以先在IOManager上给fd注册一个写事件，回调函数是让当前协程resume并执行实际的send操作，然后当前协程yield，等可写事件发生。</li><li>上一步协徎2也yield了，可以马上调度协程3。协程3与协程2类似，也是给fd注册一个读事件，回调函数是让当前协程resume并继续recv，然后本协程yield，等事件发生。</li><li>等2秒超时后，执行定时器回调函数，将协程1 resume以便继续执行。</li><li>等协程2的fd可写，一旦可写，调用写事件回调函数将协程2 resume以便继续执行send。</li><li>等协程3的fd可读，一旦可读，调用回调函数将协程3 resume以便继续执行recv。</li></ol><p>上面的4、5、6步都是异步的，调度线程并不会阻塞，IOManager仍然可以调度其他的任务，只在相关的事件发生后，再继续执行对应的任务即可。并且，由于hook的函数签名与原函数一样，所以对调用方也很方便，只需要<strong>以同步的方式编写代码，实现的效果却是异步执行的，效率很高。</strong></p><p><strong>总而言之，在IO协程调度中对相关的系统调用进行hook，可以让调度线程尽可能得把时间片都花在有意义的操作上，而不是浪费在阻塞等待中。</strong></p><p><strong>hook的重点是在替换API的底层实现的同时完全模拟其原本的行为</strong>，因为调用方是不知道hook的细节的，在调用被hook的API时，如果其行为与原本的行为不一致，就会给调用方造成困惑。比如，所有的socket fd在进行IO调度时都会被设置成NONBLOCK模式，如果用户未显式地对fd设置NONBLOCK，那就要处理好fcntl，不要对用户暴露fd已经是NONBLOCK的事实，这点也说明，除了IO相关的函数要进行hook外，对fcntl, setsockopt之类的功能函数也要进行hook，才能保证API的一致性。</p><h5 id="9-1-3-hook实现"><a href="#9-1-3-hook实现" class="headerlink" title="9.1.3 hook实现"></a>9.1.3 hook实现</h5><p>这里只讲解动态链接中的hook实现，静态链接以及基于内核模块的hook不在本章讨论范围。</p><p>在学习hook之前需要对Linux的动态链接有一定的了解，建议阅读《程序员的自我修养 —— 链接、装载与库》第7章。本站 <a href="https://www.midlane.top/wiki/pages/viewpage.action?pageId=16418206">关于链接与装载的几个测试代码</a> 提供了一些示例，有助于理解动态链接的具体行为。</p><p><strong>hook的实现机制非常简单，就是通过动态库的全局符号介入功能，用自定义的接口来替换掉同名的系统调用接口。由于系统调用接口基本上是由C标准函数库libc提供的，所以这里要做的事情就是用自定义的动态库来覆盖掉libc中的同名符号。</strong></p><p>基于动态链接的hook有两种方式，<strong>第一种是外挂式hook</strong>，也称为非侵入式hook，通过优先加载自定义动态库来实现对后加载的动态库进行hook，这种hook方式不需要重新编译代码，考虑以下例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;hello world\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello world\n&quot;</span>)); <span class="comment">// 调用系统调用write写标准输出文件描述符</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面在不重新编译代码的情况下，用自定义的动态库来替换掉可执行程序a.out中的write实现，新建hook.c，内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    syscall(SYS_write, STDOUT_FILENO, <span class="string">&quot;12345\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;12345\n&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里实现了一个write函数，这个函数的签名和libc提供的write函数完全一样，函数内容是用syscall的方式直接调用编号为SYS_write的系统调用，实现的效果也是往标准输出写内容，只不过这里我们将输出内容替换成了其他值。将hook.c编译成动态库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">gcc -fPIC -shared hook.c -o libhook.so</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">通过设置 LD_PRELOAD环境变量，将libhoook.so设置成优先加载，从面覆盖掉libc中的write函数，如下：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> LD_PRELOAD=<span class="string">&quot;./libhook.so&quot;</span> ./a.out</span></span><br><span class="line">12345</span><br></pre></td></tr></table></figure><p>这里我们并没有重新编译可执行程序a.out，但是可以看到，write的实现已经替换成了我们自己的实现。究其原因，就是LD_PRELOAD环境变量，它指明了在运行a.out之前，系统会优先把libhook.so加载到了程序的进程空间，使得在a.out运行之前，其全局符号表中就已经有了一个write符号，这样在后续加载libc共享库时，由于全局符号介入机制，libc中的write符号不会再被加入全局符号表，所以全局符号表中的write就变成了我们自己的实现。</p><p><strong>第二种方式的hook是侵入式的，</strong>需要改造代码或是重新编译一次以指定动态库加载顺序。如果是以改造代码的方式来实现hook，那么可以像下面这样直接将write函数的实现放在main.c里，那么编译时全局符号表里先出现的必然是main.c中的write符号：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/syscall.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count)</span> </span>&#123;</span><br><span class="line">    syscall(SYS_write, STDOUT_FILENO, <span class="string">&quot;12345\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;12345\n&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    write(STDOUT_FILENO, <span class="string">&quot;hello world\n&quot;</span>, <span class="built_in">strlen</span>(<span class="string">&quot;hello world\n&quot;</span>)); <span class="comment">// 这里调用的是上面的write实现</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果不改造代码，那么可以重新编译一次，通过编译参数将自定义的动态库放在libc之前进行链接。由于默认情况下gcc总会链接一次libc，并且libc的位置也总在命令行所有参数后面，所以只需要像下面这样操作就可以了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># gcc main.c -L. -lhook -Wl,-rpath=.</span></span><br><span class="line"># ./a.out</span><br><span class="line"><span class="number">12345</span></span><br></pre></td></tr></table></figure><blockquote><p>这里显式指定了链接libhook.so（<code>-Wl,-rpath=.</code>用于指定运行时的动态库搜索路径，避免找不到动态库的问题），由于libhook.so的链接位置比libc要靠前（可以通过gcc -v进行验证），所以运行时会先加载libhook.so，从而实现全局符号介入，这点也可以通过ldd命令来查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ldd a.out</span></span><br><span class="line">        linux-vdso.so.1 (0x00007ffe615f9000)</span><br><span class="line">        libhook.so =&gt; ./libhook.so (0x00007fab4bae3000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007fab4b8e9000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007fab4baef000)</span><br></pre></td></tr></table></figure></blockquote><p>于hook的另一个讨论点是<strong>如何找回已经被全局符号介入机制覆盖的系统调用接口</strong>，这个功能非常实用，因为大部分情况下，系统调用提供的功能都是无可替代的，我们虽然可以用hook的方式将其替换成自己的实现，但是最终要实现的功能，还是得由原始的系统调用接口来完成。</p><blockquote><p>以malloc和free为例，假如我们要hook标准库提供的malloc和free接口，以跟踪每次分配和释放的内存地址，判断有无内存泄漏问题，那么具体的实现方式应该是，先调用自定义的malloc和free实现，在分配和释放内存之前，记录下内存地址，然后再调用标准库里的malloc和free，以真正实现内存申请和释放。</p></blockquote><p>上面的过程涉及到了查找后加载的动态库里被覆盖的符号地址问题。首先，这个操作本身就具有合理性，因为程序运行时，依赖的动态库无论是先加载还是后加载，最终都会被加载到程序的进程空间中，也就是说，那些因为<strong>加载顺序靠后而被覆盖的符号，它们只是被“雪藏”了而已，实际还是存在于程序的进程空间中的，通过一定的办法，可以把它们再找回来。</strong>在Linux中，这个方法就是<code>dslym</code>，它的函数原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">dlsym</span><span class="params">(<span class="keyword">void</span> *handle, <span class="keyword">const</span> <span class="keyword">char</span> *symbol)</span></span>;</span><br></pre></td></tr></table></figure><p>关于dlsym的使用可参考<code>man 3 dlsym</code>，在<strong>链接时需要指定 <code>-ldl</code> 参数</strong>。<strong>使用dlsym找回被覆盖的符号时，第一个参数固定为 <code>RTLD_NEXT</code>，第二个参数为符号的名称，下面通过dlsym来实现上面的内存跟踪功能：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dlfcn.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">void</span>* (*<span class="keyword">malloc_func_t</span>)(<span class="keyword">size_t</span> size);</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*<span class="keyword">free_func_t</span>)</span><span class="params">(<span class="keyword">void</span> *ptr)</span></span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 这两个指针用于保存libc中的malloc和free的地址</span></span><br><span class="line"><span class="keyword">malloc_func_t</span> sys_malloc = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">free_func_t</span> sys_free = <span class="literal">NULL</span>;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// 重定义malloc和free，在这里重定义会导致libc中的同名符号被覆盖</span></span><br><span class="line"><span class="comment">// 这里不能调用带缓冲的printf接口，否则会出段错误</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">malloc</span><span class="params">(<span class="keyword">size_t</span> size)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先调用标准库里的malloc申请内存，再记录内存分配信息，这里只是简单地将内存地址和长度打印出来</span></span><br><span class="line">    <span class="keyword">void</span> *ptr = sys_malloc(size);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;malloc: ptr=%p, length=%ld\n&quot;</span>, ptr, size);</span><br><span class="line">    <span class="keyword">return</span> ptr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(<span class="keyword">void</span> *ptr)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 打印内存释放信息，再调用标准库里的free释放内存</span></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;free: ptr=%p\n&quot;</span>, ptr);</span><br><span class="line">    sys_free(ptr);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过dlsym找到标准库中的malloc和free的符号地址</span></span><br><span class="line">    sys_malloc = dlsym(RTLD_NEXT, <span class="string">&quot;malloc&quot;</span>);</span><br><span class="line">    assert(dlerror() == <span class="literal">NULL</span>);</span><br><span class="line">    sys_free = dlsym(RTLD_NEXT, <span class="string">&quot;free&quot;</span>);</span><br><span class="line">    assert(dlerror() == <span class="literal">NULL</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">char</span> *ptrs[<span class="number">5</span>];</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        ptrs[i] = <span class="built_in">malloc</span>(<span class="number">100</span> + i);</span><br><span class="line">        <span class="built_in">memset</span>(ptrs[i], <span class="number">0</span>, <span class="number">100</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">        <span class="built_in">free</span>(ptrs[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译运行以上代码，效果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> gcc hook_malloc.c -ldl</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ./a.out</span></span><br></pre></td></tr></table></figure><img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230322170118458.png" class="" title="image-20230322170118458"><h4 id="9-2-hook-模块设计"><a href="#9-2-hook-模块设计" class="headerlink" title="9.2 hook 模块设计"></a>9.2 hook 模块设计</h4><p>sylar的hook功能以线程为单位，可自由设置当前线程是否使用hook。默认情况下，协程调度器的调度线程会开启hook，而其他线程则不会开启。</p><p>sylar对以下函数进行了hook，并且只对socket fd进行了hook，如果操作的不是socket fd，那会直接调用系统原本的API，而不是hook之后的API：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">sleep</span><br><span class="line">usleep</span><br><span class="line">nanosleep</span><br><span class="line">socket</span><br><span class="line">connect</span><br><span class="line">accept</span><br><span class="line">read</span><br><span class="line">readv</span><br><span class="line">recv</span><br><span class="line">recvfrom</span><br><span class="line">recvmsg</span><br><span class="line">write</span><br><span class="line">writev</span><br><span class="line">send</span><br><span class="line">sendto</span><br><span class="line">sendmsg</span><br><span class="line">close</span><br><span class="line">fcntl</span><br><span class="line">ioctl</span><br><span class="line">getsockopt</span><br><span class="line">setsockopt</span><br></pre></td></tr></table></figure><p>除此外，sylar还增加了一个 <code>connect_with_timeout</code> 接口用于实现带超时的connect。</p><p><strong>为了管理所有的socket fd，sylar设计了一个FdManager类来记录所有分配过的fd的上下文，这是一个单例类，每个socket fd上下文记录了当前fd的读写超时，是否设置非阻塞等信息。</strong></p><p>关于hook模块和IO协程调度的整合。一共有三类接口需要hook，如下：</p><ol><li><p>sleep延时系列接口，包括sleep/usleep/nanosleep。对于这些接口的hook，只需要给IO协程调度器注册一个定时事件，在定时事件触发后再继续执行当前协程即可。当前协程在注册完定时事件后即可yield让出执行权。</p></li><li><p>socket IO系列接口，包括read/write/recv/send…等，connect及accept也可以归到这类接口中。这类接口的hook首先需要判断操作的fd是否是socket fd，以及用户是否显式地对该fd设置过非阻塞模式，如果不是socket fd或是用户显式设置过非阻塞模式，那么就不需要hook了，直接调用操作系统的IO接口即可。如果需要hook，那么首先在IO协程调度器上注册对应的读写事件，等事件发生后再继续执行当前协程。当前协程在注册完IO事件即可yield让出执行权。</p></li><li><p>socket/fcntl/ioctl/close等接口，这类接口主要处理的是边缘情况，比如分配fd上下文，处理超时及用户显式设置非阻塞问题。</p></li></ol><h4 id="9-3-hook模块实现"><a href="#9-3-hook模块实现" class="headerlink" title="9.3 hook模块实现"></a>9.3 hook模块实现</h4><h5 id="9-3-1-关于fd上下文的类"><a href="#9-3-1-关于fd上下文的类" class="headerlink" title="9.3.1 关于fd上下文的类"></a>9.3.1 关于fd上下文的类</h5><p>首先是socket fd上下文和FdManager的实现，这两个类用于记录fd上下文和保存全部的fd上下文，它们的关键实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 文件句柄上下文类</span></span><br><span class="line"><span class="comment"> * @details 管理文件句柄类型(是否socket)</span></span><br><span class="line"><span class="comment"> *          是否阻塞,是否关闭,读/写超时时间</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FdCtx</span> :</span> <span class="keyword">public</span> <span class="built_in">std</span>::enable_shared_from_this&lt;FdCtx&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;FdCtx&gt; ptr;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 通过文件句柄构造FdCtx</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FdCtx(<span class="keyword">int</span> fd);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 析构函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    ~FdCtx();</span><br><span class="line">    ....</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 是否初始化</span></span><br><span class="line">    <span class="keyword">bool</span> m_isInit: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 是否socket</span></span><br><span class="line">    <span class="keyword">bool</span> m_isSocket: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 是否hook非阻塞</span></span><br><span class="line">    <span class="keyword">bool</span> m_sysNonblock: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 是否用户主动设置非阻塞</span></span><br><span class="line">    <span class="keyword">bool</span> m_userNonblock: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 是否关闭</span></span><br><span class="line">    <span class="keyword">bool</span> m_isClosed: <span class="number">1</span>;</span><br><span class="line">    <span class="comment">/// 文件句柄</span></span><br><span class="line">    <span class="keyword">int</span> m_fd;</span><br><span class="line">    <span class="comment">/// 读超时时间毫秒</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_recvTimeout;</span><br><span class="line">    <span class="comment">/// 写超时时间毫秒</span></span><br><span class="line">    <span class="keyword">uint64_t</span> m_sendTimeout;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief 文件句柄管理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FdManager</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> RWMutex RWMutexType;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 无参构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FdManager();</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 获取/创建文件句柄类FdCtx</span></span><br><span class="line"><span class="comment">     * @param[in] fd 文件句柄</span></span><br><span class="line"><span class="comment">     * @param[in] auto_create 是否自动创建</span></span><br><span class="line"><span class="comment">     * @return 返回对应文件句柄类FdCtx::ptr</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function">FdCtx::ptr <span class="title">get</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">bool</span> auto_create = <span class="literal">false</span>)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * @brief 删除文件句柄类</span></span><br><span class="line"><span class="comment">     * @param[in] fd 文件句柄</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">del</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">/// 读写锁</span></span><br><span class="line">    RWMutexType m_mutex;</span><br><span class="line">    <span class="comment">/// 文件句柄集合</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;FdCtx::ptr&gt; m_datas;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/// 文件句柄单例</span></span><br><span class="line"><span class="keyword">typedef</span> Singleton&lt;FdManager&gt; FdMgr;</span><br></pre></td></tr></table></figure><p>FdCtx类在用户态记录了fd的读写超时和非阻塞信息，其中非阻塞包括用户显式设置的非阻塞和hook内部设置的非阻塞，区分这两种非阻塞可以有效应对用户对fd设置/获取NONBLOCK模式的情形。</p><p>另外注意一点，FdManager类对FdCtx的寻址采用了和IOManager中对FdContext的寻址一样的寻址方式，直接用fd作为数组下标进行寻址。</p><h5 id="9-3-2-整体实现"><a href="#9-3-2-整体实现" class="headerlink" title="9.3.2 整体实现"></a>9.3.2 整体实现</h5><p>接下来是hook的整体实现。首先定义线程局部变量t_hook_enable，用于表示当前线程是否启用hook，使用线程局部变量表示hook模块是线程粒度的，各个线程可单独启用或关闭hook。然后是获取各个被hook的接口的原始地址， 这里要借助dlsym来获取。sylar使用了一套宏来简化编码，这套宏的实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HOOK_FUN(XX) \</span></span><br><span class="line">    XX(sleep) \</span><br><span class="line">    XX(usleep) \</span><br><span class="line">    XX(nanosleep) \</span><br><span class="line">    XX(socket) \</span><br><span class="line">    XX(connect) \</span><br><span class="line">    XX(accept) \</span><br><span class="line">    XX(read) \</span><br><span class="line">    XX(readv) \</span><br><span class="line">    XX(recv) \</span><br><span class="line">    XX(recvfrom) \</span><br><span class="line">    XX(recvmsg) \</span><br><span class="line">    XX(write) \</span><br><span class="line">    XX(writev) \</span><br><span class="line">    XX(send) \</span><br><span class="line">    XX(sendto) \</span><br><span class="line">    XX(sendmsg) \</span><br><span class="line">    XX(close) \</span><br><span class="line">    XX(fcntl) \</span><br><span class="line">    XX(ioctl) \</span><br><span class="line">    XX(getsockopt) \</span><br><span class="line">    XX(setsockopt)</span><br><span class="line"> </span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(name) name ## _fun name ## _f = nullptr;</span></span><br><span class="line">    HOOK_FUN(XX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hook_init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">bool</span> is_inited = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(is_inited) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(name) name ## _f = (name ## _fun)dlsym(RTLD_NEXT, #name);</span></span><br><span class="line">    HOOK_FUN(XX);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的宏展开之后的效果如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line">    sleep_fun sleep_f = <span class="literal">nullptr</span>; \</span><br><span class="line">    usleep_fun usleep_f = <span class="literal">nullptr</span>; \</span><br><span class="line">    ....</span><br><span class="line">    setsocketopt_fun setsocket_f = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">hook_init() &#123;</span><br><span class="line">    ...</span><br><span class="line">     </span><br><span class="line">    sleep_f = (sleep_fun)dlsym(RTLD_NEXT, <span class="string">&quot;sleep&quot;</span>); \</span><br><span class="line">    usleep_f = (usleep_fun)dlsym(RTLD_NEXT, <span class="string">&quot;usleep&quot;</span>); \</span><br><span class="line">    ...</span><br><span class="line">    setsocketopt_f = (setsocketopt_fun)dlsym(RTLD_NEXT, <span class="string">&quot;setsocketopt&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>hook_init() 放在一个静态对象的构造函数中调用，这表示在main函数运行之前就会获取各个符号的地址并保存在全局变量中。</p><h5 id="9-3-3-各个接口实现"><a href="#9-3-3-各个接口实现" class="headerlink" title="9.3.3 各个接口实现"></a>9.3.3 各个接口实现</h5><p>最后是各个接口的hook实现，这部分和上面的全局变量定义要放在extern “C”中，以防止C++编译器对符号名称添加修饰。由于被hook的接口要完全模拟原接口的行为，所以这里要小心处理好各种边界情况以及返回值和errno问题。</p><p>首先是sleep/usleep/nanosleep的hook实现，它们的实现思路完全一样，即先添加定时器再yield，比如sleep函数的hook代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">sleep</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> seconds)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sylar::t_hook_enable) &#123;</span><br><span class="line">        <span class="keyword">return</span> sleep_f(seconds);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sylar::Fiber::ptr fiber = sylar::Fiber::GetThis();</span><br><span class="line">    sylar::IOManager* iom = sylar::IOManager::GetThis();</span><br><span class="line">    iom-&gt;addTimer(seconds * <span class="number">1000</span>, <span class="built_in">std</span>::bind((<span class="keyword">void</span>(sylar::Scheduler::*)</span><br><span class="line">            (sylar::Fiber::ptr, <span class="keyword">int</span> thread))&amp;sylar::IOManager::schedule</span><br><span class="line">            ,iom, fiber, <span class="number">-1</span>));</span><br><span class="line">    sylar::Fiber::GetThis()-&gt;yield();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是socket接口的hook实现，socket用于创建套接字，需要在拿到fd后将其添加到FdManager中，代码实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sylar::t_hook_enable) &#123;</span><br><span class="line">        <span class="keyword">return</span> socket_f(domain, type, protocol);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> fd = socket_f(domain, type, protocol);</span><br><span class="line">    <span class="keyword">if</span>(fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> fd;</span><br><span class="line">    &#125;</span><br><span class="line">    sylar::FdMgr::GetInstance()-&gt;get(fd, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来是connect和connect_with_timeout的实现，由于connect有默认的超时，所以这里只需要实现connect_with_timeout即可：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect_with_timeout</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen, <span class="keyword">uint64_t</span> timeout_ms)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!sylar::t_hook_enable) &#123;</span><br><span class="line">        <span class="keyword">return</span> connect_f(fd, addr, addrlen);</span><br><span class="line">    &#125;</span><br><span class="line">    sylar::FdCtx::ptr ctx = sylar::FdMgr::GetInstance()-&gt;get(fd);</span><br><span class="line">    <span class="keyword">if</span>(!ctx || ctx-&gt;isClose()) &#123;</span><br><span class="line">        errno = EBADF;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(!ctx-&gt;isSocket()) &#123;</span><br><span class="line">        <span class="keyword">return</span> connect_f(fd, addr, addrlen);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(ctx-&gt;getUserNonblock()) &#123;</span><br><span class="line">        <span class="keyword">return</span> connect_f(fd, addr, addrlen);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> n = connect_f(fd, addr, addrlen);</span><br><span class="line">    <span class="keyword">if</span>(n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(n != <span class="number">-1</span> || errno != EINPROGRESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    sylar::IOManager* iom = sylar::IOManager::GetThis();</span><br><span class="line">    sylar::Timer::ptr timer;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;timer_info&gt; <span class="title">tinfo</span><span class="params">(<span class="keyword">new</span> timer_info)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::weak_ptr&lt;timer_info&gt; <span class="title">winfo</span><span class="params">(tinfo)</span></span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span>(timeout_ms != (<span class="keyword">uint64_t</span>)<span class="number">-1</span>) &#123;</span><br><span class="line">        timer = iom-&gt;addConditionTimer(timeout_ms, [winfo, fd, iom]() &#123;</span><br><span class="line">                <span class="keyword">auto</span> t = winfo.lock();</span><br><span class="line">                <span class="keyword">if</span>(!t || t-&gt;cancelled) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                t-&gt;cancelled = ETIMEDOUT;</span><br><span class="line">                iom-&gt;cancelEvent(fd, sylar::IOManager::WRITE);</span><br><span class="line">        &#125;, winfo);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> rt = iom-&gt;addEvent(fd, sylar::IOManager::WRITE);</span><br><span class="line">    <span class="keyword">if</span>(rt == <span class="number">0</span>) &#123;</span><br><span class="line">        sylar::Fiber::GetThis()-&gt;yield();</span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            timer-&gt;cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tinfo-&gt;cancelled) &#123;</span><br><span class="line">            errno = tinfo-&gt;cancelled;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(timer) &#123;</span><br><span class="line">            timer-&gt;cancel();</span><br><span class="line">        &#125;</span><br><span class="line">        SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;connect addEvent(&quot;</span> &lt;&lt; fd &lt;&lt; <span class="string">&quot;, WRITE) error&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">socklen_t</span> len = <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">-1</span> == getsockopt(fd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;len)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!error) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        errno = error;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的实现重点如下：</p><ol><li>判断传入的fd是否为套接字，如果不为套接字，则调用系统的connect函数并返回。</li><li>判断fd是否被显式设置为了非阻塞模式，如果是则调用系统的connect函数并返回。</li><li>调用系统的connect函数，由于套接字是非阻塞的，这里会直接返回EINPROGRESS错误。</li><li>如果超时参数有效，则添加一个条件定时器，在定时时间到后通过t-&gt;cancelled设置超时标志并触发一次WRITE事件。</li><li>添加WRITE事件并yield，等待WRITE事件触发再往下执行。</li><li>等待超时或套接字可写，如果先超时，则条件变量winfo仍然有效，通过winfo来设置超时标志并触发WRITE事件，协程从yield点返回，返回之后通过超时标志设置errno并返回-1；如果在未超时之前套接字就可写了，那么直接取消定时器并返回成功。取消定时器会导致定时器回调被强制执行一次，但这并不会导致问题，因为只有当前协程结束后，定时器回调才会在接下来被调度，由于定时器回调被执行时connect_with_timeout协程已经执行完了，所以理所当然地条件变量也被释放了，所以实际上定时器回调函数什么也没做。这里是sylar条件定时器的巧妙应用，自行体会，感觉说得不是很清楚。</li></ol><p>接下来是accept和read/write/recv/send等IO接口的hook实现，这里sylar又一次充分发挥了懒得写代码的本事，用一个do_io模板函数将全部情况都囊括了进来。do_io模板函数的实现与上面的connect_with_timout实现基本一致，都借助了条件定时器和READ/WRITE事件，这里我也懒得写了，自行看代码。</p><p>最后是一些边边角角的情况，有以下几个要注意：</p><ol><li>close，这里除了要删除fd的上下文，还要取消掉fd上的全部事件，这会让fd的读写事件回调都执行一次。</li><li>fcntl，这里的O_NONBLOCK标志要特殊处理，因为所有参与协程调度的fd都会被设置成非阻塞模式，所以要在应用层维护好用户设置的非阻塞标志。</li><li>ioctl，同样要特殊处理FIONBIO命令，这个命令用于设置非阻塞，处理方式和上面的fcntl一样。</li><li>setsocketopt，这里要特殊处理SO_RECVTIMEO和SO_SNDTIMEO，在应用层记录套接字的读写超时，方便协程调度器获取。</li></ol><h4 id="9-4-注意事项"><a href="#9-4-注意事项" class="headerlink" title="9.4 注意事项"></a>9.4 注意事项</h4><ol><li>由于定时器模块只支持毫秒级定时，所以被hook后的nanosleep()实际精度只能达到毫秒级，而不是纳秒级。</li><li>按照 <code>man 2 socket</code> 的描述，自2.6.27版本的内核开始socket函数支持直接在type中位或SOCK_NONBLOCK标志位以创建非阻塞套接字，sylar的hook模块未处理这种情况。</li><li>按sylar hook模块的实现，非调度线程不支持启用hook。</li></ol><h3 id="十-Address-模块"><a href="#十-Address-模块" class="headerlink" title="十 Address 模块"></a>十 Address 模块</h3><hr><h4 id="10-1-Address模块概述"><a href="#10-1-Address模块概述" class="headerlink" title="10.1 Address模块概述"></a>10.1 Address模块概述</h4><p>提供网络地址相关的类，支持与网络地址相关的操作，一共有以下几个类：</p><ul><li><code>Address</code>：所有网络地址的基类，抽象类，对应sockaddr类型，但只包含抽象方法，不包含具体的成员。除此外，Address作为地址类还提供了网络地址查询及网卡地址查询功能。</li><li><code>IPAddress</code>：IP地址的基类，抽象类，在Address基础上，增加了IP地址相关的端口以及子网掩码、广播地址、网段地址操作，同样是只包含抽象方法，不包含具体的成员。</li><li><code>IPv4Address</code>：IPv4地址类，实体类，表示一个IPv4地址，对应sockaddr_in类型，包含一个sockaddr_in成员，可以操作该成员的网络地址和端口，以及获取子码掩码等操作。</li><li><code>IPv6Address</code>：IPv6地址类，实体类，与IPv4Address类似，表示一个IPv6地址，对应sockaddr_in6类型，包含一个sockaddr_in6成员。</li><li><code>UnixAddreess</code>：Unix域套接字类，对应sockaddr_un类型，同上。</li><li><code>UnknownAddress</code>：表示一个未知类型的套接字地址，实体类，对应sockaddr类型，这个类型与Address类型的区别是它包含一个sockaddr成员，并且是一个实体类。</li></ul><p>整个网络地址模块的类继承关系图如下：</p><img src="sylar服务器开发/image-20230323212942172.png" alt="image-20230323212942172" style="zoom:67%;" /><h4 id="10-2-关于套接字地址"><a href="#10-2-关于套接字地址" class="headerlink" title="10.2 关于套接字地址"></a>10.2 关于套接字地址</h4><p>Linux使用<strong>Berkeley套接字接口</strong>进行网络编程，这套接口是事实上的标准网络套接字编程接口，在基本所有的系统上都支持。Berkeley套接字接口提供了一系列用于网络编程的通用API，通过这些API可以实现跨主机之间网络通信，或是在本机上通过Unix域套接字进行进程间通信。</p><p>Berkeley套接字接口拟定了一个<strong>通用套接字地址结构sockaddr</strong>，用于表示任意类型的地址，所有的套接字API在传入地址参数时都只需要传入sockaddr类型，以保证接口的通用性。除通用地址结构sockaddr外，还有一系列表示具体的网络地址的结构，<strong>这些具体的网络地址结构用于用户赋值，但在使用时，都要转化成sockaddr的形式。</strong></p><p>sockaddr表示通用套接字地址结构，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sa_family; <span class="comment">// 地址族，也就是地址类型</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>];         <span class="comment">// 地址内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p><strong>所有的套接字API都是以指针形式接收sockaddr参数</strong>，并且额外需要一个地址长度参数，这可以保证当sockaddr本身不足以容纳一个具体的地址时，可以通过指针取到全部的内容。比如上面的地址内容占14字节，这并不足以容纳一个128位16字节的IPv6地址。但当以指针形式传入时，完全可以通过指针取到适合IPv6的长度。</p></blockquote><p><strong>除sockaddr外，套接字接口还定义了一系列具体的网络地址结构，比如sockaddr_in表示IPv4地址</strong>，sockaddr_in6表示IPv6地址，sockaddr_un表示Unix域套接字地址，它们的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_family; <span class="comment">// 地址族，IPv4的地址族为AF_INET</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin_port;   <span class="comment">// 端口</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>   <span class="comment">// IP地址，IPv4的地址用一个32位整数来表示</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>];          <span class="comment">// 填充位，填零即可</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sin6_family; <span class="comment">// 地址族，IPv6的地址族为AF_INET6</span></span><br><span class="line">    <span class="keyword">in_port_t</span> sin6_port;        <span class="comment">// 端口</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_flowinfo;     <span class="comment">// IPv6流控信息</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span>  <span class="comment">// IPv6地址，实际为一个128位的结构体</span></span><br><span class="line">    <span class="keyword">uint32_t</span> sin6_scope_id;     <span class="comment">// IPv6 scope-id</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> sun_family;  <span class="comment">// 地址族，Unix域套字地址族为AF_UNIX</span></span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];         <span class="comment">// 路径字符串</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>通过上面的定义也可以发现，除sockaddr_in可以无缝转换为sockaddr外，sockaddr_in6和sockaddr_un都不能转换为sockaddr，因为<strong>大小不一样。但这并不影响套接字接口的通用性，因为在使用时，所有类型的地址都会转换成sockaddr指针形式，又由于以上所有的地址结构的前两个字节都表示地址族，所以通过sockaddr指针总能拿到传入地址的地址类型，通过地址类型判断出地址长度后，再通过sockaddr指针取适合该地址的长度即可拿到地址内容。</strong></p><h4 id="10-3-其他的类"><a href="#10-3-其他的类" class="headerlink" title="10.3 其他的类"></a>10.3 其他的类</h4><h5 id="10-3-1-Address类"><a href="#10-3-1-Address类" class="headerlink" title="10.3.1 Address类"></a>10.3.1 Address类</h5><p>这个类是所有网络地址类的基类，并且是一个抽象类，对应的是sockaddr，表示通用网络地址。对于一个通用的网络地址，需要关注它的地址类型，sockaddr指针，地址长度这几项内容。</p><p>除此外，Address类还提供了地址解析与本机网卡地址查询的功能，地址解析功能可以实现域名解析，网卡地址查询可以获取本机指定网卡的IP地址。</p><h5 id="10-3-2-IPAddress类"><a href="#10-3-2-IPAddress类" class="headerlink" title="10.3.2 IPAddress类"></a>10.3.2 IPAddress类</h5><p>继承自Address类，表示一个IP地址，同样是一个抽象类，因为IP地址包含IPv4地址和IPv6地址。IPAddress类提供了IP地址相关的端口和掩码、网段地址、网络地址操作，无论是IPv4还是IPv6都支持这些操作，但这些方法都是抽象方法，需要由继承类来实现。</p><h5 id="10-3-3-IPv4Address类"><a href="#10-3-3-IPv4Address类" class="headerlink" title="10.3.3 IPv4Address类"></a>10.3.3 IPv4Address类</h5><p>继承自IPAddress类，表示一个IPv4地址，到这一步，IPv4Address就是一个实体类了，它包含一个sockaddr_in类型的成员，并且提供具体的端口设置/获取，掩码、网段、网络地址设置/获取操作。</p><h5 id="10-3-4-IPv6Address类"><a href="#10-3-4-IPv6Address类" class="headerlink" title="10.3.4 IPv6Address类"></a>10.3.4 IPv6Address类</h5><p>继承自IPAddress类，表示一个IPv6地址，也是一个实体类，实现思路和IPv4Address一致。</p><h5 id="10-3-5-UnixAddress类"><a href="#10-3-5-UnixAddress类" class="headerlink" title="10.3.5 UnixAddress类"></a>10.3.5 UnixAddress类</h5><p>继承自Address类，表示一个Unix域套接字地址，是一个实体类，可以用于实例化对象。UnixAddress类包含一个sockaddr_un对象以及一个路径字符串长度。</p><h5 id="10-3-6-UnknownAddress类"><a href="#10-3-6-UnknownAddress类" class="headerlink" title="10.3.6 UnknownAddress类"></a>10.3.6 UnknownAddress类</h5><p>继承自Address类，包含一个sockaddr成员，表示未知的地址类型。</p><h3 id="11-Socket模块"><a href="#11-Socket模块" class="headerlink" title="11 Socket模块"></a>11 Socket模块</h3><p>套接字类，表示一个套接字对象。</p><p>对于套接字类，需要关注以下属性：</p><ol><li>文件描述符</li><li>地址类型（AF_INET, AF_INET6等）</li><li>套接字类型（SOCK_STREAM, SOCK_DGRAM等）</li><li>协议类型（这项其实可以忽略）</li><li>是否连接（针对TCP套接字，如果是UDP套接字，则默认已连接）</li><li>本地地址和对端的地址</li></ol><p>套接字类应提供以下方法：</p><ol><li>创建各种类型的套接字对象的方法（TCP套接字，UDP套接字，Unix域套接字）</li><li>设置套接字选项，比如超时参数</li><li>bind/connect/listen方法，实现绑定地址、发起连接、发起监听功能 </li><li>accept方法，返回连入的套接字对象</li><li>发送、接收数据的方法</li><li>获取本地地址、远端地址的方法</li><li>获取套接字类型、地址类型、协议类型的方法</li><li>取消套接字读、写的方法</li></ol><p>以下是Socket类的继承关系图：</p><img src="sylar服务器开发/image-20230324115003541.png" alt="image-20230324115003541" style="zoom:50%;" /><h3 id="12-ByteArray类"><a href="#12-ByteArray类" class="headerlink" title="12 ByteArray类"></a>12 ByteArray类</h3><p>字节数组容器，提供基础类型的序列化与反序列化功能。</p><p>ByteArray的底层存储是固定大小的块，以链表形式组织。每次写入数据时，将数据写入到链表最后一个块中，如果最后一个块不足以容纳数据，则分配一个新的块并添加到链表结尾，再写入数据。<strong>ByteArray会记录当前的操作位置，每次写入数据时，该操作位置按写入大小往后偏移，如果要读取数据，则必须调用setPosition重新设置当前的操作位置。</strong></p><p>ByteArray支持基础类型的序列化与反序列化功能，并且支持将序列化的结果写入文件，以及从文件中读取内容进行反序列化。ByteArray支持以下类型的序列化与反序列化：</p><ol><li>固定长度的有符号/无符号8位、16位、32位、64位整数</li><li>不固定长度的有符号/无符号32位、64位整数</li><li>float、double类型</li><li>字符串，包含字符串长度，长度范围支持16位、32位、64位。</li><li>字符串，不包含长度。</li></ol><p>以上所有的类型都支持读写。</p><p>ByteArray还支持设置序列化时的大小端顺序。</p><p>私有属性： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// 内存块的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> m_baseSize;</span><br><span class="line">    <span class="comment">/// 当前操作位置</span></span><br><span class="line">    <span class="keyword">size_t</span> m_position;</span><br><span class="line">    <span class="comment">/// 当前的总容量</span></span><br><span class="line">    <span class="keyword">size_t</span> m_capacity;</span><br><span class="line">    <span class="comment">/// 当前数据的大小</span></span><br><span class="line">    <span class="keyword">size_t</span> m_size;</span><br><span class="line">    <span class="comment">/// 字节序,默认大端</span></span><br><span class="line">    <span class="keyword">int8_t</span> m_endian;</span><br><span class="line">    <span class="comment">/// 第一个内存块指针</span></span><br><span class="line">    Node* m_root;</span><br><span class="line">    <span class="comment">/// 当前操作的内存块指针</span></span><br><span class="line">    Node* m_cur;</span><br></pre></td></tr></table></figure><p>浅谈序列化</p><p><strong>zigzag算法</strong></p><p>用于压缩较小的整数，参考：<a href="https://blog.csdn.net/zgwangbo/article/details/51590186">小而巧的数字压缩算法：zigzag_简单的老王-CSDN博客_zigzag编码</a>。</p><p>ByteArray在序列化不固定长度的有符号/无符号32位、64位整数时使用了zigzag算法。</p><p><strong>TLV编码结构</strong></p><p>用于序列化和消息传递，指Tag（类型），Length（长度），Value（值），参考：<a href="https://www.wtango.com/tlv%E7%BC%96%E7%A0%81%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE%E8%AE%BE%E8%AE%A1/">TLV编码通信协议设计 - Tango 博客 | Tango Blog</a>。</p><p>ByteArray在序列化字符串时使用TLV中的Length和Value。</p><h3 id="13-Stream-模块"><a href="#13-Stream-模块" class="headerlink" title="13 Stream 模块"></a>13 Stream 模块</h3><p>流结构，提供字节流读写接口。</p><p>所有的流结构都继承自抽象类Stream，Stream类规定了一个流必须具备read/write接口和readFixSize/writeFixSize接口，继承自Stream的类必须实现这些接口。</p><p>以下是Stream模块的继承关系图：</p><img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230324222943834.png" class="" title="image-20230324222943834"><p><strong>SocketStream类</strong></p><p>套接字流结构，将套接字封装成流结构，以支持Stream接口规范，除此外，SocketStream还支持套接字关闭操作以及获取本地/远端地址的操作。</p><h3 id="14-TcpServer类"><a href="#14-TcpServer类" class="headerlink" title="14 TcpServer类"></a>14 TcpServer类</h3><p>TCP服务器封装。</p><p>TcpServer类支持同时绑定多个地址进行监听，只需要在绑定时传入地址数组即可。TcpServer还可以分别指定接收客户端和处理客户端的协程调度器。</p><p>以下是TcpServer的继承关系图：</p><img src="sylar服务器开发/image-20230324223242442.png" alt="image-20230324223242442" style="zoom:67%;" /><p>TcpServer类采用了Template Pattern设计模式，它的HandleClient是交由继承类来实现的。使用TcpServer时，必须从TcpServer派生一个新类，并重新实现子类的handleClient操作，这点可以参考test_tcp_server.cc。</p><h3 id="15-HTTP模块"><a href="#15-HTTP模块" class="headerlink" title="15 HTTP模块"></a>15 HTTP模块</h3><p>提供HTTP服务，主要包含以下几个模块：</p><ol><li>HTTP常量定义，包括HTTP方法<code>HttpMethod</code>与HTTP状态<code>HttpStatus</code>。</li><li>HTTP请求与响应结构，对应<code>HttpRequest</code>和<code>HttpResponse</code>。</li><li>HTTP解析器，包含HTTP请求解析器与HTTP响应解析器，对应<code>HttpRequestParser</code>和<code>HttpResponseParser</code>。</li><li>HTTP会话结构，对应<code>HttpSession</code>。</li><li>HTTP服务器。</li><li>HTTP Servlet。</li><li>HTTP客户端<code>HttpConnection</code>，用于发起GET/POST等请求，支持连接池。</li></ol><p>HTTP模块依赖<a href="https://github.com/nodejs/http-parser">nodejs/http-parser</a>提供的HTTP解析器，并且直接复用了nodejs/http-parser中定义的HTTP方法与状态枚举。</p><h4 id="15-1-HTTP常量定义"><a href="#15-1-HTTP常量定义" class="headerlink" title="15.1 HTTP常量定义"></a>15.1 HTTP常量定义</h4><p><strong>http_parser/http_parser.h</strong> 包括HttpMethod和HttpStatus两个定义，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Request Methods */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HTTP_METHOD_MAP(XX)         \</span></span><br><span class="line">  XX(<span class="number">0</span>,  DELETE,      DELETE)       \</span><br><span class="line">  XX(<span class="number">1</span>,  GET,         GET)          \</span><br><span class="line">  XX(<span class="number">2</span>,  HEAD,        HEAD)         \</span><br><span class="line">  XX(<span class="number">3</span>,  POST,        POST)         \</span><br><span class="line">  XX(<span class="number">4</span>,  PUT,         PUT)          \</span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="comment">/* Status Codes */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HTTP_STATUS_MAP(XX)                                                 \</span></span><br><span class="line">  XX(<span class="number">100</span>, CONTINUE,                        Continue)                        \</span><br><span class="line">  XX(<span class="number">101</span>, SWITCHING_PROTOCOLS,             Switching Protocols)             \</span><br><span class="line">  XX(<span class="number">102</span>, PROCESSING,                      Processing)                      \</span><br><span class="line">  XX(<span class="number">200</span>, OK,                              OK)                              \</span><br><span class="line">  XX(<span class="number">201</span>, CREATED,                         Created)                         \</span><br><span class="line">  XX(<span class="number">202</span>, ACCEPTED,                        Accepted)                        \</span><br><span class="line">  XX(<span class="number">203</span>, NON_AUTHORITATIVE_INFORMATION,   Non-Authoritative Information)   \</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>http.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief HTTP方法枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">HttpMethod</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(num, name, string) name = num,</span></span><br><span class="line">    HTTP_METHOD_MAP(XX)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">    INVALID_METHOD</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @brief HTTP状态枚举</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">HttpStatus</span> &#123;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XX(code, name, desc) name = code,</span></span><br><span class="line">    HTTP_STATUS_MAP(XX)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">undef</span> XX</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="15-2-HTTP-请求与相应结构"><a href="#15-2-HTTP-请求与相应结构" class="headerlink" title="15.2 HTTP 请求与相应结构"></a>15.2 HTTP 请求与相应结构</h4><p>包括HttpRequest和HttpResponse两个结构，用于封装HTTP请求与响应。</p><p>关于HTTP请求和响应的格式可参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Messages">HTTP消息 - HTTP | MDN</a>，以下是一个HTTP请求与响应的示例：</p><img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/Clip_20230325_202242.png" class="" title="Clip_20230325_202242"><p>对于HTTP请求，需要关注HTTP方法，请求路径和参数，HTTP版本，HTTP头部的key-value结构，Cookies，以及HTTP Body内容。</p><p>对于HTTP响应，需要关注HTTP版本，响应状态码，响应字符串，响应头部的key-value结构，以及响应的Body内容。</p><h4 id="15-3-HTTP解析器"><a href="#15-3-HTTP解析器" class="headerlink" title="15.3 HTTP解析器"></a>15.3 HTTP解析器</h4><p>输入字节流，解析HTTP消息，包括HttpRequestParser和HttpResponseParser两个结构。</p><p>HTTP解析器基于<a href="https://github.com/nodejs/http-parser">nodejs/http-parser</a>实现，通过套接字读到HTTP消息后将消息内容传递给解析器，解析器通过回调的形式通知调用方HTTP解析的内容。</p><p>以下是HTTP解析器的类协作图：</p><img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230325204529999.png" class="" title="image-20230325204529999"><img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230325204548232.png" class="" title="image-20230325204548232"><h4 id="15-4-HTTP-会话结构httpsession"><a href="#15-4-HTTP-会话结构httpsession" class="headerlink" title="15.4 HTTP 会话结构httpsession"></a>15.4 HTTP 会话结构httpsession</h4><p>继承自SocketStream，实现了在套接字流上读取HTTP请求与发送HTTP响应的功能，在读取HTTP请求时需要借助HTTP解析器，以便于将套接字流上的内容解析成HTTP请求。以下是HttpSession的继承关系图：</p><img src="/2023/03/27/sylar%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/image-20230325210116271.png" class="" title="image-20230325210116271"><h4 id="15-5-HTTP服务器"><a href="#15-5-HTTP服务器" class="headerlink" title="15.5 HTTP服务器"></a>15.5 HTTP服务器</h4><p>继承自TcpServer，重载handleClient方法，将accept后得到的客户端套接字封装成HttpSession结构，以便于接收和发送HTTP消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">HttpServer::handleClient</span><span class="params">(Socket::ptr client)</span> </span>&#123;</span><br><span class="line">    SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;handleClient &quot;</span> &lt;&lt; *client;</span><br><span class="line">    <span class="function">HttpSession::ptr <span class="title">session</span><span class="params">(<span class="keyword">new</span> HttpSession(client))</span></span>;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">auto</span> req = session-&gt;recvRequest();</span><br><span class="line">        <span class="keyword">if</span>(!req) &#123;</span><br><span class="line">            SYLAR_LOG_DEBUG(g_logger) &lt;&lt; <span class="string">&quot;recv http request fail, errno=&quot;</span></span><br><span class="line">                &lt;&lt; errno &lt;&lt; <span class="string">&quot; errstr=&quot;</span> &lt;&lt; strerror(errno)</span><br><span class="line">                &lt;&lt; <span class="string">&quot; cliet:&quot;</span> &lt;&lt; *client &lt;&lt; <span class="string">&quot; keep_alive=&quot;</span> &lt;&lt; m_isKeepalive;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function">HttpResponse::ptr <span class="title">rsp</span><span class="params">(<span class="keyword">new</span> HttpResponse(req-&gt;getVersion()</span></span></span><br><span class="line"><span class="function"><span class="params">                            ,req-&gt;isClose() || !m_isKeepalive))</span></span>;</span><br><span class="line">        rsp-&gt;setHeader(<span class="string">&quot;Server&quot;</span>, getName());</span><br><span class="line">        m_dispatch-&gt;handle(req, rsp, session);</span><br><span class="line">        session-&gt;sendResponse(rsp);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!m_isKeepalive || req-&gt;isClose()) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(<span class="literal">true</span>);</span><br><span class="line">    session-&gt;close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-6-HTTP-Servlet"><a href="#15-6-HTTP-Servlet" class="headerlink" title="15.6 HTTP Servlet"></a>15.6 HTTP Servlet</h4><p>提供HTTP请求路径到处理类的映射，用于规范化的HTTP消息处理流程。</p><p>HTTP Servlet包括两部分，第一部分是Servlet对象，每个Servlet对象表示一种处理HTTP消息的方法，第二部分是ServletDispatch，它包含一个请求路径到Servlet对象的映射，用于指定一个请求路径该用哪个Servlet来处理。</p><p>以下是Servlet对象用于处理请求的声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">     * @brief 处理请求</span><br><span class="line">     * @param[in] request HTTP请求</span><br><span class="line">     * @param[in] response HTTP响应</span><br><span class="line">     * @param[in] session HTTP连接</span><br><span class="line">     * @<span class="keyword">return</span> 是否处理成功</span><br><span class="line">     */</span><br><span class="line">    <span class="keyword">virtual</span> <span class="keyword">int32_t</span> handle(sylar::http::HttpRequest::ptr request</span><br><span class="line">                   , sylar::http::HttpResponse::ptr response</span><br><span class="line">                   , sylar::http::HttpSession::ptr session) = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h4 id="15-7-HTTP-客户端HttpConnection"><a href="#15-7-HTTP-客户端HttpConnection" class="headerlink" title="15.7 HTTP 客户端HttpConnection"></a>15.7 HTTP 客户端HttpConnection</h4><p>用于发起GET/POST等请求并获取响应，支持设置超时，keep-alive，支持连接池。</p><p>HTTP服务端的业务模型是接收请求→ 发送响应，而HTTP客户端的业务模型是发送请求→ 接收响应。</p><p>关于连接池，是指提前预备好一系列已接建立连接的socket，这样，在发起请求时，可以直接从中选择一个进行通信，而不用重复创建套接字→ 发起connect→ 发起请求 的流程。</p><p>连接池与发起请求时的keep-alive参数有关，如果使用连接池来发起GET/POST请求，在未设置keep-alive时，连接池并没有什么卵用。</p><h3 id="16-守护进程"><a href="#16-守护进程" class="headerlink" title="16 守护进程"></a>16 守护进程</h3><p>将进程与终端解绑，转到后台运行，除此外，sylar还实现了双进程唤醒功能，父进程作为守护进程的同时会检测子进程是否退出，如果子进程退出，则会定时重新拉起子进程。</p><p>以下是守护进程的实现步骤：</p><ol><li>调用daemon(1, 0)将当前进程以守护进程的形式运行；</li><li>守护进程fork子进程，在子进程运行主业务；</li><li>父进程通过waitpid()检测子进程是否退出，如果子进程退出，则重新拉起子进程；</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">real_daemon</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv,</span></span></span><br><span class="line"><span class="function"><span class="params">                     <span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)&gt; main_cb)</span> </span>&#123;</span><br><span class="line">    daemon(<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    ProcessInfoMgr::GetInstance()-&gt;parent_id = getpid();</span><br><span class="line">    ProcessInfoMgr::GetInstance()-&gt;parent_start_time = time(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span>(pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//子进程返回</span></span><br><span class="line">            ProcessInfoMgr::GetInstance()-&gt;main_id = getpid();</span><br><span class="line">            ProcessInfoMgr::GetInstance()-&gt;main_start_time  = time(<span class="number">0</span>);</span><br><span class="line">            SYLAR_LOG_INFO(g_logger) &lt;&lt; <span class="string">&quot;process start pid=&quot;</span> &lt;&lt; getpid();</span><br><span class="line">            <span class="keyword">return</span> real_start(argc, argv, main_cb);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;fork fail return=&quot;</span> &lt;&lt; pid</span><br><span class="line">                &lt;&lt; <span class="string">&quot; errno=&quot;</span> &lt;&lt; errno &lt;&lt; <span class="string">&quot; errstr=&quot;</span> &lt;&lt; strerror(errno);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//父进程返回</span></span><br><span class="line">            <span class="keyword">int</span> status = <span class="number">0</span>;</span><br><span class="line">            waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(status) &#123;</span><br><span class="line">                SYLAR_LOG_ERROR(g_logger) &lt;&lt; <span class="string">&quot;child crash pid=&quot;</span> &lt;&lt; pid</span><br><span class="line">                    &lt;&lt; <span class="string">&quot; status=&quot;</span> &lt;&lt; status;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                SYLAR_LOG_INFO(g_logger) &lt;&lt; <span class="string">&quot;child finished pid=&quot;</span> &lt;&lt; pid;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ProcessInfoMgr::GetInstance()-&gt;restart_count += <span class="number">1</span>;</span><br><span class="line">            sleep(g_daemon_restart_interval-&gt;getValue());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;sylar服务器开发&quot;&gt;&lt;a href=&quot;#sylar服务器开发&quot; class=&quot;headerlink&quot; title=&quot;sylar服务器开发&quot;&gt;&lt;/a&gt;sylar服务器开发&lt;/h2&gt;&lt;h3 id=&quot;〇-开发环境&quot;&gt;&lt;a href=&quot;#〇-开发环境&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="服务器开发" scheme="http://okeyia.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BC%80%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>四 性能检测和优化</title>
    <link href="http://okeyia.github.io/2023/03/11/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E4%B8%8E%E6%A3%80%E6%B5%8B/"/>
    <id>http://okeyia.github.io/2023/03/11/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E4%B8%8E%E6%A3%80%E6%B5%8B/</id>
    <published>2023-03-11T12:55:24.000Z</published>
    <updated>2023-03-13T13:12:20.826Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第四篇-高性能服务器优化与监测"><a href="#第四篇-高性能服务器优化与监测" class="headerlink" title="第四篇 高性能服务器优化与监测"></a>第四篇 高性能服务器优化与监测</h2><h3 id="第十六章-服务器调制、调试和测试"><a href="#第十六章-服务器调制、调试和测试" class="headerlink" title="第十六章 服务器调制、调试和测试"></a>第十六章 服务器调制、调试和测试</h3><p>我们要从系统的角度来优化、改进服务器，这包括3个方面的 内容：系统调制、服务器调试和压力测试。</p><h4 id="16-1-最大文件描述符数"><a href="#16-1-最大文件描述符数" class="headerlink" title="16.1 最大文件描述符数"></a>16.1 最大文件描述符数</h4><p>文件描述符是服务器程序的宝贵资源，几乎所有的系统调用都是和文件描述符打交道。系统分配给应用程序的文件描述符数量是有限制的，所以我们必须总是关闭那些已经不再使用的文件描述符，以释放它们占用的资源。</p><blockquote><p>比如作为守护进程运行的服务器程序就应该总是 关闭标准输入、标准输出和标准错误这3个文件描述符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br></pre></td></tr></table></figure></blockquote><p>Linux对应用程序能打开的最大文件描述符数量有两个层次的限 制：用户级限制和系统级限制。</p><ul><li>用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数；</li><li>系统级的限制是指所有用户总共能打开的文件描述符数。</li></ul><p>为永久修改<strong>用户级文件</strong>描述符数限制，可以在<code>/etc/security/limits.conf</code>文件中加入如 下两项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*hard nofile max-file-number   // 第一行是指系统的硬限制，</span><br><span class="line">*soft nofile max-file-number// 第二行是软限制。</span><br></pre></td></tr></table></figure><p>如果要修改<strong>系统级</strong>文件描述符数限制，则可以使用如下命令：在<code>/etc/sysctl.conf</code>文件中添加如下一项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max=max-file-number</span><br></pre></td></tr></table></figure><p>然后通过执行 <code>sysctl -p</code>命令使更改生效。</p><h4 id="16-2-调整内核参数"><a href="#16-2-调整内核参数" class="headerlink" title="16.2 调整内核参数"></a>16.2 调整内核参数</h4><p>几乎所有的内核模块，包括内核核心模块和驱动程序，都 在<code>/proc/sys</code>文件系统下提供了某些配置文件以供用户调整模块的属性 和行为。通常一个配置文件对应一个内核参数，文件名就是参数的名 字，文件的内容是参数的值。</p><p>我们可以通过命令<code>sysctl -a</code>查看所有这些 内核参数。</p><h5 id="16-2-1-proc-sys-fs目录下的部分文件"><a href="#16-2-1-proc-sys-fs目录下的部分文件" class="headerlink" title="16.2.1 /proc/sys/fs目录下的部分文件"></a>16.2.1 <code>/proc/sys/fs</code>目录下的部分文件</h5><p><code>/proc/sys/fs</code> 目录下的内核参数都与文件系统相关。</p><ul><li><p><code>/proc/sys/fs/file-max</code>，系统级文件描述符数限制。直接修改这个 参数和16.1节讨论的修改方法有相同的效果（不过这是临时修改）。</p></li><li><p><code>/proc/sys/fs/epoll/max_user_watches</code>，一个用户能够往epoll内核 事件表中注册的事件的总量。它是指该用户打开的所有epoll实例总共 能监听的事件数目，而不是单个epoll实例能监听的事件数目。</p><blockquote><p>往epoll 内核事件表中注册一个事件，在32位系统上大概消耗90字节的内核空 间，在64位系统上则消耗160字节的内核空间。所以，这个内核参数限 制了epoll使用的内核内存总量。</p></blockquote></li></ul><h5 id="16-2-2-proc-sys-net-目录下的部分文件"><a href="#16-2-2-proc-sys-net-目录下的部分文件" class="headerlink" title="16.2.2 /proc/sys/net 目录下的部分文件"></a>16.2.2 <code>/proc/sys/net</code> 目录下的部分文件</h5><p>内核中网络模块的相关参数都位于/proc/sys/net目录下，其中和 TCP/IP协议相关的参数主要位于如下三个子目录中：core、ipv4和 ipv6。</p><ul><li><code>/proc/sys/net/core/somaxconn</code>，指定listen监听队列里，能够建立完整连接从而进入ESTABLISHED状态的socket的最大数目。</li><li><code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>，指定listen监听队列里， 能够转移至ESTABLISHED或者 SYN_RCVD 状态的socket的最大数目。</li><li><code>/proc/sys/net/ipv4/tcp_wmem</code>，它包含3个值，分别指定一个 socket的TCP<strong>写缓冲区</strong>的最小值、默认值和最大值。</li><li><code>/proc/sys/net/ipv4/tcp_rmem</code>，它包含3个值，分别指定一个socket 的TCP<strong>读缓冲区</strong>的最小值、默认值和最大值。</li><li>/<code>proc/sys/net/ipv4/tcp_syncookies</code>，指定是否打开TCP同步标签 （syncookie）。同步标签通过启动cookie来防止一个监听socket因不停 地重复接收来自同一个地址的连接请求（同步报文段），而导致listen 监听队列溢出（所谓的SYN风暴）。</li></ul><p>除了通过<strong>直接修改文件的方式来修改这些系统参数</strong>外，我们也可以<strong>使用sysctl命令来修改</strong>它们。这两种修改方式都是<strong>临时</strong>的。</p><p>永久的修改方法是在**/etc/sysctl.conf文件中加入相应网络参数及其数值**，并执行 sysctl-p使之生效，就像修改系统最大允许打开的文件描述符数那样。</p><h4 id="16-3-gdb调试"><a href="#16-3-gdb调试" class="headerlink" title="16.3 gdb调试"></a>16.3 <code>gdb</code>调试</h4><h5 id="16-3-1-用gdb调试多进程程序"><a href="#16-3-1-用gdb调试多进程程序" class="headerlink" title="16.3.1 用gdb调试多进程程序"></a>16.3.1 用gdb调试多进程程序</h5><p>如果一个进程通过fork系统调用创建了子进程，gdb会继续调试原来的进程，子进程则正常运行。</p><p>那么该如何调试子进程呢？常用的方法有如下两种。</p><ol><li><p>单独调试子进程</p><p>子进程从本质上说也是一个进程，因此我们可以用通用的gdb调试 方法来调试它。举例来说，如果要调试代码清单15-2描述的 <code>CGI</code> 进程池服务器的某一个子进程，则我们可以先运行服务器，然后<strong>找到目标 子进程的PID，再将其附加（attach）到gdb调试器上</strong></p></li><li><p>使用调试器选项follow-fork-mode</p><p>gdb调试器的选项follow-fork-mode允许我们选择程序在执行fork系 统调用后是继续调试父进程还是调试子进程。其用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)set follow-fork-mode mode</span><br></pre></td></tr></table></figure><p>其中，mode的可选值是parent和child，分别表示调试父进程和子进程。</p></li></ol><h5 id="16-3-2-用gdb调试多线程程序"><a href="#16-3-2-用gdb调试多线程程序" class="headerlink" title="16.3.2 用gdb调试多线程程序"></a>16.3.2 用gdb调试多线程程序</h5><p>gdb有一组命令可辅助多线程程序的调试。下面我们仅列举其中常用的一些：</p><ul><li>info threads，显示当前可调试的所有线程。gdb会为每个线程分 配一个ID，我们可以使用这个ID来操作对应的线程。ID前面有“*”号 的线程是当前被调试的线程。</li><li>thread ID，调试目标ID指定的线程。</li><li>set scheduler-locking[off|on|step]。调试多线程程序时，默认除了 被调试的线程在执行外，其他线程也在继续执行，但有的时候我们希 望只让被调试的线程运行。这可以通过这个命令来实现。该命令设置 scheduler-locking的值：off表示不锁定任何线程，即所有线程都可以继 续执行，这是默认值；on表示只有当前被调试的线程会继续执行； step表示在单步执行的时候，只有当前线程会执行。</li></ul><p>最后，关于调试进程池和线程池程序的一个不错的方法，是<strong>先将池中的进程个数或线程个数减少至1，以观察程序的逻辑是否正确</strong>，比 如代码清单16-3就是这样做的；然后逐步增加进程或线程的数量，以 调试进程或线程的同步是否正确。</p><h4 id="16-4-压力测试"><a href="#16-4-压力测试" class="headerlink" title="16.4 压力测试"></a>16.4 压力测试</h4><p>压力测试程序有很多种实现方式，比如I/O复用方式，多线程、多 进程并发编程方式，以及这些方式的结合使用。</p><p>单纯的I/O复用 方式的施压程度是最高的，因为线程和进程的调度本身也是要占用一 定CPU时间的。</p><p>使用epoll实现一个通用的服务器压力测试程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*每个客户连接不停地向服务器发送这个请求*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *request = <span class="string">&quot;GET http://localhost/index.html &quot;</span></span><br><span class="line">                             <span class="string">&quot;HTTP/1.1\r\nConnection:keep-alive\r\n\r\nxxxxxxxxxxxx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLOUT | EPOLLET | EPOLLERR;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向服务器写入len字节的数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">write_nbytes</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bytes_write = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;write out%d bytes to socket%d\n&quot;</span>, len, sockfd);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">bytes_write = send(sockfd, buffer, len, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (bytes_write == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_write == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">len -= bytes_write;</span><br><span class="line">buffer = buffer + bytes_write;</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从服务器读取数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_once</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, len);</span><br><span class="line">bytes_read = recv(sockfd, buffer, len, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read in%d bytes from socket%d with content:%s\n&quot;</span>, bytes_read, sockfd, buffer);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向服务器发起num个TCP连接，我们可以通过改变num来调整测试压力*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_conn</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> num, <span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create 1 sock\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (connect(sockfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address)) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;build connection%d\n&quot;</span>, i);</span><br><span class="line">addfd(epoll_fd, sockfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_conn</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_DEL, sockfd, <span class="number">0</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">assert(argc == <span class="number">4</span>);</span><br><span class="line"><span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">100</span>);</span><br><span class="line">start_conn(epoll_fd, atoi(argv[<span class="number">3</span>]), argv[<span class="number">1</span>], atoi(argv[<span class="number">2</span>]));</span><br><span class="line">epoll_event events[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">2048</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> fds = epoll_wait(epoll_fd, events, <span class="number">10000</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fds; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">if</span> (!read_once(sockfd, buffer, <span class="number">2048</span>)) &#123;</span><br><span class="line">close_conn(epoll_fd, sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>&#123;</span>&#125;;</span><br><span class="line">event.events = EPOLLOUT | EPOLLET | EPOLLERR;</span><br><span class="line">event.data.fd = sockfd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &amp;event);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line"><span class="keyword">if</span> (!write_nbytes(sockfd, request, <span class="built_in">strlen</span>(request))) &#123;</span><br><span class="line">close_conn(epoll_fd, sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>&#123;</span>&#125;;</span><br><span class="line">event.events = EPOLLIN | EPOLLET | EPOLLERR;</span><br><span class="line">event.data.fd = sockfd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &amp;event);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLERR) &#123;</span><br><span class="line">close_conn(epoll_fd, sockfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第十七章-系统监测工具"><a href="#第十七章-系统监测工具" class="headerlink" title="第十七章 系统监测工具"></a>第十七章 系统监测工具</h3><p>Linux提供了很多有用的工具，以方便开发人员调试和测评服务器程序。</p><h4 id="17-1-tcpdump"><a href="#17-1-tcpdump" class="headerlink" title="17.1 tcpdump"></a>17.1 tcpdump</h4><p>tcpdump是一款经典的网络抓包工具。tcpdump给使用者提供了大量的选项，用以过滤数据包或者定制输 出格式。</p><p>现在我们把常见的选项 总结如下：</p><ul><li><p>-n，使用 IP 地址表示主机，而不是主机名；使用数字表示端口 号，而不是服务名称。</p></li><li><p>-i，指定要监听的网卡接口。“-i any”表示抓取所有网卡接口上 的数据包。</p></li><li><p>-v，输出一个稍微详细的信息，例如，显示IP数据包中的TTL和 TOS信息。</p></li><li><p>-t，不打印时间戳。 </p></li><li><p>-e，显示以太网帧头部信息。 </p></li><li><p>-c，仅抓取指定数量的数据包。 </p></li><li><p>-x，以十六进制数显示数据包的内容，但不显示包中以太网帧 的头部信息。 </p></li><li><p>-X，与-x选项类似，不过还打印每个十六进制字节对应的ASCII 字符。 </p></li><li><p>-XX，与-X相同，不过还打印以太网帧的头部信息。 </p></li><li><p>-s，设置抓包时的抓取长度。当数据包的长度超过抓取长度 时，tcpdump抓取到的将是被截断的数据包。</p><blockquote><p>在4.0以及之前的版本 中，默认的抓包长度是68字节。这对于IP、TCP和UDP等协议就已经 足够了，但对于像DNS、NFS这样的协议，68字节通常不能容纳一个 完整的数据包。比如我们在1.6.3小节抓取DNS数据包时，就使用了-s 选项（测试机器ernest-laptop上，tcpdump的版本是4.0.0）。不过4.0之 后的版本，默认的抓包长度被修改为65 535字节，因此我们不用再担 心抓包长度的问题了。 </p></blockquote></li><li><p>-S，以绝对值来显示TCP报文段的序号，而不是相对值。 </p></li><li><p>-w，将tcpdump的输出以特殊的格式定向到某个文件。 </p></li><li><p>-r，从文件读取数据包信息并显示之。</p></li></ul><h4 id="17-2-lsof"><a href="#17-2-lsof" class="headerlink" title="17.2 lsof"></a>17.2 lsof</h4><p>lsof（list open file）是一个列出当前系统打开的文件描述符的工 具。通过它我们可以了解感兴趣的进程打开了哪些文件描述符，或者 我们感兴趣的文件描述符被哪些进程打开了。</p><ul><li><p>-i，显示socket文件描述符。  如果-i选项后不指定任何参数，则lsof命令将显示所有socket文件 描述符。  该选项的使用方法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof-i[46][protocol][@hostname|ipaddr][:service|port]</span><br></pre></td></tr></table></figure><p>其中，4表示IPv4协议，6表示IPv6协议；protocol指定传输层协 议，可以是TCP或者UDP；hostname指定主机名；ipaddr指定主机的IP 地址；service指定服务名；port指定端口号。</p></li><li><p>-u，显示指定用户启动的所有进程打开的所有文件描述符。</p></li><li><p>-c，显示指定的命令打开的所有文件描述符。</p></li><li><p>-p，显示指定进程打开的所有文件描述符。</p></li><li><p>-t，仅显示打开了目标文件描述符的进程的PID。</p></li></ul><h4 id="17-3-nc"><a href="#17-3-nc" class="headerlink" title="17.3 nc"></a>17.3 nc</h4><p>它主要被用来快速构建网络连接。我们可以让它以服务器方式运行， 监听某个端口并接收客户连接，因此它可用来调试客户端程序。我们 也可以使之以客户端方式运行，向服务器发起连接并收发数据，因此 它可以用来调试服务器程序，此时它有点像telnet程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- Listen on a specified port and <span class="built_in">print</span> any data received:</span><br><span class="line">   nc -l &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Connect to a certain port:</span><br><span class="line">   nc &#123;&#123;ip_address&#125;&#125; &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Set a timeout:</span><br><span class="line">   nc -w &#123;&#123;timeout_in_seconds&#125;&#125; &#123;&#123;ipaddress&#125;&#125; &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Keep the server up after the client detaches:</span><br><span class="line">   nc -k -l &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Keep the client up even after EOF:</span><br><span class="line">   nc -q &#123;&#123;timeout&#125;&#125; &#123;&#123;ip_address&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Scan the open ports of a specified host:</span><br><span class="line">   nc -v -z &#123;&#123;ip_address&#125;&#125; &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Act as proxy and forward data from a <span class="built_in">local</span> TCP port to the given remote host:</span><br><span class="line">   nc -l &#123;&#123;local_port&#125;&#125; | nc &#123;&#123;hostname&#125;&#125; &#123;&#123;remote_port&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="17-4-strace"><a href="#17-4-strace" class="headerlink" title="17.4 strace"></a>17.4 strace</h4><p>strace是测试服务器性能的重要工具。它跟踪程序运行过程中执行 的系统调用和接收到的信号，并将系统调用名、参数、返回值及信号 名输出到标准输出或者指定的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- Start tracing a specific process by its PID:</span><br><span class="line">   strace -p &#123;&#123;pid&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Trace a process and filter output by system call:</span><br><span class="line">   strace -p &#123;&#123;pid&#125;&#125; -e &#123;&#123;system_call_name&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Count time, calls, and errors for each system call and report a summary on program exit:</span><br><span class="line">   strace -p &#123;&#123;pid&#125;&#125; -c</span><br><span class="line"></span><br><span class="line"> - Show the time spent in every system call:</span><br><span class="line">   strace -p &#123;&#123;pid&#125;&#125; -T</span><br><span class="line"></span><br><span class="line"> - Start tracing a program by executing it:</span><br><span class="line">   strace &#123;&#123;program&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Start tracing file operations of a program:</span><br><span class="line">   strace -e trace=file &#123;&#123;program&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="17-5-netstat"><a href="#17-5-netstat" class="headerlink" title="17.5 netstat"></a>17.5 netstat</h4><p>netstat是一个功能很强大的网络信息统计工具。它可以打印本地 网卡接口上的全部连接、路由表信息、网卡接口信息等。</p><p><strong>对本书而 言，我们主要利用的是上述功能中的第一个，即显示TCP连接及其状 态信息。</strong>毕竟，要获得路由表信息和网卡接口信息，我们可以使用输 出内容更丰富的route和ifconfig命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- List all ports:</span><br><span class="line">  netstat --all</span><br><span class="line"></span><br><span class="line">- List all listening ports:</span><br><span class="line">  netstat --listening</span><br><span class="line"></span><br><span class="line">- List listening TCP ports:</span><br><span class="line">  netstat --tcp</span><br><span class="line"></span><br><span class="line">- Display PID and program names:</span><br><span class="line">  netstat --program</span><br><span class="line"></span><br><span class="line">- List information continuously:</span><br><span class="line">  netstat --continuous</span><br><span class="line"></span><br><span class="line">- List routes and do not resolve IP addresses to hostnames:</span><br><span class="line">  netstat --route --numeric</span><br><span class="line"></span><br><span class="line">- List listening TCP and UDP ports (+ user and process if you&#x27;re root):</span><br><span class="line">  netstat --listening --program --numeric --tcp --udp --extend</span><br></pre></td></tr></table></figure><h4 id="17-6-vmstat"><a href="#17-6-vmstat" class="headerlink" title="17.6 vmstat"></a>17.6 vmstat</h4><p>vmstat是virtual memory statistics的缩写，它能实时输出系统的各 种资源的使用情况，比如进程信息、内存使用、CPU使用率以及I/O使 用情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- Display virtual memory statistics:</span><br><span class="line">  vmstat</span><br><span class="line"></span><br><span class="line">- Display reports every 2 seconds for 5 times:</span><br><span class="line">  vmstat &#123;&#123;2&#125;&#125; &#123;&#123;5&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="17-7-ifstat"><a href="#17-7-ifstat" class="headerlink" title="17.7 ifstat"></a>17.7 ifstat</h4><p>ifstat是interface statistics的缩写，它是一个简单的网络流量监测工 具。</p><ul><li>-a，监测系统上的所有网卡接口。 </li><li>-i，指定要监测的网卡接口。 </li><li>-t，在每行输出信息前加上时间戳。 </li><li>-b，以Kbit/s为单位显示数据，而不是默认的KB/s。 </li><li>delay，采样间隔（单位是s），即每隔delay的时间输出一次统 计信息。 </li><li>count，采样次数，即共输出count次统计信息。</li></ul><h4 id="17-8-mpstat"><a href="#17-8-mpstat" class="headerlink" title="17.8 mpstat"></a>17.8 mpstat</h4><p>mpstat是multi-processor statistics的缩写，它能实时监测多处理器 系统上每个CPU的使用情况。mpstat命令和iostat命令通常都集成在包 sysstat中，安装sysstat即可获得这两个命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Display CPU statistics every 2 seconds:</span><br><span class="line">   mpstat &#123;&#123;2&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Display 5 reports, one by one, at 2 second intervals:</span><br><span class="line">   mpstat &#123;&#123;2&#125;&#125; &#123;&#123;5&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Display 5 reports, one by one, from a given processor, at 2 second intervals:</span><br><span class="line">   mpstat -P &#123;&#123;0&#125;&#125; &#123;&#123;2&#125;&#125; &#123;&#123;5&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第四篇-高性能服务器优化与监测&quot;&gt;&lt;a href=&quot;#第四篇-高性能服务器优化与监测&quot; class=&quot;headerlink&quot; title=&quot;第四篇 高性能服务器优化与监测&quot;&gt;&lt;/a&gt;第四篇 高性能服务器优化与监测&lt;/h2&gt;&lt;h3 id=&quot;第十六章-服务器调制、调试</summary>
      
    
    
    
    <category term="Linux" scheme="http://okeyia.github.io/categories/Linux/"/>
    
    
    <category term="服务器编程" scheme="http://okeyia.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>三 高性能服务器编程</title>
    <link href="http://okeyia.github.io/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    <id>http://okeyia.github.io/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</id>
    <published>2023-02-10T08:31:21.000Z</published>
    <updated>2023-03-11T12:57:20.979Z</updated>
    
    <content type="html"><![CDATA[<img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20220908201643320.png" class="" title="image-20220908201643320"><h2 id="第三篇-高性能服务器编程"><a href="#第三篇-高性能服务器编程" class="headerlink" title="第三篇 高性能服务器编程"></a>第三篇 高性能服务器编程</h2><h3 id="第12章-高性能I-O框架库Libevent"><a href="#第12章-高性能I-O框架库Libevent" class="headerlink" title="第12章 高性能I/O框架库Libevent"></a>第12章 高性能I/O框架库Libevent</h3><p>前面我们利用三章的篇幅较为细致地讨论了Linux服务器程序必须 处理的三类事件：<strong>I/O事件、信号和定时事件。</strong></p><p>在处理这三类事件时我 们通常需要考虑如下三个问题：</p><ul><li>统一事件源。统一处理这三类事件既能使代码简单易 懂，又能避免一些潜在的逻辑错误。前面我们已经讨论了实现统一事 件源的一般方法——利用I/O复用系统调用来管理所有事件。</li><li>可移植性。不同的操作系统具有不同的I/O复用方式，比如 Solaris的dev/poll文件，FreeBSD的kqueue机制，Linux的epoll系列系统 调用。</li><li>对并发编程的支持。在多进程和多线程环境下，我们需要考虑 各执行实体如何协同处理客户连接、信号和定时器，以避免竞态条 件。</li></ul><p>本章将 介绍其中相对轻量级的Libevent框架库</p><h4 id="12-1-I-O框架库概述"><a href="#12-1-I-O框架库概述" class="headerlink" title="12.1  I/O框架库概述"></a>12.1  I/O框架库概述</h4><p>I/O框架库以库函数的形式，封装了较为底层的系统调用，给应用 程序提供了一组更便于使用的接口。</p><p>各种I/O框架库的实现原理基本相似，要么以Reactor模式实现，要 么以Proactor模式实现，要么同时以这两种模式实现。举例来说，基于 Reactor模式的I/O框架库包含如下几个组件：句柄（Handle）、事件多 路分发器（EventDemultiplexer）、事件处理器（EventHandler）和具体 的事件处理器（ConcreteEventHandler）、Reactor。这些组件的关系如 图12-1所示[6]。</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230305225701977.png" class="" title="image-20230305225701977"><ul><li><strong>句柄:</strong> I/O框架库要处理的对象，即I/O事件、信号和定时事件，统一称为事件源。一个事件源通常和一个句柄绑定在一起。<strong>句柄的作用是，当内核检测到就绪事件时，它将通过句柄来通知应用程序这一事件。</strong>在 Linux环境下，I/O事件对应的句柄是文件描述符，信号事件对应的句柄就是信号值。</li><li><strong>事件多路分发器:</strong> 事件的到来是随机的、异步的。我们无法预知程序何时收到一个客户连接请求，又亦或收到一个暂停信号。所以程序需要循环地等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O 复用技术来实现。<strong>I/O框架库一般将系统支持的各种I/O复用系统调用封装成统一的接口，称为事件多路分发器。</strong>事件多路分发器的demultiplex 方法是等待事件的核心函数，其内部调用的是select、poll、epoll_wait 等函数。</li><li><strong>事件处理器和具体事件处理器:</strong>  事件处理器执行事件对应的业务逻辑。它通常包含一个或多个 handle_event回调函数，这些回调函数在事件循环中被执行。<strong>I/O框架库 提供的事件处理器通常是一个接口，用户需要继承它来实现自己的事 件处理器，即具体事件处理器。</strong>因此，事件处理器中的回调函数一般 被声明为虚函数，以支持用户的扩展。</li><li><strong>Reactor:</strong>  Reactor是I/O框架库的核心。<ul><li>handle_events。该方法执行事件循环。它重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器。</li><li>register_handler。该方法调用事件多路分发器的register_event方法来往事件多路分发器中注册一个事件。</li><li>remove_handler。该方法调用事件多路分发器的remove_event方 法来删除事件多路分发器中的一个事件。</li></ul></li></ul><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230305230319003.png" class="" title="image-20230305230319003"><h4 id="12-2-Libevent源码分析"><a href="#12-2-Libevent源码分析" class="headerlink" title="12.2 Libevent源码分析"></a>12.2 Libevent源码分析</h4><p>作为一个I/O 框架库，Libevent具有如下特点：</p><ul><li>跨平台支持。Libevent支持Linux、UNIX和Windows。</li><li>统一事件源。Libevent对I/O事件、信号和定时事件提供统一的处理。</li><li>线程安全。Libevent使用libevent_pthreads库来提供线程安全支 持。</li><li>基于Reactor模式的实现。</li></ul><h5 id="12-2-1-一个实例"><a href="#12-2-1-一个实例" class="headerlink" title="12.2.1 一个实例"></a>12.2.1 一个实例</h5><p>分析一款软件的源代码，最简单有效的方式是从使用入手，这样 才能从整体上把握该软件的逻辑结构。</p><p>使用Libevent库 实现的一个“Hello World”程序, 代码清单12-1虽然简单，但却基本上描述了Libevent库的主要逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_cb</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">short</span> event,<span class="keyword">void</span>*argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>*<span class="title">base</span>=</span>(event_base*)argc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span>=</span>&#123;<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Caught an interrupt signal;exiting cleanly in two seconds...\n&quot;</span>);</span><br><span class="line">event_base_loopexit(base,&amp;delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeout_cb</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">short</span> event,<span class="keyword">void</span>*argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span>=</span>event_init();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">signal_event</span>=</span>evsignal_new(base,SIGINT,signal_cb,base);</span><br><span class="line">event_add(signal_event,<span class="literal">NULL</span>);</span><br><span class="line">timeval tv =&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">timeout_event</span>=</span>evtimer_new(base,timeout_cb,<span class="literal">NULL</span>);</span><br><span class="line">event_add(timeout_event,&amp;tv);</span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">event_free(timeout_event);</span><br><span class="line">event_free(signal_event);</span><br><span class="line">event_base_free(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>调用event_init函数创建event_base对象。一个event_base相当于 一个Reactor实例。</p></li><li><p>创建具体的事件处理器，并设置它们所从属的Reactor实例。 evsignal_new和evtimer_new分别用于创建信号事件处理器和定时事件处理器，它们是定义在include/event2/event.h文件中的宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(b,x,cb,arg)\</span></span><br><span class="line">event_new((b),(x),EV_SIGNAL|EV_PERSIST,(cb),(arg))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(b,cb,arg)event_new((b),-1,0,(cb),(arg))</span></span><br></pre></td></tr></table></figure><p>可见，它们的统一入口是event_new函数，<strong>即用于创建通用事件处 理器</strong>（图12-1中的EventHandler）的函数。其定义是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event* <span class="title">event_new</span><span class="params">(struct event_base* base,<span class="keyword">evutil_socket_t</span></span></span></span><br><span class="line"><span class="function"><span class="params">fd, <span class="keyword">short</span> events, <span class="keyword">void</span>(*cb)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span>*), <span class="keyword">void</span>*arg)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>base参数指定新创建的事件处理器从属的Reactor。</p></li><li><p>fd参数指定与该事件处理器关联的句柄。<strong>创建I/O事件处理器时，应该给fd参 数传递文件描述符值；创建信号事件处理器时，应该给fd参数传递信 号值，比如代码清单12-1中的SIGINT；创建定时事件处理器时，则应该给fd参数传递-1。</strong></p></li><li><p>events参数指定事件类型，其可选值都定义在 include/event2/event.h文件中，如代码清单12-2所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_TIMEOUT 0x01<span class="comment">/*定时事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_READ 0x02<span class="comment">/*可读事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WRITE 0x04<span class="comment">/*可写事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SIGNAL 0x08<span class="comment">/*信号事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_PERSIST 0x10<span class="comment">/*永久事件*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EV_PERSIST的作用是：事件被触发后，自动重新对这个event调用event_add函数</span></span><br><span class="line"><span class="comment">/*边沿触发事件，需要I/O复用系统调用支持，比如epoll*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ET 0x20</span></span><br></pre></td></tr></table></figure></li><li><p>cb参数指定目标事件对应的回调函数，相当于图12-1中事件处理 器的handle_event方法。</p></li><li><p>arg参数则是Reactor传递给回调函数的参数。</p></li></ul><p>event_new函数成功时返回一个event类型的对象，也就是Libevent 的事件处理器。</p><blockquote><p>约定:  </p><p><strong>事件</strong>指的是一个句柄上绑定的事件，比如文件描述符0上的可读 事件。</p><p>事件处理器，也就是event结构体类型的对象，除了包含事件必 须具备的两个要素（句柄和事件类型）外，还有很多其他成员，比如 回调函数。</p><p>事件由事件多路分发器管理，事件处理器则由事件队列管理。 事件队列包括多种，比如event_base中的注册事件队列、活动事件队列 和通用定时器队列，以及evmap中的I/O事件队列、信号事件队列。</p><p>事件循环对一个被激活事件（就绪事件）的处理，指的是执行 该事件对应的事件处理器中的回调函数。</p></blockquote></li><li><p>调用event_add函数，将事件处理器添加到注册事件队列中， 并将该事件处理器对应的事件添加到事件多路分发器中。event_add函 数相当于Reactor中的register_handler方法。</p></li><li><p>调用event_base_dispatch函数来执行事件循环。</p></li><li><p>事件循环结束后，使用*_free系列函数来释放系统资源。</p></li></ol><h5 id="12-2-2-源代码组织结构"><a href="#12-2-2-源代码组织结构" class="headerlink" title="12.2.2 源代码组织结构"></a>12.2.2 源代码组织结构</h5><p>Libevent源代码中的目录和文件按照功能可划分为如下部分：</p><ul><li>头文件目录include/event2。该目录中的头文件 是Libevent提供给应用程序使用的，比如，event.h头文件提供核心函 数，http.h头文件提供HTTP协议相关服务，rpc.h头文件提供远程过程 调用支持。</li><li>源码根目录下的头文件。这些头文件分为两类：一类是对 include/event2目录下的部分头文件的包装，另外一类是供Libevent内部 使用的辅助性头文件，它们的文件名都具有*-internal.h的形式。<ul><li>event-internal.h， 比较重要</li></ul></li><li>通用数据结构目录compat/sys。该目录下仅有一个文件—— queue.h。它封装了跨平台的基础数据结构，包括单向链表、双向链 表、队列、尾队列和循环队列</li><li><strong>event.c文件。</strong> <strong>该文件实现Libevent的整体框架，主要是event和 event_base两个结构体的相关操作。</strong></li><li>devpoll.c、kqueue.c、evport.c、select.c、win32select.c、poll.c和 epoll.c文件。它们分别封装了如下I/O复用机制：/dev/poll、kqueue、 event ports、POSIX select、Windows select、poll和epoll。</li><li><strong>evmap.c文件</strong>。它维护句柄（文件描述符或信号）与事件处理器的映射关系。</li></ul><p>在整个源码中，event-internal.h、include/event2/event_struct.h、 event.c和evmap.c等4个文件最为重要。它们定义了event和event_base结 构体，并实现了这两个结构体的相关操作。</p><h5 id="12-2-3-event-结构体"><a href="#12-2-3-event-结构体" class="headerlink" title="12.2.3 event 结构体"></a>12.2.3 event 结构体</h5><p>Libevent中的事件处理器是event结构类型。<strong>event结构 体封装了句柄、事件类型、回调函数，以及其他必要的标志和数据。</strong> </p><p>该结构体在include/event2/event_struct.h文件中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TAILQ_ENTRY(event) ev_active_next;</span><br><span class="line">TAILQ_ENTRY(event) ev_next;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">TAILQ_ENTRY(event)ev_next_with_common_timeout;</span><br><span class="line"><span class="keyword">int</span> min_heap_idx;</span><br><span class="line">&#125;ev_timeout_pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">evutil_socket_t</span> ev_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">ev_base</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">TAILQ_ENTRY(event) ev_io_next;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line">&#125;ev_io;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">TAILQ_ENTRY(event) ev_signal_next;</span><br><span class="line"><span class="keyword">short</span> ev_ncalls;</span><br><span class="line"><span class="keyword">short</span>* ev_pncalls;</span><br><span class="line">&#125;ev_signal;</span><br><span class="line">&#125;_ev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> ev_events;</span><br><span class="line"><span class="keyword">short</span> ev_res;</span><br><span class="line"><span class="keyword">short</span> ev_flags;</span><br><span class="line"><span class="keyword">ev_uint8_t</span> ev_pri;</span><br><span class="line"><span class="keyword">ev_uint8_t</span> ev_closure;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line"><span class="keyword">void</span>(*ev_callback)(<span class="keyword">evutil_socket_t</span>,<span class="keyword">short</span>,<span class="keyword">void</span>*arg);</span><br><span class="line"><span class="keyword">void</span>*ev_arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>ev_active_next。所有被激活的事件处理器通过该成员串联成一 个尾队列，我们称之为活动事件队列。活动事件队列不止一个，不同 优先级的事件处理器被激活后将被插入不同的活动事件队列中。在事 件循环中，Reactor将按优先级从高到低遍历所有活动事件队列，并依 次处理其中的事件处理器。</p></li><li><p>ev_next。<strong>所有已经注册的事件处理器（包括I/O事件处理器和信 号事件处理器）通过该成员串联成一个尾队列，我们称之为注册事件队列。</strong>宏TAILQ_ENTRY是尾队列中的节点类型，它定义在 compat/sys/queue.h文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_ENTRY(type)\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span>* <span class="title">tqe_next</span>;</span>\<span class="comment">/*下一个元素*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span>** <span class="title">tqe_prev</span>;</span>\<span class="comment">/*前一个元素的地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内容暂时忽略。</p><h3 id="第13章-多进程编程"><a href="#第13章-多进程编程" class="headerlink" title="第13章 多进程编程"></a>第13章 多进程编程</h3><p>进程是Linux操作系统环境的基础，它控制着系统上几乎所有的活动。</p><ul><li>复制进程映像的fork系统调用和替换进程映像的exec系列系统调 用。</li><li>僵尸进程以及如何避免僵尸进程。</li><li>进程间通信（Inter-Process Communication，IPC）最简单的方 式：管道。</li><li>3种System V进程间通信方式：信号量、消息队列和共享内存。 它们都是由AT＆T System V2版本的UNIX引入的，所以统称为System V IPC。</li><li>在进程间传递文件描述符的通用方法：通过UNIX本地域socket 传递特殊的辅助数据（关于辅助数据，参考5.8.3小节）。</li></ul><h4 id="13-1-fork系统"><a href="#13-1-fork系统" class="headerlink" title="13.1 fork系统"></a>13.1 fork系统</h4><p>Linux下创建新进程的系统调用是fork。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的每次调用都返回两次，在父进程中返回的是子进程的 PID，在子进程中则返回0。</p><p>该返回值是后续代码判断当前进程是父进 程还是子进程的依据。fork调用失败时返回-1，并设置errno。</p><blockquote><p><strong>Fork函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和 标志寄存器的值。</strong></p><p>但也有许多属性被赋予了新的值，比如该进程的 PPID被设置成原进程的PID，信号位图被清除（原进程设置的信号处 理函数不再对新进程起作用）。</p><p>复制父进程的数据 （堆数据、栈数据和静态数据）。数据的复制采用的是所谓的写时复制（copy on writte），即只有在任一进程（父进程或子进程）对数据 执行了写操作时，复制才会发生</p><p>创建子进程后，父进程中打开的文件描述符默认在子进程 中也是打开的，且文件描述符的引用计数加1。不仅如此，父进程的用 户根目录、当前工作目录等变量的引用计数均会加1。</p></blockquote><h4 id="13-2-exec系列系统调用"><a href="#13-2-exec系列系统调用" class="headerlink" title="13.2 exec系列系统调用"></a>13.2 exec系列系统调用</h4><p>有时我们需要在子进程中执行其他程序，即替换当前进程映像， 这就需要使用如下exec系列函数之一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>**environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*file,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...,<span class="keyword">char</span>*<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">char</span>*<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*file,<span class="keyword">char</span>*<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">char</span>*<span class="keyword">const</span> argv[],<span class="keyword">char</span>*<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>path参数指定可执行文件的完整路径，</li><li>file参数可以接受文件名， 该文件的具体位置则在环境变量PATH中搜寻。</li><li>arg接受可变参数，argv 则接受参数数组，它们都会被传递给新程序（path或file指定的程序） 的main函数。</li><li>envp参数用于设置新程序的环境变量。如果未设置它， 则新程序将使用由全局变量environ指定的环境变量。</li></ul><p>一般情况下，exec函数是不返回的，除非出错。它出错时返 回-1，并设置errno。如果没出错，则<strong>原程序中exec调用之后的代码都不会执行，因为此时原程序已经被exec的参数指定的程序完全替换</strong> （包括代码和数据）。</p><h4 id="13-3-处理僵尸进程"><a href="#13-3-处理僵尸进程" class="headerlink" title="13.3 处理僵尸进程"></a>13.3 处理僵尸进程</h4><p>对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。 因此，<strong>当子进程结束运行时，内核不会立即释放该进程的进程表表 项，以满足父进程后续对该子进程退出信息的查询（如果父进程还在 运行）。在子进程结束运行之后，父进程读取其退出状态之前，我们 称该子进程处于僵尸态。</strong></p><p>另外一种使子进程进入僵尸态的情况是：<strong>父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被 操作系统设置为1，即init进程。init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态。</strong></p><p>下面这对函数在父进程中调用，以 等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程 的产生，或者使子进程的僵尸态立即结束：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/wait.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* stat_loc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* stat_loc, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>wait函数将阻塞进程，直到该进程的某个子进程结束运行为止。</strong>它返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于 stat_loc参数指向的内存中。sys/wait.h头文件中定义了几个宏来帮助解 释子进程的退出状态信息，</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306210917536.png" class="" title="image-20230306210917536"></li><li><p>wait函数的阻塞特性显然不是服务器程序期望的，而waitpid函数解 决了这个问题。<strong>waitpid只等待由pid参数指定的子进程。</strong>如果pid取值 为-1，那么它就和wait函数相同，即等待任意一个子进程结束。</p><ul><li>stat_loc 参数的含义和wait函数的stat_loc参数相同。</li><li>options参数可以控制waitpid 函数的行为。该参数最常用的取值是WNOHANG。当options的取值是 WNOHANG时，waitpid调用将是非阻塞的：<strong>如果pid指定的目标子进程还没有结束或意外终止，则waitpid立即返回0；</strong>如果目标子进程确实正常退出了，则waitpid返回该子进程的PID。waitpid调用失败时返回-1并 设置errno。</li></ul></li></ul><p><strong>要在事件已经发生的情况下执行非阻塞调用才能提高程序的效率。</strong>对waitpid函数而言，我们最好在某个子进程退出之后 再调用它。</p><p>那么父进程从何得知某个子进程已经退出了呢？这正是 SIGCHLD信号的用途。当一个进程结束时，它将给其父进程发送一个 SIGCHLD信号。因此，我们可以在父进程中捕获SIGCHLD信号，并在 信号处理函数中调用waitpid函数以“彻底结束”一个子进程, 信号处理函数如下: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span>((pid=waitpid(<span class="number">-1</span>,&amp;stat,WNOHANG))＞<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*对结束的子进程进行善后处理*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-4-管道"><a href="#13-4-管道" class="headerlink" title="13.4 管道"></a>13.4 管道</h4><p>管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0]和fd[1]）都保持打开。一对这样的文件描述符只能 保证父、子进程间一个方向的数据传输，<strong>父进程和子进程必须有一个关闭fd[0]，另一个关闭fd[1]。</strong></p><p>比如，我们要使用管道实现从父进程向 子进程写数据，就应该按照图13-1所示来操作。</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306211713409.png" class="" title="image-20230306211713409"><p>如果要实现父、子进程之间的双向数据传输，就必须使用两个管道。第6章中我们还介绍过，<strong>socket编程接口提供了一个创建全双工管道的系统调用：socketpair。</strong></p><p><strong>管道只能用于有关联的两个进程（比如父、子进程）间的 通信。</strong></p><p>而下面要讨论的3种System V IPC能用于无关联的多个进程之间 的通信，因为它们都使用一个全局唯一的键值来标识一条信道。</p><h4 id="13-5-信号量"><a href="#13-5-信号量" class="headerlink" title="13.5 信号量"></a>13.5 信号量</h4><h5 id="13-5-1-信号量原语"><a href="#13-5-1-信号量原语" class="headerlink" title="13.5.1 信号量原语"></a>13.5.1 信号量原语</h5><p>通常，程序对共享资源的访问的代码只是很短的一段，但就是这一段 代码引发了进程之间的竞态条件。我们称这段代码为关键代码段，或 者临界区。对进程同步，也就是确保任一时刻只有一个进程能进入关 键代码段。</p><p>对信号量的这两种操作更常 用的称呼是P、V操作。这两个字母来自于荷兰语单词passeren（传递， 就好像进入临界区）和vrijgeven（释放，就好像退出临界区）。</p><p>假设有 信号量SV，则对它的P、V操作含义如下：</p><ul><li>P(SV)，如果SV的值大于0，就将它减1；如果SV的值为0，则挂 起进程的执行。 </li><li>V(SV)，如果有其他进程因为等待SV而挂起，则唤醒之；如果没 有，则将SV加1。</li></ul><p>本书仅讨论二进制信号 量。使用二进制信号量同步两个进程，以确保关键代码段的独占式访 问的一个典型例子如图13-2所示。</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306212542683.png" class="" title="image-20230306212542683"><p>Linux信号量的API都定义在sys/sem.h头文件中，主要包含3个系统调用：<strong>semget、semop和semctl</strong>。它们都被设计为操作一组信号量，即 信号量集，而不是单个信号量</p><h5 id="13-5-2-semget"><a href="#13-5-2-semget" class="headerlink" title="13.5.2 semget"></a>13.5.2 semget</h5><p>semget系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sem.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> num_sems,<span class="keyword">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>key参数是一个键值，用来标识一个全局唯一的信号量集，就像文 件名全局唯一地标识一个文件一样。要通过信号量通信的进程需要使 用相同的键值来创建/获取该信号量。</li><li>num_sems参数指定要创建/获取的信号量集中信号量的数目。如果 是创建信号量，则该值必须被指定；如果是获取已经存在的信号量， 则可以把它设置为0。</li><li>sem_flags参数指定一组标志。它低端的9个比特是该信号量的权 限，其格式和含义都与系统调用open的mode参数相同。</li></ul><p><strong>semget成功时返回一个正整数值，它是信号量集的标识符</strong>；semget 失败时返回-1，并设置errno。</p><h5 id="13-5-3-semop系统调用"><a href="#13-5-3-semop系统调用" class="headerlink" title="13.5.3 semop系统调用"></a>13.5.3 semop系统调用</h5><p>semop系统调用改变信号量的值，即执行P、V操作。在讨论semop 之前，我们需要先介绍与每个信号量关联的一些重要的内核变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semval;   <span class="comment">/*信号量的值*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semzcnt;<span class="comment">/*等待信号量值变为0的进程数量*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt;<span class="comment">/*等待信号量值增加的进程数量*/</span></span><br><span class="line"><span class="keyword">pid_t</span> sempid;<span class="comment">/*最后一次执行semop操作的进程ID*/</span></span><br></pre></td></tr></table></figure><p>semop对信号量的操作实际上就是对这些内核变量的操作。</p><p>semop 的定义如下：#include＜sys/sem.h＞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf* sem_ops, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>sem_id参数是由semget调用返回的信号量集标识符，用以指定被操作的目标信号量集。</p></li><li><p>sem_ops参数指向一个sembuf结构体类型的数组， sembuf结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sem_num;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sem_op;</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>sem_num成员是<code>信号量集</code>中信号量的编号，0表示信号量集 中的第一个信号量。</li><li>sem_op成员指定操作类型，其可选值为正整数、0 和负整数。每种类型的操作的行为又受到sem_flg成员的影响。</li><li>sem_flg 的可选值是IPC_NOWAIT和SEM_UNDO。IPC_NOWAIT的含义是，无论信号量操作是否成功，semop调用都将立即返回，这类似于非阻塞 I/O操作。<strong>SEM_UNDO的含义是，当进程退出时取消正在进行的semop 操作。</strong></li></ul></blockquote></li><li><p><strong>semop系统调用的第3个参数num_sem_ops指定要执行的操作个数，即sem_ops数组中元素的个数。</strong>semop对数组sem_ops中的每个成员按照数组顺序依次执行操作，并且该过程是原子操作，以避免别的进 程在同一时刻按照不同的顺序对该信号集中的信号量执行semop操作导 致的竞态条件。</p></li></ul><p>semop成功时返回0，失败则返回-1并设置errno。失败的时候， sem_ops数组中指定的所有操作都不被执行。</p><h5 id="13-5-4-semctl系统调用"><a href="#13-5-4-semctl系统调用" class="headerlink" title="13.5.4 semctl系统调用"></a>13.5.4 semctl系统调用</h5><p>semctl系统调用允许调用者对信号量进行直接控制。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sem.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> sem_num,<span class="keyword">int</span> command,...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>sem_id参数是由semget调用返回的信号量集标识符，用以指定被操 作的信号量集。</p></li><li><p>sem_num参数指定被操作的信号量在信号量集中的编 号。</p></li><li><p>command参数指定要执行的命令。有的命令需要调用者传递第4个 参数。</p></li><li><p>第4个参数的类型由用户自己定义，但sys/sem.h头文件给出了它 的推荐格式，具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;<span class="comment">/*用于SETVAL命令*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>*<span class="title">buf</span>;</span><span class="comment">/*用于IPC_STAT和IPC_SET命令*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>*<span class="built_in">array</span>;<span class="comment">/*用于GETALL和SETALL命令*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>*__<span class="title">buf</span>;</span><span class="comment">/*用于IPC_INFO命令*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> semmap;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line"><span class="keyword">int</span> semmni;<span class="comment">/*系统最多可以拥有的信号量集数目*/</span></span><br><span class="line"><span class="keyword">int</span> semmns;<span class="comment">/*系统最多可以拥有的信号量数目*/</span></span><br><span class="line"><span class="keyword">int</span> semmnu;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line"><span class="keyword">int</span> semmsl;<span class="comment">/*一个信号量集最多允许包含的信号量数目*/</span></span><br><span class="line"><span class="keyword">int</span> semopm;<span class="comment">/*semop一次最多能执行的sem_op操作数目*/</span></span><br><span class="line"><span class="keyword">int</span> semume;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line"><span class="keyword">int</span> semusz;<span class="comment">/*sem_undo结构体的大小*/</span></span><br><span class="line"><span class="keyword">int</span> semvmx;<span class="comment">/*最大允许的信号量值*/</span></span><br><span class="line"><span class="comment">/*最多允许的UNDO次数（带SEM_UNDO标志的semop操作的次数）*/</span></span><br><span class="line"><span class="keyword">int</span> semaem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306215726484.png" class="" title="image-20230306215726484"></li></ul><p>semctl成功时的返回值取决于command参数，如表13-2所示。 semctl失败时返回-1，并设置errno。</p><h5 id="13-5-5-特殊键值IPC-PRIVATE"><a href="#13-5-5-特殊键值IPC-PRIVATE" class="headerlink" title="13.5.5 特殊键值IPC_PRIVATE"></a>13.5.5 特殊键值IPC_PRIVATE</h5><p>semget的调用者可以给其key参数传递一个特殊的键值 IPC_PRIVATE（其值为0），这样无论该信号量是否已经存在，semget 都将创建一个新的信号量。  使用该键值创建的信号量并非像它的名字 声称的那样是进程私有的。其他进程，尤其是子进程，也有方法来访 问这个信号量。</p><p>比如下面 的代码清单13-3就在父、子进程间使用一个IPC_PRIVATE信号量来同 步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/6.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>*<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>*<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>*__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*op为-1时执行P操作，op为1时执行V操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pv</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>&#123;</span>&#125;;</span><br><span class="line">sem_b.sem_num=<span class="number">0</span>;</span><br><span class="line">sem_b.sem_op=op;</span><br><span class="line">sem_b.sem_flg=SEM_UNDO;</span><br><span class="line">semop(sem_id, &amp;sem_b ,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sem_id=semget(IPC_PRIVATE,<span class="number">1</span>,<span class="number">0666</span>);</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_un</span>&#123;</span>&#125;;</span><br><span class="line">sem_un.val=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0是被操作的信号量在信号集中的编号, SETVAl 是被执行的命令</span></span><br><span class="line">semctl(sem_id,<span class="number">0</span>,SETVAL,sem_un);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">pid_t</span> id=fork();</span><br><span class="line"><span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(id==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child try to get binary sem\n&quot;</span>);</span><br><span class="line"><span class="comment">/*在父、子进程间共享IPC_PRIVATE信号量的关键就在于二者都可以操作该信号量的标识符sem_id*/</span></span><br><span class="line">pv(sem_id,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">pv(sem_id,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent try to get binary sem\n&quot;</span>);</span><br><span class="line">pv(sem_id,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">pv(sem_id,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">waitpid(id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">semctl(sem_id,<span class="number">0</span>,IPC_RMID,sem_un);<span class="comment">/*删除信号量*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-6-共享内存"><a href="#13-6-共享内存" class="headerlink" title="13.6 共享内存"></a>13.6 共享内存</h4><p>共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据 传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进 程对共享内存的访问，否则会产生竞态条件。</p><p>Linux共享内存的API都定义在sys/shm.h头文件中，包括4个系统调 用：shmget、shmat、shmdt和shmctl。</p><h5 id="13-6-1-shmget系统调用"><a href="#13-6-1-shmget系统调用" class="headerlink" title="13.6.1 shmget系统调用"></a>13.6.1 shmget系统调用</h5><p>shmget系统调用创建一段新的共享内存，或者获取一段已经存在 的共享内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">size_t</span> size,<span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>和semget系统调用一样，key参数是一个键值，用来标识一段全局 唯一的共享内存。</li><li>size参数指定共享内存的大小，单位是字节。如果是 创建新的共享内存，则size值必须被指定。如果是获取已经存在的共享 内存，则可以把size设置为0。</li><li>shmflg参数的使用和含义与semget系统调用的sem_flags参数相同。 不过shmget支持两个额外的标志——SHM_HUGETLB和 SHM_NORESERVE。它们的含义如下：<ul><li>SHM_HUGETLB，类似于mmap的MAP_HUGETLB标志，系统 将使用“大页面”来为共享内存分配空间。</li><li>SHM_NORESERVE，类似于mmap的MAP_NORESERVE标志， 不为共享内存保留交换分区（swap空间）。这样，当物理内存不足的 时候，对该共享内存执行写操作将触发SIGSEGV信号。</li></ul></li></ul><p>shmget成功时返回一个正整数值，它是共享内存的标识符。shmget 失败时返回-1，并设置errno。</p><h5 id="13-6-2-shmat和shmdt系统调用"><a href="#13-6-2-shmat和shmdt系统调用" class="headerlink" title="13.6.2 shmat和shmdt系统调用"></a>13.6.2 shmat和shmdt系统调用</h5><p>共享内存被创建/获取之后，我们不能立即访问它，而是需要先将 它关联到进程的地址空间中。使用完共享内存之后，我们也需要将它 从进程地址空间中分离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">const</span> <span class="keyword">void</span>*shm_addr,<span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*shm_addr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>shm_id参数是由shmget调用返回的共享内存标识符。 </li><li>shm_addr参数指定将共享内存关联到进程的哪块地址空间，最终的效果还受到shmflg参数的可选标志SHM_RND的影响：<ul><li>如果shm_addr为NULL，则被关联的地址由操作系统选择。这是 推荐的做法，以确保代码的可移植性.</li><li>如果shm_addr非空，并且SHM_RND标志未被设置，则共享内存 被关联到addr指定的地址处。</li></ul></li></ul><h5 id="13-6-3-shmctl系统调用"><a href="#13-6-3-shmctl系统调用" class="headerlink" title="13.6.3 shmctl系统调用"></a>13.6.3 shmctl系统调用</h5><p>shmctl系统调用控制共享内存的某些属性。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">int</span> command, struct shmid_ds* buf)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>shm_id参数是由shmget调用返回的共享内存标识符。 </p></li><li><p>command参数指定要执行的命令。</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306224911405.png" class="" title="image-20230306224911405"></li></ul><p>shmctl成功时的返回值取决于command参数，如表13-3所示。 shmctl失败时返回-1，并设置errno。</p><h5 id="13-6-5-共享内存实例"><a href="#13-6-5-共享内存实例" class="headerlink" title="13.6.5 共享内存实例"></a>13.6.5 共享内存实例</h5><p>在9.6.2小节中，我们介绍过一个聊天室服务器程序。下面我们将 它修改为一个多进程服务器：一个子进程处理一个客户连接。同时， 我们将所有客户socket连接的读缓冲设计为一块共享内存，如代码清单 13-4所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/6.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_LIMIT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_LIMIT 65536</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理一个客户连接必要的数据*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line"></span><br><span class="line">sockaddr_in address;<span class="comment">/*客户端的socket地址*/</span></span><br><span class="line"><span class="keyword">int</span> connfd;<span class="comment">/*socket文件描述符*/</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;<span class="comment">/*处理这个连接的子进程的PID*/</span></span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];<span class="comment">/*和父进程通信用的管道*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *shm_name = <span class="string">&quot;/my_shm&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> sig_pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"><span class="keyword">int</span> shmfd;</span><br><span class="line"><span class="keyword">char</span> *share_mem = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户连接数组。进程用客户连接的编号来索引这个数组，即可取得相关的客户连接数据*/</span></span><br><span class="line">client_data *users = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程和客户连接的映射关系表。用进程的PID来索引这个数组，即可取得该进程所处理的客户连接的编号*/</span></span><br><span class="line"><span class="keyword">int</span> *sub_process = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当前客户数量*/</span></span><br><span class="line"><span class="keyword">int</span> user_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> stop_child = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(sig_pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(*handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = handler;</span><br><span class="line"><span class="keyword">if</span> (restart) &#123;</span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line">&#125;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">close(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">close(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">close(listenfd);</span><br><span class="line">close(epollfd);</span><br><span class="line">shm_unlink(shm_name);</span><br><span class="line"><span class="keyword">delete</span>[]users;</span><br><span class="line"><span class="keyword">delete</span>[]sub_process;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*停止一个子进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_term_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程运行的函数。参数idx指出该子进程处理的客户连接的编号，</span></span><br><span class="line"><span class="comment"> * users是保存所有客户连接数据的数组，参数share_mem指出共享内存的起始地址*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_child</span><span class="params">(<span class="keyword">int</span> idx, client_data *users, <span class="keyword">char</span> *share_mem)</span> </span>&#123;</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="comment">/*子进程使用I/O复用技术来同时监听两个文件描述符：</span></span><br><span class="line"><span class="comment"> * 客户连接socket、与父进程通信的管道文件描述符*/</span></span><br><span class="line"><span class="keyword">int</span> child_epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(child_epollfd != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> connfd = users[idx].connfd;</span><br><span class="line">addfd(child_epollfd, connfd);</span><br><span class="line"><span class="keyword">int</span> pipefd = users[idx].pipefd[<span class="number">1</span>];</span><br><span class="line">addfd(child_epollfd, pipefd);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程需要设置自己的信号处理函数*/</span></span><br><span class="line">addsig(SIGTERM, child_term_handler, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span> (!stop_child) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(child_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本子进程负责的客户连接有数据到达*/</span></span><br><span class="line"><span class="keyword">if</span> ((sockfd == connfd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="built_in">memset</span>(share_mem + idx * BUFFER_SIZE, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将客户数据读取到对应的读缓存中。该读缓存是共享内存的一段，</span></span><br><span class="line"><span class="comment"> * 它开始于idx*BUFFER_SIZE处，长度为BUFFER_SIZE字节。</span></span><br><span class="line"><span class="comment"> * 因此，各个客户连接的读缓存是共享的</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">ret = recv(connfd, share_mem + idx * BUFFER_SIZE, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*成功读取客户数据后就通知主进程（通过管道）来处理*/</span></span><br><span class="line">send(pipefd, (<span class="keyword">char</span> *) &amp;idx, <span class="keyword">sizeof</span>(idx), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*主进程通知本进程（通过管道）将第client个客户的数据发送到本进程负责的客户端*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> client = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*接收主进程发送来的数据，即有客户数据到达的连接的编号*/</span></span><br><span class="line">ret = recv(sockfd, (<span class="keyword">char</span> *) &amp;client, <span class="keyword">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">send(connfd, share_mem + client * BUFFER_SIZE,</span><br><span class="line">     BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">close(pipefd);</span><br><span class="line">close(child_epollfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user_count = <span class="number">0</span>;</span><br><span class="line">users = <span class="keyword">new</span> client_data[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line">sub_process = <span class="keyword">new</span> <span class="keyword">int</span>[PROCESS_LIMIT];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS_LIMIT; ++i) &#123;</span><br><span class="line">sub_process[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, sig_pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">setnonblocking(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, sig_pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">addsig(SIGCHLD, sig_handler);  <span class="comment">/*子进程状态发生变化（退出或者暂停）*/</span></span><br><span class="line">addsig(SIGTERM, sig_handler);   <span class="comment">/*主进程发给子进程的中断信号*/</span></span><br><span class="line">addsig(SIGINT, sig_handler);</span><br><span class="line">addsig(SIGPIPE, SIG_IGN);       <span class="comment">/*往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">terminate</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建共享内存，作为所有客户socket连接的读缓存*/</span></span><br><span class="line">shmfd = shm_open(shm_name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">assert(shmfd != <span class="number">-1</span>);</span><br><span class="line">ret = ftruncate(shmfd, USER_LIMIT * BUFFER_SIZE);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">share_mem = (<span class="keyword">char</span> *) mmap(<span class="literal">nullptr</span>, USER_LIMIT * BUFFER_SIZE, PROT_READ | PROT_WRITE,</span><br><span class="line">                          MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line">assert(share_mem != MAP_FAILED);</span><br><span class="line">close(shmfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是哪个描述符发生了变化</span></span><br><span class="line"><span class="comment">/*新的客户连接到来*/</span></span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (user_count &gt;= USER_LIMIT) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*保存第user_count个客户连接的相关数据*/</span></span><br><span class="line">users[user_count].address = client_address;</span><br><span class="line">users[user_count].connfd = connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在主进程和子进程间建立管道，以传递必要的数据*/</span></span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, users[user_count].pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">close(epollfd);</span><br><span class="line">close(listenfd);</span><br><span class="line">close(users[user_count].pipefd[<span class="number">0</span>]);</span><br><span class="line">close(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">close(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">run_child(user_count, users, share_mem);</span><br><span class="line">munmap((<span class="keyword">void</span> *) share_mem, USER_LIMIT * BUFFER_SIZE);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(connfd);</span><br><span class="line">close(users[user_count].pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, users[user_count].pipefd[<span class="number">0</span>]);</span><br><span class="line">users[user_count].pid = pid;</span><br><span class="line"><span class="comment">/*记录新的客户连接在数组users中的索引值，建立进程pid和该索引值之间的映射关系*/</span></span><br><span class="line">sub_process[pid] = user_count;</span><br><span class="line">user_count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理信号事件*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line"><span class="comment">/*子进程退出，表示有某个客户端关闭了连接*/</span></span><br><span class="line"><span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*用子进程的pid取得被关闭的客户连接的编号*/</span></span><br><span class="line"><span class="keyword">int</span> del_user = sub_process[pid];</span><br><span class="line">sub_process[pid] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ((del_user &lt; <span class="number">0</span>) || (del_user &gt; USER_LIMIT)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*清除第del_user个客户连接使用的相关数据*/</span></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, users[del_user].pipefd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">close(users[del_user].pipefd[<span class="number">0</span>]);</span><br><span class="line">users[del_user] = users[--user_count];</span><br><span class="line">sub_process[users[del_user].pid] = del_user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">terminate</span> &amp;&amp; user_count == <span class="number">0</span>) &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM:</span><br><span class="line"><span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line"><span class="comment">/*结束服务器程序*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;kill all the clild now\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (user_count == <span class="number">0</span>) &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; user_count; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> pid = users[i].pid;</span><br><span class="line">kill(pid, SIGTERM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">terminate</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*某个子进程向父进程写入了数据*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*读取管道数据，child变量记录了是哪个客户连接有数据到达*/</span></span><br><span class="line">ret = recv(sockfd, (<span class="keyword">char</span> *) &amp;child, <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read data from child accross pipe\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*向除负责处理第child个客户连接的子进程之外的其他子进程发送消息，通知它们有客户数据要写*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; user_count; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (users[j].pipefd[<span class="number">0</span>] != sockfd) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send data to child accross pipe\n&quot;</span>);</span><br><span class="line">send(users[j].pipefd[<span class="number">0</span>], (<span class="keyword">char</span> *) &amp;child,</span><br><span class="line">     <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">del_resource();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-7-消息队列"><a href="#13-7-消息队列" class="headerlink" title="13.7 消息队列"></a>13.7 消息队列</h4><p>消息队列是在两个进程之间传递二进制块数据的一种简单有效的 方式。<strong>每个数据块都有一个特定的类型，接收方可以根据类型来有选 择地接收数据</strong>，而不一定像管道和命名管道那样必须以先进先出的方式接收数据。</p><p>Linux消息队列的API都定义在sys/msg.h头文件中，包括4个系统调 用：msgget、msgsnd、msgrcv和msgctl。</p><h5 id="13-7-1-msgget系统调用"><a href="#13-7-1-msgget系统调用" class="headerlink" title="13.7.1 msgget系统调用"></a>13.7.1 msgget系统调用</h5><p>msgget系统调用创建一个消息队列，或者获取一个已有的消息队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>和semget系统调用一样，key参数是一个键值，用来标识一个全局 唯一的消息队列。</li><li>msgflg参数的使用和含义与semget系统调用的sem_flags参数相同。</li></ul><p>msgget成功时返回一个正整数值，它是消息队列的标识符。msgget 失败时返回-1，并设置errno。</p><h5 id="13-7-2-msgsnd系统调用"><a href="#13-7-2-msgsnd系统调用" class="headerlink" title="13.7.2 msgsnd系统调用"></a>13.7.2 msgsnd系统调用</h5><p>msgsnd系统调用把一条消息添加到消息队列中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span>* msg_ptr, <span class="keyword">size_t</span> msg_sz,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>msqid参数是由msgget调用返回的消息队列标识符。</p></li><li><p>msg_ptr参数指向一个准备发送的消息，消息必须被定义为如下类 型： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span> </span><br><span class="line">    <span class="keyword">long</span> mtype;<span class="comment">/*消息类型*/</span> </span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>];<span class="comment">/*消息数据*/</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>其中，mtype成员指定消息的类型，它必须是一个正整数。</li><li>mtext是 消息数据。</li></ul></li><li><p>msg_sz参数是消息的数据部分（mtext）的长度。这个长度 可以为0，表示没有消息数据。</p></li><li><p><strong>msgflg参数控制msgsnd的行为。它通常仅支持IPC_NOWAIT标志， 即以非阻塞的方式发送消息。</strong>默认情况下，发送消息时如果消息队列 满了，则msgsnd将阻塞。若IPC_NOWAIT标志被指定，则msgsnd将立 即返回并设置errno为EAGAIN。</p></li></ul><p>msgsnd成功时返回0，失败则返回-1并设置errno。msgsnd成功时将 修改内核数据结构msqid_ds的部分字段，如下所示：</p><ul><li>将msg_qnum加1。</li><li>将msg_lspid设置为调用进程的PID。</li><li>将msg_stime设置为当前的时间。</li></ul><h5 id="13-7-3-msgrcv系统调用"><a href="#13-7-3-msgrcv系统调用" class="headerlink" title="13.7.3 msgrcv系统调用"></a>13.7.3 msgrcv系统调用</h5><p>msgrcv系统调用从消息队列中获取消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg·h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span>*msg_ptr,<span class="keyword">size_t</span> msg_sz,<span class="keyword">long</span> <span class="keyword">int</span> msgtype,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>msqid参数是由msgget调用返回的消息队列标识符。</li><li>msg_ptr参数用于存储接收的消息，msg_sz参数指的是消息数据部 分的长度。</li><li>msgtype参数指定接收何种类型的消息。我们可以使用如下几种方 式来指定消息类型： <ul><li>msgtype等于0。读取消息队列中的第一个消息。 </li><li>msgtype大于0。读取消息队列中第一个类型为msgtype的消息 （除非指定了标志MSG_EXCEPT，见后文）。 </li><li>msgtype小于0。读取消息队列中第一个类型值比msgtype的绝对 值小的消息。</li></ul></li><li>参数msgflg控制msgrcv函数的行为。它可以是如下一些标志的按位 或： <ul><li>IPC_NOWAIT。如果消息队列中没有消息，则msgrcv调用立即返 回并设置errno为ENOMSG。</li><li>MSG_EXCEPT。如果msgtype大于0，则接收消息队列中第一个 非msgtype类型的消息。 </li><li>MSG_NOERROR。如果消息数据部分的长度超过了msg_sz，就 将它截断。</li></ul></li></ul><p>msgrcv成功时返回0，失败则返回-1并设置errno。msgrcv成功时将 修改内核数据结构msqid_ds的部分字段，如下所示： </p><ul><li>将msg_qnum减1。 </li><li>将msg_lrpid设置为调用进程的PID。 </li><li>将msg_rtime设置为当前的时间。</li></ul><h5 id="13-7-4-msgctl系统调用"><a href="#13-7-4-msgctl系统调用" class="headerlink" title="13.7.4 msgctl系统调用"></a>13.7.4 msgctl系统调用</h5><p>msgctl系统调用控制消息队列的某些属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">int</span> command,struct msqid_ds*buf)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>msqid参数是由msgget调用返回的共享内存标识符。</p></li><li><p>command参数 指定要执行的命令。</p></li><li><p>msgctl支持的所有命令如表13-4所示</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230307112918598.png" class="" title="image-20230307112918598"></li></ul><p>msgctl成功时的返回值取决于command参数，如表13-4所示。 msgctl函数失败时返回-1并设置errno。</p><h4 id="13-8-IPC命令"><a href="#13-8-IPC命令" class="headerlink" title="13.8 IPC命令"></a>13.8 IPC命令</h4><p>上述3种System V IPC进程间通信方式都使用一个全局唯一的键值 （key）来描述一个共享资源。当程序调用semget、shmget或者msgget 时，就创建了这些共享资源的一个实例。</p><p>Linux提供了ipcs命令，以观 察当前系统上拥有哪些共享资源实例。</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230307113151814.png" class="" title="image-20230307113151814"><p>此外，我们可以使用ipcrm命令来删除遗留在系统中的共享资源。</p><h4 id="13-9-在进程间传递文件描述符"><a href="#13-9-在进程间传递文件描述符" class="headerlink" title="13.9 在进程间传递文件描述符"></a>13.9 在进程间传递文件描述符</h4><p>由于fork调用之后，父进程中打开的文件描述符在子进程中仍然 保持打开，所以文件描述符可以很方便地从父进程传递到子进程。</p><p>需要注意的是，<strong>传递一个文件描述符并不是传递一个文件描述符的值， 而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和 发送进程中被传递的文件描述符指向内核中相同的文件表项。</strong></p><p>那么如何把子进程中打开的文件描述符传递给父进程呢？或者更通俗地说，如何在两个不相干的进程之间传递文件描述符呢？</p><p>在Linux 下，我们可以利用UNIX域socket在进程间传递特殊的辅助数据，以实 现文件描述符的传递。</p><p>它在子进程 中打开一个文件描述符，然后将它传递给父进程，父进程则通过读取 该文件描述符来获得文件的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CONTROL_LEN = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送文件描述符，fd参数是用来传递信息的UNIX域socket，fd_to_send参数是待发送的文件描述符*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_fd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd_to_send)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line">iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">msg.msg_iov = iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">cmsghdr cm&#123;&#125;;</span><br><span class="line">cm.cmsg_len = CONTROL_LEN;</span><br><span class="line">cm.cmsg_level = SOL_SOCKET;</span><br><span class="line">cm.cmsg_type = SCM_RIGHTS;</span><br><span class="line">*(<span class="keyword">int</span> *) CMSG_DATA(&amp;cm) = fd_to_send;</span><br><span class="line">msg.msg_control = &amp;cm;<span class="comment">/*设置辅助数据*/</span></span><br><span class="line">msg.msg_controllen = CONTROL_LEN;</span><br><span class="line">sendmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*接收目标文件描述符*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_fd</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line">iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">msg.msg_name = <span class="literal">nullptr</span>;</span><br><span class="line">msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">msg.msg_iov = iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">cmsghdr cm&#123;&#125;;</span><br><span class="line">msg.msg_control = &amp;cm;</span><br><span class="line">msg.msg_controllen = CONTROL_LEN;</span><br><span class="line">recvmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fd_to_read = *(<span class="keyword">int</span> *) CMSG_DATA(&amp;cm);</span><br><span class="line"><span class="keyword">return</span> fd_to_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> fd_to_pass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建父、子进程间的管道，文件描述符pipefd[0]和pipefd[1]都是UNIX域socket*/</span></span><br><span class="line"><span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_DGRAM, <span class="number">0</span>, pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">assert(pid &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line">fd_to_pass = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR, <span class="number">0666</span>);</span><br><span class="line"><span class="comment">/* 子进程通过管道将文件描述符发送到父进程。如果文件test.txt打开失败，</span></span><br><span class="line"><span class="comment">        * 则子进程将标准输入文件描述符发送到父进程*/</span></span><br><span class="line">send_fd(pipefd[<span class="number">1</span>], (fd_to_pass &gt; <span class="number">0</span>) ? fd_to_pass : <span class="number">0</span>);</span><br><span class="line">close(fd_to_pass);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line">fd_to_pass = recv_fd(pipefd[<span class="number">0</span>]);<span class="comment">/*父进程从管道接收目标文件描述符*/</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">1024</span>);</span><br><span class="line">read(fd_to_pass, buf, <span class="number">1024</span>);<span class="comment">/*读目标文件描述符，以验证其有效性*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I got fd%d and data%s\n&quot;</span>, fd_to_pass, buf);</span><br><span class="line">close(fd_to_pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第14章-多线程编程"><a href="#第14章-多线程编程" class="headerlink" title="第14章 多线程编程"></a>第14章 多线程编程</h3><p>Native POSIX Thread Library， 本章要讨论的线程相关的内容都属于POSIX线程（简称pthread） 标准，而不局限于NPTL实现，具体包括：</p><ul><li>创建线程和结束线程。</li><li>读取和设置线程属性。</li><li>POSIX线程同步方式：POSIX信号量、互斥锁和条件变量。</li></ul><h4 id="14-1-Linux-线程概述"><a href="#14-1-Linux-线程概述" class="headerlink" title="14.1 Linux 线程概述"></a>14.1 Linux 线程概述</h4><h5 id="14-1-1-线程模型"><a href="#14-1-1-线程模型" class="headerlink" title="14.1.1 线程模型"></a>14.1.1 线程模型</h5><p>线程是程序中完成一个独立任务的完整执行序列，即一个可调度 的实体。</p><p>根据运行环境和调度者的身份，线程可分为内核线程和用户线程。<strong>内核线程，在有的系统上也称为LWP（Light Weight Process， 轻量级进程），运行在内核空间，由内核来调度</strong>；<strong>用户线程运行在用 户空间，由线程库来调度。</strong></p><p>当进程的一个内核线程获得CPU的使用权 时，它就加载并运行一个用户线程。可见，内核线程相当于用户线程 运行的“容器”。一个进程可以拥有M个内核线程和N个用户线程，其中 M≤N。并且在一个系统的所有进程中，M和N的比值都是固定的。</p><p><strong>按照M:N的取值，线程的实现方式可分为三种模式：完全在用户空间实现、完全由内核调度和双层调度（two level scheduler）。</strong></p><ol><li><strong>完全在用户空间实现的线程</strong>无须内核的支持，内核甚至根本不知 道这些线程的存在。线程库负责管理所有执行线程，比如线程的优先 级、时间片等。线程库利用longjmp来切换线程的执行，使它们看起来 像是“并发”执行的。<strong>但实际上内核仍然是把整个进程作为最小单位来调度的。</strong> 换句话说，一个进程的所有执行线程共享该进程的时间片， 它们对外表现出相同的优先级。因此，对这种实现方式而言，N=1， 即M个用户空间线程对应1个内核线程，而该内核线程实际上就是进程 本身。<ul><li><strong>优点：</strong> 创建和调度线程都无须 内核的干预，因此速度相当快。并且由于它不占用额外的内核资源， 所以即使一个进程创建了很多线程，也不会对系统性能造成明显的影 响。</li><li><strong>其缺点是</strong>：对于多处理器系统，一个进程的多个线程无法运行在不同的CPU上，因为内核是按照其最小调度单位来分配CPU的。此外，线程的优先级只对同一个进程中的线程有效，比较不同进程中的 线程的优先级没有意义。早期的伯克利UNIX线程就是采用这种方式实现的。</li></ul></li><li><strong>完全由内核调度的模式</strong>将创建、调度线程的任务都交给了内核， 运行在用户空间的线程库无须执行管理任务，这与完全在用户空间实 现的线程恰恰相反。<ul><li><strong>二者的优缺点也正好互换</strong>。较早的Linux内核对内 核线程的控制能力有限，线程库通常还要提供额外的控制能力，尤其 是线程同步机制，不过现代Linux内核已经大大增强了对线程的支持。 完全由内核调度的这种线程实现方式满足M:N=1:1，即1个用户空间线 程被映射为1个内核线程。</li></ul></li><li>双层调度模式是前两种实现模式的混合体：<strong>内核调度M个内核线 程，线程库调度N个用户线程。</strong>这种线程实现方式结合了前两种方式 的优点：不但不会消耗过多的内核资源，而且线程切换速度也较快， 同时它可以充分利用多处理器的优势。</li></ol><h5 id="14-1-2-Linux-线程库"><a href="#14-1-2-Linux-线程库" class="headerlink" title="14.1.2 Linux 线程库"></a>14.1.2 Linux 线程库</h5><p>Linux内核从 2.6版本开始，提供了真正的内核线程。新的NPTL线程库也应运而 生。相比LinuxThreads，NPTL的主要优势在于：</p><ul><li>内核线程不再是一个进程，因此避免了很多用进程模拟内核线 程导致的语义问题。</li><li>摒弃了管理线程，终止线程、回收线程堆栈等工作都可以由内核来完成。</li><li>由于不存在管理线程，所以一个进程的线程可以运行在不同的 CPU上，从而充分利用了多处理器系统的优势。</li><li>线程的同步由内核来完成。隶属于不同进程的线程之间也能共 享互斥锁，因此可实现跨进程的线程同步。</li></ul><h4 id="14-2-创建线程和结束线程"><a href="#14-2-创建线程和结束线程" class="headerlink" title="14.2 创建线程和结束线程"></a>14.2 创建线程和结束线程</h4><p>下面我们讨论创建和结束线程的基础API。Linux系统上，它们都 定义在pthread.h头文件中。</p><h5 id="14-2-1-pthread-create"><a href="#14-2-1-pthread-create" class="headerlink" title="14.2.1 pthread_create"></a>14.2.1 pthread_create</h5><p>创建一个线程的函数是pthread_create。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>*attr,<span class="keyword">void</span>*(*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span>*arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>thread参数是新线程的标识符，后续pthread_*函数通过它来引用新 线程。其类型pthread_t的定义如下：  可见，pthread_t是一个整型类型。实际上，Linux上几乎所有的资 源标识符都是一个整型数，比如socket、各种System V IPC标识符等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/pthreadtypes.h＞</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span>;</span><br></pre></td></tr></table></figure></li><li><p>attr参数用于设置新线程的属性。给它传递NULL表示使用默认线 程属性。</p></li><li><p>start_routine 和arg参数分别指定新线程将运行的函数及其参数。</p></li></ul><p>pthread_create成功时返回0，失败时返回错误码。</p><h5 id="14-2-3-pthread-exit"><a href="#14-2-3-pthread-exit" class="headerlink" title="14.2.3 pthread_exit"></a>14.2.3 pthread_exit</h5><p>线程一旦被创建好，内核就可以调度内核线程来执行start_routine 函数指针所指向的函数了。线程函数在结束时最好调用如下函数，以 确保安全、干净地退出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_exit函数通过retval参数向线程的回收者传递其退出信息。 它执行完之后不会返回到调用者，而且永远不会失败。</p><h5 id="14-2-4-pthread-join"><a href="#14-2-4-pthread-join" class="headerlink" title="14.2.4 pthread_join"></a>14.2.4 pthread_join</h5><p>一个进程中的所有线程都可以调用pthread_join函数来回收其他线 程（前提是目标线程是可回收的，见后文），即等待其他线程结束， 这类似于回收进程的wait和waitpid系统调用。</p><p>pthread_join的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span>** retval)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>hread参数是目标线程的标识符，</li><li>retval参数则是目标线程返回的退 出信息。该函数会一直阻塞，直到被回收的线程结束为止。</li></ul><p>该函数成 功时返回0，失败则返回错误码。</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230307172622769.png" class="" title="image-20230307172622769"><h5 id="14-2-5-pthread-cancel"><a href="#14-2-5-pthread-cancel" class="headerlink" title="14.2.5 pthread_cancel"></a>14.2.5 pthread_cancel</h5><p>有时候我们希望异常终止一个线程，即取消线程，它是通过如下 函数实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>thread参数是目标线程的标识符。</li></ul><p>该函数成功时返回0，失败则返 回错误码。</p><h4 id="14-3-线程属性"><a href="#14-3-线程属性" class="headerlink" title="14.3 线程属性"></a>14.3 线程属性</h4><p>pthread_attr_t结构体定义了一套完整的线程属性，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/pthreadtypes.h＞</span></span><br><span class="line">#define__SIZEOF_PTHREAD_ATTR_T <span class="number">36</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line"><span class="keyword">long</span> int__align;</span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="14-4-POSIX信号量"><a href="#14-4-POSIX信号量" class="headerlink" title="14.4 POSIX信号量"></a>14.4 POSIX信号量</h4><p>和多进程程序一样，多线程程序也必须考虑同步问题。 pthread_join可以看作一种简单的线程同步方式，不过很显然，它无法 高效地实现复杂的同步需求，比如控制对共享资源的独占式访问，又抑或是在某个条件满足之后唤醒一个线程。</p><p>接下来我们讨论3种专门用 于线程同步的机制：POSIX信号量、互斥量和条件变量。</p><blockquote><p>在Linux上，信号量API有两组。一组是第13章讨论过的System V IPC信号量，另外一组是我们现在要讨论的POSIX信号量。这两组接口 很相似，但不保证能互换。由于这两种信号量的语义完全相同，因此 我们不再赘述信号量的原理。</p></blockquote><p><code>POSIX信号量函数的名字都以sem_开头，并不像大多数线程函数 那样以pthread_开头。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜semaphore.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>*sem,<span class="keyword">int</span> pshared,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>这些函数的第一个参数sem指向被操作的信号量。</li><li>sem_init函数用于初始化一个未命名的信号量,  pshared参数指定信号量的类 型。如果其值为0，就表示这个信号量是当前进程的局部信号量，否则 该信号量就可以在多个进程之间共享。value参数指定信号量的初始 值。此外，初始化一个已经被初始化的信号量将导致不可预期的结 果。</li><li>sem_destroy函数用于销毁信号量，以释放其占用的内核资源。如 果销毁一个正被其他线程等待的信号量，则将导致不可预期的结果。</li><li>sem_wait函数以原子操作的方式将信号量的值减1。如果信号量的 值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</li><li>sem_trywait与sem_wait函数相似，不过它始终立即返回，而不论 被操作的信号量是否具有非0值，相当于sem_wait的非阻塞版本。当信 号量的值非0时，sem_trywait对信号量执行减1操作。当信号量的值为0 时，它将返回-1并设置errno为EAGAIN。</li><li>sem_post函数以原子操作的方式将信号量的值加1。当信号量的值 大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</li></ul><p>上面这些函数成功时返回0，失败则返回-1并设置errno。</p><h4 id="14-5-互斥锁"><a href="#14-5-互斥锁" class="headerlink" title="14.5 互斥锁"></a>14.5 互斥锁</h4><p>互斥锁（也称互斥量）可以用于保护关键代码段，以确保其独占 式的访问，这有点像一个二进制信号量（见13.5.1小节）。</p><h5 id="14-5-1-互斥锁基础API"><a href="#14-5-1-互斥锁基础API" class="headerlink" title="14.5.1 互斥锁基础API"></a>14.5.1 互斥锁基础API</h5><p>POSIX互斥锁的相关函数主要有如下5个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span>*mutexattr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>这些函数的第一个参数mutex指向要操作的目标互斥锁，互斥锁的 类型是pthread_mutex_t结构体。</p></li><li><p>pthread_mutex_init函数用于初始化互斥锁。mutexattr参数指定互 斥锁的属性。如果将它设置为NULL，则表示使用默认属性。除了这个函数外，我们<strong>还可以使用如 下方式来初始化一个互斥锁</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER; </span><br></pre></td></tr></table></figure><p>宏PTHREAD_MUTEX_INITIALIZER实际上只是把互斥锁的各个 字段都初始化为0。</p></li><li><p>pthread_mutex_destroy函数用于销毁互斥锁，以释放其占用的内核 资源。销毁一个已经加锁的互斥锁将导致不可预期的后果。</p></li><li><p>pthread_mutex_lock函数以原子操作的方式给一个互斥锁加锁。如 果目标互斥锁已经被锁上，则pthread_mutex_lock调用将阻塞，直到该 互斥锁的占有者将其解锁。</p></li><li><p>pthread_mutex_trylock与pthread_mutex_lock函数类似，不过它始 终立即返回，而不论被操作的互斥锁是否已经被加锁，相当于 pthread_mutex_lock的非阻塞版本。当目标互斥锁未被加锁时， pthread_mutex_trylock对互斥锁执行加锁操作。当互斥锁已经被加锁 时，pthread_mutex_trylock将返回错误码EBUSY。</p></li><li><p>pthread_mutex_unlock函数以原子操作的方式给一个互斥锁解锁。 如果此时有其他线程正在等待这个互斥锁，则这些线程中的某一个将 获得它。</p></li></ul><p>上面这些函数成功时返回0，失败则返回错误码。</p><h5 id="14-5-2-互斥锁属性"><a href="#14-5-2-互斥锁属性" class="headerlink" title="14.5.2 互斥锁属性"></a>14.5.2 互斥锁属性</h5><p>pthread_mutexattr_t结构体定义了一套完整的互斥锁属性。线程库 提供了一系列函数来操作pthread_mutexattr_t类型的变量，以方便我们 获取和设置互斥锁属性。</p><p>本书只讨论互斥锁的两种常用属性：pshared和type。</p><ol><li>互斥锁属性 pshared指定是否允许跨进程共享互斥锁，其可选值有两个：<ul><li>PTHREAD_PROCESS_SHARED。互斥锁可以被跨进程共享。</li><li>PTHREAD_PROCESS_PRIVATE。互斥锁只能被和锁的初始化 线程隶属于同一个进程的线程共享。</li></ul></li><li>互斥锁属性type指定互斥锁的类型。Linux支持如下4种类型的互 斥锁：<ul><li>PTHREAD_MUTEX_NORMAL，普通锁。这是互斥锁默认的类 型。当一个线程对一个普通锁加锁以后，其余请求该锁的线程将形成 一个等待队列，并在该锁解锁后按优先级获得它。这种锁类型保证了 资源分配的公平性。但这种锁也很容易引发问题：一个线程如果对一 个已经加锁的普通锁再次加锁，将引发死锁；对一个已经被其他线程 加锁的普通锁解锁，或者对一个已经解锁的普通锁再次解锁，将导致 不可预期的后果。</li><li>PTHREAD_MUTEX_ERRORCHECK，检错锁。一个线程如果 对一个已经加锁的检错锁再次加锁，则加锁操作返回EDEADLK。对 一个已经被其他线程加锁的检错锁解锁，或者对一个已经解锁的检错 锁再次解锁，则解锁操作返回EPERM</li><li>PTHREAD_MUTEX_RECURSIVE，嵌套锁。这种锁允许一个 线程在释放锁之前多次对它加锁而不发生死锁。不过其他线程如果要 获得这个锁，则当前锁的拥有者必须执行相应次数的解锁操作。对一 个已经被其他线程加锁的嵌套锁解锁，或者对一个已经解锁的嵌套锁 再次解锁，则解锁操作返回EPERM。</li><li>PTHREAD_MUTEX_DEFAULT，默认锁。一个线程如果对一个 已经加锁的默认锁再次加锁，或者对一个已经被其他线程加锁的默认 锁解锁，或者对一个已经解锁的默认锁再次解锁，将导致不可预期的 后果。这种锁在实现的时候可能被映射为上面三种锁之一。</li></ul></li></ol><h5 id="14-5-3-死锁举例"><a href="#14-5-3-死锁举例" class="headerlink" title="14.5.3 死锁举例"></a>14.5.3 死锁举例</h5><p>前文提到，在一个 线程中对一个已经加锁的普通锁再次加锁，将导致死锁。这种情况可 能出现在设计得不够仔细的递归函数中。另外，如果两个线程按照不 同的顺序来申请两个互斥锁，也容易产生死锁，如代码清单14-1所 示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">another</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in child thread,got mutex b,waiting for mutex a\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">++b;</span><br><span class="line">pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line">b += a++;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">pthread_exit(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line">pthread_mutex_init(&amp;mutex_a, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_mutex_init(&amp;mutex_b, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_create(&amp;id, <span class="literal">nullptr</span>, another, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in parent thread,got mutex a,waiting for mutex b\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">++a;</span><br><span class="line">pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line">a += b++;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">pthread_join(id, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex_a);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex_b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程试图先占有互斥锁mutex_a，然后操作被 该锁保护的变量a，但操作完毕之后，主线程并没有立即释放互斥锁 mutex_a，而是又申请互斥锁mutex_b，并在两个互斥锁的保护下，操 作变量a和b，最后才一起释放这两个互斥锁；与此同时，子线程则按 照相反的顺序来申请互斥锁mutex_a和mutex_b，并在两个锁的保护下 操作变量a和b。</p><h4 id="14-6-条件变量"><a href="#14-6-条件变量" class="headerlink" title="14.6 条件变量"></a>14.6 条件变量</h4><p>如果说互斥锁是用于同步线程对共享数据的访问的话，那么条件变量则是用于在线程之间同步共享数据的值。条件变量提供了一种线 程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个 共享数据的线程。</p><p>条件变量的相关函数主要有如下5个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span>*cond_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond,<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>这些函数的第一个参数cond指向要操作的目标条件变量，条件变 量的类型是pthread_cond_t结构体。</p></li><li><p>pthread_cond_init函数用于初始化条件变量。cond_attr参数指定条 件变量的属性。如果将它设置为NULL，则表示使用默认属性。除了pthread_cond_init函数外，我们还可以使用如下方式来初始化 一个条件变量： 宏PTHREAD_COND_INITIALIZER实际上只是把条件变量的各个 字段都初始化为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> cond=PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></li><li><p>pthread_cond_destroy函数用于销毁条件变量，以释放其占用的内 核资源。销毁一个正在被等待的条件变量将失败并返回EBUSY。</p></li><li><p>pthread_cond_broadcast函数以广播的方式唤醒所有等待目标条件 变量的线程。</p></li><li><p>pthread_cond_signal函数用于唤醒一个等待目标条件变量 的线程。至于哪个线程将被唤醒，则取决于线程的优先级和调度策 略。有时候我们可能想唤醒一个指定的线程，但pthread没有对该需求 提供解决方法。</p><blockquote><p>不过我们可以间接地实现该需求：定义一个能够唯一 表示目标线程的全局变量，在唤醒等待条件变量的线程前先设置该变 量为目标线程，然后采用广播方式唤醒所有等待条件变量的线程，这 些线程被唤醒后都检查该变量以判断被唤醒的是否是自己，如果是就 开始执行后续代码，如果不是则返回继续等待。</p></blockquote></li><li><p>pthread_cond_wait函数用于等待目标条件变量。mutex参数是用于 保护条件变量的互斥锁，以确保pthread_cond_wait操作的原子性。在 调用pthread_cond_wait前，必须确保互斥锁mutex已经加锁，否则将导 致不可预期的结果。pthread_cond_wait函数执行时，首先把调用线程 放入条件变量的等待队列中，然后将互斥锁mutex解锁。</p></li></ul><p>上面这些函数成功时返回0，失败则返回错误码。</p><h4 id="14-7-线程同步机制"><a href="#14-7-线程同步机制" class="headerlink" title="14.7 线程同步机制"></a>14.7 线程同步机制</h4><p>为了充分复用代码，同时由于后文的需要，我们将前面讨论的3种 线程同步机制分别封装成3个类，实现在locker.h文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装信号量的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*创建并初始化信号量*/</span></span><br><span class="line">sem() &#123;</span><br><span class="line"><span class="keyword">if</span> (sem_init(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*构造函数没有返回值，可以通过抛出异常来报告错误*/</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁信号量*/</span></span><br><span class="line">~sem() &#123;</span><br><span class="line">sem_destroy(&amp;m_sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*等待信号量*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sem_wait(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*增加信号量*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sem_post(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装互斥锁的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*创建并初始化互斥锁*/</span></span><br><span class="line">locker() &#123;</span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁互斥锁*/</span></span><br><span class="line">~locker() &#123;</span><br><span class="line">pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取互斥锁*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pthread_mutex_lock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*释放互斥锁*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pthread_mutex_unlock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装条件变量的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*创建并初始化条件变量*/</span></span><br><span class="line">cond() &#123;</span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pthread_cond_init(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*构造函数中一旦出现问题，就应该立即释放已经成功分配了的资源*/</span></span><br><span class="line">pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁条件变量*/</span></span><br><span class="line">~cond() &#123;</span><br><span class="line">pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">pthread_cond_destroy(&amp;m_cond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*等待条件变量*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line">ret = pthread_cond_wait(&amp;m_cond, &amp;m_mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line"><span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*唤醒等待条件变量的线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pthread_cond_signal(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="14-8-多线程环境"><a href="#14-8-多线程环境" class="headerlink" title="14.8 多线程环境"></a>14.8 多线程环境</h4><h5 id="14-8-1-可重入函数"><a href="#14-8-1-可重入函数" class="headerlink" title="14.8.1 可重入函数"></a>14.8.1 可重入函数</h5><p>如果一个函数能被多个线程同时调用且不发生竞态条件，则我们 称它是线程安全的（thread safe），或者说它是可重入函数。</p><p>关于 Linux上不可重入的库函数的完整列表，请读者参考相关书籍，这里不 再赘述。这些库函数之所以不可重入，主要是因为其内部使用了静态变量。</p><p>不过Linux对很多不可重入的库函数提供了对应的可重入版本， 这些可重入版本的函数名是在原函数名尾部加上_r。比如，函数 localtime对应的可重入函数是localtime_r。在多线程程序中调用库函 数，一定要使用其可重入版本，否则可能导致预想不到的结果。</p><h5 id="14-8-2-线程和进程"><a href="#14-8-2-线程和进程" class="headerlink" title="14.8.2 线程和进程"></a>14.8.2 线程和进程</h5><p>思考这样一个问题：<strong>如果一个多线程程序的某个线程调用了fork 函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢？ **答案是“否”，正如我们期望的那样。</strong>子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父 进程中互斥锁（条件变量与之类似）的状态。也就是说，父进程中已 经被加锁的互斥锁在子进程中也是被锁住的。**</p><p>这就引起了一个问题： 子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状 态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork 函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况， 则子进程若再次对该互斥锁执行加锁操作就会导致死锁，如代码清单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子线程运行的函数。它首先获得互斥锁mutex，然后暂停5 s，再释放该互斥锁*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">another</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in child thread,lock the mutex\n&quot;</span>);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line">pthread_create(&amp;id, <span class="literal">nullptr</span>, another, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">/*父进程中的主线程暂停1 s，以确保在执行fork操作之前，子线程已经开始运行并获得了互斥变量mutex*/</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pthread_join(id, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am in the child,want to get the lock\n&quot;</span>);</span><br><span class="line"><span class="comment">/* 子进程从父进程继承了互斥锁mutex的状态，该互斥锁处于锁住的状态，</span></span><br><span class="line"><span class="comment"> * 这是由父进程中的子线程执行pthread_mutex_lock引起的，</span></span><br><span class="line"><span class="comment"> * 因此，下面这句加锁操作会一直阻塞，尽管从逻辑上来说它是不应该阻塞的*/</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I can not run to here,oop...\n&quot;</span>);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// wait 函数将阻塞进程, 直到该进程的某个子进程结束运行为止</span></span><br><span class="line">wait(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_join(id, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pthread提供了一个专门的函数pthread_atfork，以确保fork 调用后父进程和子进程都拥有一个清楚的锁状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_atfork</span><span class="params">(<span class="keyword">void</span>(*prepare)(<span class="keyword">void</span>), <span class="keyword">void</span>(*parent)(<span class="keyword">void</span>), <span class="keyword">void</span>(*child)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>该函数将建立3个fork句柄来帮助我们清理互斥锁的状态。</p><ul><li>prepare 句柄将在fork调用创建出子进程之前被执行。它可以用来锁住所有父进程中的互斥锁。</li><li>parent句柄则是fork调用创建出子进程之后，而fork 返回之前，在父进程中被执行。它的作用是释放所有在prepare句柄中 被锁住的互斥锁。</li><li>child句柄是fork返回之前，在子进程中被执行。和 parent句柄一样，child句柄也是用于释放所有在prepare句柄中被锁住的 互斥锁。</li></ul><p>该函数成功时返回0，失败则返回错误码。</p><p>如果要让代码清单14-3正常工作，就应该在其中的fork调用 前加入代码清单14-4所示的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">infork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">pthread_atfork(prepare,infork,infork);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="14-8-3-线程和信号"><a href="#14-8-3-线程和信号" class="headerlink" title="14.8.3 线程和信号"></a>14.8.3 线程和信号</h5><p>每个线程都可以独立地设置信号掩码。我们在10.3.2小节讨论过设 置进程信号掩码的函数sigprocmask，但在多线程环境下我们应该使用 如下所示的pthread版本的sigprocmask函数来设置线程信号掩码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span>* newmask, <span class="keyword">sigset_t</span>* oldmask)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>_set</code>参数指定新的信号掩码，</p></li><li><p>_oset参数则输出原来的信号掩码（如 果不为NULL的话）。</p></li><li><p>如果_set参数不为NULL，则_how参数指定设置 进程信号掩码的方式，其可选值如表10-5所示。</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230304143250709.png" class="" title="image-20230304143250709"></li></ul><p>sigprocmask成功时返回0，失败则返回-1并设置errno。</p><p>由于进程中的所有线程共享该进程的信号，所以线程库将根据线程掩码决定把信号发送给哪个具体的线程。这两点都说明，我们应该定义一个专门的线程来处理所有的 信号。这可以通过如下两个步骤来实现：</p><ol><li><p>在主线程创建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码。这样 做之后，实际上所有线程都不会响应被屏蔽的信号了。</p></li><li><p>在某个线程中调用如下函数来等待信号并处理之：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">int</span>* sig)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>set参数指定需要等待的信号的集合。我们可以简单地将其指定为 在第1步中创建的信号掩码，表示在该线程中等待所有被屏蔽的信号。</li><li>参数sig指向的整数用于存储该函数返回的信号值。</li></ul></li></ol><p>sigwait成功时返回 0，失败则返回错误码。一旦sigwait正确返回，我们就可以对接收到的 信号做处理了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> handle_error_en(en, msg)\</span></span><br><span class="line"><span class="keyword">do</span>&#123;errno=en;perror(msg);<span class="built_in">exit</span>(EXIT_FAILURE);&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">sig_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *<span class="built_in">set</span> = (<span class="keyword">sigset_t</span> *) arg;</span><br><span class="line"><span class="keyword">int</span> s, sig;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*第二个步骤，调用sigwait等待信号*/</span></span><br><span class="line">s = sigwait(<span class="built_in">set</span>, &amp;sig);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">handle_error_en(s, <span class="string">&quot;sigwait&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Signal handling thread got signal%d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第一个步骤，在主线程中设置信号掩码*/</span></span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGUSR1);</span><br><span class="line"></span><br><span class="line">s = pthread_sigmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">handle_error_en(s, <span class="string">&quot;pthread_sigmask&quot;</span>);</span><br><span class="line"></span><br><span class="line">s = pthread_create(&amp;thread, <span class="literal">nullptr</span>, &amp;sig_thread, (<span class="keyword">void</span> *) &amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">handle_error_en(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，pthread还提供了下面的方法，使得我们可以明确地将一个 信号发送给指定的线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，thread参数指定目标线程，sig参数指定待发送的信号。</p><h3 id="第15章-进程池和线程池"><a href="#第15章-进程池和线程池" class="headerlink" title="第15章 进程池和线程池"></a>第15章 进程池和线程池</h3><p>在前面的章节中，我们是通过动态创建子进程（或子线程）来实 现并发服务器的。这样做有如下缺点：</p><ul><li>动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户响应。</li><li>动态创建的子进程（或子线程）通常只用来为一个客户服务 （除非我们做特殊的处理），这将导致系统上产生大量的细微进程 （或线程）。进程（或线程）间的切换将消耗大量CPU时间。</li><li>动态创建的子进程是当前进程的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复 制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性 能。</li></ul><h4 id="15-1-线程池和进程池概述"><a href="#15-1-线程池和进程池概述" class="headerlink" title="15.1 线程池和进程池概述"></a>15.1 线程池和进程池概述</h4><p>进程池和线程池相似，所以这里我们只以进程池为例进行介绍。 如没有特殊声明，下面对进程池的讨论完全适用于线程池。</p><p>进程池是由服务器预先创建的一组子进程，这些子进程的数目在3 ～10个之间（当然，这只是典型情况）。比如13.5.5小节所描述的， httpd守护进程就是使用包含7个子进程的进程池来实现并发的。<strong>线程池 中的线程数量应该和CPU数量差不多。</strong></p><p>进程池中的所有子进程都运行着相同的代码，并具有相同的属 性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好 了，所以<strong>每个子进程都相对“干净”，即它们没有打开不必要的文件描 述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父 进程复制得到）。</strong></p><p>当有新的任务到来时，主进程将通过某种方式选择进程池中的某 一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在 的子进程的代价显然要小得多。至于主进程选择哪个子进程来为新任 务服务，则有两种方式：</p><ul><li>主进程使用某种算法来主动选择子进程。最简单、最常用的算 法是随机算法和Round Robin（轮流选取）算法，但更优秀、更智能的 算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整 体压力。</li><li>主进程和所有子进程通过一个共享的工作队列来同步，子进程 都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到 工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程 将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之， 而其他子进程将继续睡眠在工作队列上。</li></ul><p><strong>当选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。</strong>最简单的方法是，在 父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的进程间通信（当然，要预先定义好一套协议来规范管道的使 用）。在父线程和子线程之间传递数据就要简单得多，因为我们可以 把这些数据定义为全局的，那么它们本身就是被所有线程共享的。</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230308112500214.png" class="" title="image-20230308112500214"><h4 id="15-2-处理多客户"><a href="#15-2-处理多客户" class="headerlink" title="15.2 处理多客户"></a>15.2 处理多客户</h4><p>在使用进程池处理多客户任务时，首先要考虑的一个问题是：<strong>监听socket和连接socket是否都由主进程来统一管理。</strong></p><blockquote><p>回忆第8章中我们介 绍过的几种并发模式，其中半同步/半反应堆模式是由主进程统一管理这两种socket的；而图8-11所示的高效的半同步/半异步模式，以及领导者/追随者模式，则是由主进程管理所有监听socket，而各个子进程分别 管理属于自己的连接socket的。</p><p>对于前一种情况，主进程接受新的连接 以得到连接socket，然后它需要将该socket传递给子进程（对于线程池 而言，父线程将socket传递给子线程是很简单的，因为它们可以很容易 地共享该socket。但对于进程池而言，我们必须使用13.9节介绍的方法 来传递该socket）。</p><p>后一种情况的灵活性更大一些，因为子进程可以自 己调用accept来接受新的连接，这样父进程就无须向子进程传递 socket，而只需要简单地通知一声：“我检测到新的连接，你来接受它。</p></blockquote><p>在4.6.1小节中我们曾讨论过常连接，即一个客户的多次请求可以 复用一个TCP连接。这里是指长链接和短连接. 那么，在设计进程池时还需要考虑：一个客户连接 上的所有任务是否始终由一个子进程来处理。</p><ul><li><p>如果说客户任务是无状 态的，那么我们可以考虑使用不同的子进程来为该客户的不同请求服 务，如图15-2所示:</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230308113352813.png" class="" title="image-20230308113352813"></li><li><p>但如果客户任务是存在上下文关系的，则最好一直用同一个子进 程来为之服务，否则实现起来将比较麻烦，因为我们不得不在各子进 程之间传递上下文数据。<strong>在9.3.4小节中，我们讨论了epoll的 EPOLLONESHOT事件，这一事件能够确保一个客户连接在整个生命周 期中仅被一个线程处理。</strong></p></li></ul><h4 id="15-3-半同步-半异步进程池实现"><a href="#15-3-半同步-半异步进程池实现" class="headerlink" title="15.3 半同步/半异步进程池实现"></a>15.3 半同步/半异步进程池实现</h4><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230228212643003.png" class="" title="image-20230228212643003"><p>本节我们实现一个基于图8-11所示的半同步/半 异步并发模式的进程池，如代码清单15-1所示。</p><p>为了避免在父、子进 程之间传递文件描述符，我们将接受新连接的操作放到子进程中。很 显然，对于这种模式而言，一个客户连接上的所有任务始终是由一个子进程来处理的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filename:processpool.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROCESSPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESSPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*描述一个子进程的类，m_pid是目标子进程的PID，m_pipefd是父进程和子进程通</span></span><br><span class="line"><span class="comment">信用的管道*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">process</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">process() : m_pid(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">pid_t</span> m_pid;</span><br><span class="line"><span class="keyword">int</span> m_pipefd[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池类，将它定义为模板类是为了代码复用。其模板参数是处理逻辑任务的类*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">processpool</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*将构造函数定义为私有的，因此我们只能通过后面的create静态函数来创建processpool实例*/</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">processpool</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number = <span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*单体模式，以保证程序最多创建一个processpool实例，这是程序正确处理信号的必要条件*/</span></span><br><span class="line"><span class="keyword">static</span> processpool&lt;T&gt; *</span><br><span class="line"></span><br><span class="line">create(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number = <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!m_instance) &#123;</span><br><span class="line">m_instance = <span class="keyword">new</span> processpool&lt;T&gt;(listenfd, process_number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~processpool() &#123; <span class="keyword">delete</span>[] m_sub_process; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*启动进程池*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_sig_pipe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_parent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_child</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*进程池允许的最大子进程数量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_PROCESS_NUMBER = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每个子进程最多能处理的客户数量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> USER_PER_PROCESS = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*epoll最多能处理的事件数*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENT_NUMBER = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池中的进程总数*/</span></span><br><span class="line"><span class="keyword">int</span> m_process_number;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程在池中的序号，从0开始*/</span></span><br><span class="line"><span class="keyword">int</span> m_idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每个进程都有一个epoll内核事件表，用m_epollfd标识*/</span></span><br><span class="line"><span class="keyword">int</span> m_epollfd&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*监听socket*/</span></span><br><span class="line"><span class="keyword">int</span> m_listenfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程通过m_stop来决定是否停止运行*/</span></span><br><span class="line"><span class="keyword">int</span> m_stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*保存所有子进程的描述信息*/</span></span><br><span class="line">process *m_sub_process;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池静态实例*/</span></span><br><span class="line"><span class="keyword">static</span> processpool&lt;T&gt; *m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">processpool&lt;T&gt; *processpool&lt;T&gt;::m_instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于处理信号的管道，以实现统一事件源。后面称之为信号管道*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sig_pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从epollfd标识的epoll内核事件表中删除fd上的所有注册事件*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(sig_pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span> &#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = handler;</span><br><span class="line"><span class="keyword">if</span> (restart) &#123;</span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line">&#125;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池构造函数。参数listenfd是监听socket，它必须在创建进程池之前被创建，</span></span><br><span class="line"><span class="comment">否则子进程无法直接引用它。参数process_number指定进程池中子进程的数量*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">processpool&lt;T&gt;::processpool(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number)</span><br><span class="line">    : m_listenfd(listenfd), m_process_number(process_number), m_idx(<span class="number">-1</span>),</span><br><span class="line">      m_stop(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">assert((process_number &gt; <span class="number">0</span>) &amp;&amp; (process_number &lt;= MAX_PROCESS_NUMBER));</span><br><span class="line"></span><br><span class="line">m_sub_process = <span class="keyword">new</span> process[process_number];</span><br><span class="line">assert(m_sub_process);</span><br><span class="line"><span class="comment">/*创建process_number个子进程，并建立它们和父进程之间的管道*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_number; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_sub_process[i].m_pipefd);</span><br><span class="line">assert(ret == <span class="number">0</span>);</span><br><span class="line">m_sub_process[i].m_pid = fork();</span><br><span class="line">assert(m_sub_process[i].m_pid &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">close(m_sub_process[i].m_pipefd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(m_sub_process[i].m_pipefd[<span class="number">0</span>]);</span><br><span class="line">m_idx = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*统一事件源*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::setup_sig_pipe() &#123;</span><br><span class="line"><span class="comment">/*创建epoll事件监听表和信号管道*/</span></span><br><span class="line">m_epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(m_epollfd != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, sig_pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">setnonblocking(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(m_epollfd, sig_pipefd[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">/*设置信号处理函数*/</span></span><br><span class="line">addsig(SIGCHLD, sig_handler);</span><br><span class="line">addsig(SIGTERM, sig_handler);</span><br><span class="line">addsig(SIGINT, sig_handler);</span><br><span class="line">addsig(SIGPIPE, SIG_IGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*父进程中m_idx值为-1，子进程中m_idx值大于等于0，我们据此判断接下来要运行</span></span><br><span class="line"><span class="comment">的是父进程代码还是子进程代码*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::run() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">run_child();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run_parent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::run_child() &#123;</span><br><span class="line">setup_sig_pipe();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每个子进程都通过其在进程池中的序号值m_idx找到与父进程通信的管道*/</span></span><br><span class="line"><span class="keyword">int</span> pipefd = m_sub_process[m_idx].m_pipefd[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/*子进程需要监听管道文件描述符pipefd，因为父进程将通过它来通知子进程accept</span></span><br><span class="line"><span class="comment">  新连接*/</span></span><br><span class="line">addfd(m_epollfd, pipefd);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">T *users = <span class="keyword">new</span> T[USER_PER_PROCESS];</span><br><span class="line">assert(users);</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> client = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*从父、子进程之间的管道读取数据，并将结果保存在变量client中。如果读取成</span></span><br><span class="line"><span class="comment">        功，则表示有新客户连接到来*/</span></span><br><span class="line">ret = recv(sockfd, (<span class="keyword">char</span> *) &amp;client, <span class="keyword">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (((ret &lt; <span class="number">0</span>) &amp;&amp; (errno != EAGAIN)) || ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct sockaddr_in client_address;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(m_listenfd, (struct sockaddr *) &amp;client_address,</span><br><span class="line">                    &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">addfd(m_epollfd, connfd);</span><br><span class="line"><span class="comment">/*模板类T必须实现init方法，以初始化一个客户连接。我们直接使用connfd来索引</span></span><br><span class="line"><span class="comment">          逻辑处理对象（T类型的对象），以提高程序效率*/</span></span><br><span class="line">users[connfd].init(m_epollfd, connfd, client_address);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下面处理子进程接收到的信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM:</span><br><span class="line"><span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">m_stop = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果是其他可读数据，那么必然是客户请求到来。调用逻辑处理对象的process方法</span></span><br><span class="line"><span class="comment">      处理之*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">users[sockfd].</span><br><span class="line"></span><br><span class="line">        process();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] users;</span><br><span class="line">users = <span class="literal">NULL</span>;</span><br><span class="line">close(pipefd);</span><br><span class="line"><span class="comment">// close(m_listenfd);/*我们将这句话注释掉，以提醒读者：应该由m_listenfd</span></span><br><span class="line"><span class="comment">// 的创建者来关闭这个文件描述符（见后文），即所谓的“对象（比如一个文件描述符，又或者</span></span><br><span class="line"><span class="comment">// 一段堆内存）由哪个函数创建，就应该由哪个函数销毁”*/</span></span><br><span class="line">close(m_epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::run_parent() &#123;</span><br><span class="line">setup_sig_pipe();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*父进程监听m_listenfd*/</span></span><br><span class="line">addfd(m_epollfd, m_listenfd);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> sub_process_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> new_conn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == m_listenfd) &#123;</span><br><span class="line"><span class="comment">/*如果有新连接到来，就采用Round Robin方式将其分配给一个子进程处理*/</span></span><br><span class="line"><span class="keyword">int</span> i = sub_process_counter;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">i = (i + <span class="number">1</span>) % m_process_number;</span><br><span class="line">&#125; <span class="keyword">while</span> (i != sub_process_counter);</span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">m_stop = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sub_process_counter = (i + <span class="number">1</span>) % m_process_number;</span><br><span class="line">send(m_sub_process[i].m_pipefd[<span class="number">0</span>], (<span class="keyword">char</span> *) &amp;new_conn, <span class="keyword">sizeof</span>(new_conn),</span><br><span class="line">     <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send request to child%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下面处理父进程接收到的信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line"><span class="comment">/*如果进程池中第i个子进程退出了，则主进程关闭相应的通信管道，并设置相应的</span></span><br><span class="line"><span class="comment">                  m_pid为-1，以标记该子进程已经退出*/</span></span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid == pid) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child%d join\n&quot;</span>, i);</span><br><span class="line">close(m_sub_process[i].m_pipefd[<span class="number">0</span>]);</span><br><span class="line">m_sub_process[i].m_pid = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果所有子进程都已经退出了，则父进程也退出*/</span></span><br><span class="line">m_stop = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">m_stop = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM:&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line"><span class="comment">/*如果父进程接收到终止信号，那么就杀死所有子进程，并等待它们全部结束。当然，</span></span><br><span class="line"><span class="comment">              通知子进程结束更好的方法是向父、子进程之间的通信管道发送特殊数据，读者不妨自己实</span></span><br><span class="line"><span class="comment">              现之*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;kill all the clild now\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> pid = m_sub_process[i].m_pid;</span><br><span class="line"><span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">kill(pid, SIGTERM);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// close(m_listenfd);/*由创建者关闭这个文件描述符（见后文）*/</span></span><br><span class="line">close(m_epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="15-4-用进程池实现的简单CGI服务器"><a href="#15-4-用进程池实现的简单CGI服务器" class="headerlink" title="15.4 用进程池实现的简单CGI服务器"></a>15.4 用进程池实现的简单CGI服务器</h4><p>回忆6.2节，我们曾实现过一个非常简单的CGI服务器。下面我们 将利用前面介绍的进程池来重新实现一个并发的CGI服务器，如代码 清单15-2所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用进程池实现一个并发CGI服务器*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;processpool.h&quot;</span> <span class="comment">/*引用上一节介绍的进程池*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于处理客户CGI请求的类，它可以作为processpool类的模板参数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cgi_conn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">cgi_conn() = <span class="keyword">default</span>;</span><br><span class="line">~cgi_conn() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化客户连接，清空读缓冲区*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in &amp;client_addr)</span> </span>&#123;</span><br><span class="line">m_epollfd = epollfd;</span><br><span class="line">m_sockfd = sockfd;</span><br><span class="line">m_address = client_addr;</span><br><span class="line"><span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">m_read_idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/*循环读取和分析客户数据*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">idx = m_read_idx;</span><br><span class="line">ret = recv(m_sockfd, m_buf + idx, BUFFER_SIZE - <span class="number">1</span> - idx, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*如果读操作发生错误,则关闭客户连接。但如果是暂时无数据可读，则退出循环*/</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果对方关闭连接，则服务器也关闭连接*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m_read_idx += ret;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;user content is:%s\n&quot;</span>, m_buf);</span><br><span class="line"><span class="comment">/*如果遇到字符“\r\n”，则开始处理客户请求*/</span></span><br><span class="line"><span class="keyword">for</span> (; idx &lt; m_read_idx; ++idx) &#123;</span><br><span class="line"><span class="keyword">if</span> ((idx &gt;= <span class="number">1</span>) &amp;&amp; (m_buf[idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>) &amp;&amp; (m_buf[idx] == <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果没有遇到字符“\r\n”，则需要读取更多客户数据*/</span></span><br><span class="line"><span class="keyword">if</span> (idx == m_read_idx) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_buf[idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> *file_name = m_buf;</span><br><span class="line"><span class="comment">/*判断客户要运行的CGI程序是否存在*/</span></span><br><span class="line"><span class="keyword">if</span> (access(file_name, F_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*创建子进程来执行CGI程序*/</span></span><br><span class="line">ret = fork();</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*父进程只需关闭连接*/</span></span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*子进程将标准输出定向到m_sockfd，并执行CGI程序*/</span></span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">dup(m_sockfd);</span><br><span class="line">execl(m_buf, m_buf, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*读缓冲区的大小*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_epollfd;</span><br><span class="line"><span class="keyword">int</span> m_sockfd&#123;&#125;;</span><br><span class="line">sockaddr_in m_address&#123;&#125;;</span><br><span class="line"><span class="keyword">char</span> m_buf[BUFFER_SIZE]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标记读缓冲中已经读入的客户数据的最后一个字节的下一个位置*/</span></span><br><span class="line"><span class="keyword">int</span> m_read_idx&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cgi_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span> &#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">processpool&lt;cgi_conn&gt; *pool = processpool&lt;cgi_conn&gt;::create(listenfd);</span><br><span class="line"><span class="keyword">if</span> (pool) &#123;</span><br><span class="line">pool-&gt;run();</span><br><span class="line"><span class="keyword">delete</span> pool;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="comment">/*正如前文提到的，main函数创建了文件描述符listenfd，那么就由它亲自关闭之*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-5-半同步-半反应堆线程池实现"><a href="#15-5-半同步-半反应堆线程池实现" class="headerlink" title="15.5 半同步/半反应堆线程池实现"></a>15.5 半同步/半反应堆线程池实现</h4><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230228212216219.png" class="" title="image-20230228212216219"><p>本节我们实现一个基于图8-10所示的半同步/半反应堆并发模式的 线程池，如代码清单15-3所示。</p><p>相比代码清单15-1所示的进程池实现，该线程池的通用性要高得多，因为它使用一个工作队列完全解除 了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工 作线程通过竞争来取得任务并执行它。不过，如果要将该线程池应用 到实际服务器程序中，那么我们必须保证所有客户请求都是无状态的，因为同一个连接上的不同请求可能会由不同的线程处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*引用第14章介绍的线程同步机制的包装类*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程池类，将它定义为模板类是为了代码复用。模板参数T是任务类*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadpool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*参数thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">threadpool</span><span class="params">(<span class="keyword">int</span> thread_number = <span class="number">8</span>, <span class="keyword">int</span> max_requests = <span class="number">10000</span>)</span></span>;</span><br><span class="line">~threadpool();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*往请求队列中添加任务*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T *request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_thread_number;        <span class="comment">/*线程池中的线程数*/</span></span><br><span class="line"><span class="keyword">int</span> m_max_requests;         <span class="comment">/*请求队列中允许的最大请求数*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> *m_threads;       <span class="comment">/*描述线程池的数组，其大小为m_thread_number*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T *&gt; m_workqueue; <span class="comment">/*请求队列*/</span></span><br><span class="line">locker m_queuelocker;       <span class="comment">/*保护请求队列的互斥锁*/</span></span><br><span class="line">sem m_queuestat;            <span class="comment">/*是否有任务需要处理*/</span></span><br><span class="line"><span class="keyword">bool</span> m_stop;                <span class="comment">/*是否结束线程*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::threadpool(<span class="keyword">int</span> thread_number, <span class="keyword">int</span> max_requests)</span><br><span class="line">    : m_thread_number(thread_number), m_max_requests(max_requests),</span><br><span class="line">      m_stop(<span class="literal">false</span>), m_threads(<span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_threads = <span class="keyword">new</span> <span class="keyword">pthread_t</span>[m_thread_number];</span><br><span class="line"><span class="keyword">if</span> (!m_threads) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建thread_number个线程，并将它们都设置为脱离线程*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create the%dth thread\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">if</span> (pthread_create(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_threads;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_detach(m_threads[i])) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_threads;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~threadpool() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_threads;</span><br><span class="line">m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt;T&gt;::append(T *request) &#123;</span><br><span class="line"><span class="comment">/*操作工作队列时一定要加锁，因为它被所有线程共享*/</span></span><br><span class="line">m_queuelocker.lock();</span><br><span class="line"><span class="keyword">if</span> (m_workqueue.size() &gt; m_max_requests) &#123;</span><br><span class="line">m_queuelocker.unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_workqueue.push_back(request);</span><br><span class="line">m_queuelocker.unlock();</span><br><span class="line">m_queuestat.post();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> *threadpool&lt;T&gt;::worker(<span class="keyword">void</span> *arg) &#123;</span><br><span class="line"><span class="keyword">auto</span> *pool = (threadpool *) arg;</span><br><span class="line">pool-&gt;run();</span><br><span class="line"><span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> threadpool&lt;T&gt;::run() &#123;</span><br><span class="line"><span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">m_queuestat.wait();</span><br><span class="line">m_queuelocker.lock();</span><br><span class="line"><span class="keyword">if</span> (m_workqueue.empty()) &#123;</span><br><span class="line">m_queuelocker.unlock();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">T *request = m_workqueue.front();</span><br><span class="line">m_workqueue.pop_front();</span><br><span class="line">m_queuelocker.unlock();</span><br><span class="line"><span class="keyword">if</span> (!request) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">request-&gt;process();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在C++程序中使用pthread_create函数时，该函数 的第3个参数必须指向一个静态函数。而要在一个静态函数中使用类的 动态成员（包括成员函数和成员变量），则只能通过如下两种方式来 实现：</p><ul><li>通过类的静态对象来调用。比如单体模式中，静态函数可以通 过类的全局唯一实例来访问动态成员函数。</li><li>将类的对象作为参数传递给该静态函数，然后在静态函数中引 用这个对象，并调用其动态方法。</li><li>代码清单15-3使用的是第2种方式：将线程参数设置为this指针， 然后在worker函数中获取该指针并调用其动态方法run。</li></ul><h4 id="15-6-用线程池实现的简单Web服务器"><a href="#15-6-用线程池实现的简单Web服务器" class="headerlink" title="15.6 用线程池实现的简单Web服务器"></a>15.6 用线程池实现的简单Web服务器</h4><p>在8.6节中，我们曾使用有限状态机实现过一个非常简单的解析 HTTP请求的服务器。下面我们将利用前面介绍的线程池来重新实现一 个并发的Web服务器。</p><h5 id="15-6-1-http-conn类"><a href="#15-6-1-http-conn类" class="headerlink" title="15.6.1 http_conn类"></a>15.6.1 http_conn类</h5><p>首先，我们需要准备线程池的模板参数类，用以封装对逻辑任务 的处理。这个类是http_conn，代码清单15-4是其头文件 （http_conn.h），代码清单15-5是其实现文件（http_conn.cpp）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HTTPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HTTPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">http_conn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*文件名的最大长度*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> FILENAME_LEN = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读缓冲区的大小*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> READ_BUFFER_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写缓冲区的大小*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WRITE_BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*HTTP请求方法，但我们仅支持GET*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">METHOD</span> &#123;</span> GET = <span class="number">0</span>,</span><br><span class="line">          POST,</span><br><span class="line">          HEAD,</span><br><span class="line">          PUT,</span><br><span class="line">          DELETE,</span><br><span class="line">          TRACE,</span><br><span class="line">          OPTIONS,</span><br><span class="line">          CONNECT,</span><br><span class="line">          PATCH &#125;;</span><br><span class="line"><span class="comment">/*解析客户请求时，主状态机所处的状态（回忆第8章）*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="number">0</span>,</span><br><span class="line">               CHECK_STATE_HEADER,</span><br><span class="line">               CHECK_STATE_CONTENT &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*服务器处理HTTP请求的可能结果*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTP_CODE</span> &#123;</span> NO_REQUEST,</span><br><span class="line">             GET_REQUEST,</span><br><span class="line">             BAD_REQUEST,</span><br><span class="line">             NO_RESOURCE,</span><br><span class="line">             FORBIDDEN_REQUEST,</span><br><span class="line">             FILE_REQUEST,</span><br><span class="line">             INTERNAL_ERROR,</span><br><span class="line">             CLOSED_CONNECTION &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*行的读取状态*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="number">0</span>,</span><br><span class="line">               LINE_BAD,</span><br><span class="line">               LINE_OPEN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">http_conn() = <span class="keyword">default</span>;</span><br><span class="line">~http_conn() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*初始化新接受的连接*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in&amp; addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*关闭连接*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_conn</span><span class="params">(<span class="keyword">bool</span> real_close = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理客户请求*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非阻塞读操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非阻塞写操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*初始化连接*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析HTTP请求*/</span></span><br><span class="line"><span class="function">HTTP_CODE <span class="title">process_read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*填充HTTP应答*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">process_write</span><span class="params">(HTTP_CODE ret)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面这一组函数被process_read调用以分析HTTP请求*/</span></span><br><span class="line"><span class="function">HTTP_CODE <span class="title">parse_request_line</span><span class="params">(<span class="keyword">char</span> *text)</span></span>;</span><br><span class="line"><span class="function">HTTP_CODE <span class="title">parse_headers</span><span class="params">(<span class="keyword">char</span> *text)</span></span>;</span><br><span class="line"><span class="function">HTTP_CODE <span class="title">parse_content</span><span class="params">(<span class="keyword">char</span> *text)</span></span>;</span><br><span class="line"><span class="function">HTTP_CODE <span class="title">do_request</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_line</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_read_buf + m_start_line; &#125;</span><br><span class="line"><span class="function">LINE_STATUS <span class="title">parse_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面这一组函数被process_write调用以填充HTTP应答*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unmap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_response</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_content</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *content)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_status_line</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span> *title)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_headers</span><span class="params">(<span class="keyword">int</span> content_length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_content_length</span><span class="params">(<span class="keyword">int</span> content_length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_linger</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_blank_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*所有socket上的事件都被注册到同一个epoll内核事件表中，所以将epoll文件描述符设置为静态的*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_epollfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*统计用户数量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_user_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*该HTTP连接的socket和对方的socket地址*/</span></span><br><span class="line"><span class="keyword">int</span> m_sockfd&#123;&#125;;</span><br><span class="line">sockaddr_in m_address&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读缓冲区*/</span></span><br><span class="line"><span class="keyword">char</span> m_read_buf[READ_BUFFER_SIZE]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标识读缓冲中已经读入的客户数据的最后一个字节的下一个位置*/</span></span><br><span class="line"><span class="keyword">int</span> m_read_idx&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当前正在分析的字符在读缓冲区中的位置*/</span></span><br><span class="line"><span class="keyword">int</span> m_checked_idx&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当前正在解析的行的起始位置*/</span></span><br><span class="line"><span class="keyword">int</span> m_start_line&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写缓冲区*/</span></span><br><span class="line"><span class="keyword">char</span> m_write_buf[WRITE_BUFFER_SIZE]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写缓冲区中待发送的字节数*/</span></span><br><span class="line"><span class="keyword">int</span> m_write_idx&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主状态机当前所处的状态*/</span></span><br><span class="line">CHECK_STATE m_check_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*请求方法*/</span></span><br><span class="line">METHOD m_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户请求的目标文件的完整路径，其内容等于doc_root+m_url，doc_root是网站根目录*/</span></span><br><span class="line"><span class="keyword">char</span> m_real_file[FILENAME_LEN]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户请求的目标文件的文件名*/</span></span><br><span class="line"><span class="keyword">char</span> *m_url&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*HTTP协议版本号，我们仅支持HTTP/1.1*/</span></span><br><span class="line"><span class="keyword">char</span> *m_version&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主机名*/</span></span><br><span class="line"><span class="keyword">char</span> *m_host&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*HTTP请求的消息体的长度*/</span></span><br><span class="line"><span class="keyword">int</span> m_content_length&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*HTTP请求是否要求保持连接*/</span></span><br><span class="line"><span class="keyword">bool</span> m_linger&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户请求的目标文件被mmap到内存中的起始位置*/</span></span><br><span class="line"><span class="keyword">char</span> *m_file_address&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*目标文件的状态。通过它我们可以判断文件是否存在、是否为目录、是否可读，并获</span></span><br><span class="line"><span class="comment">取文件大小等信息*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">m_file_stat</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们将采用writev来执行写操作，所以定义下面两个成员，其中m_iv_count表示</span></span><br><span class="line"><span class="comment">被写内存块的数量*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">m_iv</span>[2]&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_iv_count&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="15-6-2-http-conn实现"><a href="#15-6-2-http-conn实现" class="headerlink" title="15.6.2 http_conn实现"></a>15.6.2 http_conn实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../include/http_conn.h&quot;</span></span></span><br><span class="line"><span class="comment">/*定义HTTP响应的一些状态信息*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ok_200_title = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to satisfy.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_403_form = <span class="string">&quot;You do not have permission to get file from this server.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_500_form = <span class="string">&quot;There was an unusual problem serving the requested file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*网站的根目录*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *doc_root = <span class="string">&quot;/home/sen/html/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过fcntl函数通来将一个文件描述符设置为非阻塞的</span></span><br><span class="line"><span class="comment"> * 类似于listenfd = socket(AF_INET, SOCK_NONBLOCK | SOCK_STREAM, 0);</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册 POLLIN(数据可读) EPOLLET(高效EPOLL) EPOLLRDHUB(TCP链接被对方关闭)</span></span><br><span class="line"><span class="comment"> * oneshot = true , 操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次, 除非重置</span></span><br><span class="line"><span class="comment"> * EPOLLONESHOT标志 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line"><span class="keyword">if</span> (one_shot) &#123;</span><br><span class="line">event.events |= EPOLLONESHOT;</span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用epoll_ctl 删除内核事件表, 并且关闭文件描述符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> ev)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="keyword">bool</span> real_close)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (real_close &amp;&amp; (m_sockfd != <span class="number">-1</span>)) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line">m_sockfd = <span class="number">-1</span>;</span><br><span class="line">m_user_count--; <span class="comment">/*关闭一个连接时，将客户总量减1*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in &amp;addr)</span> </span>&#123;</span><br><span class="line">m_sockfd = sockfd;</span><br><span class="line">m_address = addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如下两行是为了避免TIME_WAIT状态，仅用于调试，实际使用时应该去掉*/</span></span><br><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">setsockopt(m_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line"></span><br><span class="line">addfd(m_epollfd, sockfd, <span class="literal">true</span>);</span><br><span class="line">m_user_count++;</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* htp_coon 初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_check_state = CHECK_STATE_REQUESTLINE;</span><br><span class="line">m_linger = <span class="literal">false</span>;</span><br><span class="line">m_method = GET;</span><br><span class="line">m_url = <span class="literal">nullptr</span>;</span><br><span class="line">m_version = <span class="literal">nullptr</span>;</span><br><span class="line">m_content_length = <span class="number">0</span>;</span><br><span class="line">m_host = <span class="literal">nullptr</span>;</span><br><span class="line">m_start_line = <span class="number">0</span>;</span><br><span class="line">m_checked_idx = <span class="number">0</span>;</span><br><span class="line">m_read_idx = <span class="number">0</span>;</span><br><span class="line">m_write_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#x27;\0&#x27;是字符串结束标志，不计入串长，但要占内存空间。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &#x27;\0&#x27;是一个ASCII控制字符，是转义字符。</span></span><br><span class="line"><span class="comment"> *  意思是告诉编译器，这不是字符0，而是空字符。空字符\0对应的二进制为0000 0000，而数字0的二进制为0011 0000。</span></span><br><span class="line"><span class="comment"> *  这里的话 可以使用 bzero代替</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">memset</span>(m_read_buf, <span class="string">&#x27;\0&#x27;</span>, READ_BUFFER_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(m_write_buf, <span class="string">&#x27;\0&#x27;</span>, WRITE_BUFFER_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(m_real_file, <span class="string">&#x27;\0&#x27;</span>, FILENAME_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从状态机，其分析请参考8.6节，这里不再赘述*/</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> temp;</span><br><span class="line"><span class="keyword">for</span> (; m_checked_idx &lt; m_read_idx; ++m_checked_idx) &#123;</span><br><span class="line">temp = m_read_buf[m_checked_idx];</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((m_checked_idx + <span class="number">1</span>) == m_read_idx) &#123;</span><br><span class="line"><span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_read_buf[m_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> LINE_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LINE_BAD;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((m_checked_idx &gt; <span class="number">1</span>) &amp;&amp; (m_read_buf[m_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)) &#123;</span><br><span class="line">m_read_buf[m_checked_idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> LINE_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LINE_BAD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*循环读取客户数据，直到无数据可读或者对方关闭连接*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_read_idx &gt;= READ_BUFFER_SIZE) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_read_idx += bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析HTTP请求行，获得请求方法、目标URL，以及HTTP版本号*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!m_url) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line">*m_url++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> *method = text;</span><br><span class="line"><span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">m_method = GET;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line">m_url += <span class="built_in">strspn</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">m_version = <span class="built_in">strpbrk</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!m_version) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line">*m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">m_version += <span class="built_in">strspn</span>(m_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (strcasecmp(m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (strncasecmp(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">m_url += <span class="number">7</span>;</span><br><span class="line">m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line">m_check_state = CHECK_STATE_HEADER;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析HTTP请求的一个头部信息*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*遇到空行，表示头部字段解析完毕*/</span></span><br><span class="line"><span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">/*如果HTTP请求有消息体，则还需要读取m_content_length字节的消息体，状态机转移到CHECK_STATE_CONTENT状态*/</span></span><br><span class="line"><span class="keyword">if</span> (m_content_length != <span class="number">0</span>) &#123;</span><br><span class="line">m_check_state = CHECK_STATE_CONTENT;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则说明我们已经得到了一个完整的HTTP请求*/</span></span><br><span class="line"><span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理Connection头部字段*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">text += <span class="number">11</span>;</span><br><span class="line">text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (strcasecmp(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">m_linger = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理Content-Length头部字段*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(text, <span class="string">&quot;Content-Length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">text += <span class="number">15</span>;</span><br><span class="line">text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">m_content_length = atol(text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理Host头部字段*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">text += <span class="number">5</span>;</span><br><span class="line">text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">m_host = text;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;oop!unknow header%s\n&quot;</span>, text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们没有真正解析HTTP请求的消息体，只是判断它是否被完整地读入了*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx)) &#123;</span><br><span class="line">text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主状态机。其分析请参考8.6节，这里不再赘述*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LINE_STATUS line_status = LINE_OK;</span><br><span class="line">HTTP_CODE ret = NO_REQUEST;</span><br><span class="line"><span class="keyword">char</span> *text = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK))</span><br><span class="line">       || ((line_status = parse_line()) == LINE_OK)) &#123;</span><br><span class="line">text = get_line();</span><br><span class="line">m_start_line = m_checked_idx;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got 1 http line: %s\n&quot;</span>, text);</span><br><span class="line"><span class="keyword">switch</span> (m_check_state) &#123;</span><br><span class="line"><span class="keyword">case</span> CHECK_STATE_REQUESTLINE: &#123;</span><br><span class="line">ret = parse_request_line(text);</span><br><span class="line"><span class="keyword">if</span> (ret == BAD_REQUEST) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CHECK_STATE_HEADER: &#123;</span><br><span class="line">ret = parse_headers(text);</span><br><span class="line"><span class="keyword">if</span> (ret == BAD_REQUEST) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == GET_REQUEST) &#123;</span><br><span class="line"><span class="keyword">return</span> do_request();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CHECK_STATE_CONTENT: &#123;</span><br><span class="line">ret = parse_content(text);</span><br><span class="line"><span class="keyword">if</span> (ret == GET_REQUEST) &#123;</span><br><span class="line"><span class="keyword">return</span> do_request();</span><br><span class="line">&#125;</span><br><span class="line">line_status = LINE_OPEN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性。如果目标文件存在、</span></span><br><span class="line"><span class="comment"> * 对所有用户可读，且不是目录，则使用mmap将其映射到内存地址m_file_address</span></span><br><span class="line"><span class="comment">处，并告诉调用者获取文件成功*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(m_real_file, doc_root);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(doc_root);</span><br><span class="line"><span class="built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stat(m_real_file, &amp;m_file_stat) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH)) &#123;</span><br><span class="line"><span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(m_file_stat.st_mode)) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fd = open(m_real_file, O_RDONLY);</span><br><span class="line">m_file_address = (<span class="keyword">char</span> *) mmap(<span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> FILE_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对内存映射区执行munmap操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::unmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_file_address) &#123;</span><br><span class="line">munmap(m_file_address, m_file_stat.st_size);</span><br><span class="line">m_file_address = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写HTTP响应*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::write</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bytes_have_send = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bytes_to_send = m_write_idx;</span><br><span class="line"><span class="keyword">if</span> (bytes_to_send == <span class="number">0</span>) &#123;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line"><span class="keyword">if</span> (temp &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/*如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件。虽然在此期间，服务器无</span></span><br><span class="line"><span class="comment">法立即接收到同一客户的下一个请求，但这可以保证连接的完整性*/</span></span><br><span class="line"><span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">unmap();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">bytes_to_send -= temp;</span><br><span class="line">bytes_have_send += temp;</span><br><span class="line"><span class="keyword">if</span> (bytes_to_send &lt;= bytes_have_send) &#123;</span><br><span class="line"><span class="comment">/*发送HTTP响应成功，根据HTTP请求中的Connection字段决定是否立即关闭连接*/</span></span><br><span class="line">unmap();</span><br><span class="line"><span class="keyword">if</span> (m_linger) &#123;</span><br><span class="line">init();</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*往写缓冲中写入待发送的数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_response</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_write_idx &gt;= WRITE_BUFFER_SIZE) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">va_list arg_list;</span><br><span class="line">va_start(arg_list, format);</span><br><span class="line"><span class="keyword">int</span> len = vsnprintf(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx, format, arg_list);</span><br><span class="line"><span class="keyword">if</span> (len &gt;= (WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_write_idx += len;</span><br><span class="line">va_end(arg_list);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span> *title)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;%s%d%s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line">add_content_length(content_len);</span><br><span class="line">add_linger();</span><br><span class="line">add_blank_line();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;Content-Length:%d\r\n&quot;</span>, content_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;Connection:%s\r\n&quot;</span>, (m_linger == <span class="literal">true</span>) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *content)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据服务器处理HTTP请求的结果，决定返回给客户端的内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> INTERNAL_ERROR: &#123;</span><br><span class="line">add_status_line(<span class="number">500</span>, error_500_title);</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(error_500_form));</span><br><span class="line"><span class="keyword">if</span> (!add_content(error_500_form)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> BAD_REQUEST: &#123;</span><br><span class="line">add_status_line(<span class="number">400</span>, error_400_title);</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(error_400_form));</span><br><span class="line"><span class="keyword">if</span> (!add_content(error_400_form)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> NO_RESOURCE: &#123;</span><br><span class="line">add_status_line(<span class="number">404</span>, error_404_title);</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line"><span class="keyword">if</span> (!add_content(error_404_form)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> FORBIDDEN_REQUEST: &#123;</span><br><span class="line">add_status_line(<span class="number">403</span>, error_403_title);</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line"><span class="keyword">if</span> (!add_content(error_403_form)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> FILE_REQUEST: &#123;</span><br><span class="line">add_status_line(<span class="number">200</span>, ok_200_title);</span><br><span class="line"><span class="keyword">if</span> (m_file_stat.st_size != <span class="number">0</span>) &#123;</span><br><span class="line">add_headers(m_file_stat.st_size);</span><br><span class="line">m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">m_iv_count = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line"><span class="keyword">if</span> (!add_content(ok_string)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">m_iv_count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*由线程池中的工作线程调用，这是处理HTTP请求的入口函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HTTP_CODE read_ret = process_read();</span><br><span class="line"><span class="keyword">if</span> (read_ret == NO_REQUEST) &#123;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> write_ret = process_write(read_ret);</span><br><span class="line"><span class="keyword">if</span> (!write_ret) &#123;</span><br><span class="line">close_conn();</span><br><span class="line">&#125;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="15-6-3-main-cpp"><a href="#15-6-3-main-cpp" class="headerlink" title="15.6.3 main.cpp"></a>15.6.3 main.cpp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FD 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = handler;</span><br><span class="line"><span class="keyword">if</span> (restart) &#123;</span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line">&#125;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_error</span><span class="params">(<span class="keyword">int</span> connfd, <span class="keyword">const</span> <span class="keyword">char</span> *info)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">/*忽略SIGPIPE信号*/</span></span><br><span class="line">addsig(SIGPIPE, SIG_IGN);</span><br><span class="line"><span class="comment">/*创建线程池*/</span></span><br><span class="line">threadpool&lt;http_conn&gt; *pool = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pool = <span class="keyword">new</span> threadpool&lt;http_conn&gt;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*预先为每个可能的客户连接分配一个http_conn对象*/</span></span><br><span class="line"><span class="keyword">auto</span> *users = <span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line">assert(users);</span><br><span class="line"><span class="keyword">int</span> user_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">tmp</span> =</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">addfd(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line">http_conn::m_epollfd = epollfd;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD) &#123;</span><br><span class="line">show_error(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*初始化客户连接*/</span></span><br><span class="line">users[connfd].init(connfd, client_address);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line"><span class="comment">/*如果有异常，直接关闭客户连接*/</span></span><br><span class="line">users[sockfd].close_conn();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="comment">/*根据读的结果，决定是将任务添加到线程池，还是关闭连接*/</span></span><br><span class="line"><span class="keyword">if</span> (users[sockfd].read()) &#123;</span><br><span class="line">pool-&gt;append(users + sockfd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">users[sockfd].close_conn();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line"><span class="comment">/*根据写的结果，决定是否关闭连接*/</span></span><br><span class="line"><span class="keyword">if</span> (!users[sockfd].write()) &#123;</span><br><span class="line">users[sockfd].close_conn();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(epollfd);</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">delete</span>[] users;</span><br><span class="line"><span class="keyword">delete</span> pool;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="15-6-4-Cmakelists-txt"><a href="#15-6-4-Cmakelists-txt" class="headerlink" title="15.6.4 Cmakelists.txt"></a>15.6.4 Cmakelists.txt</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(http_server)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp http_connection/http_conn.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main Threads::Threads)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目录结构:</p><img src="/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230311190929809.png" class="" title="image-20230311190929809">]]></content>
    
    
      
      
    <summary type="html">&lt;img src=&quot;/2023/02/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20220908201643320.png&quot; class=&quot;&quot; title=&quot;</summary>
      
    
    
    
    <category term="Linux" scheme="http://okeyia.github.io/categories/Linux/"/>
    
    
    <category term="服务器编程" scheme="http://okeyia.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>二 高性能服务器框架</title>
    <link href="http://okeyia.github.io/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://okeyia.github.io/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/</id>
    <published>2023-01-29T03:05:24.000Z</published>
    <updated>2023-03-21T09:31:46.636Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二篇-高性能服务器框架"><a href="#第二篇-高性能服务器框架" class="headerlink" title="第二篇 高性能服务器框架"></a>第二篇 高性能服务器框架</h2><h3 id="第5章-Linux网络编程基础API"><a href="#第5章-Linux网络编程基础API" class="headerlink" title="第5章 Linux网络编程基础API"></a>第5章 Linux网络编程基础API</h3><p>我们将从如 下3个方面讨论Linux网络API：</p><ul><li>socket地址API。socket最开始的含义是一个IP地址和端口对 （ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket 地址。</li><li>socket基础API。socket的主要API都定义在sys/socket.h头文件 中，包括创建socket、命名socket、监听socket、接受连接、发起连接、 读写数据、获取地址信息、检测带外标记，以及读取和设置socket选 项。</li><li>网络信息API。Linux提供了一套网络信息API，以实现主机名和 IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定 义在netdb.h头文件中，我们将讨论其中几个主要的函数。</li></ul><h4 id="5-1-socket地址API"><a href="#5-1-socket地址API" class="headerlink" title="5.1 socket地址API"></a>5.1 socket地址API</h4><h5 id="5-1-1-主机字节序和网络字节序"><a href="#5-1-1-主机字节序和网络字节序" class="headerlink" title="5.1.1 主机字节序和网络字节序"></a>5.1.1 主机字节序和网络字节序</h5><p>现代CPU的累加器一次都能装载（至少）4字节（这里考虑32位 机，下同），即一个整数。那么这4字节在内存中排列的顺序将影响它 被累加器装载成的整数的值。这就是字节序问题。</p><p>字节序分为大端字 节序（big endian）和小端字节序（little endian）。</p><ul><li>大端字节序是指一 个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0 ～7 bit）存储在内存的高地址处。</li><li>小端字节序则是指整数的高位字节存 储在内存的高地址处，而低位字节则存储在内存的低地址处。</li></ul><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224104317174-1678341964415.png" class="" title="image-20230224104317174"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断机器字节序</span></span><br><span class="line"><span class="comment">// union 参考https://www.cnblogs.com/linyx/p/3998893.html</span></span><br><span class="line"><span class="comment">// 在一个union类型结构中,所有的成员公用同样的存储空间,其占用的大小为其成员中需要空间最大者；</span></span><br><span class="line"><span class="comment">// union本身只保留一块地址空间，因为只有一个成员真正存储于该地址， 但这块地址也要满足内存对齐原则。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">byteorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">short</span> value;</span><br><span class="line"><span class="keyword">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">&#125; test;</span><br><span class="line"></span><br><span class="line">test.value = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;little endian\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unknown...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送端总是把要发送的数据转化成大端字节序数据后 再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所 以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转 换（小端机转换，大端机不转换）。</p><p>因此大端字节序也称为网络字节 序，它给所有接收数据的主机提供了一个正确解释收到的格式化数据 的保证。</p><p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的 转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="comment">// 如htonl表示“host to network long”，即将长整型（32 bit）的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="5-1-2-通用socket地址"><a href="#5-1-2-通用socket地址" class="headerlink" title="5.1.2 通用socket地址"></a>5.1.2 通用socket地址</h5><p>socket网络编程接口中表示socket地址的是结构体sockaddr，其定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sa_family成员是地址族类型（sa_family_t）的变量。地址族类型通 常与协议族类型对应。常见的协议族（protocol family，也称domain， 见后文）和对应的地址族如表5-1所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224120412533-1678341964416.png" class="" title="image-20230224120412533"><p>宏PF_<em>和AF_</em>都定义在bits/socket.h头文件中，且后者与前者有完 全相同的值，所以二者通常混用。</p><p>sa_data成员用于存放socket地址值。但是，不同的协议族的地址值 具有不同的含义和长度，如表5-2所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224133658704-1678341964416.png" class="" title="image-20230224133658704"><p>由表5-2可见，<strong>14字节的sa_data根本无法完全容纳多数协议族的地 址值。</strong>因此，Linux定义了下面这个新的通用socket地址结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> int__ss_align;</span><br><span class="line"><span class="keyword">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-3-专用socket地址"><a href="#5-1-3-专用socket地址" class="headerlink" title="5.1.3 专用socket地址"></a>5.1.3 专用socket地址</h5><p>上面这两个通用socket地址结构体显然很不好用，比如设置与获取 IP地址和端口号就需要执行烦琐的位操作。</p><p>所以Linux为各个协议族提 供了专门的socket地址结构体。UNix忽略.</p><p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构 体，它们分别用于IPv4和IPv6：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipV4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_INET*/</span></span><br><span class="line"><span class="keyword">u_int16_t</span> sin_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/*IPv4地址结构体，见下面*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">u_int32_t</span> s_addr;  <span class="comment">/*IPv4地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipV6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin6_family;<span class="comment">/*地址族：AF_INET6*/</span></span><br><span class="line"><span class="keyword">u_int16_t</span> sin6_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line"><span class="keyword">u_int32_t</span> sin6_flowinfo;<span class="comment">/*流信息，应设置为0*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/*IPv6地址结构体，见下面*/</span></span><br><span class="line"><span class="keyword">u_int32_t</span> sin6_scope_id;<span class="comment">/*scope ID，尚处于实验阶段*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];<span class="comment">/*IPv6地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使 用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因 为所有socket编程接口使用的地址参数的类型都是sockaddr。</strong></p><h5 id="5-1-4-IP地址转换函数"><a href="#5-1-4-IP地址转换函数" class="headerlink" title="5.1.4 IP地址转换函数"></a>5.1.4 IP地址转换函数</h5><p>下 面3个函数可用于用<strong>点分十进制字符串表示的IPv4地址</strong>和用<strong>网络字节序 整数表示的IPv4地址</strong>之间的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络 字节序整数表示的IPv4地址。它失败时返回INADDR_NONE。</p></li><li><p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于 参数inp指向的地址结构中。它成功时返回1，失败则返回0。</p></li><li><p>inet_ntoa函数将用网络字节序整数表示的IPv4地址转化为用点分十 进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，<strong>函数的返回值指向该静态内存</strong>，因此inet_ntoa是 不可重入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* szValue1=inet_ntoa(“<span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>”);</span><br><span class="line"><span class="keyword">char</span>* szValue2=inet_ntoa(“<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span>”);</span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">1</span>:%s\n”,szValue1);</span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">2</span>:%s\n”,szValue2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">address1:<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br><span class="line">address2:<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br></pre></td></tr></table></figure></li></ul><p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且它 们同时适用于IPv4地址和IPv6地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">char</span>* dst,<span class="keyword">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>inet_pton函数将用字符串表示的IP地址src（用点分十进制字符串表 示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节 序整数表示的IP地址，并把<strong>转换结果存储于dst指向的内存中</strong>。其中，af 参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返 回1，失败则返回0并设置errno[1]。</li><li>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参 数相同，最后一个参数cnt指定目标存储单元的大小。</li></ul><h4 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h4><p>UNIX/Linux的一个哲学是：所有东西都是文件。socket也不例 外，它就是可读、可写、可控制、可关闭的文件描述符。</p><p>下面的 socket系统调用可创建一个socket：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>domain参数告诉系统使用哪个底层协议族。对TCP/IP协议族而 言，该参数应该设置为PF_INET（Protocol Family of Internet，用于 IPv4）或PF_INET6（用于IPv6）；对于UNIX本地域协议族而言，该 参数应该设置为PF_UNIX。</li><li>type参数指定服务类型。服务类型主要有SOCK_STREAM服务 （流服务）和SOCK_UGRAM（数据报）服务。<strong>对TCP/IP协议族而 言，其值取SOCK_STREAM表示传输层使用TCP协议，取 SOCK_DGRAM表示传输层使用UDP协议。</strong></li><li>protocol参数是在前两个参数构成的协议集合下，再选择一个具体 的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它 的值）。几乎在所有情况下，我们都应该把它设置为0，表示使用默认 协议。</li></ul><p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1 并设置errno。</p><h4 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h4><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地 址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给 socket命名。</p><p>只有命名 后客户端才能知道该如何连接它。客户端则通常不需要命名socket， 而是采用匿名方式，即使用操作系统自动分配的socket地址。命名 socket的系统调用是bind，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>bind将my_addr所指的socket地址分配给未命名的sockfd文件描述 符，addrlen参数指出该socket地址的长度。</p><p>bind成功时返回0，失败则返回-1并设置errno。其中两种常见的 errno是EACCES和EADDRINUSE，它们的含义分别是：</p><ul><li>EACCES，被绑定的地址是受保护的地址，仅超级用户能够访 问。比如普通用户将socket绑定到知名服务端口（端口号为0～1023） 上时，bind将返回EACCES错误。</li><li>EADDRINUSE，被绑定的地址正在使用中。比如将socket绑定 到一个处于TIME_WAIT状态的socket地址。</li></ul><h4 id="5-4-监听socket"><a href="#5-4-监听socket" class="headerlink" title="5.4 监听socket"></a>5.4 监听socket</h4><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如 下系统调用来创建一个监听队列以存放待处理的客户连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客 户连接，客户端也将收到ECONNREFUSED错误信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/2/24.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_term</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">signal(SIGTERM, handle_term);</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number backlog\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> backlog = atoi(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sock&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建一个IPv4 socket地址*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inet_pton函数将用字符串表示的IP地址 src 转换成用网络字节 序整数表示的IP地址，</span></span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> ret = bind(sock,(struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = listen(sock, backlog);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*循环等待连接，直到有SIGTERM信号将它中断*/</span></span><br><span class="line"><span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*关闭socket，见后文*/</span></span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224203335190-1678341964416.png" class="" title="image-20230224203335190"><p>可见，在监听队列中，处于ESTABLISHED状态的连接只有6个 （backlog值加1），其他的连接都处于SYN_RCVD状态。</p><h4 id="5-5-接受连接"><a href="#5-5-接受连接" class="headerlink" title="5.5 接受连接"></a>5.5 接受连接</h4><p>下面的系统调用从listen监听队列中接受一个连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd参数是执行过listen系统调用的监听socket[1]。</li><li>addr参数用来获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数 指出。</li></ul><p>accept成功时返回一个新的连接socket，该socket唯一地标识了 被接受的这个连接，服务器可通过读写该socket来与被接受连接对应 的客户端通信。accept失败时返回-1并设置errno。</p><p>如果监听队列中处于ESTABLISHED状态的 连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么 服务器对这个连接执行的accept调用是否成功？</p><p>做实验说明,   <strong>accept只是从监听队列中取出连接，而不论连接处于 何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更 不关心任何网络状况的变化。</strong></p><h4 id="5-6-发起连接"><a href="#5-6-发起连接" class="headerlink" title="5.6 发起连接"></a>5.6 发起连接</h4><p>客户端主动建立连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数由socket系统调用返回一个socket。serv_addr参数是服 务器监听的socket地址，addrlen参数则指定这个地址的长度。</p><p>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了 这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失 败则返回-1并设置errno。</p><p>其中两种常见的errno是ECONNREFUSED和 ETIMEDOUT，它们的含义如下： </p><ul><li><p>ECONNREFUSED，目标端口不存在，连接被拒绝。我们在 3.5.1小节讨论过这种情况。 </p></li><li><p>ETIMEDOUT，连接超时。我们在3.3.3小节讨论过这种情况。</p></li></ul><h4 id="5-7-关闭连接"><a href="#5-7-关闭连接" class="headerlink" title="5.7 关闭连接"></a>5.7 关闭连接</h4><p>关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下<strong>关闭普通文件描述符的系统调用</strong>来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>fd参数是待关闭的socket。不过，close系统调用并非总是立即关闭 一个连接，而是将fd的引用计数减1。<strong>只有当fd的引用计数为0时，才真正关闭连接。</strong>多进程程序中，一次fork系统调用默认将使父进程中打开 的socket的引用计数加1，因此我们必须在父进程和子进程中都对该 socket执行close调用才能将连接关闭。</p><p>如果想强制关闭的话, 可以使用如下的shutdown系统调用（相对于close来说，它是专门 为网络编程设计的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数是待关闭的socket。howto参数决定了shutdown的行为， 它可取表5-3中的某个值。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224204515803-1678341964416.png" class="" title="image-20230224204515803"><p>由此可见，shutdown能够分别关闭socket上的读或写，或者都关 闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p><h4 id="5-8-数据读写"><a href="#5-8-数据读写" class="headerlink" title="5.8 数据读写"></a>5.8 数据读写</h4><h5 id="5-8-1-TCP数据读写"><a href="#5-8-1-TCP数据读写" class="headerlink" title="5.8.1 TCP数据读写"></a>5.8.1 TCP数据读写</h5><p><strong>对文件的读写操作read和write同样适用于socket。</strong>但是socket编程接 口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据 读写的控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>*buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>*buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。</strong></p><p>recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们 可能要多次调用recv，才能读取到完整的数据。recv可能返回0，这意 味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。</p><p>send往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置 和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置 errno。</p><p>flags参数为数据收发提供了额外的控制，它可以取表5-4所示选项 中的一个或几个的逻辑或。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224205138815-1678341964416.png" class="" title="image-20230224205138815"><p>实验结果: </p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224211104916-1678341964416.png" class="" title="image-20230224211104916"><p>客户端发送给服务器的3字节的带外数据“abc”中，仅有 最后一个字符“c”被服务器当成真正的带外数据接收（正如3.8节讨论的 那样）。并且，服务器对正常数据的接收将被带外数据截断，即前一 部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全 部读出的。</p><h5 id="5-8-2-UDP数据读写"><a href="#5-8-2-UDP数据读写" class="headerlink" title="5.8.2 UDP数据读写"></a>5.8.2 UDP数据读写</h5><p>socket编程接口中用于UDP数据报读写的系统调用是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags,struct sockaddr* src_addr,<span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags,<span class="keyword">const</span> struct sockaddr* dest_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位 置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都 需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。</li><li>sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置 和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该 地址的长度。 </li><li>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调 用的flags参数及返回值相同。</li></ul><h5 id="5-8-3-通用数据读写函数"><a href="#5-8-3-通用数据读写函数" class="headerlink" title="5.8.3 通用数据读写函数"></a>5.8.3 通用数据读写函数</h5><p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅 能用于TCP流数据，也能用于UDP数据报, 在第13.9章节进程间传递文件描述符 用到了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd,struct msghdr*msg,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd,struct msghdr*msg,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>sockfd参数指定被操作的目标socket。</p></li><li><p>msg参数是msghdr结构体类 型的指针，msghdr结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span>*msg_name;<span class="comment">/*socket地址*/</span></span><br><span class="line"><span class="keyword">socklen_t</span> msg_namelen;<span class="comment">/*socket地址的长度*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>*<span class="title">msg_iov</span>;</span><span class="comment">/*分散的内存块，见后文*/</span></span><br><span class="line"><span class="keyword">int</span> msg_iovlen;<span class="comment">/*分散内存块的数量*/</span></span><br><span class="line">    <span class="keyword">void</span>*msg_control;<span class="comment">/*指向辅助数据的起始位置*/</span></span><br><span class="line"><span class="keyword">socklen_t</span> msg_controllen;<span class="comment">/*辅助数据的大小*/</span></span><br><span class="line"><span class="keyword">int</span> msg_flags;<span class="comment">/*复制函数中的flags参数，并在调用过程中更新*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>msg_name成员指向一个socket地址结构变量。它指定通信对方的 socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置 为NULL。这是因为对数据流socket而言，对方的地址已经知道。</p></li><li><p>msg_namelen成员则指定了msg_name所指socket地址的长度。</p></li><li><p>msg_iov成员是iovec结构体类型的指针，iovec结构体封装了一块内存的起始位置和长度。 iovec结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span>* iov_base;<span class="comment">/*内存起始地址*/</span></span><br><span class="line"><span class="keyword">size_t</span> iov_len;<span class="comment">/*这块内存的长度*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>msg_iovlen指定这样的iovec结构对象有多少个。对于recvmsg而言，数 据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长 度则由msg_iov指向的数组指定，这称为分散读（scatter read）；对于 sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这称为 集中写（gather write）</p></li><li><p>msg_control和msg_controllen成员用于辅助数据的传送。我们不详 细讨论它们，仅在第13章介绍如何使用它们来实现在进程间传递文件 描述符。</p></li><li><p>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的 内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后 的标志设置到msg_flags中。</p></li></ul></li></ul><h4 id="5-9-带外标记"><a href="#5-9-带外标记" class="headerlink" title="5.9 带外标记"></a>5.9 带外标记</h4><p>在实际应用中， 我们通常无法预期带外数据何时到来。好在<strong>Linux内核检测到TCP紧急 标志</strong>时，将通知应用程序有带外数据需要接收。内核通知应用程序带 外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信 号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure><p>sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数 据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用 带MSG_OOB标志的recv调用来接收带外数据。如果不是，则 sockatmark返回0。</p><h4 id="5-10-地址信息函数"><a href="#5-10-地址信息函数" class="headerlink" title="5.10 地址信息函数"></a>5.10 地址信息函数</h4><p>在某些情况下，我们想知道一个连接socket的本端socket地址，以 及远端的socket地址。下面这两个函数正是用于解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure><p>getsockname获取sockfd对应的本端socket地址，并将其存储于 address参数指定的内存中，该socket地址的长度则存储于address_len参 数指向的变量中。</p><p>getpeername获取sockfd对应的远端socket地址，其参数及返回值的 含义与getsockname的参数及返回值相同。</p><h4 id="5-11-socket-选项"><a href="#5-11-socket-选项" class="headerlink" title="5.11 socket 选项"></a>5.11 socket 选项</h4><p>如果说<strong>fcntl系统调用（文件描述符控制）</strong>是控制文件描述符属性的通用POSIX（可移植操作系统接口）方法，那 么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> level,<span class="keyword">int</span> option_name,<span class="keyword">void</span>* option_value,<span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> level,<span class="keyword">int</span> option_name,<span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd参数指定被操作的目标socket。level参数指定要操作哪个协 议的选项（即属性），比如IPv4、IPv6、TCP等。option_name参数则指 定选项的名字。我们在表5-5中列举了socket通信中几个比较常用的 socket选项。option_value和option_len参数分别是被操作选项的值和长 度。</li><li><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304223735943.png" class="" title="image-20230304223735943"></li></ul><p>暂时用不到， 略过一部分。</p><h5 id="5-11-1-SO-REUSEADDR选项"><a href="#5-11-1-SO-REUSEADDR选项" class="headerlink" title="5.11.1 SO_REUSEADDR选项"></a>5.11.1 SO_REUSEADDR选项</h5><p>我们在3.4.2小节讨论过TCP连接的TIME_WAIT状态，并提到服务 器程序可以通过设置socket选项SO_REUSEADDR来强制使用被处于 TIME_WAIT状态的连接占用的socket地址。具体实现方法如代码清单5- 9所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reuse=<span class="number">1</span>;</span><br><span class="line">setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,＆reuse,<span class="keyword">sizeof</span>(reuse));</span><br></pre></td></tr></table></figure><p>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之 绑定的socket地址也可以立即被重用。</p><h5 id="5-11-4-SO-LINGER选项"><a href="#5-11-4-SO-LINGER选项" class="headerlink" title="5.11.4 SO_LINGER选项"></a>5.11.4 SO_LINGER选项</h5><p>SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。</p><p>默认情况下，当我们使用close系统调用来关闭一个socket时，close 将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的 数据发送给对方。</p><p>设置（获取）SO_LINGER选项的值时，我们需要给 setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定 义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l_onoff;<span class="comment">/*开启（非0）还是关闭（0）该选项*/</span></span><br><span class="line"><span class="keyword">int</span> l_linger;<span class="comment">/*滞留时间*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据linger结构体中两个成员变量的不同值，close系统调用可能产 生如下3种行为之一：</p><ul><li>l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为 来关闭socket。</li><li>l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP 模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时 给对方发送一个复位报文段（见3.5.2小节）。因此，这种情况给服务 器提供了异常终止一个连接的方法。</li><li>l_onoff不为0，l_linger大于0。此时close的行为取决于两个条 件：一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数 据；二是该socket是阻塞的，还是非阻塞的。对于阻塞的socket，close 将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并 得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到 对方的确认，那么close系统调用将返回-1并设置errno为 EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我 们需要根据其返回值和errno来判断残留数据是否已经发送完毕。</li></ul><h4 id="5-12-网络信息API"><a href="#5-12-网络信息API" class="headerlink" title="5.12 网络信息API"></a>5.12 网络信息API</h4><p>socket地址的两个要素，即IP地址和端口号，都是用数值表示的。 这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。因此在前面 的章节中，我们用主机名来访问一台机器，而避免直接使用其IP地 址。同样，我们用服务名称来代替端口号。</p><h5 id="5-12-1-gethostbyname和gethostbyaddr"><a href="#5-12-1-gethostbyname和gethostbyaddr" class="headerlink" title="5.12.1 gethostbyname和gethostbyaddr"></a>5.12.1 gethostbyname和gethostbyaddr</h5><p>gethostbyname函数<strong>根据主机名称获取主机的完整信息</strong>， gethostbyaddr函数<strong>根据IP地址获取主机的完整信息。</strong></p><ul><li>gethostbyname函数 通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访 问DNS服务器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function">struct hostent*<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*name)</span></span>;</span><br><span class="line"><span class="function">struct hostent*<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>name参数指定目标主机的主机名，</li><li>addr参数指定目标主机的IP地 址，</li><li>len参数指定addr所指IP地址的长度，</li><li>type参数指定addr所指IP地址 的类型，其合法取值包括AF_INET（用于IPv4地址）和AF_INET6（用 于IPv6地址）。</li></ul><p>这两个函数返回的都是hostent结构体类型的指针，hostent结构体的 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>*h_name;<span class="comment">/*主机名*/</span></span><br><span class="line"><span class="keyword">char</span>**h_aliases;<span class="comment">/*主机别名列表，可能有多个*/</span></span><br><span class="line"><span class="keyword">int</span> h_addrtype;<span class="comment">/*地址类型（地址族）*/</span></span><br><span class="line"><span class="keyword">int</span> h_length;<span class="comment">/*地址长度*/</span></span><br><span class="line"><span class="keyword">char</span>**h_addr_list;<span class="comment">/*按网络字节序列出的主机IP地址列表*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-12-2-getservbyname和getservbyport"><a href="#5-12-2-getservbyname和getservbyport" class="headerlink" title="5.12.2 getservbyname和getservbyport"></a>5.12.2 getservbyname和getservbyport</h5><p>getservbyname函数根据名称获取某个服务的完整信息， getservbyport函数根据端口号获取某个服务的完整信息。</p><p>它们实际上都 是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name,<span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port,<span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>name参数指定目标服务的名字，</li><li>port参数指定目标服务对应的端口 号。</li><li>proto参数指定服务类型，给它传递“tcp”表示获取流服务，给它传 递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的 服务。</li></ul><p>这两个函数返回的都是servent结构体类型的指针，结构体servent的 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>*s_name;<span class="comment">/*服务名称*/</span></span><br><span class="line"><span class="keyword">char</span>**s_aliases;<span class="comment">/*服务的别名列表，可能有多个*/</span></span><br><span class="line"><span class="keyword">int</span> s_port;<span class="comment">/*端口号*/</span></span><br><span class="line"><span class="keyword">char</span>*s_proto;<span class="comment">/*服务类型,通常是tcp或者udp*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-12-3-getaddrinfo"><a href="#5-12-3-getaddrinfo" class="headerlink" title="5.12.3 getaddrinfo"></a>5.12.3 getaddrinfo</h5><p>getaddrinfo函数既能通过主机名获得IP地址（内部使用的是 gethostbyname函数），也能通过服务名获得端口号（内部使用的是 getservbyname函数）。它是否可重入取决于其内部调用的 gethostbyname和getservbyname函数是否是它们的可重入版本。</p><p>该函数 的定义如下： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname,<span class="keyword">const</span> <span class="keyword">char</span>* service,<span class="keyword">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span>;</span><br></pre></td></tr></table></figure><p>hostname参数可以接收主机名，也可以接收字符串表示的IP地址 （IPv4采用点分十进制字符串，IPv6则采用十六进制字符串）。同样， service参数可以接收服务名，也可以接收字符串表示的十进制端口号。 hints参数是应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出 进行更精确的控制。hints参数可以被设置为NULL，表示允许 getaddrinfo反馈任何可用的结果。<strong>result参数指向一个链表，该链表用于 存储getaddrinfo反馈的结果。</strong></p><p>剩下内容 忽略.</p><h3 id="第6章-高级I-O函数"><a href="#第6章-高级I-O函数" class="headerlink" title="第6章 高级I/O函数"></a>第6章 高级I/O函数</h3><p>Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数 （比如open和read）那么常用（编写内核模块时一般要实现这些I/O函 数），但在<strong>特定的条件下却表现出优秀的性能</strong>。</p><p><strong>本章将讨论其中和网络编程相关的几个，这些函数大致分为三类：</strong></p><ul><li>用于创建文件描述符的函数，包括pipe、dup/dup2函数。</li><li>用于读写数据的函数，包括readv/writev、sendfile、 mmap/munmap、splice和tee函数。</li><li>用于控制I/O行为和属性的函数，包括fcntl函数。</li></ul><h4 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h4><p>pipe函数可用于创建一个管道，以实现进程间通信。13.4节会讲解如何使用管道实现进程间通信.</p><p>pipe函数定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>pipe函数的参数是一个包含两个int型整数的数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组。如 果失败，则返回-1并设置errno。</p><p><strong>通过pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端，往fd[1]写入的数据可以从fd[0]读出。并且，fd[0]只能用于从管道读出数据，fd[1]则只能用于往管道写入数据，而不能反过来使用。</strong>如果要实现双向的数据传输，就应该使用两个管道。</p><p>默认情况 下，这一对文件描述符都是阻塞的。此时如果我们用read系统调用来 读取一个空的管道，则read将被阻塞，直到管道内有数据可读；如果 我们用write系统调用来往一个满的管道（见后文）中写入数据，则 write亦将被阻塞，直到管道有足够多的空闲空间可用。</p><p>管道内部传输的数据是字节流, 自Linux 2.6.11 内核起，管道容量的大小默认是65536字节。我们可以使用fcntl函数来 修改管道容量（见后文）。</p><p>此外，socket的基础API中有一个socketpair函数。它能够方便地创建双向管道。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol,<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>socketpair前三个参数的含义与socket系统调用的三个参数完全相 同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能 在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一 样，只不过socketpair创建的这对文件描述符都是既可读又可写的。 socketpair成功时返回0，失败时返回-1并设置errno。</p><h4 id="6-2-dup-函数和dup2函数"><a href="#6-2-dup-函数和dup2函数" class="headerlink" title="6.2 dup 函数和dup2函数"></a>6.2 dup 函数和dup2函数</h4><p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重 定向到一个网络连接（比如CGI编程）。这可以通过下面的用于复制 文件描述符的dup或dup2函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> file_descriptor_one,<span class="keyword">int</span> file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure><p>dup函数创建一个新的文件描述符，该新文件描述符和原有文件描 述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回 的文件描述符总是取系统当前可用的最小整数值。</p><p>dup2和dup类似，不 过它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统 调用失败时返回-1并设置errno。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> connfd, sock;</span><br><span class="line">&#123;</span><br><span class="line">sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret = bind(sock, (struct sockaddr *) &amp; address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">connfd = accept(sock, (struct sockaddr *) &amp;client, &amp;client_addrlength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">dup(connfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abcd\n&quot;</span>);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们先关闭标准输出文件描述符 STDOUT_FILENO（其值是1）</li><li>然后复制socket文件描述符connfd。 因为dup总是返回系统中最小的可用文件描述符，所以它的返回值实际 上是1，即之前关闭的标准输出文件描述符的值。</li><li>这样一来，服务器输 出到标准输出的内容（这里是“abcd”）就会直接发送到与客户连接对 应的socket上，因此printf调用的输出将被客户端获得（而不是显示在 服务器程序的终端上）。<strong>这就是CGI服务器的基本工作原理。</strong></li></ul><h4 id="6-3-readv函数和writev函数"><a href="#6-3-readv函数和writev函数" class="headerlink" title="6.3 readv函数和writev函数"></a>6.3 readv函数和writev函数</h4><p><strong>readv函数将数据从文件描述符读到分散的内存块中，即分散读； writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。</strong>它们的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/uio.h＞</span></span><br><span class="line">ssize_t readv(int fd,const struct iovec* vector, int count)；</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>fd参数是被操作的目标文件描述符。vector参数的类型是iovec结构 数组。我们在第5章讨论过结构体iovec，该结构体描述一块内存区。 count参数是vector数组的长度，即有多少块内存数据需要从fd读出或 写到fd。</p><p>readv和writev在成功时返回读出/写入fd的字节数，失败则返 回-1并设置errno。</p><p>清单6.2 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-4-sendfile函数"><a href="#6-4-sendfile函数" class="headerlink" title="6.4 sendfile函数"></a>6.4 sendfile函数</h4><p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中 操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率 很高，这被称为零拷贝。</p><p>sendfile函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sendfile.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd,<span class="keyword">int</span> in_fd,<span class="keyword">off_t</span>*offset,<span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>in_fd参数是待读出内容的文件描述符，out_fd参数是待写入内容的文件描述符。</strong> offset参数指定从读入文件流的哪个位置开始读，如果 为空，则使用读入文件流默认的起始位置。count参数指定在文件描述 符in_fd和out_fd之间传输的字节数。</p><p><strong>in_fd 必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。由此可见， sendfile几乎是专门为在网络上传输文件而设计的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键部分</span></span><br><span class="line"><span class="comment">// connfd 是socket, filefd是打开的文件描述符, </span></span><br><span class="line"><span class="keyword">int</span> filefd=open(file_name,O_RDONLY);</span><br><span class="line">assert(filefd＞<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">fstat(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line">sendfile(connfd,filefd,<span class="literal">NULL</span>,stat_buf.st_size);</span><br></pre></td></tr></table></figure><p>我们将目标文件作为第3个参数传递给服务器程 序，客户telnet到该服务器上即可获得该文件。代码清单6-3没有为目标文件分配任何用户空间的缓存，也没有执行读取 文件的操作，但同样实现了文件的发送，其效率显然要高得多。</p><h4 id="6-5-mmap函数和nummap函数"><a href="#6-5-mmap函数和nummap函数" class="headerlink" title="6.5 mmap函数和nummap函数"></a>6.5 mmap函数和nummap函数</h4><p><strong>mmap函数用于申请一段内存空间。我们可以将这段内存作为进程间通信的共享内存，也可以==将文件直接映射到其中==。</strong>munmap函数则释 放由mmap创建的这段内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/mman.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>*start,<span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>start参数允许用户使用某个特定的地址作为这段内存的起始地址。 如果它被设置成NULL，则系统自动分配一个地址。</p></li><li><p>length参数指定内 存段的长度。</p></li><li><p>prot参数用来设置内存段的访问权限。它可以取以下几个 值的按位或：</p><ul><li>PROT_READ，内存段可读。 </li><li>PROT_WRITE，内存段可写。 </li><li>PROT_EXEC，内存段可执行。 </li><li>PROT_NONE，内存段不能被访问。</li></ul></li><li><p>flags参数控制内存段内容被修改后程序的行为。它可以被设置为 表6-1中的某些值（这里仅列出了常用的值）的按位或（其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226134942673-1678341964416.png" class="" title="image-20230226134942673"></li><li><p>fd参数是被映射文件对应的文件描述符。它一般通过open系统调用获得。</p></li><li><p>offset参数设置从文件的何处开始映射（对于不需要读入整个文 件的情况）。</p></li></ul><p><strong>mmap函数成功时返回指向目标内存区域的指针</strong>，失败则返回 MAP_FAILED（(void*)-1）并设置errno。munmap函数成功时返回0， 失败则返回-1并设置errno。</p><h4 id="6-6-splice函数"><a href="#6-6-splice函数" class="headerlink" title="6.6 splice函数"></a>6.6 splice函数</h4><p>splice函数用于在两个文件描述符之间移动数据，也是零拷贝操 作。splice函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in,<span class="keyword">loff_t</span>* off_in,<span class="keyword">int</span> fd_out,<span class="keyword">loff_t</span>* off_out,<span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>fd_in参数是<strong>待输入数据</strong>的文件描述符。</p><p>如果fd_in是一个管道文件 描述符，那么off_in参数必须被设置为NULL。如果fd_in不是一个管道 文件描述符（比如socket），那么off_in表示从输入数据流的何处开始 读取数据。此时，若off_in被设置为NULL，则表示从输入数据流的当 前偏移位置读入；若off_in不为NULL，则它将指出具体的偏移位置。 </p><p>fd_out/off_out参数的含义与fd_in/off_in相同，不过用于输出数据流。len 参数指定移动数据的长度；flags参数则控制数据如何移动，它可以被 设置为表6-2中的某些值的按位或。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226135725302-1678341964416.png" class="" title="image-20230226135725302"><p><strong>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。</strong></p><h4 id="6-7-tee函数"><a href="#6-7-tee函数" class="headerlink" title="6.7 tee函数"></a>6.7 tee函数</h4><p><strong>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。</strong> 它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操 作。tee函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="keyword">int</span> fd_in,<span class="keyword">int</span> fd_out,<span class="keyword">size_t</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的参数的含义与splice相同（但fd_in和fd_out必须都是管道 文件描述符）。tee函数成功时返回在两个文件描述符之间复制的数据 数量（字节数）。返回0表示没有复制任何数据。tee失败时返回-1并设 置errno。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-8-fcntl函数"><a href="#6-8-fcntl函数" class="headerlink" title="6.8 fcntl函数"></a>6.8 fcntl函数</h4><p>fcntl函数，正如其名字（file control）描述的那样，提供了对文件 描述符的各种控制操作。另外一个常见的控制文件描述符属性和行为 的系统调用是ioctl，而且ioctl比fcntl能够执行更多的控制。但是，对于控制文件描述符常用的属性和行为，<strong>fcntl函数是由POSIX规范指定的首 选方法。所以本书仅讨论fcntl函数</strong>。fcntl函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,…)</span></span>;</span><br></pre></td></tr></table></figure><p>fd参数是被操作的文件描述符，cmd参数指定执行何种类型的操 作。根据操作类型的不同，该函数可能还需要第三个可选参数arg。 </p><p>fcntl函数支持的常用操作及其参数如表6-4所示。</p><p>![image-20230226141140857](二 高性能服务器框架/image-20230226141140857.png)</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226141206370-1678341964416.png" class="" title="image-20230226141206370"><p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的，如代码清单6-6所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option=fcntl(fd,F_GETFL);<span class="comment">/*获取文件描述符旧的状态标志*/</span></span><br><span class="line"><span class="keyword">int</span> new_option=old_option|O_NONBLOCK;<span class="comment">/*设置非阻塞标志*/</span></span><br><span class="line">fcntl(fd,F_SETFL,new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;<span class="comment">/*返回文件描述符旧的状态标志，以便*/</span></span><br><span class="line"><span class="comment">/*日后恢复该状态标志*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h3><p>除了网络通信外，服务器程序通常还必须考虑许多其他细节问 题。这些细节问题涉及面广且零碎，而且基本上是模板式的，所以我 们称之为服务器程序规范。比如：</p><ul><li>Linux服务器程序一般以后台进程形式运行。后台进程又称<strong>守护进程（daemon）</strong>。它没有控制终端，因而也不会意外接收到用户输 入。守护进程的父进程通常是init进程（PID为1的进程）。</li><li>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台 进程都在/var/log目录下拥有自己的日志目录。</li><li>Linux服务器程序一般以某个专门的非root身份运行。比如 mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、 apache和syslog。</li><li>Linux服务器程序通常是可配置的。服务器程序通常能处理很多 命令行选项，<strong>如果一次运行的选项太多，则可以用配置文件来管理。</strong> 绝大多数服务器程序都有配置文件，并存放在/etc目录下。比如第4章 讨论的squid服务器的配置文件是/etc/squid3/squid.conf。</li><li>Linux服务器进程通常会在启动的时候生成一个PID文件并存 入/var/run目录中，以记录该后台进程的PID。比如syslogd的PID文件 是/var/run/syslogd.pid。</li><li>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能 承受多大负荷，比如进程可用文件描述符总数和内存总量等。</li></ul><h4 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h4><h5 id="7-1-1-Linux系统日志"><a href="#7-1-1-Linux系统日志" class="headerlink" title="7.1.1 Linux系统日志"></a>7.1.1 Linux系统日志</h5><p>服务器的调试和维护都需要一个专业 的日志系统。Linux提供一个守护进程来处理系统日志——syslogd，不 过现在的Linux系统上使用的都是它的升级版——rsyslogd。</p><p>rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日 志。<strong>用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件/dev/log中， rsyslogd则监听该文件以获取用户进程的输出。</strong></p><p><strong>内核日志在老的系统上</strong>是通过另外一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等函数打印至内核的环状缓存 （ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。 rsyslogd则通过读取该文件获得内核日志。</p><p>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。<strong>默认情况下，调试信息会保存 至/var/log/debug文件，普通信息保存至/var/log/messages文件，内核消息则保存至/var/log/kern.log文件。</strong></p><p>rsyslogd的主配置文件 是/etc/rsyslog.conf，其中主要可以设置的项包括：</p><ul><li>内核日志输入路径</li><li>是否接收UDP日志及其监听端口（默认是514，见/etc/services文件）</li><li>是否接收TCP日志及其监听端口</li><li>日志文件的权限</li><li>包含哪些子配置文 件（比如/etc/rsyslog.d/*.conf）</li></ul><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092105214-1678341964416.png" class="" title="image-20230228092105214"><h5 id="7-1-2-syslog-函数"><a href="#7-1-2-syslog-函数" class="headerlink" title="7.1.2 syslog 函数"></a>7.1.2 syslog 函数</h5><p><strong>应用程序使用syslog函数与rsyslogd守护进程通信。</strong> syslog函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span>*message,...)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数采用可变参数（第二个参数message和第三个参数…）来结 构化输出。</p><ul><li><p>priority参数是所谓的<strong>设施值与日志级别的按位或</strong>。设施值的默认值是LOG_USER，我们下面的讨论也只限于这一种设施值。日 志级别有如下几个：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092428475-1678341964416.png" class="" title="image-20230228092428475"></li></ul><p>下面这个函数可以改变syslog的默认输出方式，进一步结构化日志 内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ident,<span class="keyword">int</span> logopt,<span class="keyword">int</span> facility)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>ident参数指定的字符串将被添加到日志消息的日期和时间之后， 它通常被设置为程序的名字</p></li><li><p>logopt参数对后续syslog调用的行为进行配置，它可取<strong>下列值的按位或</strong>：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092709404-1678341964416.png" class="" title="image-20230228092709404"></li><li><p>facility参数可用来修改syslog函数中的默认设施值。</p></li></ul><p>此外，日志的过滤也很重要。程序在开发阶段可能需要输出很多 调试信息，而发布之后我们又需要将这些调试信息关闭。简单地设置日志掩码，使<strong>日志级别大于日志掩码的日志信息被系统忽略。</strong>下面这个函数用于设置syslog的日志掩码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>maskpri参数指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值。</li></ul><p>最后，不要忘了使用如下函数关闭日志功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h4><h5 id="7-2-1-UID、EUID和EGID"><a href="#7-2-1-UID、EUID和EGID" class="headerlink" title="7.2.1 UID、EUID和EGID"></a>7.2.1 UID、EUID和EGID</h5><p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分 服务器就必须以root身份启动，但不能以root身份运行。</p><p>下面这一组函 数可以获取和设置当前进程的<strong>真实用户ID（UID）</strong>、<strong>有效用户 ID（EUID）</strong>、真实组ID（GID）和<strong>有效组ID（EGID）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;<span class="comment">/*获取真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;<span class="comment">/*获取有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;<span class="comment">/*获取真实组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;<span class="comment">/*获取有效组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置真实组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置有效组ID*/</span></span><br></pre></td></tr></table></figure><p>需要指出的是，一个进程拥有两个用户ID：UID和EUID。<strong>EUID 存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。</strong> </p><blockquote><p>比如su程序，任何用户都可以使用它来修改自己的账 户信息，但修改账户时su程序不得不访问/etc/passwd文件，而访问该 文件是需要root权限的。那么以普通用户身份启动的su程序如何能访 问/etc/passwd文件呢？窍门就在EUID。用ls命令可以查看到，su程序的所有者是root，<strong>并且它被设置了set-user-id标志。</strong></p><p>这个标志表示，任 何普通用户运行su程序时，其有效用户就是该程序的所有者root。那 么，根据有效用户的含义，任何运行su程序的普通用户都能够访 问/etc/passwd文件。有效用户为root的进程称为特权进程（privileged processes）。</p></blockquote><p>EGID的含义与EUID类似：<strong>给运行目标程序的组用户提 供有效组的权限</strong>。</p><p>代码: 编译该文件，将生成的可执行文件（名为test_uid）的所有者设置 为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID 和EUID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo chown root:root test_uid<span class="comment">#修改目标文件的所有者为root</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo chmod+s test_uid<span class="comment">#设置目标文件的set-user-id标志</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./test_uid<span class="comment">#运行程序</span></span></span><br><span class="line">userid is 1000,effective userid is:0</span><br></pre></td></tr></table></figure><p>从测试程序的输出来看，进程的UID是启动程序的用户的ID，而 EUID则是root账户（文件所有者）的ID。</p><h5 id="7-2-2-切换用户"><a href="#7-2-2-切换用户" class="headerlink" title="7.2.2 切换用户"></a>7.2.2 切换用户</h5><p>下面的代码清单7-2展示了如何将以root身份启动的进程切换为以 一个普通用户身份运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">switch_to_user</span><span class="params">(<span class="keyword">uid_t</span> user_id, <span class="keyword">gid_t</span> gp_id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*先确保目标用户不是root*/</span></span><br><span class="line"><span class="keyword">if</span> ((user_id == <span class="number">0</span>) &amp;&amp; (gp_id == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*确保当前用户是合法用户：root或者目标用户*/</span></span><br><span class="line"><span class="keyword">gid_t</span> gid = getgid();</span><br><span class="line"><span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line"><span class="keyword">if</span> (((gid != <span class="number">0</span>) || (uid != <span class="number">0</span>)) &amp;&amp; ((gid != gp_id) || (uid != user_id))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果不是root，则已经是目标用户*/</span></span><br><span class="line"><span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切换到目标用户*/</span></span><br><span class="line"><span class="keyword">if</span> ((setgid(gp_id) &lt; <span class="number">0</span>) || (setuid(user_id) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h4><h5 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h5><p>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息 外，还有进程组ID（PGID）。我们可以用如下函数来获取指定进程的 PGID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>该函数成功时返回进程pid所属进程组的PGID，失败则返回-1并设 置errno。</li></ul><p><strong>每个进程组都有一个首领进程，其PGID和PID相同</strong>。进程组将一 直存在，直到其中所有进程都退出，或者加入到其他进程组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数将PID为pid的进程的PGID设置为pgid。</p><ul><li>如果pid和pgid相 同，则由pid指定的进程将被设置为进程组首领；</li><li>如果pid为0，则表示 设置当前进程的PGID为pgid；</li><li>如果pgid为0，则使用pid作为目标 PGID。</li></ul><p>一个进程只能设置自己或者其子进程的PGID。并且，当子进程调 用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p><h5 id="7-3-2-会话（session）"><a href="#7-3-2-会话（session）" class="headerlink" title="7.3.2 会话（session）"></a>7.3.2 会话（session）</h5><p>一些有关联的进程组将形成一个会话（session）。下面的函数用于创建一个会话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>该函数不能由进程组的首领进程调用，否则将产生一个错误。</strong></p><p>对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：</p><ul><li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li><li>新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领。</li><li>调用进程将甩开终端（如果有的话）。</li></ul><p>Linux进程并未提供所谓会话ID（SID）的概念，但Linux系统认为 它等于会话首领所在的进程组的PGID，并提供了如下函数来读取 SID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="7-3-3-用ps命令查看进程关系"><a href="#7-3-3-用ps命令查看进程关系" class="headerlink" title="7.3.3 用ps命令查看进程关系"></a>7.3.3 用ps命令查看进程关系</h5><p>执行ps命令可查看进程、进程组和会话之间的关系：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228100733965-1678341964416.png" class="" title="image-20230228100733965"><ul><li>我们是在bash shell下执行ps和less命令的，所以ps和less命令的父进程是bash命令，这可以从PPID（父进程PID）一列看出。</li><li>这3条命令创 建了1个会话（SID是1943）和2个进程组（PGID分别是1943和 2298）。</li><li>bash命令的PID、PGID和SID都相同，很明显它既是会话的首 领，也是组1943的首领。</li><li>ps命令则是组2298的首领，因为其PID也是 2298。</li></ul><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228100847532-1678341964416.png" class="" title="image-20230228100847532"><h4 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h4><p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制 （CPU数量、内存数量等）、系统策略限制（CPU时间等），以及具 体实现的限制（比如文件名的最大长度）。</p><p>Linux系统资源限制可以通 过如下一对函数来读取和设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/resource.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource,struct rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource,<span class="keyword">const</span> struct rlimit* rlim)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>resource参数指定资源限制类型。</p><p>![image-20230228101329120](二 高性能服务器框架/image-20230228101329120.png)</p></li><li><p>setrlimit和getrlimit成功时返回0，失败则返回-1并设置errno。</p></li></ul><p>rlim参数是rlimit结构体类型的指针，rlimit结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line"><span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>rlim_t是一个整数类型，它描述资源级别。</p></li><li><p>rlim_cur成员指定资源 的软限制，rlim_max成员指定资源的硬限制。</p><blockquote><p>软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。例如，当进程CPU时间超过其软限制时，系统将向进 程发送SIGXCPU信号；当文件尺寸超过其软限制时，系统将向进程发 送SIGXFSZ信号（见第10章）。</p><p>硬限制一般是软限制的上限。普通程 序可以减小硬限制，而只有以root身份运行的程序才能增加硬限制。</p></blockquote></li><li><p>我们可以使用ulimit命令修改当前shell环境下的资源限制（软限制 或/和硬限制），这种修改将对该shell启动的所有后续程序有效。</p></li></ul><h4 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h4><p>有些服务器程序还需要改变工作目录和根目录，<strong>获取进程当前工作目录和改变进程工作目录的函数分别是：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>buf参数指向的内存用于存储进程当前工作目录的绝对路径名，其 大小由size参数指定。</li><li>如果当前工作目录的绝对路径的长度（再加上 一个空结束字符“\0”）超过了size，则getcwd将返回NULL，并设置 errno为ERANGE。</li><li>如果buf为NULL并且size非0，则getcwd可能在内部 使用malloc动态分配内存，并将进程的当前工作目录存储在其中。如 果是这种情况，则我们必须自己来释放getcwd在内部创建的这块内 存。</li><li>getcwd函数成功时返回一个指向目标存储区（buf指向的缓存区或 是getcwd在内部动态创建的缓存区）的指针，失败则返回NULL并设 置errno。</li></ul><p><strong>改变进程根目录</strong>的函数是chroot，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>只有特权进程才能改变根目录。</li><li>path参数指定要切换到的目标根目录。它成功时返回0，失败时返 回-1并设置errno。</li><li><strong>chroot并不改变进程的当前工作目录，所以调用 chroot之后，我们仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。</strong></li><li>在调用chroot之后，进程原先打开的文件描述符依然生效，所以我们 可以利用这些早先打开的文件描述符来访问调用chroot之后不能直接 访问的文件（和目录），尤其是一些日志文件。</li></ul><h4 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h4><p>最后，我们讨论如何在代码中让一个进程以守护进程的方式运 行。守护进程的编写遵循一定的步骤[2]，下面我们通过一个具体实现 来探讨，如代码清单7-3所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">daemonize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*创建子进程，关闭父进程，这样可以使程序在后台运行*/</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，</span></span><br><span class="line"><span class="comment"> * 文件的权限将是mode &amp;0777*/</span></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建新的会话，设置本进程为进程组的首领*/</span></span><br><span class="line"><span class="keyword">pid_t</span> sid = setsid();</span><br><span class="line"><span class="keyword">if</span> (sid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切换工作目录*/</span></span><br><span class="line"><span class="keyword">if</span> ((chdir(<span class="string">&quot;/&quot;</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br><span class="line"><span class="comment">/*关闭其他已经打开的文件描述符，代码省略*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/</span></span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Linux提供了完成同样功能的库函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir,<span class="keyword">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>其中，nochdir参数用于指定是否改变工作目录，如果给它传递 0，则工作目录将被设置为“/”（根目录），否则继续使用当前工作目 录。</li><li>noclose参数为0时，标准输入、标准输出和标准错误输出都被重 定向到/dev/null文件，否则依然使用原来的设备。</li><li>该函数成功时返回 0，失败则返回-1并设置errno。</li></ul><h3 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h3><p>在这一章中，我们 按照服务器程序的一般原理，将服务器解构为如下三个主要模块：</p><ul><li>I/O处理单元。本章将介绍I/O处理单元的四种I/O模型和两种高效事件处理模式。</li><li>逻辑单元。本章将介绍逻辑单元的两种高效并发模式，以及高效的逻辑处理方式——有限状态机。</li><li>存储单元。本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关。</li></ul><h4 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h4><h5 id="8-1-1-C-S-模型"><a href="#8-1-1-C-S-模型" class="headerlink" title="8.1.1 C/S 模型"></a>8.1.1 C/S 模型</h5><p>所有客户端都通过访问 服务器来获取所需的资源。</p><p><img src="高性能服务器框架/image-20230321094137455.png" alt="image-20230321094137455" style="zoom: 67%;" /><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230321094201254.png" class="" title="image-20230321094201254"></p><p>C/S模型的逻辑很简单。服务器启动后，首先创建一个（或多个） 监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后 调用listen函数等待客户连接。</p><p>服务器稳定运行之后，<strong>客户端就可以调 用connect函数向服务器发起连接了</strong>。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。</p><img src="高性能服务器框架/image-20230321094231509.png" alt="image-20230321094231509" style="zoom:67%;" /><p>I/O模型有多种，图8-2中，<strong>服务器使用的是I/O复用技术之一的select系统调用。</strong>当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。<strong>逻辑单元可以是新创建的子进程、子线程或者 其他。</strong> 图8-2中，服务器给客户端分配的逻辑单元是由fork系统调用创 建的子进程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端接收到服务器反馈的结果之后，可以继续向服 务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连 接，则服务器执行被动关闭连接。至此，双方的通信结束。</p><h5 id="8-1-2-P2P模型"><a href="#8-1-2-P2P模型" class="headerlink" title="8.1.2 P2P模型"></a>8.1.2 P2P模型</h5><p>P2P（Peer to Peer，点对点）模型比C/S模型更符合网络通信的实 际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回 归对等的地位。P2P模型如图8-3a所示。</p><p>但P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络 的负载将加重。</p><p>图8-3a所示的P2P模型存在一个显著的问题，即主机之间很难互相 发现。所以实际使用的P2P模型通常带有一个专门的发现服务器，如图 8-3b所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228201859415-1678341964416.png" class="" title="image-20230228201859415"><h4 id="8-2-服务器编程框架"><a href="#8-2-服务器编程框架" class="headerlink" title="8.2 服务器编程框架"></a>8.2 服务器编程框架</h4><p>为了让读者能从设计的角度把握服务器编程，本章先讨论 基本框架，如图8-4所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228201956583-1678341964416.png" class="" title="image-20230228201956583"><p>该图既能用来描述一台服务器，也能用来描述一个服务器机群。 各个部件的含义和功能如下表所示:</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228202116872-1678341964417.png" class="" title="image-20230228202116872"><ul><li>I/O处理单元是服务器管理客户连接的模块。它通常要完成以下工 作：<strong>等待并接受新的客户连接，接收客户数据，将服务器响应数据返 回给客户端。</strong>但是，数据的收发不一定在I/O处理单元中执行，也可能 在逻辑单元中执行，具体在何处执行取决于事件处理模式（见后 文）。</li><li>一个逻辑单元通常是一个进程或线程。它分析并处理客户数据， 然后将结果传递给I/O处理单元或者直接发送给客户端（具体使用哪种 方式取决于事件处理模式）。</li><li>网络存储单元可以是数据库、缓存和文件，甚至是一台独立的服 务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单 元。</li><li>请求队列是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样， 多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调 处理竞态条件。<strong>请求队列通常被实现为池的一部分，我们将在后面讨 论池的概念</strong>。</li></ul><h4 id="8-3-I-O模型"><a href="#8-3-I-O模型" class="headerlink" title="8.3 I/O模型"></a>8.3 I/O模型</h4><p>第5章讲到，socket在创建的时候默认是阻塞的。我们可以给socket 系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的。</p><p>阻塞和非阻塞的概念能应用于所有文件描述符，而不仅仅是socket。<strong>我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。</strong></p><blockquote><p><strong>针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。</strong>比如，客户端通过connect向服务器 发起连接时，connect将首先发送同步报文段给服务器，然后等待服务 器返回确认报文段。如果服务器的确认报文段没有立即到达客户端， 则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调 用。socket的基础API中，可能被阻塞的系统调用包括accept、send、 recv和connect。</p><p><strong>针对非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。</strong>此时我们必须根据errno来区分这两种情况。对accept、send 和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一 次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言， errno则被设置成EINPROGRESS（意为“在处理中”）。</p></blockquote><p>很显然，<strong>我们只有在事件已经发生的情况下操作非阻塞I/O（读、 写等），才能提高程序的效率。</strong>因此，<strong>非阻塞I/O通常要和其他I/O通知机制一起使用</strong>，比如I/O复用和SIGIO信号。</p><p><strong>I/O复用是最常使用的I/O通知机制。它指的是，应用程序通过I/O 复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。</strong> Linux上常用的I/O复用函数是select、poll和 epoll_wait，我们将在第9章详细讨论它们。  需要指出的是，<strong>I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。</strong></p><p><strong>SIGIO信号也可以用来报告I/O事件。6.8节的最后一段提到，我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。</strong> 这样，当目标文件描述符上有事件发生时，SIGIO 信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了。关于信号的使用，我们将在第 10章讨论。</p><p>从理论上说，<strong>阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型。</strong> 因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后， 由应用程序来完成的。</p><p>而POSIX规范所定义的异步I/O模型则不同。<strong>对异步I/O而言，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已经由内核接管。</strong></p><blockquote><p>也就是说，<strong>同步I/O模型要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据 从用户缓冲区写入内核缓冲区），而异步I/O机制则由内核来执行I/O操 作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完 成的）。</strong>你可以这样认为，<strong>同步I/O向应用程序通知的是I/O就绪事件， 而异步I/O向应用程序通知的是I/O完成事件。</strong></p></blockquote><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228203724545-1678341964417.png" class="" title="image-20230228203724545"><h4 id="8-4-两种高效的事件处理模式"><a href="#8-4-两种高效的事件处理模式" class="headerlink" title="8.4 两种高效的事件处理模式"></a>8.4 两种高效的事件处理模式</h4><p>这一节先从整体上介绍一下两种高效的事件处理模式：Reactor和Proactor。同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现 Proactor模式。</p><h5 id="8-4-1-Reactor模式"><a href="#8-4-1-Reactor模式" class="headerlink" title="8.4.1 Reactor模式"></a>8.4.1 Reactor模式</h5><p>Reactor是这样一种模式，它要求<strong>主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程</strong>（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。<strong>读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</strong></p><p>工作流程如下:</p><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将 socket可读事件放入请求队列。 </li><li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，<strong>然后往epoll内核事件表中注册该socket上的写就绪事件。</strong></li><li>主线程调用epoll_wait等待socket可写。 </li><li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 </li><li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入 服务器处理客户请求的结果。</li></ol><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228204723763-1678341964417.png" class="" title="image-20230228204723763"><h5 id="8-4-2-Proactor模式"><a href="#8-4-2-Proactor模式" class="headerlink" title="8.4.2 Proactor模式"></a>8.4.2 Proactor模式</h5><p>与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p><p>使用异步I/O模型（以aio_read和aio_write为例）实现的Proactor模 式的工作流程是：</p><ol><li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序 （这里以信号为例，详情请参考sigevent的man手册）。</li><li>主线程继续处理其他逻辑。</li><li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操 作完成时如何通知应用程序（仍然以信号为例）。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善 后处理，比如决定是否关闭socket。</li></ol><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228205315653-1678341964417.png" class="" title="image-20230228205315653"><p>在图8-6中，连接socket上的读写事件是通过aio_read/aio_write向内 核注册的，<strong>因此内核将通过信号来向应用程序报告连接socket上的读写 事件。</strong> 所以，主线程中的epoll_wait调用仅能用来检测监听socket上的连 接请求事件，而不能用来检测连接socket上的读写事件。</p><h5 id="8-4-3-模拟Proactor模式"><a href="#8-4-3-模拟Proactor模式" class="headerlink" title="8.4.3 模拟Proactor模式"></a>8.4.3 模拟Proactor模式</h5><p>使用同步I/O方式模拟出Proactor模式的一种方 法。其原理是：<strong>主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</strong></p><p>使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式 的工作流程如下：</p><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程从 socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封 装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并 处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</li><li>主线程调用epoll_wait等待socket可写。</li><li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入 服务器处理客户请求的结果。</li></ol><img src="高性能服务器框架/image-20230228210636117.png" alt="image-20230228210636117" style="zoom:67%;" /><h4 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h4><p>并发编程的目的是让程序“同时”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。 但如果程序是I/O密集型的，比如经常读写文件，访问数据库等，则情况就不同了。由于I/O操作的速度远没有CPU的计算速度快，所以让程 序阻塞于I/O操作将浪费大量的CPU时间。如果程序有多个执行线程， 则当前被I/O操作所阻塞的执行线程可主动放弃CPU（或由操作系统来 调度），并将执行权转移到其他线程。</p><p>从实现上来说，并发编程主要有多进程和多线程两种方式，我们 将在后续章节详细讨论它们，这一节先讨论并发模式。 <strong>并发模式是指I/O处理单元和多个逻辑单元之间协调完成任务的方法。 服务器主要有两种并发编程模式：半同步/半异步（half-sync/half-async）模式和领导者/追随者（Leader/Followers）模式。</strong></p><h5 id="8-5-1-半同步-半异步模式"><a href="#8-5-1-半同步-半异步模式" class="headerlink" title="8.5.1 半同步/半异步模式"></a>8.5.1 半同步/半异步模式</h5><p>首先，半同步/半异步模式中的“同步”和“异步”与前面讨论的I/O模 型中的“同步”和“异步”是完全不同的概念。</p><blockquote><p>在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。</p></blockquote><p>在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“<strong>异步”指 的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、 信号等。</strong>比如，图8-8a描述了同步的读操作，而图8-8b则描述了异步的 读操作。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228211515292-1678341964417.png" class="" title="image-20230228211515292"><p>对于像服务器 这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程 序，我们就应该同时使用同步线程和异步线程来实现，即采用半同步/ 半异步模式来实现。</p><p><strong>半同步/半异步模式中，同步线程用于处理客户逻辑，相当于图8-4 中的逻辑单元；异步线程用于处理I/O事件，相当于图8-4中的I/O处理单元。</strong> 异步线程监听到客户请求后，就将其封装成请求对象并插入请 求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并 处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则 取决于请求队列的设计。</p><p>在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模 型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆（half-sync/half-reactive）模式，如图8-10所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228212216219-1678341964417.png" class="" title="image-20230228212216219"><p>异步线程只有一个，由主线程来充当。它负责监听所有 socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生， 即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接 socket插入请求队列中。</p><p>所有工作线程都睡眠在请求队列上，当有任务 到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这 种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。</p><blockquote><p>主线程插入请求队列中的任务是就绪的连接socket。这 说明该图所示的半同步/半反应堆模式采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中“half-reactive”的含义。</p></blockquote><p>存在的缺点:</p><ul><li>主线程和工作线程共享请求队列。主线程往请求队列中添加任 务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保 护，从而白白耗费CPU时间。</li><li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题， 则工作线程的切换也将耗费大量CPU时间。</li></ul><p>下图描述了一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228212643003-1678341964417.png" class="" title="image-20230228212643003"><p>图8-11中，主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。</p><p>主线程向工作线程派发socket的最 简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测 到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。 如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表 中。</p><p>可见，图8-11中，每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同 步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义 上的半同步/半异步模式。</p><h5 id="8-5-2-领导者-追随者模式"><a href="#8-5-2-领导者-追随者模式" class="headerlink" title="8.5.2 领导者/追随者模式"></a>8.5.2 领导者/追随者模式</h5><h4 id="8-6-有限状态机"><a href="#8-6-有限状态机" class="headerlink" title="8.6 有限状态机"></a>8.6 有限状态机</h4><p>前面两节探讨的是服务器的I/O处理单元、请求队列和逻辑单元之 间协调完成任务的各种模式，这一节我们介绍逻辑单元内部的一种高 效编程方法：有限状态机（finite state machine）。</p><p>有的应用层协议头部包含数据包类型字段，每种类型可以映射为 逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻 辑，如代码清单8-1所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE(Package_pack)</span><br><span class="line">&#123;</span><br><span class="line">PackageType _type=_pack.GetType();</span><br><span class="line"><span class="keyword">switch</span>(_type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">process_package_A(_pack);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">process_package_B(_pack);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。</p><p>状态之间的转移是需要状态 机内部驱动的，如代码清单8-2所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE()</span><br><span class="line">&#123;</span><br><span class="line">State cur_State=type_A;</span><br><span class="line"><span class="keyword">while</span>(cur_State!=type_C)</span><br><span class="line">&#123;</span><br><span class="line">Package _pack=getNewPackage();</span><br><span class="line"><span class="keyword">switch</span>(cur_State)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">process_package_state_A(_pack);</span><br><span class="line">cur_State=type_B;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">process_package_state_B(_pack);</span><br><span class="line">cur_State=type_C;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>该状态机包含三种状态：type_A、type_B和type_C，其中type_A是 状态机的开始状态，type_C是状态机的结束状态。状态机的当前状态 记录在cur_State变量中。在一趟循环过程中，状态机先通过 getNewPackage方法获得一个新的数据包，然后根据cur_State变量的值 判断如何处理该数据包。数据包处理完之后，状态机通过给cur_State变 量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环 时，它将执行新的状态对应的逻辑。</p></blockquote><h5 id="8-6-1-有限状态机实例"><a href="#8-6-1-有限状态机实例" class="headerlink" title="8.6.1 有限状态机实例"></a>8.6.1 有限状态机实例</h5><p>HTTP请求的读取和分 析。很多网络协议，包括TCP协议和IP协议，都在其头部中提供头部长度字段。程序根据该字段的值就可以知道是否接收到一个完整的协议头部。</p><p>但HTTP协议并未提供这样的头部长度字段，并且其头部长度变 化也很大，可以只有十几字节，也可以有上百字节。根据协议规定， <strong>我们判断HTTP头部结束的依据是遇到一个空行，该空行仅包含一对回 车换行符（＜CR＞＜LF＞）。</strong>如果一次读操作没有读入HTTP请求的 整个头部，即没有遇到空行，那么我们必须等待客户继续写数据并再 次读入。因此，我们每完成一次读操作，就要分析新读入的数据中是 否有空行。不过在寻找空行的过程中，我们可以同时完成对整个HTTP 请求头部的分析（记住，空行前面还有请求行和头部域），以提高解 析HTTP请求的效率。</p><p>代码清单8-3使用主、从两个有限状态机实现了最 简单的HTTP请求的读取和分析。为了使表述简洁，我们约定，直接称 HTTP请求的一行（包括请求行和头部字段）为行。</p><p><strong>我们将代码清单8-3中的两个有限状态机分别称为主状态机和从状 态机，这体现了它们之间的关系：主状态机在内部调用从状态机。下 面先分析从状态机，即parse_line函数，它从buffer中解析出一个行。图 8-15描述了其可能的状态及状态转移过程。</strong></p><img src="高性能服务器框架/image-20230309185019935.png" alt="image-20230309185019935" style="zoom: 33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-7-提高服务器的其他建议"><a href="#8-7-提高服务器的其他建议" class="headerlink" title="8.7 提高服务器的其他建议"></a>8.7 提高服务器的其他建议</h4><p>前面我们介绍了几种高效的事件处理模式和并发模式，以及高效 的逻辑处理方式——有限状态机，它们都有助于提高服务器的整体性 能。</p><h5 id="8-7-1-池"><a href="#8-7-1-池" class="headerlink" title="8.7.1 池"></a>8.7.1 池</h5><p>既然服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其 运行效率。这就是池（pool）的概念。</p><p>池是一组资源的集合，这组资 源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。 <strong>当服务器进入正式运行阶段，即开始处理客户请求的时候，如果 它需要相关的资源，就可以直接从池中获取，无须动态分配。 ** **当服务器处理完一个客户连 接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。</strong></p><p>根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。它们的含义都很明确。</p><ul><li>内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字 节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的 大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。</li><li>进程池和线程池都是并发编程常用的“伎俩”。当我们需要一个工 作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程 池或线程池中取得一个执行实体，而无须动态地调用fork或 pthread_create等函数来创建进程和线程。</li><li>连接池通常用于服务器或服务器机群的内部永久连接。图8-4中， 每个逻辑单元可能都需要频繁地访问本地的某个数据库。连接池是服务器预先和数据库程序建立的一组 连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接 池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑 单元再将该连接返还给连接池。</li></ul><h5 id="8-7-2-数据复制"><a href="#8-7-2-数据复制" class="headerlink" title="8.7.2 数据复制"></a>8.7.2 数据复制</h5><p>高性能服务器应该<strong>避免不必要的数据复制</strong>，尤其是当数据复制发 生在用户代码和内核之间的时候。如果内核可以直接处理从socket或 者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复 制到应用程序缓冲区中。这里说的“直接处理”指的是应用程序不关心 这些数据的内容，不需要对它们做任何分析。</p><blockquote><p>比如ftp服务器，当客户 请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是 否有读取它的权限，而绝对不会关心文件的具体内容。这样的话，ftp 服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调 用send函数来发送，而是可以使用“零拷贝”函数sendfile来直接将其发 送给客户端。</p></blockquote><p>此外，用户代码内部（不访问内核）的数据复制也是应该避免 的。当两个工作进程之间要传递大量的数据时，我们就应 该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管 道或者消息队列来传递。</p><h5 id="8-7-3-上下文切换和锁"><a href="#8-7-3-上下文切换和锁" class="headerlink" title="8.7.3 上下文切换和锁"></a>8.7.3 上下文切换和锁</h5><p>并发程序必须考虑上下文切换（context switch）的问题，即进程 切换或线程切换导致的的系统开销。</p><p>即使是I/O密集型的服务器，也不 应该使用过多的工作线程（或工作进程，下同），否则线程间的切换 将占用大量的CPU时间，服务器真正用于处理业务逻辑的CPU时间的 比重就显得不足了。</p><p>因此，为每个客户连接都创建一个工作线程的服 务器模型是不可取的。图8-11所描述的半同步/半异步模式是一种比较 合理的解决方案，它允许一个线程同时处理多个客户连接</p><p>并发程序需要考虑的另外一个问题是<strong>共享资源的加锁保护</strong>。锁通 常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不 仅不处理任何业务逻辑，而且需要访问内核资源。</p><p>如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写锁。</p><h3 id="第9章-I-O复用"><a href="#第9章-I-O复用" class="headerlink" title="第9章 I/O复用"></a>第9章 I/O复用</h3><p><strong>I/O复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。</strong>通常，网络程序在下列情况下需要使用I/O复用技术：</p><ul><li>客户端程序要同时处理多个socket。比如本章将要讨论的非阻塞 connect技术。</li><li>客户端程序要同时处理用户输入和网络连接。比如本章将要讨论的聊天室程序。</li><li>TCP服务器要同时处理监听socket和连接socket。这是I/O复用使 用最多的场合。</li><li>服务器要同时处理TCP请求和UDP请求。比如本章将要讨论的 回射服务器。</li><li>服务器要同时监听多个端口，或者处理多种服务。比如本章将 要讨论的xinetd服务器。</li></ul><h4 id="9-1-select系统调用"><a href="#9-1-select系统调用" class="headerlink" title="9.1 select系统调用"></a>9.1 select系统调用</h4><p><strong>select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</strong></p><h5 id="9-1-1-select-API"><a href="#9-1-1-select-API" class="headerlink" title="9.1.1 select API"></a>9.1.1 select API</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>nfds参数指定被监听的文件描述符的总数。它通常被设置为 select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开 始计数的。</p></li><li><p><strong>readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。</strong>应用程序调用select函数时，通过这3 个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。</p></li><li><p>fd_set结构体仅包含一个整型数组，该数组的每 个元素的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述 符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述 符的总量。由于位操作过于烦琐，我们应该使用下面的一系列宏来访问fd_set 结构体中的位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞</span></span><br><span class="line">FD_ZERO(fd_set* fdset);<span class="comment">/*清除fdset的所有位*/</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set* fdset);<span class="comment">/*设置fdset的位fd*/</span></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set* fdset);<span class="comment">/*清除fdset的位fd*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;<span class="comment">/*测试fdset的位fd是否被设置*/</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>timeout参数用来设置select函数的超时时间。它是一个timeval 结构类型的指针，采用指针参数是因为内核将修改它以告诉应用程序 select等待了多久。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> tv_sec;<span class="comment">/*秒数*/</span></span><br><span class="line"><span class="keyword">long</span> tv_usec;<span class="comment">/*微秒数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>select成功时返回就绪（可读、可写和异常）文件描述符的总数。 如果在超时时间内没有任何文件描述符就绪，select将返回0。select失 败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则 select立即返回-1，并设置errno为EINTR。</p><h5 id="9-1-2-文件描述符就绪条件"><a href="#9-1-2-文件描述符就绪条件" class="headerlink" title="9.1.2 文件描述符就绪条件"></a>9.1.2 文件描述符就绪条件</h5><p>哪些情况下文件描述符可以被认为是可读、可写或者出现异常， 对于select的使用非常关键。</p><p>在网络编程中，下列情况下socket可读：</p><ul><li>socket内核接收缓存区中的字节数大于或等于其低水位标记 SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返 回的字节数大于0。</li><li>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</li><li>监听socket上有新的连接请求。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取 和清除该错误。</li></ul><p>下列情况下socket可写：</p><ul><li>socket内核发送缓存区中的可用字节数大于或等于其低水位标记 SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返 回的字节数大于0。</li><li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将 触发一个SIGPIPE信号。</li><li>socket使用非阻塞connect连接成功或者失败（超时）之后。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取 和清除该错误。</li></ul><p>网络程序中，select能处理的异常情况只有一种：socket上接收到 带外数据。下面我们详细讨论之。</p><h5 id="9-1-3-处理带外数据"><a href="#9-1-3-处理带外数据" class="headerlink" title="9.1.3 处理带外数据"></a>9.1.3 处理带外数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// select是如何同时接收普通数据和带外数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">close(listenfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">fd_set read_fds;</span><br><span class="line">fd_set exception_fds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除fdset的所有位</span></span><br><span class="line">FD_ZERO(&amp;read_fds);</span><br><span class="line">FD_ZERO(&amp;exception_fds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="comment">/*每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，</span></span><br><span class="line"><span class="comment"> * 因为事件发生之后，文件描述符集合将被内核修改</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">FD_SET(connfd, &amp;read_fds);</span><br><span class="line">FD_SET(connfd, &amp;exception_fds);</span><br><span class="line">ret = select(connfd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, &amp;exception_fds, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;selection failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于可读事件，采用普通的recv函数读取数据*/</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(connfd, &amp;read_fds)) &#123;</span><br><span class="line">ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of normal data:%s\n&quot;</span>, ret, buf);</span><br><span class="line"><span class="comment">/*对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据*/</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(connfd, &amp;exception_fds)) &#123;</span><br><span class="line">ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, MSG_OOB);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of oob data:%s\n&quot;</span>, ret, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(connfd);</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-poll系统调用"><a href="#9-2-poll系统调用" class="headerlink" title="9.2 poll系统调用"></a>9.2 poll系统调用</h4><p>poll系统调用和select类似，也是在指定时间内轮询一定数量的文件 描述符，以测试其中是否有就绪者。poll的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜poll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>fds参数是一个pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。pollfd结构体的定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;<span class="comment">/*文件描述符*/</span></span><br><span class="line"><span class="keyword">short</span> events;<span class="comment">/*注册的事件*/</span></span><br><span class="line"><span class="keyword">short</span> revents;<span class="comment">/*实际发生的事件，由内核填充*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，fd成员指定文件描述符；</span></span><br><span class="line"><span class="comment">// events成员告诉poll监听fd上的哪些事件，它是一系列事件的按位或；</span></span><br><span class="line"><span class="comment">// revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件。</span></span><br></pre></td></tr></table></figure><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230301214431734-1678341964417.png" class="" title="image-20230301214431734"></li><li><p>nfds参数指定被监听事件集合fds的大小。其类型nfds_t的定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">nfds_t</span>;</span><br></pre></td></tr></table></figure></li><li><p>timeout参数指定poll的超时值，单位是毫秒。当timeout为-1 时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。</p></li></ul><p>poll系统调用的返回值的含义与select相同。</p><h4 id="9-3-epoll系列系统调用"><a href="#9-3-epoll系列系统调用" class="headerlink" title="9.3 epoll系列系统调用"></a>9.3 epoll系列系统调用</h4><h5 id="9-3-1-内核事件表"><a href="#9-3-1-内核事件表" class="headerlink" title="9.3.1 内核事件表"></a>9.3.1 内核事件表</h5><p>epoll是Linux特有的I/O复用函数。它在实现和使用上与select、 poll有很大差异。</p><p>首先，epoll使用一组函数来完成任务，而不是单个 函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一 个事件表中，从而无须像select和poll那样每次调用都要重复传入文件 描述符集或事件集。<strong>但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。</strong></p><p>这个文件描述符使用如下epoll_create函数 来创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure><ul><li>size参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。</li><li><strong>该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。</strong></li></ul><p>下面的函数用来操作epoll的内核事件表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>fd参数是要操作的文件描述符，</p></li><li><p>op参数则指定操作类型。</p><ul><li>EPOLL_CTL_ADD，往事件表中注册fd上的事件。</li><li>EPOLL_CTL_MOD，修改fd上的注册事件。</li><li>EPOLL_CTL_DEL，删除fd上的注册事件。</li></ul></li><li><p>event参数指定事件，它是epoll_event结构指针类型。epoll_event的 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">__uint32_t</span> events;<span class="comment">/*epoll事件*/</span></span><br><span class="line"><span class="keyword">epoll_data_t</span> data;<span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span>*ptr;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>epoll_data_t是一个联合体，其4个成员中使用最多的是fd，它指定 事件所从属的目标文件描述符。ptr成员可用来指定与fd相关的用户数 据。</p></li><li><p>其中events成员描述事件类型。epoll支持的事件类型和poll基本相 同。表示epoll事件类型的宏是在poll对应的宏前加上“E”，比如epoll的 数据可读事件是EPOLLIN。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230301214431734-1678341964417.png" class="" title="image-20230301214431734"></li><li><p>但epoll有两个额外的事件类型—— EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键， 我们将在后面讨论它们。</p></li></ul><p>epoll_ctl成功时返回0，失败则返回-1并设置errno。</p><h5 id="9-3-2-epoll-wait函数"><a href="#9-3-2-epoll-wait函数" class="headerlink" title="9.3.2 epoll_wait函数"></a>9.3.2 epoll_wait函数</h5><p>epoll系列系统调用的主要接口是epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数成功时返回就绪的文件描述符的个数，失败时返回-1并设 置errno。</p><ul><li>timeout参数的含义与 poll接口的timeout参数相同。</li><li>maxevents参数指定最多监听多少个事 件，它必须大于0。</li><li>epoll_wait函数如果检测到事件，就 <strong>将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。</strong> <strong>这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和poll 的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到 的就绪事件</strong>。这就极大地提高了应用程序索引就绪文件描述符的效率。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  如何索引poll返回的就绪文件描述符</span></span><br><span class="line"><span class="comment">// 当timeout为-1 时，poll调用将永远阻塞，直到某个事件发生</span></span><br><span class="line"><span class="keyword">int</span> ret = poll(fds, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (fds[i].revents &amp; POLLIN)<span class="comment">/*判断第i个文件描述符是否就绪*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = fds[i].fd;</span><br><span class="line"><span class="comment">/*处理sockfd*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如何索引epoll返回的就绪文件描述符</span></span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*仅遍历就绪的ret个文件描述符*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">/*sockfd肯定就绪，直接处理*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="9-3-3-LT和ET模式"><a href="#9-3-3-LT和ET模式" class="headerlink" title="9.3.3 LT和ET模式"></a>9.3.3 LT和ET模式</h5><p>epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平 触发）模式和ET（Edge Trigger，边沿触发）模式。</p><p><strong>LT模式是默认的 工作模式，这种模式下epoll相当于一个效率较高的poll。</strong> 对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事 件。这样，<strong>当应用程序下一次调用epoll_wait时，epoll_wait还会再次向 应用程序通告此事件，直到该事件被处理。</strong></p><p><strong>当往epoll内 核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET 模式来操作该文件描述符。ET模式是epoll的高效工作模式。</strong>而对于采用ET工作模式的 文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，<strong>应用程序必须立即处理该事件，因为后续的epoll_wait调用将 不再向应用程序通知这一事件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件描述符设置成非阻塞的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);  <span class="comment">// 获取状态标志</span></span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，</span></span><br><span class="line"><span class="comment"> * 参数enable_et指定是否对fd启用ET模式</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line"><span class="keyword">if</span> (enable_et) &#123;</span><br><span class="line">event.events |= EPOLLET;</span><br><span class="line"><span class="comment">// 等价于 event.events = event.events | EPOLLET</span></span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*LT模式的工作流程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address,</span><br><span class="line">&amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd, <span class="literal">false</span>); <span class="comment">/*对connfd禁用ET模式*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123; <span class="comment">/*只要socket读缓存中还有未读出的数据，这段代码就被触发*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of content:%s\n&quot;</span>, ret, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*ET模式的工作流程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;</span><br><span class="line">client_addrlength);</span><br><span class="line">addfd(epollfd, connfd, <span class="literal">true</span>); <span class="comment">/*对connfd开启ET模式*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="comment">/*这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。</span></span><br><span class="line"><span class="comment"> * 此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of content:%s\n&quot;</span>, ret, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret, listenfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">addfd(epollfd, listenfd, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lt(events, ret, epollfd, listenfd); <span class="comment">/*使用LT模式*/</span></span><br><span class="line"><span class="comment">//et(events,ret,epollfd,listenfd);    /*使用ET模式*/</span></span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者不妨运行一下这段代码，然后telnet到这个服务器程序上并一 次传输超过10字节（BUFFER_SIZE的大小）的数据，然后比较LT模式 和ET模式的异同。你会发现，正如我们预期的，ET模式下事件被触发 的次数要比LT模式下少很多。 </p><p>注意每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直 处于阻塞状态（饥渴状态）。</p><h5 id="9-3-4-EPOLLONESHOT事件"><a href="#9-3-4-EPOLLONESHOT事件" class="headerlink" title="9.3.4 EPOLLONESHOT事件"></a>9.3.4 EPOLLONESHOT事件</h5><p>即使我们使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程（或进程， 下同）在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发）， 此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线 程同时操作一个socket的局面。</p><p><strong>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事 件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fds</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中，参</span></span><br><span class="line"><span class="comment">数oneshot指定是否注册fd上的EPOLLONESHOT事件*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> oneshot)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line"><span class="keyword">if</span> (oneshot) &#123;</span><br><span class="line">event.events |= EPOLLONESHOT;</span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，但是操</span></span><br><span class="line"><span class="comment">作系统仍然会触发fd上的EPOLLIN事件，且只触发一次*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_oneshot</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*工作线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = ((fds *) arg)-&gt;sockfd;</span><br><span class="line"><span class="keyword">int</span> epollfd = ((fds *) arg)-&gt;epollfd;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start new thread to receive data on fd:%d\n&quot;</span>, sockfd);</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"><span class="comment">/*循环读取sockfd上的数据，直到遇到EAGAIN错误*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;foreiner closed the connection\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">reset_oneshot(epollfd, sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get content:%s\n&quot;</span>, buf);</span><br><span class="line"><span class="comment">/*休眠5s，模拟数据处理过程*/</span></span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end thread receiving data on fd:%d\n&quot;</span>, sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (</span><br><span class="line">struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意，监听socket listenfd上是不能注册EPOLLONESHOT事件的，否则应用程序</span></span><br><span class="line"><span class="comment"> * 只能处理一个客户连接！因为后续的客户连接请求将不再触发listenfd上的EPOLLIN事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">addfd(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (</span><br><span class="line">struct sockaddr *) &amp;client_address, &amp;</span><br><span class="line">                    client_addrlength);</span><br><span class="line"><span class="comment">/*对每个非监听文件描述符都注册EPOLLONESHOT事件*/</span></span><br><span class="line">addfd(epollfd, connfd, <span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line">fds fds_for_new_worker&#123;&#125;;</span><br><span class="line">fds_for_new_worker.epollfd = epollfd;</span><br><span class="line">fds_for_new_worker.sockfd = sockfd;</span><br><span class="line"><span class="comment">/*新启动一个工作线程为sockfd服务*/</span></span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, (<span class="keyword">void</span> *) &amp;fds_for_new_worker);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从工作线程函数worker来看，如果一个工作线程处理完某个socket 上的一次请求（我们用休眠5 s来模拟这个过程）之后，又接收到该 socket上新的客户请求，则该线程将继续为这个socket服务。并且因为该socket上注册了EPOLLONESHOT事件，其他线程没有机会接触这个 socket，如果工作线程等待5 s后仍然没收到该socket上的下一批客户数 据，则它将放弃为该socket服务。</p><p>同时，它调用reset_oneshot函数来重 置该socket上的注册事件，这将使epoll有机会再次检测到该socket上的 EPOLLIN事件，进而使得其他线程有机会为该socket服务。</p><h4 id="9-4-三组I-O复用函数的比较"><a href="#9-4-三组I-O复用函数的比较" class="headerlink" title="9.4 三组I/O复用函数的比较"></a>9.4 三组I/O复用函数的比较</h4><p>前面我们讨论了select、poll和epoll三组I/O复用系统调用，这3组系 统调用都能同时监听多个文件描述符。它们将等待由timeout参数指定 的超时时间，直到一个或者多个文件描述符上有事件发生时返回，返 回值是就绪的文件描述符的数量。返回0表示没有事件发生。</p><ul><li>事件集合<ul><li>select的参数类型fd_set没有将文件描述符和事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件。这一方面使得select不能处理更多类型的 事件，另一方面由于内核对fd_set集合的在线修改，应用程序下次调用 select前不得不重置这3个fd_set集合。</li><li>poll的参数类型pollfd则多少“聪 明”一些。它把文件描述符和事件都定义其中，任何事件都被统一处理，从而使得编程接口简洁得多。并且内核每次修改的是pollfd结构体 的revents成员，而events成员保持不变，因此下次调用poll时应用程序 无须重置pollfd类型的事件集参数。由于每次select和poll调用都返回整 个用户注册的事件集合（其中包括就绪的和未就绪的），所以应用程 序索引就绪文件描述符的时间复杂度为O（n）。</li><li>epoll则采用与select和 poll完全不同的方式来管理用户注册的事件。它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除、 修改事件。这样，每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文 件描述符的时间复杂度达到O（1）。</li></ul></li><li>最大文件描述符</li></ul><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302141655751-1678341964417.png" class="" title="image-20230302141655751"><h4 id="9-5-I-O复用的高级应用一：非阻塞connect"><a href="#9-5-I-O复用的高级应用一：非阻塞connect" class="headerlink" title="9.5 I/O复用的高级应用一：非阻塞connect"></a>9.5 I/O复用的高级应用一：非阻塞connect</h4><p>在对非阻塞的socket调用connect，而连接又没有立即建立时。会出现一种errno值：EINPROGRESS。 根据man文档的解释，在这种情况下，我们可以调用select、poll 等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。 如果错误码是0，表示连接成功建立，否则连接失败。</p><p>通过上面描述的非阻塞connect方式，我们就能同时发起多个连接 并一起等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1023</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 超时连接函数，参数分别是服务器IP地址、端口号和超时时间（毫秒）。</span></span><br><span class="line"><span class="comment"> * 函数成功时返回已经处于连接状态的socket，失败则返回-1</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unblock_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fdopt = setnonblocking(sockfd);</span><br><span class="line">ret = connect(sockfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果连接成功，则恢复sockfd的属性，并立即返回之*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect with server immediately\n&quot;</span>);</span><br><span class="line">fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno != EINPROGRESS) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果连接没有立即建立，那么只有当errno是EINPROGRESS时才表示连接还在进行，否则出错返回</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unblock connect not support\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd_set writefds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">FD_ZERO(&amp;writefds);</span><br><span class="line">FD_SET(sockfd, &amp;writefds);</span><br><span class="line">timeout.tv_sec = time;</span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = select(sockfd + <span class="number">1</span>, <span class="literal">nullptr</span>, &amp;writefds, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*select超时或者出错，立即返回*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection time out\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试fdset的位fd是否被设置</span></span><br><span class="line"><span class="keyword">if</span> (!FD_ISSET(sockfd, &amp;writefds)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no events on sockfd found\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(error);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用getsockopt来获取并清除sockfd上的错误, getsockopt和setsockopt这两个函数成功时返回0，</span></span><br><span class="line"><span class="comment">// 失败时返回-1并设置errno。</span></span><br><span class="line"><span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误号不为0表示连接出错</span></span><br><span class="line"><span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection failed after select with the error:%d\n&quot;</span>, error);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection ready after select with the socket:%d\n&quot;</span>, sockfd);</span><br><span class="line">fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> sockfd = unblock_connect(ip, port, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**5.11 章节 socket选项 : **     getsockopt, setsockopt, 两个系统调用则是专门用来读取和设置socket文件描述符属性的 方法。</p><h4 id="9-6-I-O复用的高级应用二：聊天室程序"><a href="#9-6-I-O复用的高级应用二：聊天室程序" class="headerlink" title="9.6 I/O复用的高级应用二：聊天室程序"></a>9.6 I/O复用的高级应用二：聊天室程序</h4><p>本节我们以poll为例实现一个简单的聊天室 程序，以阐述如何使用I/O复用技术来同时处理网络连接和用户输入。 该聊天室程序能让所有用户同时在线群聊，它分为客户端和服务器两个部分。</p><p>其中客户端程序有两个功能：一是从标准输入终端读入用户 数据，并将用户数据发送至服务器；二是往标准输出终端打印服务器 发送给它的数据。</p><p>服务器的功能是接收客户数据，并把客户数据发送 给每一个登录到该服务器上的客户端（数据发送者除外）。</p><h5 id="9-6-1-客户端"><a href="#9-6-1-客户端" class="headerlink" title="9.6.1 客户端"></a>9.6.1 客户端</h5><p>客户端程序使用poll同时监听用户输入和网络连接，并利用splice 函数将用户输入内容直接定向到网络连接上以发送之，从而实现数据 零拷贝，提高了程序执行效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">bzero(&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">server_address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;server_address.sin_addr);</span><br><span class="line">server_address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (connect(sockfd, (struct sockaddr *) &amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pollfd fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册文件描述符0（标准输入）和文件描述符sockfd上的可读事件*/</span></span><br><span class="line">fds[<span class="number">0</span>].fd = <span class="number">0</span>;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">fds[<span class="number">1</span>].fd = sockfd;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLIN | POLLRDHUP;</span><br><span class="line">fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> read_buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ret = poll(fds, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLRDHUP) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server close the connection\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="built_in">memset</span>(read_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">recv(fds[<span class="number">1</span>].fd, read_buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, read_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="comment">/*使用splice将用户输入的数据直接写到sockfd上（零拷贝）*/</span></span><br><span class="line">ret = splice(<span class="number">0</span>, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, sockfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="9-6-2-服务端"><a href="#9-6-2-服务端" class="headerlink" title="9.6.2 服务端"></a>9.6.2 服务端</h5><p>服务器程序使用poll同时管理监听socket和连接socket，并且使用牺牲空间换取时间的策略来提高服务器性能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_LIMIT 5    <span class="comment">/*最大用户数量*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64  <span class="comment">/*读缓冲区的大小*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535  <span class="comment">/*文件描述符数量限制*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户数据：客户端socket地址、待写到客户端的数据的位置、从客户端读入的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">char</span> *write_buf;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建users数组，分配FD_LIMIT个client_data对象。可以预期：</span></span><br><span class="line"><span class="comment"> * 每个可能的socket连接都可以获得一个这样的对象，并且socket的值可以直接用来索引（作为数组的下标）</span></span><br><span class="line"><span class="comment"> * socket连接对应的client_data对象，这是将socket和客户数据关联的简单而高效的方式</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line">client_data *users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管我们分配了足够多的client_data对象，但为了提高poll的性能，仍然有必要限制用户的数量</span></span><br><span class="line">pollfd fds[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> user_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= USER_LIMIT; ++i) &#123;</span><br><span class="line">fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">fds[i].events = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ret = poll(fds, user_counter + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; user_counter + <span class="number">1</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fds[0] 用于建立连接</span></span><br><span class="line"><span class="keyword">if</span> ((fds[i].fd == listenfd) &amp;&amp; (fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果请求太多，则关闭新到的连接*/</span></span><br><span class="line"><span class="keyword">if</span> (user_counter &gt;= USER_LIMIT) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于新的连接，同时修改fds和users数组。前文已经提到，</span></span><br><span class="line"><span class="comment"> * users[connfd]对应于新连接文件描述符connfd的客户数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line">user_counter++;</span><br><span class="line">users[connfd].address = client_address;</span><br><span class="line">setnonblocking(connfd);</span><br><span class="line">fds[user_counter].fd = connfd;</span><br><span class="line">fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR;</span><br><span class="line">fds[user_counter].revents = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;comes a new user,now have%d users\n&quot;</span>, user_counter);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLERR) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get an error from%d\n&quot;</span>, fds[i].fd);</span><br><span class="line"><span class="keyword">char</span> errors[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(errors, <span class="string">&#x27;\0&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(errors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getsockopt(fds[i].fd, SOL_SOCKET, SO_ERROR, &amp;errors,&amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLRDHUP) &#123;</span><br><span class="line"><span class="comment">// 如果客户端关闭连接，则服务器也关闭对应的连接，并将用户总数减1</span></span><br><span class="line">users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">close(fds[i].fd);</span><br><span class="line">fds[i] = fds[user_counter];</span><br><span class="line">i--;</span><br><span class="line">user_counter--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a client left\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line"><span class="built_in">memset</span>(users[connfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">ret = recv(connfd, users[connfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of client data%s from%d\n&quot;</span>, ret, users[connfd].buf, connfd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果读操作出错，则关闭连接*/</span></span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">close(connfd);</span><br><span class="line">users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">fds[i] = fds[user_counter];</span><br><span class="line">i--;</span><br><span class="line">user_counter--;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*如果接收到客户数据，则通知其他socket连接准备写数据*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= user_counter; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (fds[j].fd == connfd) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">fds[j].events |= ~POLLIN;</span><br><span class="line">fds[j].events |= POLLOUT;</span><br><span class="line">users[fds[j].fd].write_buf = users[connfd].buf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLOUT) &#123;</span><br><span class="line"><span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line"><span class="keyword">if</span> (!users[connfd].write_buf) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = send(connfd, users[connfd].write_buf, <span class="built_in">strlen</span>(users[connfd].write_buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">users[connfd].write_buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*写完数据后需要重新注册fds[i]上的可读事件*/</span></span><br><span class="line">fds[i].events |= ~POLLOUT;</span><br><span class="line">fds[i].events |= POLLIN;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]users;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-7-I-O-复用的高级应用三-同时处理TCP和UDP服务"><a href="#9-7-I-O-复用的高级应用三-同时处理TCP和UDP服务" class="headerlink" title="9.7 I/O 复用的高级应用三: 同时处理TCP和UDP服务"></a>9.7 I/O 复用的高级应用三: 同时处理TCP和UDP服务</h4><p>在实际应用 中，有不少服务器程序能同时监听多个端口，比如超级服务inetd和 android的调试服务adbd。</p><p>从bind系统调用的参数来看，一个socket只能与一个socket地址绑 定，即一个socket只能用来监听一个端口。因此，服务器如果要同时 监听多个端口，就必须创建多个socket，并将它们分别绑定到各个端 口上。这样一来，服务器程序就需要同时管理多个监听socket，I/O复 用技术就有了用武之地。</p><p>另外，即使是同一个端口，如果服务器要同 时处理该端口上的TCP和UDP请求，则也需要创建两个不同的socket： 一个是流socket，另一个是数据报socket，并将它们都绑定到该端口 上。比如代码清单9-8所示的回射服务器(比如echo)就能同时处理一个端口上的 TCP和UDP请求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建TCP socket，并将其绑定到端口port上*/</span></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建UDP socket，并将其绑定到端口port上*/</span></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> udpfd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">assert(udpfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(udpfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册TCP socket和UDP socket上的可读事件*/</span></span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line">addfd(epollfd, udpfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockfd == udpfd) &#123;</span><br><span class="line"><span class="keyword">char</span> buf[UDP_BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, UDP_BUFFER_SIZE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="comment">// udp数据读取</span></span><br><span class="line">ret = recvfrom(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>,(struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// udp 数据发送</span></span><br><span class="line">sendto(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>,(struct sockaddr *) &amp;client_address, client_addrlength);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">char</span> buf[TCP_BUFFER_SIZE];</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, TCP_BUFFER_SIZE);</span><br><span class="line">ret = recv(sockfd, buf, TCP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">send(sockfd, buf, ret, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-8-超级服务xinetd"><a href="#9-8-超级服务xinetd" class="headerlink" title="9.8 超级服务xinetd"></a>9.8 超级服务xinetd</h4><p>Linux因特网服务inetd是超级服务。它同时管理着多个子服务，即 监听多个端口。现在Linux系统上使用的inetd服务程序通常是其升级版 本xinetd。</p><h5 id="9-8-1-xinetd-配置文件"><a href="#9-8-1-xinetd-配置文件" class="headerlink" title="9.8.1 xinetd 配置文件"></a>9.8.1 xinetd 配置文件</h5><p>xinetd采用/etc/xinetd.conf主配置文件和/etc/xinetd.d目录下的子配置 文件来管理所有服务。主配置文件包含的是通用选项，这些选项将被 所有子配置文件继承。不过子配置文件可以覆盖这些选项。每一个子 配置文件用于设置一个子服务的参数。</p><p>比如，telnet子服务的配置文 件/etc/xinetd.d/telnet的典型内容如下：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211328677-1678341964417.png" class="" title="image-20230302211328677"><p>/etc/xinetd. d/telnet文件中的每一项的含义如表9-3所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211402685-1678341964417.png" class="" title="image-20230302211402685"><h5 id="9-8-2-xinetd-服务流程"><a href="#9-8-2-xinetd-服务流程" class="headerlink" title="9.8.2 xinetd 服务流程"></a>9.8.2 xinetd 服务流程</h5><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211732296-1678341964417.png" class="" title="image-20230302211732296"><h3 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h3><p><strong>信号是由用户、系统或者进程发送给目标进程的信息</strong>，以通知目 标进程某个状态的改变或系统异常。Linux信号可由如下条件产生：</p><ul><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</li><li>系统异常。比如浮点异常和非法内存段访问。</li><li>系统状态变化。比如alarm定时器到期将引起SIGALRM信号。</li><li>运行kill命令或调用kill函数。</li></ul><h4 id="10-1-Linux信号概述"><a href="#10-1-Linux信号概述" class="headerlink" title="10.1 Linux信号概述"></a>10.1 Linux信号概述</h4><h5 id="10-1-1-发送信号"><a href="#10-1-1-发送信号" class="headerlink" title="10.1.1 发送信号"></a>10.1.1 发送信号</h5><p>Linux下，一个进程给其他进程发送信号的API是kill函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>该函数把信号sig发送给目标进程，Linux定义的信号值都大于0，如果sig取值为0，则kill函数不发送 任何信号。但将sig设置为0可以用来检测目标进程或进程组是否存在， 因为检查工作总是在信号发送之前就执行。</p></li><li><p>目标进程由pid参数指定，其可 能的取值及含义如表10-1所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304135652650-1678341964417.png" class="" title="image-20230304135652650"></li></ul><h5 id="10-1-2-信号处理方式"><a href="#10-1-2-信号处理方式" class="headerlink" title="10.1.2 信号处理方式"></a>10.1.2 信号处理方式</h5><p>目标进程在收到信号时，需要定义一个接收函数来处理之。信号 处理函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">__sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>信号处理函数只带有一个整型参数，该参数用来指示信号类型。</p><h5 id="10-1-3-Linux信号"><a href="#10-1-3-Linux信号" class="headerlink" title="10.1.3 Linux信号"></a>10.1.3 Linux信号</h5><p>Linux的可用信号都定义在bits/signum.h头文件中，其中包括标准信 号和POSIX实时信号。本书仅讨论标准信号， 以下列举几种与网络编程关系紧密的几个信号：</p><ol><li>SIGHUP：控制终端挂起</li><li>SIGPIPE：往读端被关闭的管道或者socket连接中写数据</li><li>SIGURG：socket连接上接收到紧急数据</li><li>SIGALRM：由alarm或setitimer设置的实时闹钟超时引起</li><li>SIGCHLD：子进程状态发生变化（退出或者暂停）</li></ol><h5 id="10-1-4-中断系统调用"><a href="#10-1-4-中断系统调用" class="headerlink" title="10.1.4 中断系统调用"></a>10.1.4 中断系统调用</h5><p>如果程序在执行处于阻塞状态的系统调用时接收到信号，并且我 们为该信号设置了信号处理函数，则默认情况下系统调用将被中断， 并且errno被设置为EINTR。</p><p>我们可以使用sigaction函数（见后文）为信 号设置SA_RESTART标志以自动重启被该信号中断的系统调用。</p><h4 id="10-2-信号函数"><a href="#10-2-信号函数" class="headerlink" title="10.2 信号函数"></a>10.2 信号函数</h4><h5 id="10-2-1-signal系统调用"><a href="#10-2-1-signal系统调用" class="headerlink" title="10.2.1 signal系统调用"></a>10.2.1 signal系统调用</h5><p>要为一个<strong>信号设置处理函数</strong>，可以使用下面的signal系统调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">_sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">_sighandler_t</span> _handler)</span></span></span><br></pre></td></tr></table></figure><ul><li>sig参数指出要捕获的信号类型。</li><li>_handler参数是_sighandler_t类型 的函数指针，用于指定信号sig的处理函数。</li></ul><p>signal函数成功时返回一个函数指针，该函数指针的类型也是 _sighandler_t。 <strong>这个返回值是前一次调用signal函数时传入的函数指针， 或者是信号sig对应的默认处理函数指针SIG_DEF（如果是第一次调用 signal的话）。</strong></p><p>signal系统调用出错时返回SIG_ERR，并设置errno。</p><h5 id="10-2-2-sigaction系统调用"><a href="#10-2-2-sigaction系统调用" class="headerlink" title="10.2.2 sigaction系统调用"></a>10.2.2 sigaction系统调用</h5><p>设置<strong>信号处理函数</strong>的更健壮的接口是如下的系统调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction* act,struct sigaction* oact)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sig参数指出要捕获的信号类型</li><li>act参数指定新的信号处理方式</li><li>oact参数则输出信号先前的处理方式（如果不为NULL的话）</li></ul><p>sigaction结构体描述了信号处理 的细节，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure describing the action to be taken when a signal arrives.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* Signal handler.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="comment">/* Used if SA_SIGINFO is not set.  */</span></span><br><span class="line"><span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line"><span class="comment">/* Used if SA_SIGINFO is set.  */</span></span><br><span class="line"><span class="keyword">void</span> (*sa_sigaction) (<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">      &#125;</span><br><span class="line">    __sigaction_handler;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> sa_handler__sigaction_handler.sa_handler</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> sa_sigaction__sigaction_handler.sa_sigaction</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional set of signals to be blocked.  */</span></span><br><span class="line">    <span class="keyword">__sigset_t</span> sa_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Special flags.  */</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore handler.  */</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer) (<span class="keyword">void</span>);</span><br><span class="line">    <span class="comment">// 指向返回值是void, 参数是void类型的 函数指针</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li><p>该结构体中的sa_hander成员指定信号处理函数。</p></li><li><p>sa_mask成员设置进程的信号掩码（确切地说是在进程原有信号掩码的基础上增加信号 掩码），以指定哪些信号不能发送给本进程。<strong>sa_mask是信号集 sigset_t（_sigset_t的同义词）类型，该类型指定一组信号。</strong> 下一节介绍sigset_t</p></li><li><p>sa_flags成员用于设置程序收到信号时的行 为，其可选值如表10-4所示：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304142154845-1678341964417.png" class="" title="image-20230304142154845"></li></ul><h4 id="10-3-信号集"><a href="#10-3-信号集" class="headerlink" title="10.3 信号集"></a>10.3 信号集</h4><h5 id="10-3-1-信号集函数"><a href="#10-3-1-信号集函数" class="headerlink" title="10.3.1 信号集函数"></a>10.3.1 信号集函数</h5><p>前文提到，Linux使用数据结构sigset_t来表示一组信号。其定义如 下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/sigset.h＞</span></span><br><span class="line">#define_SIGSET_NWORDS(<span class="number">1024</span>/(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>)))</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> int__val[_SIGSET_NWORDS];</span><br><span class="line">&#125;<span class="keyword">__sigset_t</span>;</span><br></pre></td></tr></table></figure><p>sigset_t实际上是一个长整型数组，数组的每个元素的每个位表示一个信号。这种定义方式和文件描述符集fd_set类似。</p><p>Linux提供了如下一组函数来设置、修改、删除和查询信号集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*清空信号集*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*在信号集中设置所有信号*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>*_set,<span class="keyword">int</span> _signo)</span><span class="comment">/*将信号_signo添加至信号集中*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>* _set,<span class="keyword">int</span> _signo)</span><span class="comment">/*将信号_signo从信号集中删除*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(_const <span class="keyword">sigset_t</span>* _set, int_signo)</span><span class="comment">/*测试_signo是否在信号集中*/</span></span></span><br></pre></td></tr></table></figure><h5 id="10-3-2-进程信号掩码"><a href="#10-3-2-进程信号掩码" class="headerlink" title="10.3.2 进程信号掩码"></a>10.3.2 进程信号掩码</h5><p>我们可以利用<strong>sigaction结构体的sa_mask成员来设置进程的信号掩码</strong>。此外，如下函数也可以用于设置或查看进程的信号掩 码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> _how, _const <span class="keyword">sigset_t</span>* _set, <span class="keyword">sigset_t</span>* _oset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>_set</code>参数指定新的信号掩码，</p></li><li><p>_oset参数则输出原来的信号掩码（如 果不为NULL的话）。</p></li><li><p>如果_set参数不为NULL，则_how参数指定设置 进程信号掩码的方式，其可选值如表10-5所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304143250709-1678341964417.png" class="" title="image-20230304143250709"></li></ul><p>sigprocmask成功时返回0，失败则返回-1并设置errno。</p><h5 id="10-3-3-被挂起的信号"><a href="#10-3-3-被挂起的信号" class="headerlink" title="10.3.3 被挂起的信号"></a>10.3.3 被挂起的信号</h5><p>设置进程信号掩码后，被屏蔽的信号将不能被进程接收。<strong>如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个被挂起的信号。</strong>如果我们取消对被挂起信号的屏蔽，则它能立即被进 程接收到</p><p>如下函数可以获得进程当前被挂起的信号集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>set参数用于保存被挂起的信号集。显然，进程即使多次接收到同 一个被挂起的信号，sigpending函数也只能反映一次。并且，当我们再 次使用sigprocmask使能该挂起的信号时，该信号的处理函数也只被触 发一次。</p><p>sigpending成功时返回0，失败时返回-1并设置errno。</p><h4 id="10-4-统一事件源"><a href="#10-4-统一事件源" class="headerlink" title="10.4 统一事件源"></a>10.4 统一事件源</h4><p>信号是一种异步事件：信号处理函数和程序的主循环是两条不同 的执行路线。很显然，信号处理函数需要尽可能快地执行完毕，以确 保该信号不被屏蔽（前面提到过，为了避免一些竞态条件，信号在处 理期间，系统不会再次触发它）太久。</p><p>一种典型的解决方案是：<strong>把信号的主要处理逻辑放到程序的主循环中</strong>，当信号处理函数被触发时， 它<strong>只是简单地通知主循环程序接收到信号</strong>，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。</p><p><strong>信号处理函数通常使用管道来将信号“传递”给主循环</strong>：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么 主循环怎么知道管道上何时有数据可读呢  ?</p><p>这很简单，<strong>我们只需要使用 I/O复用系统调用来监听管道的读端文件描述符上的可读事件</strong>。如此一 来，信号事件就能和其他I/O事件一样被处理，即统一事件源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将事件添加到 epoll的内核事件表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*保留原来的errno，在函数最后恢复，以保证函数的可重入性*/</span></span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">/*将信号值写入管道，以通知主循环*/</span></span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置信号的处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = sig_handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SA_RESTART 重新调用被该信号终止的系统调用</span></span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在信号集中设置所有信号*/</span></span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表</span></span><br><span class="line"><span class="comment"> * 文件描述符使用如下epoll_create函数 来创建</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用socketpair创建管道，注册pipefd[0]上的可读事件*/</span></span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line"></span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置一些信号的处理函数*/</span></span><br><span class="line">addsig(SIGHUP);</span><br><span class="line">addsig(SIGCHLD);</span><br><span class="line">addsig(SIGTERM);</span><br><span class="line">addsig(SIGINT);</span><br><span class="line"><span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">/*如果就绪的文件描述符是listenfd，则处理新的连接*/</span></span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果就绪的文件描述符是pipefd[0]，则处理信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*因为每个信号值占1字节，所以按字节来逐个接收信号。我们以SIGTERM为例，</span></span><br><span class="line"><span class="comment"> * 来说明如何安全地终止服务器主循环*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD:</span><br><span class="line"><span class="keyword">case</span> SIGHUP: &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM:</span><br><span class="line"><span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;close fds\n&quot;</span>);</span><br><span class="line">close(listenfd);</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-5-网络编程相关信号"><a href="#10-5-网络编程相关信号" class="headerlink" title="10.5 网络编程相关信号"></a>10.5 网络编程相关信号</h4><p>本节中我们详细探讨三个和网络编程密切相关的信号。</p><h5 id="10-5-1-SIGHUP"><a href="#10-5-1-SIGHUP" class="headerlink" title="10.5.1 SIGHUP"></a>10.5.1 SIGHUP</h5><p><strong>当挂起进程的控制终端时，SIGHUP信号将被触发。</strong>对于没有控 制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务 器重读配置文件。一个典型的例子是xinetd超级服务程序。</p><p>xinetd程序在接收到SIGHUP信号之后将调用hard_reconfig函数 （见xinetd源码），它循环读取/etc/xinetd.d/目录下的每个子配置文 件，并检测其变化。如果某个正在运行的子服务的配置文件被修改以停止服务，则xinetd主进程将给该子服务进程发送SIGTERM信号以结 束它。如果某个子服务的配置文件被修改以开启服务，则xinetd将创建 新的socket并将其绑定到该服务对应的端口上。</p><h5 id="10-5-2-SIGPIPE"><a href="#10-5-2-SIGPIPE" class="headerlink" title="10.5.2 SIGPIPE"></a>10.5.2 SIGPIPE</h5><p>默认情况下，往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号。我们需要在<strong>代码中捕获并处理该信号</strong>，或者至少忽 略它，因为程序接收到SIGPIPE信号的默认行为是结束进程，而我们 绝对不希望因为错误的写操作而导致程序退出。引起SIGPIPE信号的 写操作将设置errno为EPIPE。</p><p>第5章提到，我们可以使用send函数的MSG_NOSIGNAL标志来禁 止写操作触发SIGPIPE信号。在这种情况下，我们应该使用send函数反 馈的errno值来判断管道或者socket连接的读端是否已经关闭。 </p><p>此外，我们也可以利用I/O复用系统调用来检测管道和socket连接 的读端是否已经关闭。以poll为例，当管道的读端关闭时，写端文件 描述符上的POLLHUP事件将被触发；当socket连接被对方关闭时， socket上的POLLRDHUP事件将被触发。</p><h5 id="10-5-3-SIGURG"><a href="#10-5-3-SIGURG" class="headerlink" title="10.5.3 SIGURG"></a>10.5.3 SIGURG</h5><p>在Linux环境下，内核通知应用程序带外数据到达主要有两种方 法：</p><ol><li>一种是第9章介绍的I/O复用技术，select等系统调用在接收到带外 数据时将返回，并向应用程序报告socket上的异常事件, 代码9_1</li><li>另外一种方法就是使用SIGURG信号，如 代码清单10-3所示。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGURG信号的处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_urg</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno=errno;</span><br><span class="line"><span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,MSG_OOB);<span class="comment">/*接收带外数据*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of oob data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">errno=save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig,<span class="keyword">void</span>(*sig_handler)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler=sig_handler;</span><br><span class="line">sa.sa_flags|=SA_RESTART;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig,&amp;sa,<span class="literal">nullptr</span>)!=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,&amp;address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sock&gt;=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret=bind(sock,(struct sockaddr*)&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=listen(sock,<span class="number">5</span>);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client);</span><br><span class="line">connfd=accept(sock,(struct sockaddr*)&amp;client,&amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>,errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">addsig(SIGURG,sig_urg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用SIGURG信号之前，我们必须设置socket的宿主进程或进程组</span></span><br><span class="line"><span class="comment"> * F_SETOWN 设定SIGIO和SIGURG信号的宿主进程的PID或者进程组的组id</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">fcntl(connfd,F_SETOWN, getpid());</span><br><span class="line"><span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">/*循环接收普通数据*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line">ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of normal data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第11章-定时器"><a href="#第11章-定时器" class="headerlink" title="第11章 定时器"></a>第11章 定时器</h3><hr><p>网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态。服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。</p><p>为此，<strong>我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构</strong>， 比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定 时事件的统一管理。本章主要讨论的就是两种高效的管理定时器的容器：时间轮和时间堆。</p><p><strong>注</strong>: 定时器容器是容器类数据结构，比如时间轮；定时器则是容器内容纳的一个个对象，它是对定时事件的封装。</p><p>我们先要介绍定时的方法。 定时是指在一段时间之后触发某段代码的机制，我们可以在这段代码 中依次处理所有到期的定时器。换言之，定时机制是定时器得以被处 理的原动力。Linux提供了三种定时方法，它们是：</p><ul><li>socket选项SO_RCVTIMEO和SO_SNDTIMEO。</li><li>SIGALRM信号。</li><li>I/O复用系统调用的超时参数</li></ul><h4 id="11-1-socket选项SO-RCVTIMEO和-SO-SNDTIMEO"><a href="#11-1-socket选项SO-RCVTIMEO和-SO-SNDTIMEO" class="headerlink" title="11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO"></a>11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO</h4><p>第5章中我们介绍过socket选项SO_RCVTIMEO和 SO_SNDTIMEO，它们分别用来设置socket接收数据超时时间和发送数 据超时时间。</p><p>这两个选项仅对与数据接收和发送相关的socket专用系统调用有效，这些系统调用包括send、sendmsg、recv、recvmsg、 accept和connect。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304222359944-1678341964417.png" class="" title="image-20230304222359944"><p>我们可以<strong>根据系统调用（send、 sendmsg、recv、recvmsg、accept和connect）的返回值以及errno来判断 超时时间是否已到</strong>，进而决定是否开始处理定时任务。</p><h4 id="11-2-SIGALRM-信号"><a href="#11-2-SIGALRM-信号" class="headerlink" title="11.2 SIGALRM 信号"></a>11.2 SIGALRM 信号</h4><p>第10章提到，<strong>由alarm和setitimer函数设置的实时闹钟一旦超时</strong>， 将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来 处理定时任务。</p><p>但是，如果要处理多个定时任务，我们就需要不断地 触发SIGALRM信号，并在其信号处理函数中执行到期的任务。一般而言，<strong>SIGALRM信号按照固定的频率生成，即由alarm或setitimer函数设 置的定时周期T保持不变。</strong>如果某个定时任务的超时时间不是T的整数 倍，那么它实际被执行的时间和预期的时间将略有偏差。因此定时周 期T反映了定时的精度。</p><p>我们需要先给出一种简单的定时器实现 ——基于升序链表的定时器，并把它应用到处理非活动连接这个实例 中。</p><p>这样，我们才能观察到<strong>SIGALRM信号处理函数是如何处理定时器 并执行定时任务的</strong>。此外，我们介绍这种定时器也是为了和后面要讨论的高效定时器——时间轮和时间堆做对比。</p><h5 id="11-2-1-基于升序链表的定时器"><a href="#11-2-1-基于升序链表的定时器" class="headerlink" title="11.2.1 基于升序链表的定时器"></a>11.2.1 基于升序链表的定时器</h5><p>定时器通常至少要包含两个成员：</p><ul><li>一个超时时间（相对时间或者 绝对时间）</li><li>一个任务回调函数</li><li>有的时候还可能包含回调函数被执 行时需要传入的参数，以及是否重启定时器等信息。</li><li>如果使用链表作为容器来串联所有的定时器，则每个定时器还要包含指向下一个定时 器的指针成员。进一步，如果链表是双向的，则每个定时器还需要包 含指向前一个定时器的指针成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LST_TIMER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span>;</span><span class="comment">/*前向声明*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用户数据结构：客户端socket地址、socket文件描述符、读缓存和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">util_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">util_timer() : prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">time_t</span> expire&#123;&#125;;<span class="comment">/*任务的超时时间，这里使用绝对时间*/</span></span><br><span class="line"><span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*任务回调函数*/</span></span><br><span class="line"><span class="comment">/*回调函数处理的客户数据，由定时器的执行者传递给回调函数*/</span></span><br><span class="line"></span><br><span class="line">client_data *user_data&#123;&#125;;</span><br><span class="line">util_timer *prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">util_timer *next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器链表。它是一个升序、双向链表，且带有头结点和尾节点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort_timer_lst</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">sort_timer_lst() : head(<span class="literal">nullptr</span>), tail(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表被销毁时，删除其中所有的定时器*/</span></span><br><span class="line">~sort_timer_lst() &#123;</span><br><span class="line">util_timer *tmp = head;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">head = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将目标定时器timer添加到链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line">head = tail = timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果目标定时器的超时时间小于当前链表中所有定时器的超时时间，</span></span><br><span class="line"><span class="comment"> * 则把该定时器插入链表头部，作为链表新的头节点。否则就需要调用重载函数</span></span><br><span class="line"><span class="comment">add_timer(util_timer*timer,util_timer*lst_head)，把它插入链表中合适的位</span></span><br><span class="line"><span class="comment">置，以保证链表的升序特性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire) &#123;</span><br><span class="line">timer-&gt;next = head;</span><br><span class="line">head-&gt;prev = timer;</span><br><span class="line">head = timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">add_timer(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当某个定时任务发生变化时，调整对应的定时器在链表中的位置。这个函数只考虑被</span></span><br><span class="line"><span class="comment">调整的定时器的超时时间延长的情况，即该定时器需要往链表的尾部移动*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">util_timer *tmp = timer-&gt;next;</span><br><span class="line"><span class="comment">/*如果被调整的目标定时器处在链表尾部，或者该定时器新的超时值仍然小于其下一个</span></span><br><span class="line"><span class="comment">定时器的超时值，则不用调整*/</span></span><br><span class="line"><span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器是链表的头节点，则将该定时器从链表中取出并重新插入链表*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">add_timer(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器不是链表的头节点，则将该定时器从链表中取出，然后插入其原来所</span></span><br><span class="line"><span class="comment">在位置之后的部分链表中*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">add_timer(timer, timer-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将目标定时器timer从链表中删除*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下面这个条件成立表示链表中只有一个定时器，即目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail)) &#123;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">head = <span class="literal">nullptr</span>;</span><br><span class="line">tail = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的头结点，</span></span><br><span class="line"><span class="comment"> * 则将链表的头结点重置为原头节点的下一个节点，然后删除目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的尾结点，</span></span><br><span class="line"><span class="comment"> * 则将链表的尾结点重置为原尾节点的前一个节点，然后删除目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == tail) &#123;</span><br><span class="line">tail = tail-&gt;prev;</span><br><span class="line">tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果目标定时器位于链表的中间，则把它前后的定时器串联起来，然后删除目标定时器*/</span></span><br><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGALRM信号每次被触发就在其信号处理函数（如果使用统一事件源，则是主函数）</span></span><br><span class="line"><span class="comment">中执行一次tick函数，以处理链表上到期的任务*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;timer tick\n&quot;</span>);</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);<span class="comment">/*获得系统当前的时间*/</span></span><br><span class="line"></span><br><span class="line">util_timer *tmp = head;</span><br><span class="line"><span class="comment">/*从头结点开始依次处理每个定时器，直到遇到一个尚未到期的定时器，这就是定时器的核心逻辑*/</span></span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 因为每个定时器都使用绝对时间作为超时值，所以我们可以把定时器的超时值和系统当前时间，</span></span><br><span class="line"><span class="comment"> * 比较以判断定时器是否到期*/</span></span><br><span class="line"><span class="keyword">if</span> (cur &lt; tmp-&gt;expire) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用定时器的回调函数，以执行定时任务*/</span></span><br><span class="line">tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头结点*/</span></span><br><span class="line">head = tmp-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*一个重载的辅助函数，它被公有的add_timer函数和adjust_timer函数调用。</span></span><br><span class="line"><span class="comment"> * 该函数表示将目标定时器timer添加到节点lst_head之后的部分链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span> </span>&#123;</span><br><span class="line">util_timer *prev = lst_head;</span><br><span class="line">util_timer *tmp = prev-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 遍历lst_head节点之后的部分链表，直到找到一个超时时间大于目标定时器的超时时间的节点，</span></span><br><span class="line"><span class="comment"> * 并将目标定时器插入该节点之前*/</span></span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire) &#123;</span><br><span class="line">prev-&gt;next = timer;</span><br><span class="line">timer-&gt;next = tmp;</span><br><span class="line">tmp-&gt;prev = timer;</span><br><span class="line">timer-&gt;prev = prev;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev = tmp;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果遍历完lst_head节点之后的部分链表，仍未找到超时时间大于目标定时器的超</span></span><br><span class="line"><span class="comment">时时间的节点，则将目标定时器插入链表尾部，并把它设置为链表新的尾节点*/</span></span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">prev-&gt;next = timer;</span><br><span class="line">timer-&gt;prev = prev;</span><br><span class="line">timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">tail = timer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">util_timer *head;</span><br><span class="line">util_timer *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>sort_timer_lst是一 个升序链表。其核心函数tick相当于一个心搏函数，它每隔一段固定的 时间就执行一次，以检测并处理到期的任务。判断定时任务到期的依据是定时器的expire值小于当前的系统时间。</p><p><strong>从执行效率来看，添加定时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)（因为是双向链表），执行定时任务的时间复杂度是O(1)。</strong></p><h5 id="11-2-2-处理非活动连接"><a href="#11-2-2-处理非活动连接" class="headerlink" title="11.2.2 处理非活动连接"></a>11.2.2 处理非活动连接</h5><p>现在我们考虑上述升序定时器链表的实际应用——处理非活动连接。服务器程序通常要定期处理非活动连接：给客户端发一个重连请 求，或者关闭该连接，或者其他。</p><blockquote><p>Linux在内核中提供了对连接是否处 于活动状态的定期检查机制，我们可以通过socket选项KEEPALIVE来 激活它。不过使用这种方式将使得应用程序对连接的管理变得复杂。</p></blockquote><p>比如，代码清单11-3利用alarm函 数周期性地触发SIGALRM信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../11 timer/lst_timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMESLOT 5</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">static</span> sort_timer_lst timer_lst; <span class="comment">/*利用代码清单11-2中的升序链表来管理定时器*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll 添加到内核表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = sig_handler;</span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*定时处理任务，实际上就是调用tick函数*/</span></span><br><span class="line">timer_lst.tick();</span><br><span class="line"><span class="comment">/*因为一次alarm调用只会引起一次SIGALRM信号，所以我们要重新定时，以不断触发SIGALRM信号*/</span></span><br><span class="line">alarm(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器回调函数，它删除非活动连接socket上的注册事件，并关闭之*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span> </span>&#123;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">assert(user_data);</span><br><span class="line">close(user_data-&gt;sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;close fd%d\n&quot;</span>, user_data-&gt;sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置信号处理函数*/</span></span><br><span class="line">addsig(SIGALRM);</span><br><span class="line">addsig(SIGTERM);  <span class="comment">// 主进程发给子进程的结束信号</span></span><br><span class="line"><span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"><span class="keyword">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">alarm(TIMESLOT);<span class="comment">/*定时*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理新到的客户连接*/</span></span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">users[connfd].address = client_address;</span><br><span class="line">users[connfd].sockfd = connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建定时器，设置其回调函数与超时时间，然后绑定定时器与用户数据，最后将定时器添加到链表timer_lst中*/</span></span><br><span class="line"><span class="keyword">auto</span> *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">timer-&gt;user_data = &amp;users[connfd];</span><br><span class="line">timer-&gt;cb_func = cb_func;</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">users[connfd].timer = timer;</span><br><span class="line">timer_lst.add_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// recv成功时返回实际读取到的数据的长度</span></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//handle the error</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ret; ++j) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[j]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGALRM: &#123;</span><br><span class="line"><span class="comment">/* 用timeout变量标记有定时任务需要处理，但不立即处理定时任务。这是因为定时任</span></span><br><span class="line"><span class="comment">务的优先级不是很高，我们优先处理其他更重要的任务*/</span></span><br><span class="line">timeout = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM: &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理客户连接上接收到的数据*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="built_in">memset</span>(users[sockfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">ret = recv(sockfd, users[sockfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of client data%s from%d\n&quot;</span>, ret, users[sockfd].buf, sockfd);</span><br><span class="line">util_timer *timer = users[sockfd].timer;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果发生读错误，则关闭连接，并移除其对应的定时器*/</span></span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">cb_func(&amp;users[sockfd]);</span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line">timer_lst.del_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果对方已经关闭连接，则我们也关闭连接，并移除对应的定时器*/</span></span><br><span class="line">cb_func(&amp;users[sockfd]);</span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line">timer_lst.del_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*如果某个客户连接上有数据可读，则我们要调整该连接对应的定时器，以延迟该连接被关闭的时间*/</span></span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);</span><br><span class="line">timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;adjust timer once\n&quot;</span>);</span><br><span class="line">timer_lst.adjust_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//others</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*最后处理定时事件，因为I/O事件有更高的优先级。当然，这样做将导致定时任务不能精确地按照预期的时间执行*/</span></span><br><span class="line"><span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">timer_handler();</span><br><span class="line">timeout = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">delete</span>[]users;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="11-3-I-O复用系统调用的超时参数"><a href="#11-3-I-O复用系统调用的超时参数" class="headerlink" title="11.3 I/O复用系统调用的超时参数"></a>11.3 I/O复用系统调用的超时参数</h4><p>Linux下的3组I/O复用系统调用都带有超时参数，因此它们不仅能 统一处理信号和I/O事件，也能统一处理定时事件。</p><p>但是由于I/O复用 系统调用可能在超时时间到期之前就返回（有I/O事件发生），所以如 果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT 5000</span></span><br><span class="line"><span class="keyword">int</span> timeout = TIMEOUT;</span><br><span class="line"><span class="keyword">time_t</span> start = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">time_t</span> end = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the timeout is now%d mil-seconds\n&quot;</span>, timeout);</span><br><span class="line">start = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, timeout);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">/*如果epoll_wait成功返回0，则说明超时时间到，此时便可处理定时任务，并重置定时时间*/</span></span><br><span class="line"><span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">timeout = TIMEOUT;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">end = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*如果epoll_wait的返回值大于0，则本次epoll_wait调用持续的时间是(endstart)*1000 ms，</span></span><br><span class="line"><span class="comment"> * 我们需要将定时时间timeout减去这段时间，以获得下次epoll_wait调用的超时参数*/</span></span><br><span class="line">timeout -= (end - start) * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">/*重新计算之后的timeout值有可能等于0，说明本次epoll_wait调用返回时，不仅有文件描述符就绪，</span></span><br><span class="line"><span class="comment"> * 而且其超时时间也刚好到达，此时我们也要处理定时任务，并重置定时时间*/</span></span><br><span class="line"><span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">timeout = TIMEOUT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//handle connections</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-4-高性能计时器"><a href="#11-4-高性能计时器" class="headerlink" title="11.4 高性能计时器"></a>11.4 高性能计时器</h4><h5 id="11-4-1-时间轮"><a href="#11-4-1-时间轮" class="headerlink" title="11.4.1 时间轮"></a>11.4.1 时间轮</h5><p>前文提到，基于排序链表的定时器存在一个问题：添加定时器的效率偏低。</p><p>下面我们要讨论的时间轮解决了这个问题。一种简单的时 间轮如图11-1所示。</p><img src="高性能服务器框架/image-20230305172536051.png" alt="image-20230305172536051" style="zoom:67%;" /><p>图11-1所示的时间轮内，（实线）指针指向轮子上的一个槽 （slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽 （虚线指针指向的槽），每次转动称为一个滴答（tick）。一个滴答的 时间称为时间轮的槽间隔si（slot interval），它实际上就是心搏时间。该时间轮共有N个槽，因此它运转一周的时间是<code>N*si</code>。每个槽指向一条 定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间 相差<code>N*si</code>的整数倍。</p><p>时间轮正是利用这个关系将定时器散列到不同的 链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时 器，则该定时器将被插入槽ts（timer slot）对应的链表中：</p><p><strong>ts = (cs + (ti / si)) % N</strong></p><p>很显然，对时间轮而言，要提高定时精度，就要使si值足够小；要 提高执行效率，则要求N值足够大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIME_WHEEL_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_WHEEL_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">tw_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">tw_timer(<span class="keyword">int</span> rot, <span class="keyword">int</span> ts): next(<span class="literal">nullptr</span>), prev(<span class="literal">nullptr</span>), rotation(rot), time_slot(ts) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> rotation;<span class="comment">/*记录定时器在时间轮转多少圈后生效*/</span></span><br><span class="line"><span class="keyword">int</span> time_slot;<span class="comment">/*记录定时器属于时间轮上哪个槽（对应的链表，下同）*/</span></span><br><span class="line"><span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*定时器回调函数*/</span></span><br><span class="line">client_data *user_data&#123;&#125;;<span class="comment">/*客户数据*/</span></span><br><span class="line">tw_timer *next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">tw_timer *prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_wheel</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">time_wheel() : cur_slot(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">slots[i] = <span class="literal">nullptr</span>;<span class="comment">/*初始化每个槽的头结点*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~time_wheel() &#123;</span><br><span class="line"><span class="comment">/*遍历每个槽，并销毁其中的定时器*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; slot : slots) &#123;</span><br><span class="line">tw_timer *tmp = slot;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">slot = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = slot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据定时值timeout创建一个定时器，并把它插入合适的槽中*/</span></span><br><span class="line"><span class="function">tw_timer *<span class="title">add_timer</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ticks = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*下面根据待插入定时器的超时值计算它将在时间轮转动多少个滴答后被触发，并将该</span></span><br><span class="line"><span class="comment">滴答数存储于变量ticks中。如果待插入定时器的超时值小于时间轮的槽间隔SI，则将</span></span><br><span class="line"><span class="comment">ticks向上折合为1，否则就将ticks向下折合为timeout/SI*/</span></span><br><span class="line"><span class="keyword">if</span> (timeout &lt; SI) &#123;</span><br><span class="line">ticks = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ticks = timeout / SI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*计算待插入的定时器在时间轮转动多少圈后被触发*/</span></span><br><span class="line"><span class="keyword">int</span> rotation = ticks / N;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算待插入的定时器应该被插入哪个槽中*/</span></span><br><span class="line"><span class="keyword">int</span> ts = (cur_slot + (ticks % N)) % N;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建新的定时器，它在时间轮转动rotation圈之后被触发，且位于第ts个槽上*/</span></span><br><span class="line">tw_timer *timer = <span class="keyword">new</span> tw_timer(rotation, ts);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果第ts个槽中尚无任何定时器，则把新建的定时器插入其中，并将该定时器设置为该槽的头结点*/</span></span><br><span class="line"><span class="keyword">if</span> (!slots[ts]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;add timer,rotation is%d,ts is%d,cur_slotis%d\n&quot;</span>, rotation, ts, cur_slot);</span><br><span class="line">slots[ts] = timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则，将定时器插入第ts个槽中*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">timer-&gt;next = slots[ts];</span><br><span class="line">slots[ts]-&gt;prev = timer;</span><br><span class="line">slots[ts] = timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(tw_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ts = timer-&gt;time_slot;</span><br><span class="line"><span class="comment">/*slots[ts]是目标定时器所在槽的头结点。如果目标定时器就是该头结点，则需要重置第ts个槽的头结点*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == slots[ts]) &#123;</span><br><span class="line">slots[ts] = slots[ts]-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (slots[ts]) &#123;</span><br><span class="line">slots[ts]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (timer-&gt;next) &#123;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SI时间到后，调用该函数，时间轮向前滚动一个槽的间隔*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tw_timer *tmp = slots[cur_slot];<span class="comment">/*取得时间轮上当前槽的头结点*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;current slot is%d\n&quot;</span>, cur_slot);</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tick the timer once\n&quot;</span>);</span><br><span class="line"><span class="comment">/*如果定时器的rotation值大于0，则它在这一轮不起作用*/</span></span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;rotation &gt; <span class="number">0</span>) &#123;</span><br><span class="line">tmp-&gt;rotation--;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则，说明定时器已经到期，于是执行定时任务，然后删除该定时器*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line"><span class="keyword">if</span> (tmp == slots[cur_slot]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;delete header in cur_slot\n&quot;</span>);</span><br><span class="line">slots[cur_slot] = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">if</span> (slots[cur_slot]) &#123;</span><br><span class="line">slots[cur_slot]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = slots[cur_slot];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp-&gt;prev-&gt;next = tmp-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;next) &#123;</span><br><span class="line">tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line">tw_timer *tmp2 = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur_slot = ++cur_slot % N;<span class="comment">/*更新时间轮的当前槽，以反映时间轮的转动*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*时间轮上槽的数目*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每1 s时间轮转动一次，即槽间隔为1 s*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SI = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时间轮的槽，其中每个元素指向一个定时器链表，链表无序*/</span></span><br><span class="line">tw_timer *slots[N]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cur_slot;<span class="comment">/*时间轮的当前槽*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TIME_WHEEL_TIMER_H</span></span></span><br></pre></td></tr></table></figure><p><strong>可见，对时间轮而言，添加一个定时器的时间复杂度是O（1）， 删除一个定时器的时间复杂度也是O（1），执行一个定时器的时间复 杂度是O（n）。</strong>但实际上执行一个定时器任务的效率要比O（n）好得 多，因为时间轮将所有的定时器散列到了不同的链表上。时间轮的槽 越多，等价于散列表的入口（entry）越多，从而每条链表上的定时器 数量越少。</p><h5 id="11-4-2-时间堆"><a href="#11-4-2-时间堆" class="headerlink" title="11.4.2 时间堆"></a>11.4.2 时间堆</h5><p>设计 定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器。<strong>然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。</strong></p><p>最小堆很适合处理这种定时方案。最小堆是指每个节点的值都小 于或等于其子节点的值的完全二叉树。图11-2给出了一个具有6个元素 的最小堆。</p><img src="高性能服务器框架/image-20230305174923066.png" alt="image-20230305174923066" style="zoom:33%;" /><p>由于最小堆是一种完全二叉树，所以我们可以用数组来组织其中 的元素。</p><p>比如，图11-2所示的最小堆可以用图11-5所示的数组来表示。 <strong>对于数组中的任意一个位置i上的元素，其左儿子节点在位置2i+1上， 其右儿子节点在位置2i+2上，其父节点则在位置[（i-1）/2]（i＞0） 上</strong>。与用链表来表示堆相比，用数组表示堆不仅节省空间，而且更容 易实现堆的插入、删除等操作[5]。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230305175239841-1678341964417.png" class="" title="image-20230305175239841"><p>假设我们已经有一个包含N个元素的数组，现在要把它初始化为一 个最小堆。那么最简单的方法是：初始化一个空堆，然后将数组中的 每个元素插入该堆中。不过这样做的效率偏低。</p><p>实际上，我们只需要 对数组中的第[（N-1）/2]～0个元素执行下虑操作，即可确保该数组构 成一个最小堆。这是因为对包含N个元素的完全二叉树而言，它具有 [（N-1）/2]个非叶子节点，这些非叶子节点正是该完全二叉树的第0～ [（N-1）/2]个节点。我们只要确保这些非叶子节点构成的子树都具有 堆序性质，整个树就具有堆序性质。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MIN_HEAP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_HEAP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::exception;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span>;</span><span class="comment">/*前向声明*/</span></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">heap_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">heap_timer</span><span class="params">(<span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">expire = time(<span class="literal">nullptr</span>) + delay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">time_t</span> expire;<span class="comment">/*定时器生效的绝对时间*/</span></span><br><span class="line"><span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*定时器的回调函数*/</span></span><br><span class="line">client_data *user_data&#123;&#125;;<span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时间堆类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_heap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*构造函数之一，初始化一个大小为cap的空堆*/</span></span><br><span class="line">explicit time_heap(int cap) throw(std::exception): capacity(cap), cur_size(0) &#123;</span><br><span class="line"><span class="built_in">array</span> = <span class="keyword">new</span> heap_timer *[capacity];<span class="comment">/*创建堆数组*/</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数之二，用已有数组来初始化堆*/</span></span><br><span class="line">time_heap(heap_timer **init_array, <span class="keyword">int</span> size, <span class="keyword">int</span> capacity) <span class="keyword">throw</span></span><br><span class="line">(<span class="built_in">std</span>::exception): cur_size(size), capacity(capacity) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity &lt; size) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span> = <span class="keyword">new</span> heap_timer *[capacity];<span class="comment">/*创建堆数组*/</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*初始化堆数组*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = init_array[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (cur_size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;<span class="comment">/*对数组中的第[(cur_size-1)/2]～0个元素执行下虑操作*/</span></span><br><span class="line">percolate_down(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁时间堆*/</span></span><br><span class="line">~time_heap() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(heap_timer *timer)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur_size &gt;= capacity)<span class="comment">/*如果当前堆数组容量不够，则将其扩大1倍*/</span></span><br><span class="line">&#123;</span><br><span class="line">resize();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*新插入了一个元素，当前堆大小加1，hole是新建空穴的位置*/</span></span><br><span class="line"><span class="keyword">int</span> hole = cur_size++;</span><br><span class="line"><span class="keyword">int</span> parent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对从空穴到根节点的路径上的所有节点执行上虑操作*/</span></span><br><span class="line"><span class="keyword">for</span> (; hole &gt; <span class="number">0</span>; hole = parent) &#123;</span><br><span class="line">parent = (hole - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[parent]-&gt;expire &lt;= timer-&gt;expire) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[hole] = <span class="built_in">array</span>[parent];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[hole] = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(heap_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*仅仅将目标定时器的回调函数设置为空，即所谓的延迟销毁。这将节省真正删除该定</span></span><br><span class="line"><span class="comment">时器造成的开销，但这样做容易使堆数组膨胀*/</span></span><br><span class="line">timer-&gt;cb_func = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获得堆顶部的定时器*/</span></span><br><span class="line"><span class="function">heap_timer *<span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除堆顶部的定时器*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (empty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">/*将原来的堆顶元素替换为堆数组中最后一个元素*/</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[--cur_size];</span><br><span class="line">percolate_down(<span class="number">0</span>);<span class="comment">/*对新的堆顶元素执行下虑操作*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*心搏函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap_timer *tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>);<span class="comment">/*循环处理堆中到期的定时器*/</span></span><br><span class="line"><span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果堆顶定时器没到期，则退出循环*/</span></span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;expire &gt; cur) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则就执行堆顶定时器中的任务*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func) &#123;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func(<span class="built_in">array</span>[<span class="number">0</span>]-&gt;user_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将堆顶元素删除，同时生成新的堆顶定时器（array[0]）*/</span></span><br><span class="line">pop_timer();</span><br><span class="line">tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> cur_size == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*最小堆的下虑操作，它确保堆数组中以第hole个节点作为根的子树拥有最小堆性质*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">percolate_down</span><span class="params">(<span class="keyword">int</span> hole)</span> </span>&#123;</span><br><span class="line">heap_timer *temp = <span class="built_in">array</span>[hole];</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ((hole * <span class="number">2</span> + <span class="number">1</span>) &lt;= (cur_size - <span class="number">1</span>)); hole = child) &#123;</span><br><span class="line">child = hole * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((child &lt; (cur_size - <span class="number">1</span>)) &amp;&amp; (<span class="built_in">array</span>[child + <span class="number">1</span>]-&gt;expire &lt; <span class="built_in">array</span>[child]-&gt;expire)) &#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[child]-&gt;expire &lt; temp-&gt;expire) &#123;</span><br><span class="line"><span class="built_in">array</span>[hole] = <span class="built_in">array</span>[child];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[hole] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将堆数组容量扩大1倍*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> **temp = <span class="keyword">new</span> heap_timer *[<span class="number">2</span> * capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * capacity; ++i) &#123;</span><br><span class="line">temp[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">capacity = <span class="number">2</span> * capacity;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line">temp[i] = <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span> = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">heap_timer **<span class="built_in">array</span>;<span class="comment">/*堆数组*/</span></span><br><span class="line"><span class="keyword">int</span> capacity;<span class="comment">/*堆数组的容量*/</span></span><br><span class="line"><span class="keyword">int</span> cur_size;<span class="comment">/*堆数组当前包含元素的个数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>由代码清单11-6可见，对时间堆而言，添加一个定时器的时间复杂 度是O（lgn），删除一个定时器的时间复杂度是O（1），执行一个定 时器的时间复杂度是O（1）。因此，时间堆的效率是很高的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二篇-高性能服务器框架&quot;&gt;&lt;a href=&quot;#第二篇-高性能服务器框架&quot; class=&quot;headerlink&quot; title=&quot;第二篇 高性能服务器框架&quot;&gt;&lt;/a&gt;第二篇 高性能服务器框架&lt;/h2&gt;&lt;h3 id=&quot;第5章-Linux网络编程基础API&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Linux" scheme="http://okeyia.github.io/categories/Linux/"/>
    
    
    <category term="服务器编程" scheme="http://okeyia.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>一 TCP/IP协议详解</title>
    <link href="http://okeyia.github.io/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://okeyia.github.io/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-12-09T09:34:01.000Z</published>
    <updated>2023-03-10T02:54:14.046Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一篇-TCP-IP协议详解"><a href="#第一篇-TCP-IP协议详解" class="headerlink" title="第一篇 TCP/IP协议详解"></a>第一篇 TCP/IP协议详解</h2><h3 id="第1章-TCP-IP协议族"><a href="#第1章-TCP-IP协议族" class="headerlink" title="第1章 TCP/IP协议族"></a>第1章 TCP/IP协议族</h3><p>本章则简单介绍其中几个相关协议：ICMP协议、ARP协 议和DNS协议，学习它们对于理解网络通信很有帮助。</p><h4 id="1-1-TCP-IP协议族体系结构以及主要协议"><a href="#1-1-TCP-IP协议族体系结构以及主要协议" class="headerlink" title="1.1 TCP/IP协议族体系结构以及主要协议"></a>1.1 TCP/IP协议族体系结构以及主要协议</h4><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223191117670.png" class="" title="image-20230223191117670"><h5 id="1-1-1-数据链路层"><a href="#1-1-1-数据链路层" class="headerlink" title="1.1.1 数据链路层"></a>1.1.1 数据链路层</h5><p>数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理 媒介（比如以太网、令牌环等）上的传输。</p><p>数据链路层两个常用的协议是ARP协议（Address Resolve Protocol，地址解析协议）和RARP协议（Reverse Address Resolve Protocol，逆地址解析协议）。它们实现了IP地址和机器物理地址（通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址） 之间的相互转换。</p><p>网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻 址一台机器，因此<strong>网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。</strong></p><p>RARP 协议仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作 站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网 络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服 务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p><h5 id="1-1-3-传输层"><a href="#1-1-3-传输层" class="headerlink" title="1.1.3 传输层"></a>1.1.3 传输层</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223203039797.png" class="" title="image-20230223203039797"><p>垂直的实线箭头表示TCP/IP协议族各层之间的实体通信 （数据包确实是沿着这些线路传递的），而水平的虚线箭头表示逻辑 通信线路。该图中还附带描述了不同物理网络的连接方法。</p><p>可见，数 据链路层（驱动程序）封装了物理网络的电气细节；网络层封装了网 络连接的细节；传输层则为应用程序封装了一条端到端的逻辑通信链 路，它负责数据的收发、链路的超时重连等。</p><p>传输层协议主要有三个：TCP协议、UDP协议和SCTP协议。</p><p>TCP协议（Transmission Control Protocol，传输控制协议）为应用 层提供可靠的、面向连接的和基于流（stream）的服务。</p><p>TCP协议使用 超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因 此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接， 并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读 写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以 释放这些内核数据。<strong>TCP服务是基于流的。基于流的数据没有边界（长 度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个 字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。</strong></p><p>UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协 议完全相反，它为应用层提供不可靠、无连接和基于数据报的服 务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目 的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误 而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此， 使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻 辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此 应用程序每次发送数据都要明确指定接收端的地址（IP地址等信 息）。<strong>基于数据报的服务，是相对基于流的服务而言的。每个UDP数 据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一 次性读出，否则数据将被截断。</strong></p><h4 id="1-7-socket和TCP-IP协议族的关系"><a href="#1-7-socket和TCP-IP协议族的关系" class="headerlink" title="1.7  socket和TCP/IP协议族的关系"></a>1.7  socket和TCP/IP协议族的关系</h4><p>由socket定义的这一组API提供如下两点功能：</p><ol><li>将应用程序数 据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，以交付内核来发 送数据（比如图1-5所示的send函数），或者是从内核TCP/UDP接收缓 冲区中复制数据到用户缓冲区，以读取数据；</li><li>应用程序可以通过 它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精 细地控制底层通信的行为。比如可以通过setsockopt函数来设置IP数据 报在网络上的存活时间。我们将在第5章详细讨论这一组API。</li></ol><h3 id="第2章-IP协议详解"><a href="#第2章-IP协议详解" class="headerlink" title="第2章 IP协议详解"></a>第2章 IP协议详解</h3><p>P协议是TCP/IP协议族的核心协议，也是socket网络编程的基础之 一。</p><p>本章从两个方面较为深入地探讨IP协议：</p><ul><li>IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通 信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分 通信行为。</li><li>IP数据报的路由和转发。IP数据报的路由和转发发生在除目标 机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及 如何转发。</li></ul><h4 id="2-1-IP服务的特点"><a href="#2-1-IP服务的特点" class="headerlink" title="2.1 IP服务的特点"></a>2.1 IP服务的特点</h4><p><strong>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</strong></p><ul><li><strong>无状态（stateless）是指IP通信双方不同步传输数据的状态信息， 因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。</strong>这种服务最大的缺点是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收 端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这 两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数 据报之间没有任何上下文关系。</li><li><strong>无连接（connectionless）是指IP通信双方都不长久地维持对方的 任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对 方的IP地址。</strong></li><li><strong>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是 承诺尽最大努力（best effort）。</strong>很多种情况都能导致IP数据报发送失 败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长 （根据IP数据报头部字段TTL判断，见后文），那么它将丢弃之，并 返回一个ICMP错误消息（超时错误）给发送端。又比如，接收端发现 收到的IP数据报不正确（通过校验机制），它也将丢弃之，并返回一 个ICMP错误消息（IP头部参数错误）给发送端。</li></ul><h4 id="2-2-IPv4头部结构"><a href="#2-2-IPv4头部结构" class="headerlink" title="2.2 IPv4头部结构"></a>2.2 IPv4头部结构</h4><h5 id="2-2-1-IPv4头部结构"><a href="#2-2-1-IPv4头部结构" class="headerlink" title="2.2.1 IPv4头部结构"></a>2.2.1 IPv4头部结构</h5><p>通常为20字节</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223192622355.png" class="" title="image-20230223192622355"><h4 id="2-3-IP分片"><a href="#2-3-IP分片" class="headerlink" title="2.3 IP分片"></a>2.3 IP分片</h4><p>前文曾提到，当IP数据报的长度超过帧的MTU时，它将被分片传 输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能 在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才 会被内核中的IP模块重新组装。</p><p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息：<strong>数据报标识、标志和片偏移</strong>。一个IP数据报的每个分片都具有自己的IP头 部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一 个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总 长度字段将被设置为该分片的长度。</p><p>以太网帧的MTU是1500字节（可以通过ifconfig命令或者netstat命 令查看），因此它携带的IP数据报的数据部分最多是1480字节（IP头部 占用20字节）。考虑用IP数据报封装一个长度为1481字节的ICMP报文 （包括8字节的ICMP头部，所以其数据部分长度为1473字节），则该 数据报在使用以太网帧传输时必须被分片，如图2-2所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223194207843.png" class="" title="image-20230223194207843"><p>图2-2中，长度为1501字节的IP数据报被拆分成两个IP分片，第一 个IP分片长度为1500字节，第二个IP分片的长度为21字节。每个IP分片 都包含自己的IP头部（20字节），且第一个IP分片的IP头部设置了MF 标志，而第二个IP分片的IP头部则没有设置该标志，因为它已经是最后 一个分片了。原始IP数据报中的ICMP头部内容被完整地复制到了第一 个IP分片中。第二个IP分片不包含ICMP头部信息，因为IP模块重组该 ICMP报文的时候只需要一份ICMP头部信息，重复传送这个信息没有 任何益处。1473字节的ICMP报文数据的前1472字节被IP模块复制到第 一个IP分片中，使其总长度为1500字节，从而满足MTU的要求；而多 出的最后1字节则被复制到第二个IP分片中。</p><h4 id="2-4-IP路由"><a href="#2-4-IP路由" class="headerlink" title="2.4 IP路由"></a>2.4 IP路由</h4><h3 id="第3章-TCP协议详解"><a href="#第3章-TCP协议详解" class="headerlink" title="第3章 TCP协议详解"></a>第3章 TCP协议详解</h3><p>和IP协议相比， TCP协议更靠近应用层，因此在应用程序中具有更强的可操作性。一些 重要的socket选项都和TCP协议相关。</p><p>本章从如下四方面来讨论TCP协议：</p><ol><li>TCP头部信息。TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的 数据流。</li><li>TCP状态转移过程。TCP连接的任意一端都是一个状态机。在 TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。</li><li>TCP数据流。通过分析TCP数据流，我们就可以从网络应用程序 外部来了解应用层协议和通信双方交换的应用程序数据。这一部分将 讨论两种类型的TCP数据流：交互数据流和成块数据流。TCP数据流中 有一种特殊的数据，称为紧急数据，我们也将简单讨论之。</li><li>TCP数据流的控制。为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。这一部分讨论TCP数据流控制的两个方 面：超时重传和拥塞控制。</li></ol><h4 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h4><p><strong>TCP协议相对于 UDP协议的特点是：面向连接、字节流和可靠传输。</strong>使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读 写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和 连接上数据的传输。TCP连接是全双工的，即双方的数据读写可以通过 一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放 系统资源。</p><p>TCP协议的这种连接是一对一的，所以基于广播和多播（目标是多 个主机地址）的应用程序不能使用TCP服务。而无连接协议UDP则非常 适合于广播和多播。</p><p>当接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应 用程序数据按照TCP报文段的序号（见后文）依次放入TCP接收缓冲区 中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收 缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的 应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模 块接收到的TCP报文段个数之间也没有固定的数量关系。</p><p>UDP则不然。发送端应用程序每执行一 次写操作，UDP模块就将其封装成一个UDP数据报并发送之。<strong>接收端 必须及时针对每一个UDP数据报执行读操作（通过recvfrom系统调 用），否则就会丢包（这经常发生在较慢的服务器上）。</strong>并且，如果 用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将 被截断。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223203748839.png" class="" title="image-20230223203748839"><p>TCP传输是可靠的。首先，TCP协议采用发送应答机制，即发送端 发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文 段传输成功。其次，TCP协议采用超时重传机制，发送端在发送出一个 TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发 该报文段。最后，因为TCP报文段最终是以IP数据报发送的，而IP数据 报到达接收端可能乱序、重复，所以TCP协议还会对接收到的TCP报文 段重排、整理，再交付给应用层。</p><h4 id="3-2-TCP头部结构"><a href="#3-2-TCP头部结构" class="headerlink" title="3.2 TCP头部结构"></a>3.2 TCP头部结构</h4><h4 id="3-3-TCP的建立与关闭"><a href="#3-3-TCP的建立与关闭" class="headerlink" title="3.3 TCP的建立与关闭"></a>3.3 TCP的建立与关闭</h4><h5 id="3-3-1-使用tcpdump观察TCP连接的建立和关闭"><a href="#3-3-1-使用tcpdump观察TCP连接的建立和关闭" class="headerlink" title="3.3.1 使用tcpdump观察TCP连接的建立和关闭"></a>3.3.1 使用tcpdump观察TCP连接的建立和关闭</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223204422693.png" class="" title="image-20230223204422693"><p>因为整个过程并没有发生应用层数据的交换，所以TCP报文段的数 据部分的长度（length）总是0。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223204455397.png" class="" title="image-20230223204455397"><p>第1个TCP报文段包含SYN标志，因此它是一个同步报文段，即 ernest-laptop（客户端）向Kongming20（服务器）发起连接请求。同 时，该同步报文段包含一个ISN值为535734930的序号。</p><p>第2个TCP报文 段也是同步报文段，表示Kongming20同意与ernest-laptop建立连接。同 时它发送自己的ISN值为2159701207的序号，并对第1个同步报文段进 行确认。确认值是535734931，即第1个同步报文段的序号值加1。</p><p>第3个TCP报文段是ernest-laptop对第2个同步报文段的确认。至 此，TCP连接就建立起来了。建立TCP连接的这3个步骤被称为TCP三 次握手。 （从第3个TCP报文段开始，tcpdump输出的序号值和确认值都是相对 初始ISN值的偏移。当然，我们可以开启tcpdump的-S选项来选择打印 序号的绝对值。)</p><p><strong>后面4个TCP报文段是关闭连接的过程。</strong></p><p>第4个TCP报文段包含FIN 标志，因此它是一个结束报文段，即ernest-laptop要求关闭连接。结束 报文段和同步报文段一样，也要占用一个序号值。</p><p>Kongming20用TCP 报文段5来确认该结束报文段。</p><p>紧接着Kongming20发送自己的结束报文 段6，ernest-laptop则用TCP报文段7给予确认。实际上，仅用于确认目 的的确认报文段5是可以省略的，因为结束报文段6也携带了该确认信 息。确认报文段5是否出现在连接断开的过程中，取决于TCP的延迟确 认特性。延迟确认将在后面讨论。</p><h5 id="3-3-2-半关闭状态"><a href="#3-3-2-半关闭状态" class="headerlink" title="3.3.2 半关闭状态"></a>3.3.2 半关闭状态</h5><p>TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。换言之，<strong>通信的一端可以发送结束报文段给对方，告诉它本端已 经完成了数据的发送，但允许继续接收来自对方的数据，</strong>直到对方也 发送结束报文段以关闭连接。TCP连接的这种状态称为半关闭（half close）状态，如图3-7所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223204900972.png" class="" title="image-20230223204900972"><p>在图3-7中，服务器和客户端应用程序判断对方是否已经 关闭连接的方法是：read系统调用返回0（收到结束报文段）。当然， Linux还提供其他检测连接是否被对方关闭的方法，这将在后续章节讨 论。</p><h4 id="3-4-TCP-状态转移"><a href="#3-4-TCP-状态转移" class="headerlink" title="3.4 TCP 状态转移"></a>3.4 TCP 状态转移</h4><h5 id="3-4-2-TIME-WAIT状态"><a href="#3-4-2-TIME-WAIT状态" class="headerlink" title="3.4.2 TIME_WAIT状态"></a>3.4.2 TIME_WAIT状态</h5><img src="TCPIP协议详解/image-20230310104904354.png" alt="image-20230310104904354" style="zoom:50%;" /><p>从图3-9来看，客户端连接在收到服务器的结束报文段（TCP报文 段6）之后，并没有直接进入CLOSED状态[1]，而是转移到TIME_WAIT 状态。在这个状态，客户端连接要等待一段长为2MSL（Maximum Segment Life，报文段最大生存时间）的时间，才能完全关闭。MSL是 TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2 min。</p><p>TIME_WAIT状态存在的原因有两点：</p><ul><li><p>可靠地终止TCP连接。</p><blockquote><p>假设图3-9中用于确认服务器结束报文段6的 TCP报文段7丢失，那么服务器将重发结束报文段。<strong>因此客户端需要停留在某个状态以处理重复收到的结束报文段（即向服务器发送确认报 文段）。</strong> 否则，客户端将以复位报文段来回应服务器，服务器则认为 这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文 段。</p></blockquote></li><li><p>保证让迟来的TCP报文段有足够的时间被识别并丢弃。</p><blockquote><p>在Linux系统上，一个TCP端口不能被同时打开多次（两次及以 上）。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用 该连接占用着的端口来建立一个新连接。反过来思考，<strong>如果不存在 TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似 的连接（这里说的相似，是指它们具有相同的IP地址和端口号）。</strong> 这 个新的、和原来相似的连接被称为原来的连接的化身（incarnation）。 新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文 段（迟到的报文段），这显然是不应该发生的。这就是TIME_WAIT状 态存在的第二个原因。</p></blockquote></li></ul><h4 id="3-6-TCP交互数据流"><a href="#3-6-TCP交互数据流" class="headerlink" title="3.6 TCP交互数据流"></a>3.6 TCP交互数据流</h4><p>TCP报文段所携带的应用程序数据按照长度 分为两种：交互数据和成块数据。</p><ul><li><p>交互数据仅包含很少的字节。使用 交互数据的应用程序（或协议）对实时性要求高，比如telnet、ssh等。</p></li><li><p>成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块 数据的应用程序（或协议）对传输效率要求高，比如ftp。本节我们讨 论交互数据流。</p></li></ul><h4 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据"></a>3.8 带外数据</h4><p>有些传输层协议具有带外（Out Of Band，OOB）数据的概念，用 于迅速通告对方本端发生的重要事件。</p><p>因此，带外数据比普通数据 （也称为带内数据）有更高的优先级，它应该总是立即被发送，而不 论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可 以使用一条独立的传输层连接，也可以映射到传输普通数据的连接 中。实际应用中，带外数据的使用很少见，已知的仅有telnet、ftp等远 程非活跃程序。</p><p>UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过 TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提 供了一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧 急数据。这种紧急数据的含义和带外数据类似，因此后文也将TCP紧急 数据称为带外数据。</p><ul><li>我们先来介绍TCP发送带外数据的过程。假设一个进程已经往某个 TCP连接的发送缓冲区中写入了N字节的普通数据，并等待其发送。</li><li>在 数据被发送前，该进程又向这个连接写入了3字节的带外数据“abc”。</li><li>此 时，待发送的TCP报文段的<strong>头部将被设置URG标志</strong>，并且紧急指针被 设置为指向最后一个带外数据的下一字节（进一步减去当前TCP报文段 的序号值得到其头部中的紧急偏移值），如图3-10所示。<img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224211617697.png" class="" title="image-20230224211617697"></li></ul><p>由图3-10可见，发送端一次发送的多字节的带外数据中只有最后一 字节被当作带外数据（字母c），而其他数据（字母a和b）被当成了普 通数据。<strong>如果TCP模块以多个TCP报文段来发送图3-10所示TCP发送缓 冲区中的内容，则每个TCP报文段的头部都将设置URG标志，并且它们的紧 急指针指向同一个位置（数据流中带外数据的下一个位置），但只有 一个TCP报文段真正携带带外数据。</strong></p><p>现在考虑TCP接收带外数据的过程。TCP接收端只有在接收到紧急 指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外 数据的位置，并将它读入一个特殊的缓存中。<strong>这个缓存只有1字节，称 为带外缓存。</strong>如果上层应用程序没有及时将带外数据从带外缓存中读 出，则后续的带外数据（如果有的话）将覆盖它。</p><h4 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h4><p>慢启动（slow start）、</p><p>拥塞避免（congestion avoidance）、</p><p>快速重传（fast retransmit）</p><p>快速恢复（fast recovery）。</p><p><strong>拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其 中第一个数据的确认之前）的数据量，我们称为SWND（Send Window，发送窗口[1]）。不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。</strong>这些TCP 报文段的最大长度（仅指数据部分）称为SMSS（Sender Maximum Segment Size，发送者最大段大小），其值一般等于MSS。</p><h3 id="第4章-TCP-IP通信案例：访问Internet上的Web服务器"><a href="#第4章-TCP-IP通信案例：访问Internet上的Web服务器" class="headerlink" title="第4章 TCP/IP通信案例：访问Internet上的Web服务器"></a>第4章 TCP/IP通信案例：访问Internet上的Web服务器</h3><h4 id="4-1-实例综图"><a href="#4-1-实例综图" class="headerlink" title="4.1 实例综图"></a>4.1 实例综图</h4><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224091619497.png" class="" title="image-20230224091619497"><p>wget客户端程序和代理服务器之间，以及代理服务 器与Web服务器之间都是使用HTTP协议通信的。</p><h4 id="4-2-部署代理服务器"><a href="#4-2-部署代理服务器" class="headerlink" title="4.2 部署代理服务器"></a>4.2 部署代理服务器</h4><p>在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代 理服务器，它们提供对目标资源的中转访问。一个HTTP请求可能被多 个代理服务器转发，后面的服务器称为前面服务器的上游服务器。</p><p>代 理服务器按照其使用方式和作用，分为<strong>正向代理服务器、反向代理服 务器和透明代理服务器。</strong></p><ul><li>正向代理要求客户端自己设置代理服务器的地址。客户的每次请 求都将直接发送到该代理服务器，并由代理服务器来请求目标资源。</li><li>反向代理则被设置在服务器端，因而客户端无须进行任何设置。 反向代理是指用代理服务器来接收Internet上的连接请求，然后将请求 转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给 客户端。</li><li>透明代理只能设置在网关上。用户访问Internet的数据报必然都经 过网关，如果在网关上设置代理，则该代理对用户来说显然是透明 的。透明代理可以看作正向代理的一种特殊情况。</li></ul><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224091945626.png" class="" title="image-20230224091945626"><h4 id="4-3-使用tcpdump抓取传输数据包"><a href="#4-3-使用tcpdump抓取传输数据包" class="headerlink" title="4.3 使用tcpdump抓取传输数据包"></a>4.3 使用tcpdump抓取传输数据包</h4><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224101238917.png" class="" title="image-20230224101238917"><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224092256808.png" class="" title="image-20230224092256808"><p>但为了讨论问题的方便，我们将这43个数据包按照其逻辑关 系分为如下4个部分：</p><ul><li>代理服务器访问DNS服务器以查询域名<a href="http://www.baidu.com对应的ip/">www.baidu.com对应的IP</a> 地址，包括数据包8、9。</li><li>代理服务器查询路由器MAC地址的ARP请求和应答，包括数据 包6、7。</li><li>wget客户端（192.168.1.109）和代理服务器（192.168.1.108）之 间的HTTP通信，包括数据包1～5、23～25、32～40、42和43。</li><li>代理服务器和Web服务器（119.75.218.77）之间的HTTP通信， 包括数据包10～22、26～31和41。</li></ul><h4 id="4-4-访问DNS服务器"><a href="#4-4-访问DNS服务器" class="headerlink" title="4.4 访问DNS服务器"></a>4.4 访问DNS服务器</h4><p>数据包8、9表示代理服务器ernest-laptop向DNS服务器 （219.239.26.42，首选DNS服务器的IP地址，见1.6.2节）查询域名 <a href="http://www.baidu.com对应的ip地址,并得到了回复.该回复包括一个主机别/">www.baidu.com对应的IP地址，并得到了回复。该回复包括一个主机别</a> 名（<a href="http://www.a.shifen.com)和两个ip地址(119.75.218.77和/">www.a.shifen.com）和两个IP地址（119.75.218.77和</a> 119.75.217.56）。</p><p>代理服务器执行DNS查询的完整过程如图4-3所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224093159050.png" class="" title="image-20230224093159050"><p>根据路由策略，目标IP地址（219.239.26.42）仅能匹配路由表 中的默认路由项，因此该IP数据报先被发送至路由器（IP地址为 192.168.1.1），然后通过路由器来转发。<strong>因为ernest-laptop的ARP缓存 中没有与路由器对应的缓存项（我们手动将其删除了），所以ernest-aptop需要发起一个ARP广播以查询路由器的IP地址，而这正是数据包6 描述的内容。</strong></p><p><strong>路由器则通过ARP应答告诉ernest-laptop自己的MAC地址 是14:e6:e4:93:5b:78，如数据包7所示。</strong>最终，以太网驱动程序将IP数据 报封装成以太网帧发送给路由器。此后，代理服务器再次发送数据到 Internet时将不再需要ARP查询，因为ernest-laptop的ARP高速缓存中已 经记录了路由器的IP地址和MAC地址的映射关系。</p><p>==注意:== 虽然IP数据报是先发送到路由器，再由它转发给 目标主机，但是其头部的目标IP地址却是最终的目标主机（DNS服务 器）的IP地址，而不是中转路由器的IP地址（192.168.1.1）。</p><p>这说明， IP头部的源端IP地址和目的端IP地址在转发过程中是始终不变的（一种 例外是源路由选择）。但帧头部的源端物理地址和目的端物理地址在 转发过程中则是一直在变化的。</p><h4 id="4-5-本地名称查询"><a href="#4-5-本地名称查询" class="headerlink" title="4.5 本地名称查询"></a>4.5 本地名称查询</h4><p>Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件 中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文 件。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224094308966.png" class="" title="image-20230224094308966"><p>当wget访问某个Web服务器时，它先读取环境变 量http_proxy。如果该环境变量被设置，并且我们没有阻止wget使用代 理服务，则wget将通过http_proxy指定的代理服务器来访问Web服务。 但http_proxy环境变量中包含主机名ernest-laptop，因此wget将首先读 取/etc/hosts配置文件，试图通过它来解析主机名ernest-laptop对应的IP 地址。其结果正如wget的输出所示，解析成功。</p><p>如果程序在/etc/hosts文件中未找到目标机器名对应的IP地址，它 将求助于DNS服务。</p><h4 id="4-6-HTTP通信"><a href="#4-6-HTTP通信" class="headerlink" title="4.6 HTTP通信"></a>4.6 HTTP通信</h4><p>为了方便讨论，我们将wget客户端和代理服务器之间的通信过程 画成图4-4所示的TCP时序图</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224095552897.png" class="" title="image-20230224095552897"><p>首先应该注意的是，TCP连接从建立到关闭的过程中，客户端仅给 服务器发送了一个HTTP请求（即TCP报文段4），该请求的长度为136 字节（见代码清单4-2中TCP报文段4的length值）。</p><p>代理服务器则用6个 TCP报文段（23、24、25、33、35和36）给客户端返回了总长度为8522 字节（<strong>这可以从对方的最后一个确认报文段42的确认值计算得到，考虑同步报文段和结束报文段各占用一个序号</strong>）的HTTP应答。客户端使 用了7个TCP报文段（32、34、37、38、39、40和42）来确认这8522字 节的HTTP应答数据。</p><p>下面我们简单分析一下这136字节的HTTP请求和8522字节的HTTP 应答的部分主要内容（开启tcpdump的-X选项来查看）。</p><h5 id="4-6-1-HTTP-请求"><a href="#4-6-1-HTTP-请求" class="headerlink" title="4.6.1 HTTP 请求"></a>4.6.1 HTTP 请求</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224100629900.png" class="" title="image-20230224100629900"><p>第1行是请求行。其中“GET”是请求方法，表示客户端以只读的方 式来申请资源。常见的HTTP请求方法有9种，如表4-1所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224100838654.png" class="" title="image-20230224100838654"><p>GET、HEAD、OPTIONS、TRACE、PUT和DELETE 等请求方法被认为是等幂的（idempotent），即多次连续的、重复的请 求和只发送一次该请求具有完全相同的效果。而POST方法则不同，连 续多次发送同样一个请求可能进一步影响服务器上的资源。</p><p>“<a href="http://www.baidu.com/index.html%E2%80%9D%E6%98%AF%E7%9B%AE%E6%A0%87%E8%B5%84%E6%BA%90%E7%9A%84URL%E3%80%82%E5%85%B6">http://www.baidu.com/index.html”是目标资源的URL。其</a> 中“http”是所谓的scheme，表示获取目标资源需要使用的应用层协议。 其他常见的scheme还有ftp、rtsp和file等。“<a href="http://www.baidu.com”指定资源所/">www.baidu.com”指定资源所</a> 在的目标主机。<strong>“index.html”指定资源文件的名称，这里指的是服务器 根目录（站点的根目录，而不是服务器的文件系统根目录“/”）中的索 引文件。</strong></p><ul><li><p>“HTTP/1. 0”表示客户端（wget程序）使用的HTTP的版本号是1.0。 目前的主流HTTP版本是1.1。</p></li><li><p>HTTP请求内容中的第2～4行都是HTTP请求的头部字段。一个 HTTP请求可以包含多个头部字段。一个头部字段用一行表示，包含字 段名称、冒号、空格和字段的值。HTTP请求中的头部字段可按任意顺 序排列。</p></li><li><p>“User-Agent:Wget/1. 12(linux-gnu)”表示客户端使用的程序是wget。 </p></li><li><p>“Host:www. baidu.com”表示目标主机名是<a href="http://www.baidu.com.http/">www.baidu.com。HTTP</a> 协议规定HTTP请求中必须包含的头部字段就是目标主机名。</p></li><li><p>“Connection:close”是我们执行wget命令时传入的（见代码清单4- 1），用以告诉服务器处理完这个HTTP请求之后就关闭连接。</p><blockquote><p>在旧的 HTTP协议中，Web客户端和Web服务器之间的一个TCP连接只能为一 个HTTP请求服务。当处理完客户的一个HTTP请求之后，Web服务器就 （主动）将TCP连接关闭了。此后，同一客户如果要再发送一个HTTP 请求的话，必须与服务器建立一个新的TCP连接。也就是说，<strong>同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为短连接。</strong></p><p><strong>长连接与之相反，是指多个请求可以使用同一个TCP连接。长连接在编程上稍微复杂一些，但性能上却有很大提高：它极大地减少了网络上 为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。</strong></p></blockquote></li></ul><p><strong>在所有头部字段之后，HTTP请求必须包含一个空行，以标识头部 字段的结束。</strong>请求行和每个头部字段都必须以＜CR＞＜LF＞结束（回 车符和换行符）；而空行则必须只包含一个＜CR＞＜LF＞，不能有其 他字符，甚至是空白字符。 </p><p>在空行之后，HTTP请求可以包含可选的消息体。如果消息体非 空，则HTTP请求的头部字段中必须包含描述该消息体长度的字 段“Content-Length”。我们的实例只是获取目标服务器上的资源，所以 没有消息体。</p><h5 id="4-6-2-HTTP应答"><a href="#4-6-2-HTTP应答" class="headerlink" title="4.6.2 HTTP应答"></a>4.6.2 HTTP应答</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224101613564.png" class="" title="image-20230224101613564"><p><strong>第一行是状态行。</strong>“HTTP/1.0”是服务器使用的HTTP协议的版本 号。通常，服务器需要使用和客户端相同的HTTP协议版本。“200 OK”是状态码和状态信息。常见的状态码和状态信息及其含义如表4-2 所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224101716998.png" class="" title="image-20230224101716998"><p>第2～7行是HTTP应答的头部字段。其表示方法与HTTP请求中的 头部字段相同。</p><ul><li>“Server:BWS/1. 0”表示目标Web服务器程序的名字是BWS（Baidu Web Server）。 </li><li>“Content-Length:8024”表示目标文档的长度为8024字节。这个值和 wget输出的文档长度一致。</li><li>“Content-Type:text/html;charset=gbk”表示目标文档的MIME类型。 其中“text”是主文档类型，“html”是子文档类型。“text/html”表示目标文 档index.html是text类型中的html文档。“charset”是text文档类型的一个参 数，用于指定文档的字符编码。</li><li>“Set-Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expires=Wed,04-Jul-42 00:10:47 GMT;path=/;domain=. baidu.com”表示服务器 传送一个Cookie给客户端。其中，“BAIDUID”指定Cookie的名 字，“expires”指定Cookie的生存时间，“domain”和“path”指定该Cookie 生效的域名和路径。下面我们简单分析一下Cookie的作用。</li><li>“Via:1. 0 localhost(squid/3.0 STABLE18)”表示HTTP应答在返回过程 中经历过的所有代理服务器的地址和名称。这里的localhost实际上指的 是“192.168.1.108”。这个头部字段的功能有点类似于IP协议的记录路由 功能。</li></ul><p>第2章中曾提到，<strong>HTTP协议是一种无状态的协议，即每个HTTP请求之间没有任何上下文关系。</strong>如果服务器处理后续HTTP请求时需要用 到前面的HTTP请求的相关信息，客户端必须重传这些信息。这样就导 致HTTP请求必须传输更多的数据。</p><p>在交互式Web应用程序兴起之后，HTTP协议的这种无状态特性就显得不适应了，因为交互程序通常要承上启下。因此，我们要使用额 外的手段来保持HTTP连接状态，常见的解决方法就是Cookie。<strong>Cookie 是服务器发送给客户端的特殊信息（通过HTTP应答的头部字段“Set-Cookie”），客户端每次向服务器发送请求的时候都需要带上这些信息 （通过HTTP请求的头部字段“Cookie”）。这样服务器就可以区分不同 的客户了。基于浏览器的自动登录就是用Cookie实现的。</strong></p><p>在所有头部字段之后，HTTP应答必须包含一个空行，以标识头部 字段的结束。状态行和每个头部字段都必须以＜CR＞＜LF＞结束；而 空行则必须只包含一个＜CR＞＜LF＞，不能有其他字符，甚至是空白 字符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一篇-TCP-IP协议详解&quot;&gt;&lt;a href=&quot;#第一篇-TCP-IP协议详解&quot; class=&quot;headerlink&quot; title=&quot;第一篇 TCP/IP协议详解&quot;&gt;&lt;/a&gt;第一篇 TCP/IP协议详解&lt;/h2&gt;&lt;h3 id=&quot;第1章-TCP-IP协议族&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Linux" scheme="http://okeyia.github.io/categories/Linux/"/>
    
    
    <category term="服务器编程" scheme="http://okeyia.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>现代 C++ 教程</title>
    <link href="http://okeyia.github.io/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/"/>
    <id>http://okeyia.github.io/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/</id>
    <published>2022-11-18T07:32:08.000Z</published>
    <updated>2023-02-27T07:37:24.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现代-C-教程"><a href="#现代-C-教程" class="headerlink" title="现代 C++ 教程"></a>现代 C++ 教程</h2><p><strong>现代 C++</strong> (本书中均指 C++11/14/17/20) 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。</p><h3 id="一-迈向现代C"><a href="#一-迈向现代C" class="headerlink" title="一 迈向现代C++"></a>一 迈向现代C++</h3><h4 id="1-1-被弃用的特性"><a href="#1-1-被弃用的特性" class="headerlink" title="1.1 被弃用的特性"></a>1.1 被弃用的特性</h4><p><strong>注意</strong>：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽 量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分 特性其实会『永久』保留。</p><ul><li>不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。 如 char *str = “hello world!”;    // 将出现弃用警告</li><li>auto_ptr 被弃用，应使用 unique_ptr。</li><li>特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 <code>&lt;ccomplex&gt;</code>与**<cstdalign>**  等</li></ul><h4 id="1-2-与C的兼容性"><a href="#1-2-与C的兼容性" class="headerlink" title="1.2 与C的兼容性"></a>1.2 与C的兼容性</h4><p>出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码，例如 Linux 系统调用。</p><p>从现在开始，你的脑子里应该树立『C++ 不是 C 的一个超集』这个观念。在编写 C++ 时，也应该尽可能 的避免使用诸如 void* 之类的程序风格。</p><p>而在不得不使用 C 时，应该注意使用 ==extern “C”== 这种特性， 将 C 语言的代码与 C++ 代码进行分离编译，再统一链接这种做法。</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118155902628.png" class="" title="image-20221118155902628"><p>标识: <code>-std=c++2a</code> 启用预先批准的部分C++ 特性</p><h3 id="二-语言可用性的强化"><a href="#二-语言可用性的强化" class="headerlink" title="二 语言可用性的强化"></a>二 语言可用性的强化</h3><p>当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都 是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及语言可用性，是 指那些发生在运行时之前的语言行为。</p><h4 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h4><h5 id="2-1-1-nullptr"><a href="#2-1-1-nullptr" class="headerlink" title="2.1.1 nullptr"></a>2.1.1 nullptr</h5><blockquote><p>在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东 西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义 为 0。但是C++ 不允许直接将 void * 隐式转换到其他类型。</p><p>但如果编译器尝试把 NULL 定义为 ((void*)0)， 那么在下面这句代码中： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ch = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p> 没有了 void * 隐式转换的 C++ 只好将 NULL 定义为 0。而这依然会产生新的问题，将 NULL 定义 成 0 将导致 C++ 中重载特性发生混乱。 <strong>那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直觉。</strong></p></blockquote><p>C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型 为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><p>下面的程序会判断 **NULL, nullptr, 0是否是同一种类型: **</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="keyword">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="built_in">std</span>::<span class="keyword">nullptr_t</span>&gt;::value)</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-constexpr"><a href="#2-1-2-constexpr" class="headerlink" title="2.1.2  constexpr"></a>2.1.2  constexpr</h5><blockquote><p>常量表达式：比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。</p></blockquote><p>C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这 个关键字明确的告诉编译器应该去验证 foo 在编译期就应该是一个常量表达式。</p><p>从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码在C++ 11 中编译不过, 因为含有分支, 改为以下代码可以编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h4><h5 id="2-2-1-if-switch-变量声明强化"><a href="#2-2-1-if-switch-变量声明强化" class="headerlink" title="2.2.1 if/switch 变量声明强化"></a>2.2.1 if/switch 变量声明强化</h5><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终<strong>没有办法在 if 和 switch 语句中声明一个临时的变量。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 c++17 之前</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>);</span><br><span class="line">itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和Go 语言有点像</span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-初始化列表"><a href="#2-2-2-初始化列表" class="headerlink" title="2.2.2 初始化列表"></a>2.2.2 初始化列表</h5><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。这就为类对象的初始化与普通数组和 POD(Plain Old Data，即没有构造、析构和虚函 数的类或结构体) 的初始化方法提供了<strong>统一的桥梁</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicFoo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">MagicFoo(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">it != <span class="built_in">list</span>.end(); ++it)</span><br><span class="line">vec.push_back(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// after C++11</span></span><br><span class="line">MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = magicFoo.vec.begin();</span><br><span class="line">it != magicFoo.vec.end(); ++it)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。</p><h5 id="2-2-3-结构化绑定"><a href="#2-2-3-结构化绑定" class="headerlink" title="2.2.3 结构化绑定"></a>2.2.3 结构化绑定</h5><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。C++11 新 增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。</p><p>但是，C++11/14 并没有提供一种 ==简单的方法== 直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p><p>C++ 17进行了完善, 给出的结构化绑定可以让我们写出这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int, double, std::string&gt; f() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = f();   <span class="comment">// 简单的进行拆包</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-类型推导"><a href="#2-3-类型推导" class="headerlink" title="2.3 类型推导"></a>2.3 类型推导</h4><p>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这 使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p><h5 id="2-3-1-auto"><a href="#2-3-1-auto" class="headerlink" title="2.3.1 auto"></a>2.3.1 auto</h5><p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11 之前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = vec.cbegin(); it != vec.cend(); ++it)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// C++ 11, 避免代码臭长</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.begin(); it != <span class="built_in">list</span>.end(); ++it)</span><br></pre></td></tr></table></figure><p>从C++ 20 起, auto 还支持函数传参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(i, j) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-decltype"><a href="#2-3-2-decltype" class="headerlink" title="2.3.2 decltype"></a>2.3.2 decltype</h5><p>decltype 关键字是为了解决 auto 关键字只能对<strong>变量</strong>进行类型推导的缺陷而出现的。它的用法和 typeof 很相似：decltype(表达式)。</p><p>有时候，我们可能需要计算某个表达式的类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-3-3-尾返回类型推导"><a href="#2-3-3-尾返回类型推导" class="headerlink" title="2.3.3 尾返回类型推导"></a>2.3.3 尾返回类型推导</h5><p>typename 和 class 在模板参数列表中<strong>没有区别</strong>，在 typename 这个关键字出现之前，都 是使用 class 来定义模板参数的。但在模板中定义有==嵌套依赖类型的变量==时，需要用 ==typename消除歧义== 。</p><p>在介绍 auto 时，我们已经提过 auto 不能用于函数形参进行类型推导，那么 auto 能不能用于推导函数的返回类型呢？例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码很差，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 decltype 推导 x+y 的类型，写出这样的代码：</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) add(T x, U y)</span><br></pre></td></tr></table></figure><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定 义。</p><p>C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键 字将返回类型后置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add2(T x, U y) -&gt; decltype(x+y)&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  C++14 开始是可以直接让普通函数具备返回值推导, 直接写成</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-decltype-auto"><a href="#2-3-4-decltype-auto" class="headerlink" title="2.3.4 decltype(auto)"></a>2.3.4 decltype(auto)</h5><p>decltype(auto) 是 C++14 开始提供的一个略微复杂的用法。</p><p>简单来说，decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的 指定 decltype 的参数表达式。</p><p>学完语言运行时强化  再回头看</p><h4 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h4><h5 id="2-4-1-if-constexpr"><a href="#2-4-1-if-constexpr" class="headerlink" title="2.4.1 if constexpr"></a>2.4.1 if constexpr</h5><p>C++11 引入了 constexpr 关键字，它将表达式或函数编译为常量结果。</p><p>一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断， 岂不是能让程序效率更高？</p><p>C++17 将 constexpr 这个关键字引入到 if 语句中，<strong>允许在代码中声明常量表达式的判断条件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在编译时，实际代码就会表现为如下：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-2-区间for循环"><a href="#2-4-2-区间for循环" class="headerlink" title="2.4.2 区间for循环"></a>2.4.2 区间for循环</h5><p>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">element += <span class="number">1</span>; <span class="comment">// writeable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h4><p>模板的哲学在于将一切能够在编译期处理的问题丢到<strong>编译期</strong>进行处理，仅在运行时处理那些最核心的动 态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</p><h5 id="2-5-1-外部模板"><a href="#2-5-1-外部模板" class="headerlink" title="2.5.1 外部模板"></a>2.5.1 外部模板</h5><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中 编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。 并且，我们没有办法通知编译器不要触发模板的实例化。 </p><p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能 够显式的通知编译器何时进行模板的实例化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>; <span class="comment">// 强行实例化 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure><h5 id="2-5-2-类型别名模板"><a href="#2-5-2-类型别名模板" class="headerlink" title="2.5.2 类型别名模板"></a>2.5.2 类型别名模板</h5><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的</strong>。在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一 个新的名称。因为，模板不是类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T dark;</span><br><span class="line">U magic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法, 因为模板不是类型, 所以使用typedef 不能定义新的名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MagicType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; FakeDarkMagic;</span><br></pre></td></tr></table></figure><p>C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，</span></span><br><span class="line"><span class="comment">// 但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*process)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">using</span> NewProcess = <span class="keyword">int</span>(*)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TrueDarkMagic&lt;<span class="keyword">bool</span>&gt; you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-3-变长参数模板"><a href="#2-5-3-变长参数模板" class="headerlink" title="2.5.3 变长参数模板"></a>2.5.3 变长参数模板</h5><p>在 C++11 之前，无论是类模板 还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数, 所以也可以是0个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;</span><span class="keyword">int</span>,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; darkMagic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;</span>&gt; nothing;</span><br></pre></td></tr></table></figure><p>定义了变长的模板参数，如何对==参数解包==呢？</p><p>首先，我们可以使用 <strong>sizeof…</strong> 来计算参数的个数，：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理 手法：</p><ol><li><p>递归模板函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，</span></span><br><span class="line"><span class="comment">// 进而达到递归遍历所有模板参数的目的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">printf1(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">printf1(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变参模板展开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 printf 的编写</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t0 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化列表展开</p><p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">(<span class="keyword">void</span>) <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行</span></span><br><span class="line"><span class="comment">//前面的 lambda 表达式，完成参数的输出。为了避免编译器警告，我们可以将 std::initializer_list</span></span><br><span class="line"><span class="comment">//显式的转为 void。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h5 id="2-5-4-非类型模板参数推导"><a href="#2-5-4-非类型模板参数推导" class="headerlink" title="2.5.4 非类型模板参数推导"></a>2.5.4 非类型模板参数推导</h5><p>前面我们主要提及的是模板参数的一种形式：类型模板参数。<strong>其中模板的参数 T 和 U 为具体的类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但还有一种常见模板参数形式可以<strong>让不同字面量成为模板参数</strong>，即非类型模板参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> BufSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">buffer_t</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T data[BufSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">buffer_t</span>&lt;<span class="keyword">int</span>, <span class="number">100</span>&gt; buf; <span class="comment">// 100 作为模板参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 C++11 引入了类型推导这 一特性后，我们会很自然的问，既然此处的模板参数以具体的字面量进行传递，能否让编译器辅助我们 进行类型推导，通过使用占位符 auto 从而不再需要明确指明类型？</p><p>C++17 引入了这一特性， 我们的确可以 auto 关键字，让编译器辅助完成具体类型的推导，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">foo&lt;<span class="number">10</span>&gt;(); <span class="comment">// value 被推导为 int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-面向对象"><a href="#2-6-面向对象" class="headerlink" title="2.6 面向对象"></a>2.6 面向对象</h4><h5 id="2-6-1-委托构造"><a href="#2-6-1-委托构造" class="headerlink" title="2.6.1 委托构造"></a>2.6.1 委托构造</h5><p>C++11 引入了委托构造的概念，这使得<strong>构造函数可以在同一个类中一个构造函数调用另一个构造函数</strong>，从而达到简化代码的目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value1;</span><br><span class="line"><span class="keyword">int</span> value2;</span><br><span class="line">Base() &#123;</span><br><span class="line">value1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> value) : Base() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">value2 = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-2-继承构造"><a href="#2-6-2-继承构造" class="headerlink" title="2.6.2 继承构造"></a>2.6.2 继承构造</h5><p>在传统 C++ 中，<strong>构造函数如果需要继承</strong>是需要将参数一一传递的，这将导致效率低下。C++11 利 用关键字 using 引入了继承构造函数的概念：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value1;</span><br><span class="line"><span class="keyword">int</span> value2;</span><br><span class="line">Base() &#123;</span><br><span class="line">value1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> value) : Base() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">value2 = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-3-显式虚函数重载"><a href="#2-6-3-显式虚函数重载" class="headerlink" title="2.6.3 显式虚函数重载"></a>2.6.3 显式虚函数重载</h5><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SubClass::foo 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。</p><p>另 一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成 为了一个普通的类方法，这将造成灾难性的后果。</p><p>C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生。</p><ul><li><p>override 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass1</span> <span class="keyword">final</span>:</span> Base &#123;</span><br><span class="line">&#125;; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass2</span> :</span> SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass3</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-6-4-显式禁用默认函数"><a href="#2-6-4-显式禁用默认函数" class="headerlink" title="2.6.4 显式禁用默认函数"></a>2.6.4 显式禁用默认函数</h5><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成<strong>默认构造函数、复制构造、赋值 算符以及析构函数</strong>。另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。当程序员有需要时， 可以重载这部分函数。</p><p>这就引发了一些需求：无法精确控制默认函数的生成行为。例如禁止类的拷贝时，必须将复制构造 函数与赋值算符声明为 private。尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p><p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Magic() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">Magic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">Magic(<span class="keyword">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-5-强类型枚举"><a href="#2-6-5-强类型枚举" class="headerlink" title="2.6.5 强类型枚举"></a>2.6.5 强类型枚举</h5><p>在传统 C++ 中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类 型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型 的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p><p>C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3 = <span class="number">100</span>,</span><br><span class="line">value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数 字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那 么可以进行比较。</p><p>如果我们希望获得枚举值的时候， 将必须显式的进行类型转换，不过我们可以通过重载 &lt;&lt; 这个算符来 进行输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_enum&lt;T&gt;::value,</span><br><span class="line"><span class="built_in">std</span>::ostream&gt;::type&amp; stream, <span class="keyword">const</span> T&amp; e)&#123;</span><br><span class="line"><span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&#123;</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3 = <span class="number">100</span>,</span><br><span class="line">value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (new_enum::value3 == new_enum::value4)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;new_enum::value3 == new_enum::value4&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; new_enum::value3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-语言运行期的强化"><a href="#三-语言运行期的强化" class="headerlink" title="三 语言运行期的强化"></a>三 语言运行期的强化</h3><h4 id="3-1-Lambda-表达式"><a href="#3-1-Lambda-表达式" class="headerlink" title="3.1 Lambda 表达式"></a>3.1 Lambda 表达式</h4><p>Lambda 表达式，实际上就是提供了一个类 似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用 的。</p><p>Lambda 表达式的基本语法如下：</p><p><code>[捕获列表](参数列表)</code> mutable(可选) 异常属性 -&gt; 返回类型 { // 函数体 }</p><p> 所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下<strong>是不能够使用函数体外部的变量</strong>的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列 表也分为以下几种：</p><ol><li><p>值捕获 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被<strong>创建时拷贝</strong>，而非调用时才拷贝。</p></li><li><p>引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化。</p></li><li><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时 候可以在捕获列表中写一个 &amp; 或 = 向编译器声明采用引用捕获或者值捕获.</p><p>捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表 </li><li>[name1, name2, . . . ] 捕获一系列变量 </li><li>[&amp;] 引用捕获, 让编译器自行推导引用列表 </li><li> [=] 值捕获, 让编译器自行推导值捕获列表</li></ul></li><li><p>表达式捕获</p><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的<strong>均为左值</strong>，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被 声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> important = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = <span class="built_in">std</span>::move(important)](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h4><h5 id="3-2-1-std-function"><a href="#3-2-1-std-function" class="headerlink" title="3.2.1 std::function"></a>3.2.1 std::function</h5><p>Lambda 表达式的本质是一个和<strong>函数对象类型相似的类类型</strong>（称为闭包类型）的对象（称为闭包对象），当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void(int), 参考https://stackoverflow.com/questions/34437557/difference-between-voidint-void-int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo = <span class="keyword">void</span>(<span class="keyword">int</span>); <span class="comment">// 定义 函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于 </span></span><br><span class="line"><span class="comment">//void functional(void(*f)(int) ) &#123; </span></span><br><span class="line"><span class="comment">//f(1); // 通过函数指针调用函数</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">functional(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    </span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用，而另一种 则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，<strong>将能够被调用的对象的类型，统一称之为可调用类型</strong>。而这种类型，便是通过 std::function 引入的。</p><p>C++11 std::function 是一种通用、多态的函数封装，<strong>它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作</strong>，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数 指针的调用不是类型安全的），换句话说，就是函数的容器。</p><p>当我们有了函数的容器之后便能够更加方便 的将函数、函数指针作为对象进行处理。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func = foo;</span><br><span class="line"><span class="keyword">int</span> important = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func2 = [&amp;](<span class="keyword">int</span> value) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func2(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-std-bind-和-std-placeholder"><a href="#3-2-2-std-bind-和-std-placeholder" class="headerlink" title="3.2.2 std::bind 和 std::placeholder"></a>3.2.2 std::bind 和 std::placeholder</h5><p>std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以<strong>将部分调用参数提前绑定到函数身上</strong>成为一 个新的对象，然后在参数齐全后，完成调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将参数 1,2 绑定到函数 foo 上，</span></span><br><span class="line"><span class="comment">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line"><span class="keyword">auto</span> bindFoo = <span class="built_in">std</span>::bind(foo, <span class="built_in">std</span>::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">bindFoo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h4><p>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大 量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能。</p><h5 id="3-3-1-左值、右值、纯右值、将亡值"><a href="#3-3-1-左值、右值、纯右值、将亡值" class="headerlink" title="3.3.1 左值、右值、纯右值、将亡值"></a>3.3.1 左值、右值、纯右值、将亡值</h5><p><strong>左值</strong> (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋 值表达式）后依然存在的持久对象。</p><p><strong>右值</strong> (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。</p><p>也有人将左值翻译为locator value, 意思是可以在内存中找到地址。右值为read value。而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p><p><strong>纯右值</strong> (prvalue, pure rvalue)，纯粹的右值，要么是<strong>纯粹的字面量</strong>，例如 10, true；要么是<strong>求值结果相当于字面量或匿名临时对象</strong>，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。==需要注意的是==，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 正确，&quot;01234&quot; 类型为 const char [6]，因此是左值</span></span><br><span class="line">const char (&amp;left)[6] = &quot;01234&quot;;</span><br><span class="line"><span class="comment">// 断言正确，确实是 const char [6] 类型，注意 decltype(expr) 在 expr 是左值</span></span><br><span class="line"><span class="comment">// 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="string">&quot;01234&quot;</span>), <span class="keyword">const</span> <span class="keyword">char</span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 错误，&quot;01234&quot; 是左值，不可被右值引用</span></span><br><span class="line"><span class="comment">// const char (&amp;&amp;right)[6] = &quot;01234&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将亡值</strong> (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中，纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = foo();</span><br></pre></td></tr></table></figure><blockquote><p>在这样的代码中，就传统的理解而言，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，<strong>会将整个 temp 拷贝一份，然后把 temp 销毁</strong>，如果这个 temp 非常大，这将造成大量 额外的开销（这也就是传统 C++ 一直被诟病的问题）。</p><p>在最后一行中，v 是左值、foo() 返回的值就是 右值（也是纯右值）。但是，v 可以被别的变量捕获到，而 foo() 产生的那个返回值作为一个临时值，一 旦被 v 复制后，将立即被销毁，无法获取、也不能修改。</p><p>而将亡值就定义了这样一种行为：<strong>临时的值能够被识别、同时又能够被移动。</strong></p></blockquote><p>在 C++11 之后，编译器为我们做了一些工作，<strong>此处的左值 temp 会被进行此隐式右值转换</strong>，等价于 static_cast &amp;&amp;&gt;(temp)，进而此处的 v 会将 foo 局部返回的值进行移动。也就是 后面我们将会提到的移动语义。</p><h5 id="3-3-2-右值引用和左值引用"><a href="#3-3-2-右值引用和左值引用" class="headerlink" title="3.3.2 右值引用和左值引用"></a>3.3.2 右值引用和左值引用</h5><p><strong>要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。</strong>右值引用的声明让这个临时值的 生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p><p> C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> lv1 = <span class="string">&quot;string,&quot;</span>; <span class="comment">// lv1 是一个左值</span></span><br><span class="line"><span class="comment">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv1 = <span class="built_in">std</span>::move(lv1); <span class="comment">// 合法, std::move 可以将左值转移为右值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; lv2 = lv1 + lv1; <span class="comment">// 合法, 常量左值引用能够延长临时变量的生命周期</span></span><br><span class="line"><span class="comment">// lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">rv2 += <span class="string">&quot;Test&quot;</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,string,Test</span></span><br><span class="line">    </span><br><span class="line">reference(rv2); <span class="comment">// 输出左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。</p><h5 id="3-3-3-移动语义"><a href="#3-3-3-移动语义" class="headerlink" title="3.3.3 移动语义"></a>3.3.3 移动语义</h5><p>传统 C++ 通过<strong>拷贝构造函数和赋值操作符</strong>为类对象设计了<strong>拷贝/复制</strong>的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> *pointer;</span><br><span class="line"></span><br><span class="line">A() : pointer(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 构造&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A(A &amp;a) : pointer(<span class="keyword">new</span> <span class="keyword">int</span>(*a.pointer)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 拷贝&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">// 无意义的对象拷贝</span></span><br><span class="line">    </span><br><span class="line">A(A &amp;&amp;a) : pointer(a.pointer) &#123;</span><br><span class="line">a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 移动&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 析构&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止编译器优化</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="keyword">bool</span> test)</span> </span>&#123;</span><br><span class="line">A a, b;</span><br><span class="line"><span class="keyword">if</span> (test) <span class="keyword">return</span> a; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A obj = return_rvalue(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; obj.pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *obj.pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 运行结果</span><br><span class="line"></span><br><span class="line">构造 0x2353eb0</span><br><span class="line"> 构造 0x2354ee0</span><br><span class="line"> 移动 0x2354ee0</span><br><span class="line"> 析构 0</span><br><span class="line"> 析构 0x2353eb0</span><br><span class="line">cout obj:</span><br><span class="line">0x2354ee0</span><br><span class="line">1</span><br><span class="line"> 析构 0x2354ee0</span><br></pre></td></tr></table></figure><ol><li>首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出；</li><li><strong>函数返回后，产生一个将亡值</strong>，被 A 的移动构造（A(A&amp;&amp;)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。</li></ol><p>从而避免了无意义的拷贝构造，加强了性能。</p></blockquote><h5 id="3-3-4-完美转发"><a href="#3-3-4-完美转发" class="headerlink" title="3.3.4 完美转发"></a>3.3.4 完美转发</h5><p>前面我们提到了(3.3.2 小节)，<strong>一个声明的右值引用其实是一个左值</strong>。这就为我们进行参数转发（传递）造成了 问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 普通传参:&quot;</span>;</span><br><span class="line">reference(v); <span class="comment">// 始终调用 reference(int&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">pass(<span class="number">1</span>); <span class="comment">// 1 是右值, 但输出是左值</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">pass(l); <span class="comment">// l 是左值, 输出左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于 pass(1) 来说，虽然传递的是右值，但由于 <strong>v 是一个引用，所以同时也是左值</strong>。因此 reference(v) 会调用 reference(int&amp;)，输出『左值』。而对于 pass(l) 而言，l 是一个左值，为什么 会成功传递给 pass(T&amp;&amp;) 呢？</p><p>这是基于引用坍缩规则的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由 于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，既能左引 用，又能右引用。但是却遵循如下规则：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118225944987.png" class="" title="image-20221118225944987"><p>准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为 右引用类型。这才使得 v 作为左值的成功传递。</p><p><strong>完美转发就是基于上述规律产生的。</strong>所谓完美转发，就是为了让我们在传递参数的时候，保持原来的参数类型（左引用保持左引用，右引用保持右引用）。为了解决这个问题，我们应该使用 std::forward 来进行参数的转发（传递）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值引用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值引用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 普通传参: &quot;</span>;</span><br><span class="line">reference(v);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; std::move 传参: &quot;</span>;</span><br><span class="line">reference(<span class="built_in">std</span>::move(v));</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; std::forward 传参: &quot;</span>;</span><br><span class="line">reference(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;</span>;</span><br><span class="line">reference(<span class="keyword">static_cast</span>&lt;T &amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">pass(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">    pass(v);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，所以 std::move 总会接受到一个左值，从而转发调用了 reference(int&amp;&amp;) 输出右值引用。 </p><p>唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发 (传递) 了函数的实参给了内部调用 的其他函数。</p><p> std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值， std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看，std::forward(v) 和 static_cast(v) 是完全一样的。</p></blockquote><h3 id="四-容器"><a href="#四-容器" class="headerlink" title="四 容器"></a>四 容器</h3><h4 id="4-1-线性容器"><a href="#4-1-线性容器" class="headerlink" title="4.1 线性容器"></a>4.1 线性容器</h4><h5 id="4-1-1-std-array"><a href="#4-1-1-std-array" class="headerlink" title="4.1.1 std::array"></a>4.1.1 std::array</h5><ol><li><p>为什么要引入 std::array 而不是直接使用 std::vector？ </p><blockquote><p>与 std::vector 不同，std::array 对象的大小是固定的，<strong>如果容器大小是固定的，那么可以优先考虑使用 std::array 容器</strong>。另外由于 std::vector 是自动扩容的，当存入大量的 数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候就需要手动 运行 shrink_to_fit() 释放这部分内存。</p></blockquote></li><li><p>已经有了传统数组，为什么要用 std::array?</p><blockquote><p>使用 std::array 能够让代码变得更加 ‘‘现代化’’，而且封装了一些操作函 数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort。</p></blockquote></li></ol><h5 id="4-1-2-std-forward-list"><a href="#4-1-2-std-forward-list" class="headerlink" title="4.1.2 std::forward_list"></a>4.1.2 std::forward_list</h5><p>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进 行介绍了。 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一 个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</p><h4 id="4-2-无序容器"><a href="#4-2-无序容器" class="headerlink" title="4.2 无序容器"></a>4.2 无序容器</h4><p>传统 C++ 中的<strong>有序容器 std::map/std::set</strong>，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 &lt; 操作符比较元素大小并判断元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 &lt; 操作符的顺序来逐个遍历。</p><p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。</p><p>C++11 引入了的两组无序容器分别是：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。</p><h4 id="4-3-元组"><a href="#4-3-元组" class="headerlink" title="4.3 元组"></a>4.3 元组</h4><p>关于元组的使用有三个核心的函数： </p><ol><li>std::make_tuple: 构造元组 </li><li>std::get: 获得元组某个位置的值</li><li>std::tie: 元组拆包</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">3.8</span>, ’A’, <span class="string">&quot; 张三&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">2.9</span>, ’C’, <span class="string">&quot; 李四&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1.7</span>, ’D’, <span class="string">&quot; 王五&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">0.0</span>, ’D’, <span class="string">&quot;null&quot;</span>);</span><br><span class="line"><span class="comment">// 如果只写 0 会出现推断错误, 编译失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> student = get_student(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: 0, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(student) &lt;&lt; ’\n’;</span><br><span class="line"><span class="keyword">double</span> gpa;</span><br><span class="line"><span class="keyword">char</span> grade;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="comment">// 元组进行拆包</span></span><br><span class="line"><span class="built_in">std</span>::tie(gpa, grade, name) = get_student(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: 1, &quot;</span> &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; gpa &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名: &quot;</span> &lt;&lt; name &lt;&lt; ’\n’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::get 除了使用常量获取元组对象外，C++14 增加了<strong>使用类型来获取元组中的对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;std::string, double, double, int&gt; t(&quot;123&quot;, 4.5, 6.7, 8);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">double</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 非法, 引发编译期错误</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">3</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="4-3-1-运行期索引"><a href="#4-3-1-运行期索引" class="headerlink" title="4.3.1 运行期索引"></a>4.3.1 运行期索引</h5><p>如果你仔细思考一下可能就会发现上面代码的问题，std::get&lt;&gt; 依赖一个编译期的常量，所以下面 的方式是不合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::get&lt;index&gt;(t);</span><br></pre></td></tr></table></figure><p>那么要怎么处理？答案是，使用 std::variant&lt;&gt;（C++ 17 引入），提供给 variant&lt;&gt; 的类型模板参数可以让一个 variant&lt;&gt; 从而容纳提供的几种类型的变量:</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118232359960.png" class="" title="image-20221118232359960"><p>这样就可以:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tuple_index(t, i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-元组合并与遍历"><a href="#4-3-2-元组合并与遍历" class="headerlink" title="4.3.2 元组合并与遍历"></a>4.3.2 元组合并与遍历</h5><p>还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;std::string, double, double, int&gt; t(&quot;123&quot;, 4.5, 6.7, 8);</span><br><span class="line"><span class="keyword">auto</span> new_tuple = <span class="built_in">std</span>::tuple_cat(get_student(<span class="number">1</span>), <span class="built_in">std</span>::move(t));</span><br></pre></td></tr></table></figure><h3 id="五-智能指针"><a href="#五-智能指针" class="headerlink" title="五 智能指针"></a>五 智能指针</h3><h4 id="5-1-RALL与引用计数"><a href="#5-1-RALL与引用计数" class="headerlink" title="5.1 RALL与引用计数"></a>5.1 RALL与引用计数</h4><p>引用计数这种计数是为了防止内存泄 露而产生的。基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那 么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减 为零时，就自动删除指向的堆内存。</p><p><strong>『记得』手动释放资源，总不是最佳实践。</strong>因为我们很有可能就忘记了去释放资源 而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在 离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。</p><p>而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序 员不再需要关心手动释放内存。这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr， 使用它们需要包含头文件 。</p><h4 id="5-2-std-shared-ptr"><a href="#5-2-std-shared-ptr" class="headerlink" title="5.2 std::shared_ptr"></a>5.2 std::shared_ptr</h4><p>std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当<strong>引用计数变为零</strong>的时候就会将对象自动删除。</p><p>但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。 </p><p>std::make_shared 就能够用来消除显式的使用 new，所以 std::make_shared 会分配创建传入参 数中的对象，并返回这个对象类型的 std::shared_ptr 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; i)</span> </span>&#123;</span><br><span class="line">(*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// auto pointer = new int(10); // illegal, no direct assignment</span></span><br><span class="line"><span class="comment">// Constructed a std::shared_ptr</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> pointer = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">foo(pointer);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// The shared_ptr will be destructed before leaving the scope</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::shared_ptr 可以通过 <strong>get() 方法</strong>来获取原始指针，通过 <strong>reset()</strong> 来减少一个引用计数，并 通过 <strong>use_count()</strong> 来查看一个对象的引用计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数 +1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = pointer.get(); <span class="comment">// 这样不会增加引用计数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">pointer2.reset();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reset pointer2:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="5-3-std-unique-ptr"><a href="#5-3-std-unique-ptr" class="headerlink" title="5.3 std::unique_ptr"></a>5.3 std::unique_ptr</h4><p>std::unique_ptr 是一种<strong>独占的智能指针</strong>，它禁止其他智能指针与其共享同一个对象，从而保证代 码的安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pointer = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_unique 从 C++14 引入</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pointer2 = pointer; <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是C++ 11 中没有实现make_unique, 据说是忘记了, 可以自己实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp; ...args )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;( <span class="keyword">new</span> T( <span class="built_in">std</span>::forward&lt;Args&gt;(args)... ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr。</p><h4 id="5-4-weak-ptr"><a href="#5-4-weak-ptr" class="headerlink" title="5.4 weak_ptr"></a>5.4 weak_ptr</h4><p>如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;B&gt; pointer;</span><br><span class="line"></span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;A&gt; pointer;</span><br><span class="line"></span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">std</span>::make_shared&lt;A&gt;();</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">std</span>::make_shared&lt;B&gt;();</span><br><span class="line">a-&gt;pointer = b;</span><br><span class="line">b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引 用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却只能造成这块区域的引用计数减一，这样 就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了 内存泄露，如图:</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119152443945.png" class="" title="image-20221119152443945"></blockquote><p>解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr 是一种弱引用（相比较 而言 std::shared_ptr 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的 释放流程如图 5.2 所示：<img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119152600314.png" class="" title="image-20221119152600314"></p><p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。 </p><p>*<em>std::weak_ptr 没有 * 运算符和 -&gt; 运算符*</em>，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true； 除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未 被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回 nullptr。</p><h3 id="六-正则表达式"><a href="#六-正则表达式" class="headerlink" title="六 正则表达式"></a>六 正则表达式</h3><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p><ul><li>检查一个串是否包含某种形式的子串；</li><li>将匹配的子串替换</li><li>从某个串中取出符合条件的子串。</li></ul><h4 id="6-1-正则表达式简介"><a href="#6-1-正则表达式简介" class="headerlink" title="6.1 正则表达式简介"></a>6.1 正则表达式简介</h4><h5 id="6-1-1-特殊字符"><a href="#6-1-1-特殊字符" class="headerlink" title="6.1.1 特殊字符"></a>6.1.1 特殊字符</h5><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153031490.png" class="" title="image-20221119153031490"><h5 id="6-1-2-限定符"><a href="#6-1-2-限定符" class="headerlink" title="6.1.2 限定符"></a>6.1.2 限定符</h5><p>限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153120714.png" class="" title="image-20221119153120714"><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153137416.png" class="" title="image-20221119153137416"><h4 id="6-2-std-regex-及其相关"><a href="#6-2-std-regex-及其相关" class="headerlink" title="6.2 std::regex 及其相关"></a>6.2 std::regex 及其相关</h4><p>对字符串内容进行匹配的最常见手段就是使用正则表达式。可惜在传统 C++ 中正则表达式一直没 有得到语言层面的支持，没有纳入标准库，而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时，使用正则表达式也是工业界最为成熟的普遍做法。</p><p><strong>C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex) 进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch（本质是 std::match_results 对象）。</strong></p><p>示例: </p><ul><li><code>[a-z]+\.txt</code>: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多 次，因此 [a-z]+ 能够匹配一个小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字 符，而 <code>\.</code> 则表示匹配字符 .，最后的 txt 表示严格匹配 txt 则三个字母。因此这个正则表达式的 所要匹配的内容就是由纯小写字母组成的文本文件。</li><li>std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是 传入 std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fnames[] = &#123;<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;a0.txt&quot;</span>, <span class="string">&quot;AAA.txt&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 在 C++ 中 \ 会被作为字符串内的转义符，</span></span><br><span class="line"><span class="comment">// 为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">txt_regex</span><span class="params">(<span class="string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">std</span>::regex_match(fname, txt_regex) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;现代-C-教程&quot;&gt;&lt;a href=&quot;#现代-C-教程&quot; class=&quot;headerlink&quot; title=&quot;现代 C++ 教程&quot;&gt;&lt;/a&gt;现代 C++ 教程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;现代 C++&lt;/strong&gt; (本书中均指 C++11/14/17/20)</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>现代化Cmake</title>
    <link href="http://okeyia.github.io/2022/11/06/Modern_CMake/"/>
    <id>http://okeyia.github.io/2022/11/06/Modern_CMake/</id>
    <published>2022-11-06T06:29:04.000Z</published>
    <updated>2023-03-09T14:07:39.501Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Modern-CMake"><a href="#Modern-CMake" class="headerlink" title="Modern CMake"></a>Modern CMake</h2><blockquote><p>现代的 CMake 是指 CMake 3.4+ ，甚至是 CMake 3.21+ ！ 它简洁、强大、优雅，所以你能够花费你的大部分时间在编写代码上，而不是在一个不可读、不可维护的 Make （或 CMake 2） 文件上浪费时间。 并且 CMake 3.11+ 的构建速度应该也会更加的快！！！</p></blockquote><h3 id="一-基础知识简介"><a href="#一-基础知识简介" class="headerlink" title="一 基础知识简介"></a>一 基础知识简介</h3><hr><h4 id="1-1-最低版本要求"><a href="#1-1-最低版本要求" class="headerlink" title="1.1 最低版本要求"></a>1.1 最低版本要求</h4><p>这是每个 <code>CMakeLists.txt</code> 都必须包含的第一行，默认小写</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br></pre></td></tr></table></figure><p><code>CMake</code> 的版本与它的特性（policies）相互关联，这意味着它也定义了 <code>CMake</code> 行为的变化。</p><h4 id="1-2-设置一个项目"><a href="#1-2-设置一个项目" class="headerlink" title="1.2 设置一个项目"></a>1.2 设置一个项目</h4><p>每一个顶层 CMakelists 文件都应该有下面这一行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(MyProject VERSION <span class="number">1.0</span></span><br><span class="line">                  DESCRIPTION <span class="string">&quot;Very nice project&quot;</span></span><br><span class="line">                  LANGUAGES CXX)</span><br></pre></td></tr></table></figure><p>项目名称是这里的第一个参数。所有的关键字参数都可选的。<code>VERSION</code> 设置了一系列变量，例如 <code>MyProject_VERSION</code> 和 <code>PROJECT_VERSION</code>。<code>DESCRIPTION</code>，对项目进行简单介绍。语言最好不写，英文c++中项目中，可能存在个别的C文件。</p><h4 id="1-3-生成可执行文件"><a href="#1-3-生成可执行文件" class="headerlink" title="1.3 生成可执行文件"></a>1.3 生成可执行文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(one two.cpp three.h)</span><br></pre></td></tr></table></figure><p><code>one</code> 既是生成的可执行文件的名称，也是创建的 <code>CMake</code> 目标(target)的名称。</p><p>紧接着的是源文件的列表，你想列多少个都可以。CMake 很聪明 ，它根据拓展名只编译源文件。</p><p>在大多数情况下，<strong>头文件将会被忽略</strong>；列出他们的唯一原因是为了让他们在 IDE 中被展示出来，目标文件在许多 IDE 中被显示为文件夹。</p><h4 id="1-4-生成一个库"><a href="#1-4-生成一个库" class="headerlink" title="1.4 生成一个库"></a>1.4 生成一个库</h4><p>制作一个库是通过 <code>add_library</code> 命令完成的，并且非常简单：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(one STATIC two.cpp three.h)</span><br></pre></td></tr></table></figure><p>你可以选择库的类型，可以是 <code>STATIC</code>,<code>SHARED</code>, 或者<code>MODULE</code>. </p><ul><li>STATIC 库是链接其他目标时使用的目标文件档案（archives）。</li><li>SHARED 库是动态链接的，并在运行时加载。</li><li>MODULE 库是未链接到其他目标但可以在运行时使用类似 dlopen 的功能动态加载的插件。</li></ul><p><strong>生成的library名会根据<code>STATIC</code>或<code>SHARED</code>成为<code>name.a</code>或<code>name.lib</code>。</strong></p><p>如果你不选择它，CMake 将会通过 <code>BUILD_SHARED_LIBS</code> 的值来选择构建 STATIC 还是 SHARED 类型的库。</p><h4 id="1-5-目标时常伴随着你"><a href="#1-5-目标时常伴随着你" class="headerlink" title="1.5 目标时常伴随着你"></a>1.5 目标时常伴随着你</h4><p>现在我们已经指定了一个目标，那我们如何添加关于它的信息呢？例如，它可能需要包含一个目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(one PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><blockquote><p>The <code>INTERFACE</code>, <code>PUBLIC</code> and <code>PRIVATE</code> keywords are required to specify the scope of the following arguments.</p></blockquote><p><code>target_include_directories</code>  指定编译给定目标时要使用的包含目录。命名的 <code>&lt;target&gt;</code> 必须是由 <code>add_executable()</code> 或  <code>add_library()</code>  等命令创建的，并且不能是 ALIAS 目标。</p><p> <code>PUBLIC</code> 对于一个二进制目标没有什么含义；但对于库来说，它让 CMake 知道，任何链接到这个目标的目标也必须包含这个目录。</p><p>其他选项还有 <code>PRIVATE</code>（只影响当前目标，不影响依赖），以及 <code>INTERFACE</code>（只影响依赖）。</p><p>接下来我们可以将目标之间链接起来：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(another STATIC another.cpp another.h)</span><br><span class="line"></span><br><span class="line"><span class="comment">#target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...)</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(another PUBLIC one)</span><br></pre></td></tr></table></figure><p><code>target_link_libraries</code> 指定一个目标，并且在给出目标的情况下添加一个依赖关系。</p><p>如果不存在名称为 <code>one</code> 的目标，那他会添加一个链接到你路径中 <code>one</code> 库（这也是命令叫 <code>target_link_libraries</code> 的原因）。<strong>或者</strong>你可以给定一个库的完整路径，或者是链接器标志。</p><p><em>最后再说一个有些迷惑性的知识：），经典的 CMake 允许你省略 <code>PUBLIC</code> 关键字，但是你在目标链中省略与不省略混用，那么 CMake 会报出错误。</em></p><h4 id="1-6-include-directories"><a href="#1-6-include-directories" class="headerlink" title="1.6 include_directories"></a>1.6 include_directories</h4><blockquote><p><strong><code>include_directories</code> ([<code>AFTER|BEFORE</code>] [<code>SYSTEM</code>] dir1 [dir2 …])</strong><br> 将指定目录添加到编译器的头文件搜索路径之下，指定的目录被解释成当前源码路径的相对路径。</p></blockquote><p>使用 <code>include_directories</code> 后, 不需在 <code>add_executable()</code> 里面添加 <code>test.h</code>, 编译器会自动寻找, 默认顺序是</p><p><strong><code>/usr/include</code></strong> -&gt; <strong><code>/usr/local/include</code></strong> -&gt; <strong><code>dir1</code></strong> -&gt; **<code>dir2</code>**。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">→ tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include       </span><br><span class="line">│   ├── test.cpp  </span><br><span class="line">│   └── test.h    </span><br><span class="line">└── main.cpp      </span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure><p>cmakeList.txt写法:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><p>有以下两种方式都可以让main函数运行成功:</p><ol><li>在main函数中, 直接使用<code>#include &quot;test.cpp&quot;</code></li><li>在main函数中, 使用#include “test.h”, 但是test.h 必须实现main调用的函数。</li></ol><h4 id="1-7-设置编译器选项以及编译选项"><a href="#1-7-设置编译器选项以及编译选项" class="headerlink" title="1.7 设置编译器选项以及编译选项"></a>1.7 设置编译器选项以及编译选项</h4><p>CMAKE_C_COMPILER：指定C编译器</p><p>CMAKE_CXX_COMPILER：指定C++编译器</p><p>CMAKE_C_FLAGS：指定编译C文件时编译选项，也可以通过add_definitions命令添加编译选项</p><p>在cmake脚本中，设置编译选项（配置编译器）有如下三种方法：</p><p><code>-Wall选项意思是编译后显示所有警告</code>; <code>-Werror选项意思是所有警告当做错误处理</code>。</p><ul><li><p>add_compile_options命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-Wall -Werror )</span><br></pre></td></tr></table></figure></li><li><p>add_definitions 命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_DEFINITIONS</span>(<span class="string">&quot;-Wall -Werror&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>set命令修改CMAKE_CXX_FLAGS 或 CMAKE_C_FLAGS</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;-Wall -Werror -Wstrict-prototypes -Wmissing-prototypes&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>使用这三种方式在有的情况下效果是一样的，但请注意它们还是有区别的：</p><p>add_compile_options命令和add_definitions添加的编译选项是针对所有编译器的(包括c和c++编译器)，而set命令设置CMAKE_C_FLAGS或CMAKE_CXX_FLAGS变量则是分别只针对c和c++编译器的。</p><h3 id="二-变量与缓存"><a href="#二-变量与缓存" class="headerlink" title="二 变量与缓存"></a>二 变量与缓存</h3><hr><h4 id="2-1-本地变量"><a href="#2-1-本地变量" class="headerlink" title="2.1 本地变量"></a>2.1 本地变量</h4><p>你可以这样声明一个本地 ( local ) 变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">&quot;value&quot;</span>)</span><br></pre></td></tr></table></figure><p>变量名通常全部用大写，变量值跟在其后。你可以通过 <code>$&#123;&#125;</code> 来解析一个变量，例如 <code>$&#123;MY_VARIABLE&#125;</code>.</p><p>列表就是简单地包含一系列变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;one&quot;</span> <span class="string">&quot;two&quot;</span>)</span><br></pre></td></tr></table></figure><p>你也可以通过 <code>;</code> 分隔变量，这和空格的作用是一样的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;one;two&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-2-缓存变量"><a href="#2-2-缓存变量" class="headerlink" title="2.2 缓存变量"></a>2.2 缓存变量</h4><p>CMake 提供了一个缓存变量来允许你从命令行中设置变量。CMake 中已经有一些预置的变量，像 <code>CMAKE_BUILD_TYPE</code>。</p><p>通过 <code>set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</code>这个命令来设置的变量就是 Cache Variables。例如 <code>set(MY_CACHE_VAL &quot;666&quot; CACHE STRING INTERNAL)</code>，此时 MY_CACHE_VAL 就是一个 CACHE 变量。相当于一个全局变量，我们在同一个 cmake 工程中都可以使用。</p><ul><li>Cache 变量 CMAKE_INSTALL_PREFIX 默认值是 /usr/local (可以在生成的 CMakeCache.txt 文件中查看)，这时候如果我们 在某个 CMakeLists.txt 中，仍然使用 set(CMAKE_INSTALL_PREFIX “/usr”)，那么此时我们 install 的时候，CMake 以后面的 /usr 作为 CMAKE_INSTALL_PREFIX 的值，这是因为 CMake 规定，有一个与 Cache 变量同名的 Normal 变量出现时，后面使用这个变量的值都是以 Normal 为准，如果没有同名的 Normal 变量，CMake 才会自动使用 Cache 变量。</li><li>所有的 Cache 变量都会出现在 CMakeCache.txt 文件中。这个文件是我们键入 <code>cmake .</code>命令后自动出现的文件。打开这个文件发现，CMake 本身会有一些默认的全局 Cache 变量。例如：CMAKE_INSTALL_PREFIX、CMAKE_BUILD_TYPE、CMAKE_CXX_FLAGSS 等等。可以自行查看。当然，我们自己定义的 Cache 变量也会出现在这个文件中。Cache 变量定义格式为 <code>set(&lt;variable&gt; &lt;value&gt; CACHE STRING INTERNAL)</code>。这里的 <code>STRING</code>可以替换为 <code>BOOL</code> <code>FILEPATH</code> <code>PATH</code> ，但是要根据前面 value 类型来确定。参考。</li><li>修改 Cache 变量。可以通过 <code>set(&lt;variable&gt; &lt;value&gt; CACHE INSTERNAL FORCE)</code>，另一种方式是直接在终端中使用 <code>cmake -D var=value ..</code>来设定默认存在的CMake Cache 变量。</li></ul><h4 id="3-3-环境变量、缓存"><a href="#3-3-环境变量、缓存" class="headerlink" title="3.3 环境变量、缓存"></a>3.3 环境变量、缓存</h4><ul><li>你也可以通过 <code>set(ENV&#123;variable_name&#125; value)</code> 和 <code>$ENV&#123;variable_name&#125;</code> 来设置和获取环境变量，不过一般来说，我们最好避免这么用。</li><li>缓存实际上就是个文本文件，<code>CMakeCache.txt</code> ，当你运行 CMake 构建目录时会创建它。 CMake 可以通过它来记住你设置的所有东西，因此你可以不必在重新运行 CMake 的时候再次列出所有的选项。</li></ul><h3 id="三-寻找其他库"><a href="#三-寻找其他库" class="headerlink" title="三 寻找其他库"></a>三 寻找其他库</h3><h4 id="3-1-OpenMP"><a href="#3-1-OpenMP" class="headerlink" title="3.1 OpenMP"></a>3.1 OpenMP</h4><p><a href="https://cmake.org/cmake/help/latest/module/FindOpenMP.html">OpenMP</a> support was drastically improved in CMake 3.9+. The Modern(TM) way to add OpenMP to a target is:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenMP)</span><br><span class="line"><span class="keyword">if</span>(OpenMP_CXX_FOUND)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(MyTarget PUBLIC OpenMP::OpenMP_CXX)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h4 id="3-2-MPI"><a href="#3-2-MPI" class="headerlink" title="3.2 MPI"></a>3.2 MPI</h4><p>To add MPI, like OpenMP, you’ll be best off with CMake 3.9+.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MPI REQUIRED)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Run: $&#123;MPIEXEC&#125; $&#123;MPIEXEC_NUMPROC_FLAG&#125; $&#123;MPIEXEC_MAX_NUMPROCS&#125; $&#123;MPIEXEC_PREFLAGS&#125; EXECUTABLE $&#123;MPIEXEC_POSTFLAGS&#125; ARGS&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyTarget PUBLIC MPI::MPI_CXX)</span><br></pre></td></tr></table></figure><h4 id="3-3-添加pthread"><a href="#3-3-添加pthread" class="headerlink" title="3.3 添加pthread"></a>3.3 添加pthread</h4><p>ubuntu 下, 在CmakeList中添加pthread库</p><p>等同于shell中的 <code>g++ -o server main.cpp -lpthread -g</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main Threads::Threads)</span><br></pre></td></tr></table></figure><h3 id="四-参考链接"><a href="#四-参考链接" class="headerlink" title="四 参考链接"></a>四 参考链接</h3><ol><li><a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/">Modern CMake 简体中文版</a></li><li><a href="https://cliutils.gitlab.io/modern-cmake/">An Introduction to Modern CMake</a></li><li><a href="https://cmake.org/cmake/help/v3.15/manual/cmake-commands.7.html#id2">cmake-commands(7)</a></li><li><a href="https://www.cnblogs.com/lidabo/p/16661713.html">cmake cache变量_反复研究好几遍，我才发现关于 CMake 变量还可以这样理解！ </a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Modern-CMake&quot;&gt;&lt;a href=&quot;#Modern-CMake&quot; class=&quot;headerlink&quot; title=&quot;Modern CMake&quot;&gt;&lt;/a&gt;Modern CMake&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;现代的 CMake 是指 CMak</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="cmake" scheme="http://okeyia.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>Git学习以及配置</title>
    <link href="http://okeyia.github.io/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <id>http://okeyia.github.io/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/</id>
    <published>2022-11-05T06:11:13.000Z</published>
    <updated>2022-11-06T00:39:46.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git学习以及配置"><a href="#Git学习以及配置" class="headerlink" title="Git学习以及配置"></a>Git学习以及配置</h2><h3 id="一-Git学习"><a href="#一-Git学习" class="headerlink" title="一 Git学习"></a>一 Git学习</h3><p>可视化 git 学习网站 <a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p><h4 id="1-1-git-checkout"><a href="#1-1-git-checkout" class="headerlink" title="1.1 git checkout"></a>1.1 git checkout</h4><p>用来切换分支,  表明当前所在的分支</p><p><em>在 Git2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）</em></p><h4 id="1-2-git-merge"><a href="#1-2-git-merge" class="headerlink" title="1.2 git merge"></a>1.2 git merge</h4><p>将其他的分支合并到当前的分支,   比如将bugFix 合并到main</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先切换到main分支</span></span><br><span class="line">git checkout main</span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105131530367.png" class="" title="image-20221105131530367"><h4 id="1-3-git-rebase"><a href="#1-3-git-rebase" class="headerlink" title="1.3 git rebase"></a>1.3 git rebase</h4><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p><strong>使用命令 git rebase main 后 发生的变化:</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140803587.png" class="" title="image-20221105140803587"><p>现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。<strong>注意</strong>，提交记录 C3 依然存在（树上那个半透明的节点），而 C3’ 是我们 Rebase 到 main 分支上的 C3 的副本。</p><p>此时main还未更新, 使用下列操作更新main。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105131320406.png" class="" title="image-20221105131320406"><p>由于 <code>bugFix</code> 继承自 <code>main</code>，所以 Git只是简单的把 <code>main</code> 分支的引用向前移动了一下而已。</p><h4 id="1-4-HEAD"><a href="#1-4-HEAD" class="headerlink" title="1.4 HEAD"></a>1.4 HEAD</h4><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p><p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git命令都是从改变 HEAD 的指向开始的。</p><p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p><p><strong>分离的HEAD:</strong> 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。</p><p><strong>举例说明：</strong></p><p><strong>执行以下操作：</strong> 发生的变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout c1</span><br><span class="line">git checkout main</span><br><span class="line">git commit</span><br><span class="line">git checkout c2 </span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140632320.png" class="" title="image-20221105140632320"><h4 id="1-5-撤销变更"><a href="#1-5-撤销变更" class="headerlink" title="1.5 撤销变更"></a>1.5 撤销变更</h4><p> Git里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p><p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p><h5 id="1-5-1-git-reset"><a href="#1-5-1-git-reset" class="headerlink" title="1.5.1 git reset"></a>1.5.1 git reset</h5><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105133031370.png" class="" title="image-20221105133031370"><p>原本的main 是指向c2的, 使用<code>git reset HEAD~1</code>后，main分支有迁回了c1，本地代码库就不知道c2的存在了。</p><h5 id="1-5-2-Git-Revert"><a href="#1-5-2-Git-Revert" class="headerlink" title="1.5.2 Git Revert"></a>1.5.2 Git Revert</h5><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><p><strong>使用命令： git revert HEAD</strong> 进行撤销。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140357585.png" class="" title="image-20221105140357585"><p>在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code>是相同的。</p><p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><h4 id="1-6-远程分支"><a href="#1-6-远程分支" class="headerlink" title="1.6 远程分支"></a>1.6 远程分支</h4><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p><p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><p><strong>远程仓库（在图示中）的样子：</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140500408.png" class="" title="image-20221105140500408"><h4 id="1-7-git-fetch"><a href="#1-7-git-fetch" class="headerlink" title="1.7 git fetch"></a>1.7 git fetch</h4><p>Git远程仓库相当的操作实际可以归纳为两点：</p><p><strong>向远程仓库传输数据以及从远程仓库获取数据</strong>。既然我们能与远程仓库同步，那么就可以分享任何能被 Git管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p>执行 <strong>git fetch</strong> 的变化：</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105134417699.png" class="" title="image-20221105134417699"><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><h4 id="1-8-git-pull"><a href="#1-8-git-pull" class="headerlink" title="1.8 git pull"></a>1.8 git pull</h4><p>然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/main</code></li><li><code>git rebase o/main</code></li><li><code>git merge o/main</code></li><li>等等</li></ul><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><ol><li><p>使用命令 <code>git fetch; git merge o/main</code></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105135236346.png" class="" title="image-20221105135236346"><p>我们用 <code>fetch</code> 下载了 <code>C3</code>, 然后通过 <code>git merge o/main</code> 合并了这一提交记录。现在我们的 <code>main</code> 分支包含了远程仓库中的更新（在本例中远程仓库名为 <code>origin</code>）</p></li><li><p>使用 <code>git pull</code> 可以达到同样的效果</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105135555684.png" class="" title="image-20221105135555684"></li></ol><h4 id="1-9-git-push"><a href="#1-9-git-push" class="headerlink" title="1.9 git push"></a>1.9 git push</h4><p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code> 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p><p>*注意 —— <code>git push</code> 不带任何参数时的行为与 Git的一个名为 <code>push.default</code> 的配置有关。它的默认值取决于你正使用的 Git的版本，但是在教程中我们使用的是 <code>upstream</code>*。</p><p><strong>使用 git push 后的变化：</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140045762.png" class="" title="image-20221105140045762"><p>远程仓库接收了 <code>C2</code>，远程仓库中的 <code>main</code> 分支也被更新到指向 <code>C2</code> 了，我们的远程分支 (o/main) 也同样被更新了。所有的分支都同步了！</p><h3 id="二-ssh-key-配置"><a href="#二-ssh-key-配置" class="headerlink" title="二 ssh-key 配置"></a>二 ssh-key 配置</h3><hr><h4 id="2-1-github-使用-token"><a href="#2-1-github-使用-token" class="headerlink" title="2.1 github 使用 token"></a>2.1 github 使用 token</h4><p>为了安全起见，github不再支持密码登录，改为了token，token就相当于一个比较安全的密码，获取到的token是全局的，可以对所有仓库进行操作</p><ol><li><p>获取token，在个人设置下，Developer settings中，新增token</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105112248257.png" class="" title="image-20221105112248257"></li><li><p>拿到token后，有两种使用方式</p><ul><li><p>使用git的时候，每次输入账号密码，这里的密码就是token，但是每次使用都要输入，比较麻烦</p></li><li><p>在git中的远程分支添加token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除原来的分支</span></span><br><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加由token构成的新分支</span></span><br><span class="line">git remote add origin https://token(这里改为自己的token)/okeyia/gem5_vans.git</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105112958726.png" class="" title="image-20221105112958726"></li><li><p>然后就可以愉快的 <code>git push origin master</code>了</p></li></ul></li></ol><h4 id="2-2-github-添加私钥"><a href="#2-2-github-添加私钥" class="headerlink" title="2.2 github 添加私钥"></a>2.2 github 添加私钥</h4><p>这里的话配置的是 <strong>某个仓库</strong> 的私钥，只允许对某个仓库进行操作。第 <strong>2.1</strong> 章节 配置的全局的私钥，可以对账号下面的所有仓库进行操作。</p><p>建议新建一个demo的仓库，在demo中进行配置</p><ol><li><p>在终端中生成一个 github 的 <code>ssh-key</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;xxxxx@qq.com&#x27; -f ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>将私钥对应的公钥,也就是 <strong>github_id_rsa.pub</strong> 的内容copy到github中某个仓库</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105105215110.png" class="" title="image-20221105105215110"></li><li><p>按照<strong>第2.3章节</strong>，配置 config 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.ssh/config</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">内容如下</span></span><br><span class="line">Host github.com</span><br><span class="line">   HostName github.com</span><br><span class="line">   IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line">   </span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 600 ~/.ssh/config</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>配置完成后, 测试一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现一下内容, 则说明配置成功</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Hi 用户名/仓库名! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span>  </span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3-为主机指定私钥"><a href="#2-3-为主机指定私钥" class="headerlink" title="2.3 为主机指定私钥"></a>2.3 为主机指定私钥</h4><p>主机上可能存在多个私钥, 但是连接的时候默认使用的是<code>id_rsa</code>,  如果不匹配的话, 则连接失败。有三种方法实现为主机指定密钥：</p><ul><li><p>ssh -i xxxx 用户@ip地址，（这里xxx是指密钥文件），这样的话每次都要输入密钥文件，比较麻烦</p></li><li><p>将密钥交给 <strong>ssh-agent</strong> 进行管理，但是ssh-agent在系统中并没有开启自启，每次都需要手动开启，不推荐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-agent bash   <span class="comment">#启动 ssh-agent</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add Identity_Linux  <span class="comment"># 为 ssh-agent 添加私钥。这里的 Identity_Linux 是我的私钥文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add -l   <span class="comment">#查看已添加的私钥</span></span></span><br></pre></td></tr></table></figure></li><li><p>配置 <strong>config</strong> 文件，一劳永逸，强烈推荐</p></li></ul><p>SSH的配置文件有两个:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ~/.ssh/config            <span class="comment"># 用户配置文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/ssh/ssh_config      <span class="comment"># 系统配置文件</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 个人建议只配置用户配置文件</span></span><br><span class="line">chmod 600 ~/.ssh/config</span><br></pre></td></tr></table></figure><p>常用的配置参数:</p><ul><li><p><strong>Host</strong></p><p>用于我们执行 SSH 命令的时候如何匹配到该配置。</p><ul><li><code>*</code>，匹配所有主机名。</li><li><code>*.example.com</code>，匹配以 .example.com 结尾。</li><li><code>!*.dialup.example.com,*.example.com</code>，以 ! 开头是排除的意思。</li><li><code>192.168.0.?</code>，匹配 192.168.0.[0-9] 的 IP。</li></ul></li><li><p><strong>HostName</strong></p><p>真实的主机名，默认值为命令行输入的值（允许 IP）</p></li><li><p><strong>Port</strong></p><p>默认端口为22, 使用其他端口的话加上 <code>-p xxx</code></p></li><li><p><strong>User</strong></p><p>登录的用户名</p></li><li><p><strong>IdentityFile</strong></p><p>指定连接的私钥</p></li></ul><p><strong>本地配置实例如下:</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104210515209.png" class="" title="image-20221104210515209"><h3 id="三-gitignore-文件"><a href="#三-gitignore-文件" class="headerlink" title="三 .gitignore 文件"></a>三 .gitignore 文件</h3><p>本地仓库的文件目录结构如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── a.cpp</span><br><span class="line">├── afs</span><br><span class="line">│   └── bfs</span><br><span class="line">├── b.c</span><br><span class="line">├── b.cpp</span><br><span class="line">├── bfs</span><br><span class="line">│   ├── a.cpp</span><br><span class="line">│   └── b.c</span><br><span class="line">├── b.o</span><br><span class="line">└── cfs</span><br><span class="line">    └── fs</span><br><span class="line">        └── bfs</span><br><span class="line">            └── test.txt</span><br></pre></td></tr></table></figure><h4 id="3-1-忽略文件"><a href="#3-1-忽略文件" class="headerlink" title="3.1 忽略文件"></a>3.1 忽略文件</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># this is .gitignore file.</span><br><span class="line"># 以下是忽略的文件</span><br><span class="line">bfs</span><br></pre></td></tr></table></figure><p>只写bfs的话, 忽略同名的文件夹以及文件。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213043599.png" class="" title="image-20221104213043599"><h4 id="3-2-忽略文件而不忽略目录"><a href="#3-2-忽略文件而不忽略目录" class="headerlink" title="3.2 忽略文件而不忽略目录"></a>3.2 忽略文件而不忽略目录</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">bfs</span><br><span class="line">!bfs/</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213424804.png" class="" title="image-20221104213424804"><h4 id="3-3-忽略目录而不忽略文件"><a href="#3-3-忽略目录而不忽略文件" class="headerlink" title="3.3 忽略目录而不忽略文件"></a>3.3 忽略目录而不忽略文件</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">bfs/</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213251537.png" class="" title="image-20221104213251537"><h4 id="3-4-通配符"><a href="#3-4-通配符" class="headerlink" title="3.4 通配符"></a>3.4 通配符</h4><hr><p>常用的通配符有：</p><p>（1）星号“*” ：匹配多个字符；</p><p>（2）问号“?”：匹配除 ‘/’外的任意一个字符；</p><p>（3）方括号“[xxxx]”：匹配多个列表中的字符；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">*.[co]</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104214535749.png" class="" title="image-20221104214535749"><h4 id="3-5-其他规则"><a href="#3-5-其他规则" class="headerlink" title="3.5 其他规则"></a>3.5 其他规则</h4><ol><li>空行不匹配任何文件；</li><li>git 跟踪文件，而不是目录；</li><li>在 .gitignore 文件中，每行表示一种模式；</li><li>如果本地仓库文件已被跟踪，那么即使在 .gitignore 中设置了忽略，也不起作用。这个时候使用 <code>git rm -rf --cached .</code> 先将git cache中的内容全部删除, 然后再重新添加。</li><li>.gitignore 文件也会被上传的到远程仓库，所以，同一个仓库的人可以使用同一个.gitignore 文件。</li></ol><h3 id="四-参考链接"><a href="#四-参考链接" class="headerlink" title="四 参考链接"></a>四 参考链接</h3><ol><li><a href="https://linux.die.net/man/5/ssh_config">ssh_config(5) - Linux man page</a></li><li><a href="https://blog.csdn.net/senlin1202/article/details/122081089">SSH Config 使用</a></li><li><a href="https://gitee.com/help/articles/4229#article-header0">Gitee git 配置多个SSH-KEY</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git学习以及配置&quot;&gt;&lt;a href=&quot;#Git学习以及配置&quot; class=&quot;headerlink&quot; title=&quot;Git学习以及配置&quot;&gt;&lt;/a&gt;Git学习以及配置&lt;/h2&gt;&lt;h3 id=&quot;一-Git学习&quot;&gt;&lt;a href=&quot;#一-Git学习&quot; class=&quot;he</summary>
      
    
    
    
    <category term="工欲善其事, 必先利其器" scheme="http://okeyia.github.io/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B-%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="git配置" scheme="http://okeyia.github.io/tags/git%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>求职算法总结</title>
    <link href="http://okeyia.github.io/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://okeyia.github.io/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-10-24T07:52:03.000Z</published>
    <updated>2022-12-23T12:04:52.388Z</updated>
    
    <content type="html"><![CDATA[<hr><p>还没有总结完!   待续……..</p><hr><h2 id="求职算法总结"><a href="#求职算法总结" class="headerlink" title="求职算法总结"></a>求职算法总结</h2><p>为什么选择c++ 作为主攻语言?   C/C++ 能让我见识到整个计算机体系结构是如何被搭建起来的、程序是如何跑起来的、程序是如何被编译链接在一起的、函数的底层构造是怎样的。</p><h3 id="〇-递归中的时间复杂度"><a href="#〇-递归中的时间复杂度" class="headerlink" title="〇 递归中的时间复杂度"></a>〇 递归中的时间复杂度</h3><p>递归算法的时间复杂度表达式：O(T) = R * O(s)。</p><p>O(T) 表示时间复杂度， R表示递归调用的次数， O(s)每次递归调用计算的时间复杂度。</p><blockquote><p> 斐波那契函数,  它的递归关系是f(n) = f(n-1) + f(n-2),  这里将 n = 5 作为输入,  </p><p>递归过程 抽象成一棵递归树,  在这棵二叉树中每一个节点都是一次递归，那么这棵树有多少个节点呢？  </p><p>一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点, 所以该递归算法的时间复杂度为O(2^n)。</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220921_195136.png" class="" title="Clip_20220921_195136"></blockquote><h3 id="一-二分法"><a href="#一-二分法" class="headerlink" title="一 二分法"></a>一 二分法</h3><hr><h4 id="1-1-找下界"><a href="#1-1-找下界" class="headerlink" title="1.1 找下界"></a>1.1 找下界</h4><p><strong>问题定义：</strong>给定一个升序数组，我们将满足  <code>x ≥ target</code> 的第一个元素定义为 <strong>下界</strong> 。</p><p><code>C++ STL</code>中的 <code>lower_bound()</code> 函数就实现了这个功能。</p><h5 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h5><p>对于数组 <code>[1,2,3,5,5,5,6,7,9]</code>，令 <code>target=5</code>，则满足 <code>x ≥ target</code> 的下界的下标应该是 <code>3</code>。</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_141823.jpg" class="" title="Clip_20220919_141823"><p>可以看到，从这个位置将数组分为左右两部分，**左侧的元素都「小于」<code>target</code>，右侧的元素都「大于等于」<code>target</code>**。</p><p><strong>定义变量 ：</strong></p><ul><li>区间范围为 <code>[left,right]</code>，<code>left</code>、<code>right</code> 是区间的左右边界的下标</li><li><code>mid</code> 是 <code>[left,right]</code> 的中间位置</li><li>初始时，<code>left</code>、<code>right</code> 分别指向数组的第一个和最后一个元素</li><li><strong>当 <code>left &gt; right</code> 时，表示区间为空</strong></li></ul><p>如果我们在二分查找的过程中，<strong>不断右移 <code>left</code>，左移 <code>right</code>，使得所有「小于」<code>target</code> 的元素都在 <code>left</code> 左侧，所有「大于等于」<code>target</code> 的元素都在 <code>right</code> 右侧，那么当区间为空时，<code>left</code> 就是要查找的下界</strong></p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_142137.jpg" class="" title="Clip_20220919_142137"><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><p>根据上述思路，<strong>算法步骤</strong>如下：</p><ul><li>若 <code>nums[mid] &gt;= target</code>，说明 <code>[mid,right]</code> 区间的所有元素均「大于等于」<code>target</code>，因此 <code>right</code> 左移，有 <code>right = mid-1</code></li><li>否则，说明 <code>[left,mid]</code> 区间的所有元素均「小于」<code>target</code>，因此 <code>left</code> 右移，有 <code>left = mid+1</code></li><li>重复上述步骤，直到区间为空，表示找到了下界，**返回 <code>left</code>**。因此循环条件为 <code>left &lt;= right</code>，表示“区间不为空”</li><li>注意，上述两个赋值语句均跳过了中间元素 <code>mid</code></li></ul><p>上述的查找过程如下： </p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_142436.jpg" class="" title="Clip_20220919_142436"><h5 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找满足 x ≥ target 的下界的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> search（<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] &gt;= target)&#123;  <span class="comment">// 这里的比较运算符与题目要求一致</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;   <span class="comment">// 返回下界的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，**<code>if</code> 的判定条件和给定的比较规则是一致的<strong>：要找满足 <code>x &gt;= target</code> 的第一个元素，所以是 <code>if nums[m] &gt;= target</code>。如果要找满足 <code>x &gt; target</code> 的第一个元素，那么只需改为 <code>if nums[m] &gt; target</code>。</strong><code>if</code> 为真时更新 <code>right</code>**。</p><p>最后注意一些细节：</p><ul><li><code>left</code>、<code>right</code> 的初值为 <code>0</code>、<code>n-1</code>，表示「闭区间」</li><li>循环的判定条件是 <code>left &lt;= right</code>，表示区间不为空</li><li>更新 <code>left</code> 和 <code>right</code> 时均跳过了中间元素 <code>mid</code></li></ul><h4 id="1-2-找上界"><a href="#1-2-找上界" class="headerlink" title="1.2 找上界"></a>1.2 找上界</h4><p>定义：满足 <code>x &lt; target</code> 的<strong>最后一个元素</strong>为「上界」。</p><p>给定一个 <code>target</code>，要求返回升序数组中上界的下标。比如：对于数组 <code>[0,1,2,3,4]</code>，当 <code>target=3</code> 时，返回下标 <code>2</code>；当 <code>target=5</code> 时，返回下标 <code>4</code>。</p><p>根据上界和下界的定义，我们可以发现：<strong>上界和「互补的」下界是相邻的，并且 <code>上界 = 下界 - 1</code>**。比如 <code>x ≤ target</code> 的上界和 <code>x &gt; target</code> 的下界相邻。因此，</strong>所有找上界的问题，都可以转换为「互补的」找下界的问题。**</p><p>对于 <code>x &lt; target</code> 而言，要找上界，套用上文的模板，实现 <code>x &gt;= target</code> 的下界, 参考 <a href="#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81">模板代码</a>。</p><p>然后再将下界 减一, 就是我们要找的上界。</p><h4 id="1-3-参考例题"><a href="#1-3-参考例题" class="headerlink" title="1.3 参考例题"></a>1.3 参考例题</h4><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 寻找下界, 第一个 x &gt;= target的位置</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt;= target) right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= nums.size() || nums[left] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找 x == taget 最后一次出现的位置, 只需查找 x &lt;= target的上界 </span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断一下是否越界，或者不相等</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;searchFirst(nums,target),searchLast(nums,target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-4-二分参考链接"><a href="#1-4-二分参考链接" class="headerlink" title="1.4 二分参考链接"></a>1.4 二分参考链接</h4><ol><li></li></ol><h3 id="二-回溯"><a href="#二-回溯" class="headerlink" title="二 回溯"></a>二 回溯</h3><p>回溯法解决的问题</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯解决的问题都可以抽象为树形结构，因为回溯解决的都是在集合中查找子集，集合的大小构成了树的宽度，递归的深度。</p><h4 id="2-1-回溯算法模板"><a href="#2-1-回溯算法模板" class="headerlink" title="2.1 回溯算法模板"></a>2.1 回溯算法模板</h4><ol><li>回溯函数模板返回值以及参数</li><li>回归函数终止条件</li><li>回溯搜索的遍历过程</li></ol><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_200402.png" class="" title="Clip_20220919_200402"><p>综上，回溯算法模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-startIndex-开始位置"><a href="#2-2-startIndex-开始位置" class="headerlink" title="2.2 startIndex 开始位置"></a>2.2 <code>startIndex</code> 开始位置</h4><p>如果是一个集合来求组合的话，就需要<code>startIndex</code>, 例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！</a></p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用<code>startIndex</code>, 如 <a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">回溯算法：电话号码的字母组合</a></p><h4 id="2-3-去重"><a href="#2-3-去重" class="headerlink" title="2.3 去重"></a>2.3 去重</h4><p>分为:  <strong>“树层去重”和“树枝去重”</strong></p><h3 id="三-哈希表"><a href="#三-哈希表" class="headerlink" title="三 哈希表"></a>三 哈希表</h3><h4 id="3-1-set-集合"><a href="#3-1-set-集合" class="headerlink" title="3.1 set(集合)"></a>3.1 set(集合)</h4><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><h4 id="3-2-map-映射"><a href="#3-2-map-映射" class="headerlink" title="3.2 map(映射)"></a>3.2 map(映射)</h4><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><h3 id="四-动态规划"><a href="#四-动态规划" class="headerlink" title="四 动态规划"></a>四 动态规划</h3><p>模板:</p><ol><li>确定<code>dp</code> 数组 (<code>dp table</code>) 以及下表的含义</li><li>确定递推公式</li><li><code>dp</code> 数组初始化</li><li>确定遍历顺序</li><li>举例推导 数组</li></ol><p><strong>分类解题模板</strong><br>背包问题大体的解题模板是两层循环，分别遍历物品<code>nums</code>和背包容量target，然后写转移方程，<br>根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法</p><p><strong>首先是背包分类的模板：</strong><br>1、0/1背包：外循环 <code>nums</code> ,内循环 target, target 倒序且 <code>target&gt;=nums[i]</code> ;<br>2、完全背包：外循环 <code>nums</code> ,内循环 target, target 正序且<code>target&gt;=nums[i]</code>;<br>3、组合背包(考虑顺序)：外循环target,内循环 <code>nums</code>, target正序且 <code>target&gt;=nums[i]</code>;<br>4、分组背包：这个比较特殊，需要三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板</p><p><strong>然后是问题分类的模板：</strong><br>1、最值问题: <code>dp[i] = max/min(dp[i], dp[i-nums]+1)</code>或<code>dp[i] = max/min(dp[i], dp[i-num]+nums)</code>;<br>2、存在问题**<code>(bool)</code>**：<code>dp[i]=dp[i]||dp[i-num]</code>;<br>3、组合问题：<code>dp[i]+=dp[i-num]</code>;</p><p>这样遇到问题将两个模板往上一套大部分问题就可以迎刃而解</p><h4 id="4-1-01-背包问题"><a href="#4-1-01-背包问题" class="headerlink" title="4.1 01 背包问题"></a>4.1 01 背包问题</h4><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221001190410813.png" class="" title="image-20221001190410813"><p><code>dp[i][j]</code> : <strong>表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>对于<code>物品i</code>来说,  有两种状态,  <strong>放入</strong> 或者 <strong>不放</strong>:</p><ol><li>不放的话, <code>dp[i][j]就是dp[i - 1][j]</code></li><li>放入的话, 由<code>dp[i - 1][j - weight[i]]</code>推出</li></ol><p>所以递推公式为:  <code> dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code> </p><p>初始化数组:</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20221001_191233.png" class="" title="Clip_20221001_191233"><p>遍历代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-滚动数组"><a href="#4-2-滚动数组" class="headerlink" title="4.2 滚动数组"></a>4.2 滚动数组</h4><blockquote><p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><p>每一行的 <code>dp[i][∗]</code> 状态值都只与上一行的 <code>dp[i-1][*]</code>状态值有关，因此可基于滚动数组的思想进行对状态空间 <code>dp</code> 进行优化而省去第一维度</p><p><strong>其实可以发现如果把<code>dp[i - 1]</code>那一层拷贝到<code>dp[i]</code>上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p></blockquote><p>滚动数组:  需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p><p>在一维<code>dp</code>数组中，<code>dp[j]</code>表示：容量为j的背包，所背的物品价值可以最大为<code>dp[j]</code>。</p><p><code>dp[j]</code>可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为<code>j - weight[i]</code>的背包所背的最大价值。</p><p>所以递推公式为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量, 从大到小</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历背包是倒序的</strong>,  仔细想一想为为什么要倒叙 ?</p><blockquote><p>考虑到我我们在更新 <code>dp[j]</code>时，使用的其实是上一行的 <code>dp</code>值；而如果第二层循环从小到大计算的话，那么 <code>dp[j−nums[i-1]]</code> 先于 <code>dp[j]</code> 被更新，因此当我们计算 <code>dp[j]</code>值的时候，<code>dp[j−nums[i-1]]</code>已经是被更新过的状态，而不再是上一行的 <code>dp</code> 值了。</p><p>而在第二层循环中，通过从大到小计算则可巧妙地保证在计算 <code>dp[j]</code> 时所用到的 <code>dp[j]</code>]和 <code>dp[j-nums[i-1]]</code>均来自上一行。</p></blockquote><h4 id="4-3-完全背包"><a href="#4-3-完全背包" class="headerlink" title="4.3 完全背包"></a>4.3 完全背包</h4><h4 id="4-4-典型例题"><a href="#4-4-典型例题" class="headerlink" title="4.4 典型例题"></a>4.4 典型例题</h4><p> <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>    <a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">题解</a></p><p>怎么将数学思维和代码结合起来</p><blockquote><p> 题目要求是计算不同二叉搜索树的个数。定义两个函数：</p><p>G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。</p><p>F(i, n) 以 ii为根、序列长度为 n 的不同二叉搜索树个数 (1≤i≤n)</p><p>G(n) 可以从 F(i, n) 得到，而 F(i, n) 又会递归地依赖于 G(n)。</p></blockquote><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20220930214755016.png" class="" title="image-20220930214755016"><h4 id="4-5-参考链接"><a href="#4-5-参考链接" class="headerlink" title="4.5 参考链接"></a>4.5 参考链接</h4><ol><li><a href="https://leetcode.cn/problems/coin-change/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-sq9n/">一篇文章吃透背包问题！（细致引入+解题模板+例题分析+代码呈现）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;还没有总结完!   待续……..&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;求职算法总结&quot;&gt;&lt;a href=&quot;#求职算法总结&quot; class=&quot;headerlink&quot; title=&quot;求职算法总结&quot;&gt;&lt;/a&gt;求职算法总结&lt;/h2&gt;&lt;p&gt;为什么选择c++ 作为主攻语言?   C</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://okeyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C/C++常用刷题技巧</title>
    <link href="http://okeyia.github.io/2022/09/17/C_C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://okeyia.github.io/2022/09/17/C_C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2022-09-17T00:28:27.000Z</published>
    <updated>2022-11-14T02:39:55.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-C-常用刷题技巧"><a href="#C-C-常用刷题技巧" class="headerlink" title="C/C++常用刷题技巧"></a>C/C++常用刷题技巧</h2><p><strong>万能头文件</strong></p><blockquote><p>万能头文件</p><p>基本包括了大部分的STL库函数，使用方便快捷</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="一-vector"><a href="#一-vector" class="headerlink" title="一  vector"></a>一  vector</h3><h4 id="1-1-一维vector初始化"><a href="#1-1-一维vector初始化" class="headerlink" title="1.1  一维vector初始化"></a>1.1  一维vector初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first; <span class="comment">// 空的vector，只是一个列表的头，里面没有元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">second</span> <span class="params">(<span class="number">4</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 初始化一个具有4个元素的vector，每个元素的值都是100</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">third</span> <span class="params">(second.begin(), second.end())</span></span>; <span class="comment">// 通过其他vector的迭代器的方式，进行拷贝复制初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fourth</span> <span class="params">(third)</span></span>; <span class="comment">// 直接对其他vector的拷贝复制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>, <span class="number">2</span>, <span class="number">77</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fifth</span> <span class="params">(myints, myints+<span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>; <span class="comment">// 将数组转化成vector，需要提供的是数组的首地址和地址偏移。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sixth = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>&#125;; <span class="comment">// 指定内容进行构造，内容为1,5,4,6的vector</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vars;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;<span class="comment">//建立一个vector</span></span><br><span class="line"></span><br><span class="line">test.push_back(<span class="number">1</span>);</span><br><span class="line">test.push_back(<span class="number">2</span>);<span class="comment">//把1和2压入vector，这样test[0]就是1,test[1]就是2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//使用下标访问元素</span></span><br><span class="line"><span class="comment">//使用迭代器访问元素.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++)&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec.insert(vec.begin()+i,a);<span class="comment">//在第i+1个元素前面插入a;</span></span><br><span class="line">vec.erase(vec.begin()+<span class="number">2</span>);<span class="comment">//删除第3个元素</span></span><br><span class="line">vec.erase(vec.begin()+i,vec.end()+j);<span class="comment">//删除区间[i,j-1];区间从0开始</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.size()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//向量大小</span></span><br><span class="line">vec.clear();<span class="comment">//清空</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sort(v.begin(),v.end());              <span class="comment">//用sort()函数从小到大进行排序</span></span><br><span class="line">reverse(v.begin(),v.end());          <span class="comment">// 用reverse()函数翻转数组</span></span><br><span class="line">v.size()                             <span class="comment">// 返回容器的大小</span></span><br><span class="line">v.empty()                             <span class="comment">//判断容器是否为空，为空返回0，不为空则为1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v[<span class="number">0</span>];                          <span class="comment">// 打印第一个元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v[v.size()]                     <span class="comment">//打印最后一个元素</span></span><br><span class="line">lower_bound(v.begin(),v.end(),a)      <span class="comment">//在有序数组中返回第一个大于等于a的元素的下标,返回值的是地址</span></span><br><span class="line">upper_bound(v.begin(),v.end(),a)-v.begin()  <span class="comment">//在有序数组中返回第一个大于a的元素的下标,这里通过减去首地址，得到了下标位置</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  <span class="comment">//定义迭代器方便得到元素值，相当于指针</span></span><br><span class="line">it=upper_bound(v.begin,v.end(),a)    </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(*it)                          <span class="comment">//这里返回的是第一个大于a的元素的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-二维数组初始化"><a href="#1-2-二维数组初始化" class="headerlink" title="1.2 二维数组初始化"></a>1.2 二维数组初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维vector的初始化</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vars(size, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size, <span class="number">0</span>)); <span class="comment">// （size,size）的矩阵，元素全部是0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; a(<span class="number">3</span>);<span class="comment">//初始化的是3*3的矩阵,注意我们所申请的矩阵行数和列数默认相等的</span></span><br><span class="line"><span class="comment">//如果我们需要行数和列数不相等的二维数组，那么我们可以对每一行所包含的元素个数加以限制；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)<span class="comment">//利用resize函数将每一行的元素个数设置为5个，即5列 </span></span><br><span class="line">a[i].resize(<span class="number">5</span>);<span class="comment">//此时我们得到的就是一个3行5列的二维数组</span></span><br></pre></td></tr></table></figure><p>如果我们采用size函数来得到数组规模，那么我们所得到的结果是矩阵的行数，如果需要得到列数可以使用<code>a[0].size()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; a(<span class="number">3</span>);<span class="comment">//初始化的是3*3的矩阵 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)<span class="comment">//利用resize函数将每一行的元素个数设置为5个，即5列 </span></span><br><span class="line">a[i].resize(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//打印的是vector的行数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>除上述初始化行列数不同的二维数组之外，我们也可以直接定义</strong>，结果也是3行5列的二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Array(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Array[<span class="number">0</span>].size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下也可以</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;num =</span><br><span class="line">&#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="二-字符串部分"><a href="#二-字符串部分" class="headerlink" title="二 字符串部分"></a>二 字符串部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">string</span> t=<span class="string">&quot;m&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;<span class="comment">//不包括空格</span></span><br><span class="line">getline(<span class="built_in">cin</span>,s);<span class="comment">//读取一行，可以包含空格</span></span><br><span class="line">s.append(t);<span class="comment">//将字符t添加到s  </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s+t;  <span class="comment">//同上述效果一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//find(“字符串”) / find(&quot;字符串&quot;,postion)   ---找不到就返回很大很大的数,可以与-1比较</span></span><br><span class="line"><span class="keyword">if</span>(s1.find(s2)==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;在s1中未找到s2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.find(t)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//找子序列t在s中出现的首次位置</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.find(t,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//从第二个位置开始找，找子序列t在s中出现的首次位置</span></span><br><span class="line"><span class="keyword">int</span> len = s.size();<span class="comment">//字符串s的⻓度</span></span><br><span class="line"><span class="keyword">int</span> len = s.length();<span class="comment">//字符串s的⻓度</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*s1.begin()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指向字符串的第一个元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(s1.end()<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指向字符串的最后一个元素</span></span><br><span class="line"></span><br><span class="line">reverse(s.begin(), s.end());<span class="comment">//字符串反转</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> sTemp=s1.substr(<span class="number">1</span>);<span class="comment">//下标1开始到结束</span></span><br><span class="line"><span class="comment">//截取substr（pos,num） ----在哪个位置截取，截取多少字符</span></span><br><span class="line"><span class="built_in">string</span> sTemp2 = s1.substr(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//下标1开始，截取3个字符</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sTemp&lt;&lt;<span class="string">&quot;----&quot;</span>&lt;&lt;sTemp2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//访问字符串的0处的位置</span></span><br><span class="line"><span class="built_in">string</span> s1,s2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个字符串之间的大小关系</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1==s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1&gt;s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1&lt;s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//插入insert(position,&quot;字符串&quot;)</span></span><br><span class="line">s1.insert(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br><span class="line"><span class="comment">//删除 erase(pos,num)----在哪个位置删除多少字符</span></span><br><span class="line">s1.earse(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将123456转为字符串</span></span><br><span class="line">s1 = to_string(<span class="number">123456</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br><span class="line"><span class="comment">//将字符型1234转为int类型   ---string to int</span></span><br><span class="line"><span class="keyword">int</span> x=stoi(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三-栈"><a href="#三-栈" class="headerlink" title="三 栈"></a>三 栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;  //要引入库函数</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">      s.push(i);<span class="comment">//入栈操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问s的栈顶元素</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.size()&lt;&lt;<span class="built_in">endl</span>;  输出s的元素个数</span><br><span class="line">   s.pop(); <span class="comment">// 删除栈顶元素但不返回其值</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.empty()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//非空返回0，是空返回1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四-队列"><a href="#四-队列" class="headerlink" title="四 队列"></a>四 队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;//要引入库函数</span></span></span><br><span class="line">   <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        s.push(i);<span class="comment">//将i元素接到队列的末端；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;首元素为：&quot;</span>&lt;&lt;s.front()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问队首元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;队尾元素：&quot;</span>&lt;&lt;s.back()&lt;&lt;<span class="built_in">endl</span>;  访问队尾元素</span><br><span class="line">     s.pop(); <span class="comment">// 弹出队列的第一个元素，并不会返回元素的值；</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.empty()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//非空返回0，是空返回1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五-set"><a href="#五-set" class="headerlink" title="五 set"></a>五 set</h3><blockquote><p>⼀个<code>set</code>⾥⾯的各元素是各不相同的（重复元素自动删除），⽽且<code>set</code>会按照元素进⾏从⼩到⼤排序</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">  s.insert(<span class="number">2</span>);<span class="comment">//插入元素</span></span><br><span class="line"></span><br><span class="line">  s.insert(<span class="number">100</span>);<span class="comment">//插入元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    s.insert(i);<span class="comment">//插入元素</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//迭代变量set&lt;int&gt;::iterator it</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s.begin();it!=s.end();it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//集合的遍历，it是一个迭代的指针</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span> v: s)  <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//输入结果：0 1 2 3 4 5 100</span></span><br><span class="line"><span class="comment">//按照从小到大排序，且删除相同元素</span></span><br><span class="line"></span><br><span class="line">s.erase(<span class="number">3</span>);<span class="comment">//删除元素为3的</span></span><br><span class="line">s.clear();<span class="comment">//清空</span></span><br><span class="line">s.size();<span class="comment">//长度</span></span><br><span class="line">s.empty();<span class="comment">//判空</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*s.find(<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//查找某一个num值，返回的是迭代器，因此需要*来输出</span></span><br></pre></td></tr></table></figure><h3 id="六-哈希表"><a href="#六-哈希表" class="headerlink" title="六 哈希表"></a>六 哈希表</h3><h4 id="6-1-map"><a href="#6-1-map" class="headerlink" title="6.1 map"></a>6.1 map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">  mp[x] =i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v: mp) <span class="built_in">cout</span>&lt;&lt;v.first&lt;&lt;<span class="string">&quot; ： &quot;</span>&lt;&lt;v.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-2-unordered-map"><a href="#6-2-unordered-map" class="headerlink" title="6.2 unordered_map"></a>6.2 unordered_map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">//2. 初始化</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 插入元素</span></span><br><span class="line"><span class="comment">//3.1 数组形式</span></span><br><span class="line"><span class="built_in">map</span>[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//3.2 直接插入</span></span><br><span class="line"><span class="built_in">map</span>.insert( &#123; &#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; , &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>&#125; &#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 修改元素</span></span><br><span class="line"><span class="built_in">map</span>[<span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 删除元素</span></span><br><span class="line"><span class="comment">//5.1 删除key为&#x27;a&#x27;的元素</span></span><br><span class="line"><span class="built_in">map</span>.erase(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line"><span class="comment">//5.2删除第一个元素</span></span><br><span class="line"><span class="built_in">map</span>.erase(<span class="built_in">map</span>.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 判断元素是否存在</span></span><br><span class="line"><span class="comment">//6.1 如果元素存在</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">&#x27;a&#x27;</span>)!=<span class="built_in">map</span>.end())</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>.count(<span class="string">&#x27;a&#x27;</span>)!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 清空所有元素    </span></span><br><span class="line"><span class="built_in">map</span>.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 遍历取值并取出键和值</span></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span>&amp; a : <span class="built_in">map</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> key= a.first;</span><br><span class="line">    <span class="keyword">int</span>  value= a.second;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); it++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> key = it-&gt;first;</span><br><span class="line">        <span class="keyword">int</span>  value = it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9. 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>.empty() )</span><br><span class="line">    </span><br><span class="line"><span class="comment">//10. 求元素个数</span></span><br><span class="line"><span class="built_in">map</span>.size();</span><br></pre></td></tr></table></figure><h3 id="七-ACM模式输入输出参考书程序"><a href="#七-ACM模式输入输出参考书程序" class="headerlink" title="七 ACM模式输入输出参考书程序"></a>七 ACM模式输入输出参考书程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;  //INT_MIN 和 INT_MAX的头文件  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 直接输入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 直接输入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 只读取一个字符 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2： cin.get(ch) 或者 ch = cin.get() 或者 cin.get()</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch)) &#123;   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式3 ：ch = getchar()  </span></span><br><span class="line"><span class="keyword">while</span> (getchar()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1给定一个数，表示有多少组数（可能是数字和字符串的组合），然后读取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;   <span class="comment">//每次读取1 + n 个数，即一个样例有n+1个数 </span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理这组数/字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2 首先给一个数字，表示需读取n个字符，然后顺序读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;  <span class="comment">//输入数量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">strs.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理这组字符串</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.未给定数据个数，但是每一行代表一组数据，每个数据之间用空格隔开</span></span><br><span class="line"><span class="comment">//4.1使用getchar() 或者 cin.get() 读取判断是否是换行符，若是的话，则表示该组数（样例）结束了，需进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ele;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ele) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = ele;</span><br><span class="line"><span class="comment">// getchar()   //读取单个字符</span></span><br><span class="line"><span class="comment">/*while (cin.get() != &#x27;\n&#x27;) &#123;*/</span>   <span class="comment">//判断换行符号</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) &#123;  <span class="comment">//如果不是换行符号的话，读到的是数字后面的空格或者table</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.2 给定一行字符串，每个字符串用空格间隔，一个样例为一行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line"><span class="keyword">if</span> (getchar() == <span class="string">&#x27;\n&#x27;</span>) &#123;  <span class="comment">//控制测试样例</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">strs.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.3 使用getline 读取一整行数字到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> input;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, input)) &#123;  <span class="comment">//读取一行</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">data</span><span class="params">(input)</span></span>;  <span class="comment">//使用字符串流</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (data &gt;&gt; num) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.4 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> words;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, words)) &#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">data</span><span class="params">(words)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (data &gt;&gt; str) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.5 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。每个字符中间用&#x27;,&#x27;间隔</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while (cin &gt;&gt; line) &#123;  //因为加了“，”所以可以看出一个字符串读取</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (getline(ss, str, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言读取字符、数字</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch)) &#123; <span class="comment">//获得单个字符</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;  <span class="comment">//遇到空白停止</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str);  <span class="comment">//读入一行字符串</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="八-其他"><a href="#八-其他" class="headerlink" title="八 其他"></a>八 其他</h3><h4 id="自带的宏常量"><a href="#自带的宏常量" class="headerlink" title="自带的宏常量"></a>自带的宏常量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = INT_MIN;</span><br><span class="line"><span class="keyword">int</span> N = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">//通常用来代替最大值，防止运算过程中溢出  0x16进制</span></span><br></pre></td></tr></table></figure><h4 id="字符串判断函数"><a href="#字符串判断函数" class="headerlink" title="字符串判断函数"></a>字符串判断函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isdigit</span>(c)  <span class="comment">//判断c字符是不是数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)  <span class="comment">//判断c字符是不是字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(c)  <span class="comment">//判断c字符是不是数字或者字母</span></span><br><span class="line"><span class="built_in">tolower</span>(c)  <span class="comment">//转为小写</span></span><br><span class="line"><span class="built_in">toupper</span>(c)  <span class="comment">//转为大写</span></span><br></pre></td></tr></table></figure><h4 id="字符串和数值间的转换"><a href="#字符串和数值间的转换" class="headerlink" title="字符串和数值间的转换"></a>字符串和数值间的转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">string</span> str = to_string(num); <span class="comment">//整形转字符串</span></span><br><span class="line"><span class="keyword">int</span> number = stoi(str);  <span class="comment">//字符串转为整形 stol()是字符串转为长整形</span></span><br></pre></td></tr></table></figure><h4 id="迭代器的二分"><a href="#迭代器的二分" class="headerlink" title="迭代器的二分"></a>迭代器的二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">44</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k = lower_bound(nums.begin(), nums.end(), <span class="number">56</span>) - nums.begin(); <span class="comment">//第一个大于等于目标值的迭代器位置</span></span><br><span class="line"><span class="keyword">int</span> k = upper_bound(nums.begin(), nums.end(), <span class="number">56</span>) - nums.begin(); <span class="comment">// 找到第一个大于目标值的迭代器位置</span></span><br></pre></td></tr></table></figure><h4 id="字符串转为小写"><a href="#字符串转为小写" class="headerlink" title="字符串转为小写"></a>字符串转为小写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**op作用的范围[str1.begin(), str1.end], 作用完成后，存储位置的开头为：str2.begin()，op为toupper/tolower*/</span></span><br><span class="line">transform(str1.begin(), str1.end(), str2.begin(), ::<span class="built_in">toupper</span>);</span><br><span class="line">transform(str1.begin(), str1.end(), str2.begin(), ::<span class="built_in">tolower</span>);</span><br></pre></td></tr></table></figure><h4 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">//默认是大根堆</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq; <span class="comment">//小根堆</span></span><br></pre></td></tr></table></figure><h4 id="快速初始化数组"><a href="#快速初始化数组" class="headerlink" title="快速初始化数组"></a>快速初始化数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这个函数是按字节初始化的</span></span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">-1</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> nums);</span><br></pre></td></tr></table></figure><h4 id="C-11的特性"><a href="#C-11的特性" class="headerlink" title="C++11的特性"></a>C++11的特性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> ListNode(); <span class="comment">// auto 关键字</span></span><br><span class="line">Node* pre = <span class="literal">nullptr</span>   <span class="comment">// nullptr代替NULL</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp; <span class="comment">//哈希表 内部是无序的</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">//无序集合</span></span><br></pre></td></tr></table></figure><h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(n).to_string();</span><br><span class="line">    reverse(s.begin(), s.end());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(s).to_ulong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><p>将字符串按照空格分割</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world my name is yao jun&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; str)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>hello</p><p>world</p><p>my</p><p>name</p><p>is</p><p>yao</p><p>jun</p><p>7</p></blockquote><h4 id="四舍五入保留小数"><a href="#四舍五入保留小数" class="headerlink" title="四舍五入保留小数"></a>四舍五入保留小数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">double</span> num = <span class="number">22.23434</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;%.2f&quot;</span>, num);</span><br><span class="line"><span class="built_in">string</span> s = str;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串按格式拆分"><a href="#字符串按格式拆分" class="headerlink" title="字符串按格式拆分"></a>字符串按格式拆分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;12:59:36&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(str2, a.c_str(), <span class="built_in">strlen</span>(a.c_str()));</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">sscanf</span>(str2, <span class="string">&quot;%d:%d:%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;w&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>12 59 36</p></blockquote><h4 id="相同字符的字符串"><a href="#相同字符的字符串" class="headerlink" title="相同字符的字符串"></a>相同字符的字符串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果:</p><p>aaaaaaaaaa</p></blockquote><h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; node_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; tt;</span><br><span class="line">    tt.push_back(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    tt.push_back(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    sort(tt.begin(), tt.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node: tt)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;node.b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>1 5</p><p>2 3</p></blockquote><h4 id="优先队列自定义排序"><a href="#优先队列自定义排序" class="headerlink" title="优先队列自定义排序"></a>优先队列自定义排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="comment">// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; node_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line">    pq.push(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    pq.push(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    pq.push(&#123;<span class="number">2</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pq.top().a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pq.top().b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果</p><p>2 5</p><p>2 3</p><p>1 5</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-C-常用刷题技巧&quot;&gt;&lt;a href=&quot;#C-C-常用刷题技巧&quot; class=&quot;headerlink&quot; title=&quot;C/C++常用刷题技巧&quot;&gt;&lt;/a&gt;C/C++常用刷题技巧&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;万能头文件&lt;/strong&gt;&lt;/p&gt;
&lt;blockquo</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://okeyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>QT学习笔记</title>
    <link href="http://okeyia.github.io/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://okeyia.github.io/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-08-16T08:08:03.000Z</published>
    <updated>2022-11-26T03:05:37.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QT学习笔记"><a href="#QT学习笔记" class="headerlink" title="QT学习笔记"></a>QT学习笔记</h2><hr><p>未完待续。。。。。。 预计寒假期间完成</p><hr><h3 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h3><h4 id="pro-配置文件"><a href="#pro-配置文件" class="headerlink" title=".pro 配置文件"></a>.pro 配置文件</h4><h4 id="QT注意事项"><a href="#QT注意事项" class="headerlink" title="QT注意事项"></a>QT注意事项</h4><ul><li><p>命名规范</p><ul><li>类名 首字母大写，单词和单词之间首字母大写</li><li>函数名 变量名称 首字母小写,单词和单词之间首字母大写</li></ul></li><li><p>快捷键</p><ul><li>注释 ctrl + /</li><li>运行 ctrl + r</li><li>编译 ctrl + b</li><li>查找 ctrl + f</li><li>帮助文档 F1</li><li>自动对齐 ctrl + i</li><li>同名的.h和.cpp切换 F4</li></ul></li></ul><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><ul><li>按钮常用API</li></ul><ol><li>show() 以顶层方式弹出窗口控件</li><li>setParent() 选择依赖方式</li><li>setText() 设置文本</li><li>resize() 重置窗口大小</li><li>move() 移动</li><li>setWindowTitle() 设置窗口大小</li><li>setFixedSize() 设置固定窗口大小</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line"><span class="comment">// btn-&gt;show();</span></span><br><span class="line"><span class="comment">// 让 btn 对象依赖于myWidget 中</span></span><br><span class="line">btn-&gt;setParent(<span class="keyword">this</span>);</span><br><span class="line">btn-&gt;setText(<span class="string">&quot;第一个按钮&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="QT中的对象树"><a href="#QT中的对象树" class="headerlink" title="QT中的对象树"></a>QT中的对象树</h4><ol><li>当创建的对象在堆区的时候,如果指定的父亲是QObject 派生下来的类或者子类</li><li>派生下来的类,可以不需要管理释放操作,会将对象放入对象树一定程度上简化了内存回收机制</li></ol><p>这里的话 ,打印顺序是反的, 是先打印了代码, 但是对象还没有释放掉。 正确的理解过程是先释放 我的按钮类 析构， 然后myWidget类析构 调用。</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220818125200089.png" class="" title="image-20220818125200089"><h4 id="QT的窗口坐标系"><a href="#QT的窗口坐标系" class="headerlink" title="QT的窗口坐标系"></a>QT的窗口坐标系</h4><ol><li>笛卡尔坐标系[左上角为0,0点]</li></ol><h4 id="QT信号和槽"><a href="#QT信号和槽" class="headerlink" title="QT信号和槽"></a>QT信号和槽</h4><p>connect( 信号的发送者 ,信号的具体信息(函数的地址), 信号的接受者,信号的处理(槽)(也是函数的地址))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求:点击 &quot;我的按钮&quot; 关闭窗口</span></span><br><span class="line">connect(mybtn3,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;myWidget::close);</span><br></pre></td></tr></table></figure><ul><li>信号槽的优点 松散耦合,信号发送端 和 接收端本身是没有关联的,通过connectl连接,将两者耦合在一起<ul><li>信号关键字：Signals<ul><li>chlicked(bool) 点击</li><li>pressed() 按下</li><li>released() 释放</li><li>toggled(bool) 切换状态</li></ul></li><li>槽的关键字：Slots</li></ul></li><li>自定义信号和槽位函数<ul><li>自定义信号<ul><li>写在类的signals下,返回值为void,可以有参数,支持重载,不需要实现</li></ul></li><li>自定义槽函数<ul><li>不能写在signals下,public slots[公共的槽函数] 5.4版本以后全局函数或者public都行</li><li>返回值也是void,需要声明,也需要实现,可以有参数,支持重载</li></ul></li><li>然后用connect连接信号和槽</li><li>触发信号 emit</li><li>信号和槽重载，需要函数指针，明确指向函数的地址</li><li>QString 转char * 使用.toUtf8().data()</li><li>信号和槽连接：触发这个信号才能触发槽<ul><li>一个信号可以连接多个槽</li><li>多个信号也可以连接同一个槽函数</li><li>信号和槽的参数和类型必须对应</li><li>信号的参数个数可以多于槽的参数个数</li></ul></li><li>信号和信号连接 触发一个信号也能触发另外一个信号</li><li>断开信号 disconnect(参数一样)</li></ul></li></ul><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><ul><li>C++11版本特性 [CONFIG += c++11] 匿名函数对象<ul><li>Lambda表达式函数声明 <code>[]()&#123;&#125;</code><ul><li>[=] 允许使用局部变量</li><li>[&amp;] 允许使用引用传递变量</li><li>[变量] 允许变量使用值传递</li><li>mutable 可修改值传递进来的参数[虽然还是局部变量]<ul><li><code>[m]()mutable&#123;m+=100;打印&#125;;</code> 不加mutable会报错</li></ul></li><li>-&gt;类型 带返回值<ul><li><code>int ret = []()-&gt;int&#123;return 1000&#125;();</code></li></ul></li></ul></li><li>Lambda表达式函数调用 <code>[]()&#123;&#125;()</code></li><li>最常见的<code>[=]()&#123;&#125;</code></li></ul></li></ul><h3 id="MainWindow"><a href="#MainWindow" class="headerlink" title="MainWindow"></a>MainWindow</h3><h4 id="菜单栏-QMenuBar"><a href="#菜单栏-QMenuBar" class="headerlink" title="菜单栏 QMenuBar"></a>菜单栏 QMenuBar</h4><pre><code>* 菜单栏最多只能有一个    + QMenuBar * bar = menuBar(); setMenuBar(bar);    + 创建菜单        * QMenu * fileMenu = bar-&gt;addMenu(&quot;文件&quot;);            + 创建菜单栏目                * QAction * newAction =  fileMenu-&gt;addAction(&quot;新建&quot;);            + 添加分隔符                 * fileMenu-&gt;addSeparator();</code></pre><h4 id="工具栏-QToolBar"><a href="#工具栏-QToolBar" class="headerlink" title="工具栏 QToolBar"></a>工具栏 QToolBar</h4><pre><code>* 工具栏可以有多个    + QToolBar * toolBar = new QToolBar(this);      + addToolBar(toolBar);        * 可选参数 默认停靠范围            + addToolBar(Qt::BottomToolBarArea,toolBar);        * 只允许左右停靠            + toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea);        * 取消浮动            + toolBar-&gt;setFloatable(false);        * 设置禁止移动            + toolBar-&gt;setMovable(false);        * 给工具栏设置栏目            + toolBar-&gt;addAction(&quot;绝了&quot;或者QAction);        * 给工具栏添加控件            + toolBar-&gt;addWidget(QPushButton按钮);</code></pre><h4 id="状态栏-QStatusBar"><a href="#状态栏-QStatusBar" class="headerlink" title="状态栏 QStatusBar"></a>状态栏 QStatusBar</h4><pre><code>* 状态栏最多只能有一个    + QStatusBar * stBar = statusBar();    + setStatusBar(stBar);        * 添加标签控件            + QLabel * label = new QLabel(&quot;左侧提示的信息&quot;,this);            + QLabel * label1 = new QLabel(&quot;右侧提示的信息&quot;,this);            + stBar-&gt;addWidget(label);            + stBar-&gt;addPermanentWidget(label1);</code></pre><h4 id="铆接部件-QDockWidget"><a href="#铆接部件-QDockWidget" class="headerlink" title="铆接部件 QDockWidget"></a>铆接部件 QDockWidget</h4><pre><code>* 铆接部件可以有多个    + QDockWidget * dockWidget = new QDockWidget(&quot;浮动&quot;,this);    + addDockWidget(Qt::BottomDockWidgetArea,dockWidget); 放置位置下面 如果没有中心部件默认占满        + 只允许上下                * dockWidget-&gt;setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);  </code></pre><h4 id="中心部件"><a href="#中心部件" class="headerlink" title="中心部件"></a>中心部件</h4><pre><code>* 中心内容也只能有一个    + 文本窗口 QTextEdit        + QTextEdit * edit = new QTextEdit(this);        + setCentralWidget(edit); //设置中心部件</code></pre><h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><ol><li>将图片文件文件夹拷贝到项目下</li><li>右键项目-&gt;添加新文件-&gt;Qt-&gt;Qt recourse File</li><li>res 生成 res.qrc</li><li>右键res.qrc-&gt;open in editor 编辑资源</li><li>添加前缀 添加文件</li><li>使用 “: + 前缀名 + 文件名”</li></ol><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><pre><code>+ 只能有一个的是set 可以允许多个是add</code></pre><h4 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h4><ul><li>模态对话框 不可以对其他窗口进行操作<ul><li>QDialog dlg(this);</li><li>dlg.exec();</li><li>消息对话框<ul><li>错误对话框 QMessageBox::critical(this,”critical”,”错误”);</li><li>信息对话框 information</li><li>提问对话框 question</li><li>警告对话框warning</li><li>颜色对话框<ul><li>QColor a = QColorDialog::getColor(QColor(255,0,0));</li></ul></li><li>文件对话框 最后一个是过滤<ul><li>QString str = QFileDialog::getOpenFileName(this,”打开文件”,”./“,”(*.cpp)”);</li></ul></li><li>字体对话框<ul><li>bool flag;</li><li>QFont font = QFontDialog::getFont(&amp;flag,QFont(“华文彩云”,12));</li><li>setFont(font);//设置字体</li></ul></li></ul></li></ul></li><li>非模态对话框 可以对其他窗口进行操作<ul><li>QDialog *dlg2 = new QDialog(this); //为了确保不释放,开在堆上</li><li>dlg2-&gt;show();</li><li>dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose);//55号 用于按关闭键自动释放[QWidge的对象树是在关闭总的窗口才会全部释放]</li></ul></li></ul><h4 id="列表控件-listWidget"><a href="#列表控件-listWidget" class="headerlink" title="列表控件 listWidget"></a>列表控件 listWidget</h4><ul><li>QListWidgetItem * item = new QListWidgetItem(“锄禾日当午”);</li><li>ui-&gt;listWidget-&gt;addItem(item); //添加进去</li><li>item-&gt;setTextAlignment(Qt::AlignCenter); //居中</li></ul><h4 id="ui窗口自布局"><a href="#ui窗口自布局" class="headerlink" title="ui窗口自布局"></a>ui窗口自布局</h4><ol><li>Spacers 弹簧 Widget div盒子</li><li>Group Box 分组[适用于Radio Button]</li><li>主窗口设置垂直布局后可以在sizePolicy-&gt;垂直策略-&gt;Fixed来使组件高度合适</li><li>如果找不到某个组件的信号或者槽，找基类</li></ol><h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><ol><li>add new -&gt; 设计师类</li><li>使用自定义组件<ul><li>查看基类[如widget] 从界面库中拖出来一个widget组件,然后点击提升为,写入类名<ul><li>[设置全局后可以直接在右键中显示]<br>3 自定义组件只有同基类才能被提升</li></ul></li></ul></li></ol><h4 id="QT事件-QEvent"><a href="#QT事件-QEvent" class="headerlink" title="QT事件 QEvent"></a>QT事件 QEvent</h4><ul><li><p>鼠标事件</p><ul><li>事件是虚函数,可以进行重载<br>//鼠标进入事件<br>virtual void enterEvent(QEvent *event);<br>//鼠标离开事件<br>virtual void leaveEvent(QEvent *event);<br>//鼠标按下<br>virtual void mouseReleaseEvent(QMouseEvent *ev);<br>//鼠标释放<br>virtual void mousePressEvent(QMouseEvent *ev);<br>//鼠标移动<br>virtual void mouseMoveEvent(QMouseEvent *ev);  </li></ul></li><li><p>定时器 QTimeEvent</p><ul><li>利用事件实现定时器<ul><li>startTimer(1000); 启动定时器，单位毫秒,返回一个唯一定时器id</li><li>void timerEvent(QTimerEvent * ev)<ul><li>定时器函数,可以通过ev-&gt;timerId()== id1来判断当前是哪个id进来的</li></ul></li></ul></li><li>定时器类QTimer<ul><li>//通过定时器类<br>  QTimer * timer = new QTimer(this);<br>  //启动定时器 每隔500秒发一个信号<br>  timer-&gt;start(500);<br>  //连接信号<br>  connect(timer,&amp;QTimer::timeout,中括号小括号{<br>  static int num = 1;<br>  ui-&gt;label_5-&gt;setText(QString::number(num++));<br>  });  </li></ul></li></ul></li><li><p>event事件分发器</p><ul><li>bool event(QEvent * ev)<ul><li>返回值是bool类型，如果返回true，代表用户要处理这个事件,不向下分发事件了[类似于钩子]</li></ul></li><li>事件枚举QEvent<ul><li>ev.type();</li><li>拦截后使用子类的操作可以使用静态类型转换<ul><li>QMouseEvent *ev = static_cast&lt;QMouseEvent *&gt;(QEvent中行参);</li></ul></li></ul></li><li>但是尽量别拦截</li></ul></li><li><p>事件过滤器</p><ul><li>在app到事件分发器前还能做个过滤</li><li>使用方式<ul><li>给控件安装时间过滤器<ul><li>installEventFilter(this);</li></ul></li><li>重写eventfilter事件</li></ul></li></ul></li></ul><h4 id="绘图-QPainter"><a href="#绘图-QPainter" class="headerlink" title="绘图 QPainter"></a>绘图 QPainter</h4><ul><li>绘图事件 void paintEvent(QPaintEvent *)</li><li>画家类 QPainter(构图的设备)<ul><li>拿起笔 .setPen(笔)</li><li>拿起刷子 .setBrush(刷子)</li></ul></li><li>画笔类 QPen(笔的颜色)</li><li>画刷类 QBrush(笔的颜色)</li><li>高级操作<ul><li>效率降低的抗锯齿<ul><li>painter.setRenderHint()</li></ul></li><li>改变画家位置<ul><li>painter.save();保存当前位置</li><li>painter.restore(); 还原到保存的位置</li><li>painter.translate(); 移动画家</li></ul></li><li>画家绘制图片drawPixmap</li></ul></li></ul><h4 id="绘图设备"><a href="#绘图设备" class="headerlink" title="绘图设备"></a>绘图设备</h4><ul><li>QPixmap 专门对图像显示做了优化</li><li>QBitmap 色深限定为1</li><li>QImage 专门为图像的像素级访问做了优化</li><li>QPicture 可以记录和重视画家的QPainter的各类命令<ul><li>自定义绘图操作 </li></ul></li></ul><h4 id="文件读写-QFile"><a href="#文件读写-QFile" class="headerlink" title="文件读写 QFile"></a>文件读写 QFile</h4><ul><li>file.open(打开方式) QtODevice::readOnly</li><li>全部读取 file.readAll() 按行读 file.readLine() 判断文件末尾atend()</li><li>QFile默认支持的是utf-8 指定格式 QTextCodec<ul><li>QTextCodec *codec = QTextCodec::codecForName(“gbk”);</li><li>ui-&gt;textEdit-&gt;setText(codec-&gt;toUnicode(array)); </li></ul></li><li>关闭文件对象 file.close();</li></ul><h4 id="文件信息-QFileInfo"><a href="#文件信息-QFileInfo" class="headerlink" title="文件信息 QFileInfo"></a>文件信息 QFileInfo</h4><ul><li>QFileInfo info(path);</li><li>后缀名 info.suffix()</li><li>创建日期 info.birthTime().toString(“yyyy/MM/dd hh:mm:ss”);</li><li>修改日期 info.lastModified().toString(“yyyy/MM/dd hh:mm:ss”);</li></ul><h4 id="Qss-前端人狂喜"><a href="#Qss-前端人狂喜" class="headerlink" title="Qss 前端人狂喜"></a>Qss 前端人狂喜</h4><ul><li>#myButton 这里的id实际上就是objectName指定的值</li><li>伪状态<ul><li>:active 当小部件驻留在活动窗口中时，将设置此状态</li><li>:checked    该控件被选中时候的状态</li><li>:hover    鼠标在控件上方</li><li>:pressed    该控件被按下时的状态</li><li>:disabled    该控件禁用时的状态</li><li>:first    该控件是第一个（列表中）</li><li>:focus    该控件有输入焦点时</li></ul></li></ul><h4 id="动画-QPropertyAnimation"><a href="#动画-QPropertyAnimation" class="headerlink" title="动画 QPropertyAnimation"></a>动画 QPropertyAnimation</h4><p>//winLabel 你要对那个组件使用动画  geometry几何结构<br>QPropertyAnimation * an = new QPropertyAnimation(winLabel,”geometry”);<br>//动画时间<br>an-&gt;setDuration(1000);<br>//动画开始<br>an-&gt;setStartValue(QRect(winLabel-&gt;x(),winLabel-&gt;y(),winLabel-&gt;width(),winLabel-&gt;height()));<br>//动画结束<br>an-&gt;setEndValue(QRect(winLabel-&gt;x(),winLabel-&gt;y() + 300,winLabel-&gt;width(),winLabel-&gt;height()));<br>//动画方式<br>an-&gt;setEasingCurve(QEasingCurve::OutBounce);<br>an-&gt;start();  </p><h4 id="背景音乐-QSound"><a href="#背景音乐-QSound" class="headerlink" title="背景音乐 QSound"></a>背景音乐 QSound</h4><ul><li>qmake: QT += multimedia</li><li>QSound * startSound = new QSound(“:/res/TapButtonSound.wav”,this); 载入音效</li><li>startSound-&gt;play(); 播放</li><li>startSound-&gt;setLoops(-1); -1循环次数无限</li></ul><h4 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h4><ul><li>debug-&gt;release</li><li>运行 运行失败添加环境变量D:\QT\5.12.3\mingw73_64\lib</li><li>把 Goldreverse.exe 单独丢到一个文件夹下</li><li>cmd中路径后windeployqt .\Goldreverse.exe 运行</li><li>此时已经可以使用了</li><li>深入打包[hm nis edit][<a href="https://www.bilibili.com/video/BV1g4411H78N?p=63&amp;spm_id_from=pageDriver%5D">https://www.bilibili.com/video/BV1g4411H78N?p=63&amp;spm_id_from=pageDriver]</a></li><li>HM NIS Edit 和 NSIS</li></ul><h3 id="Qt-amp-Clion-配置"><a href="#Qt-amp-Clion-配置" class="headerlink" title="Qt &amp; Clion 配置"></a>Qt &amp; Clion 配置</h3><h4 id="工具链的配置"><a href="#工具链的配置" class="headerlink" title="工具链的配置"></a>工具链的配置</h4><p>主要是配置工具链中的工具集，注意选中qt安装路径中的mingw</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221105202452526.png" class="" title="image-20221105202452526"><h4 id="CmakeList中的设置"><a href="#CmakeList中的设置" class="headerlink" title="CmakeList中的设置"></a>CmakeList中的设置</h4><p>在CmakeList中设置CMAKE_PREFIX_PATH 为 Qt安装路径中的cmake</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221105202714141.png" class="" title="image-20221105202714141"><h4 id="关于乱码问题"><a href="#关于乱码问题" class="headerlink" title="关于乱码问题"></a>关于乱码问题</h4><p>写入到student.text中的数据, 打开是乱码, 暂时还没有解决</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://blog.csdn.net/qq_41622214/article/details/124776481?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-124776481-blog-115482634.pc_relevant_multi_platform_whitelistv3&spm=1001.2101.3001.4242.1&utm_relevant_index=3">CLion配置Qt环境</a></li></ol><h3 id="案例一-翻金币"><a href="#案例一-翻金币" class="headerlink" title="案例一: 翻金币"></a>案例一: 翻金币</h3><hr><p><a href="https://www.bilibili.com/video/BV1g4411H78N?p=52&vd_source=d4177fc7398a75956465a504f7fd3259">视频链接</a></p><ul><li>收获<ol><li>删除资源文件后需要删除debug文件,不然会报错</li><li>界面的切换可以使用信号和槽 即其它界面emit发送一个信号,主界面接收<ul><li>当然也可以选择记录父类指针,但是必须要在构造函数中多传个参数，而不是使用默认的parent</li></ul></li><li>在按钮上方有其他组件，可以使用label-&gt;setAttribute(Qt::WA_TransparentForMouseEvents);让其可以点到按钮[51号属性]</li><li>界面翻转金币 本质上是个按钮 <ul><li>人点击后 </li><li>金币触发翻转</li><li>定时器每隔30ms发送一次信号给金币</li><li>金币触发图片重新放置,到最大值或者最小值的时候关闭定时器</li><li>金币中有坐标i 和 j 以及一个flag 来确定该金币在页面中的位置</li></ul></li><li>锁定窗口 m_chooseScence-&gt;setGeometry(this-&gt;geometry()); 每次进入或者退出都锁定他的位置</li></ol></li><li>延时器<br>QTimer::singleShot(毫秒,拉姆达表达式);</li></ul><h3 id="案例二-学生管理"><a href="#案例二-学生管理" class="headerlink" title="案例二: 学生管理"></a>案例二: 学生管理</h3><hr><p>参考大佬的代码, 建议连接上数据库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;QT学习笔记&quot;&gt;&lt;a href=&quot;#QT学习笔记&quot; class=&quot;headerlink&quot; title=&quot;QT学习笔记&quot;&gt;&lt;/a&gt;QT学习笔记&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;未完待续。。。。。。 预计寒假期间完成&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;QWidget&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Processor Counter Monitor</title>
    <link href="http://okeyia.github.io/2022/07/27/Processor_Counter_Monitor/"/>
    <id>http://okeyia.github.io/2022/07/27/Processor_Counter_Monitor/</id>
    <published>2022-07-26T16:08:58.000Z</published>
    <updated>2022-11-06T05:08:30.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Processor-Counter-Monitor测量cache及带宽"><a href="#Processor-Counter-Monitor测量cache及带宽" class="headerlink" title="Processor-Counter-Monitor测量cache及带宽"></a>Processor-Counter-Monitor测量cache及带宽</h2><p>Performance Counter Monitor（PCM）是一个由英特尔开发的，也是基于PMU(performance monitoring unit)一个性能检测工具。</p><p>它是运行在msr 内核模块(perf是内核系统调用吧？)上的，提供了C++ API。</p><ul><li>pcm：CPU、cache</li><li>pcm-memory：内存带宽（每频道及每个DRAM DIMM槽）</li><li>pcm-latency：L1 cahce</li><li>pcm-pcie：PCIe</li><li>pcm-numa：NUMA架构</li><li>pcm-power：能耗</li></ul><p><a href="https://github.com/opcm/pcm">最新版</a> , 复现论文[Saga-Bench: Software and Hardware Characterization of Streaming Graph Analytics Workloads] 的过程中, <a href="https://github.com/opcm/pcm/tree/91dbfaaf1a956c669de6cb705e033bd28e313ef7">用到的历史版本</a> 。 </p><h3 id="一-编译PCM"><a href="#一-编译PCM" class="headerlink" title="一 编译PCM"></a>一 编译PCM</h3><p>从 <code>github</code> 下载好源码, 进行编译,  编译完成后, 测试实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">0.1秒监测一次，结果输出为test.csv文件</span></span><br><span class="line">sudo ./pcm.x 0.1 -csv=test.csv --external-program Test</span><br></pre></td></tr></table></figure><p>第一次运行可能会出现如下错误:</p><blockquote><p>PCM Error: can’t open MSR handle for core 0<br>Can not access CPUs Model Specific Registers (MSRs).<br>Try to execute ‘modprobe msr’ as root user and then<br>you also must have read and write permissions for /dev/cpu/<em>/msr devices (/dev/msr</em> for Android). The ‘chown’ command can help.<br>Access to Processor Counter Monitor has denied (no MSR or PCI CFG space access).</p></blockquote><p>解决方法, 切换到 root 用户, 执行 modprobe msr 。</p><h3 id="二-测量L2-L3-cache的缺失率"><a href="#二-测量L2-L3-cache的缺失率" class="headerlink" title="二 测量L2 L3 cache的缺失率"></a>二 测量L2 L3 cache的缺失率</h3><h4 id="2-1-pcmBasic-h"><a href="#2-1-pcmBasic-h" class="headerlink" title="2.1 pcmBasic.h"></a>2.1 pcmBasic.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCMBasic_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCMBasic_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/cpucounters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">CounterStateType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_processor_level_stats</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; out, <span class="keyword">const</span> PCM * m, <span class="keyword">const</span> CounterStateType &amp; state1, <span class="keyword">const</span> CounterStateType &amp; state2)</span></span>&#123;</span><br><span class="line">    assert(out.is_open());</span><br><span class="line">    <span class="comment">/* Output format/order: L2 MPKI, L3 MPKI, L2 hit rate, LLC hit rate, TLP (active cycles method), TLP (C state method = BigBench paper&#x27;s method)</span></span><br><span class="line"><span class="comment">     incoming QPI link utilization, outgoing QPI link utilization */</span></span><br><span class="line">    assert(m-&gt;isL2CacheMissesAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL3CacheMissesAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL2CacheHitRatioAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL3CacheHitRatioAvailable());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> uint32 qpiLinks = (uint32)m-&gt;getQPILinksPerSocket();    </span><br><span class="line">    <span class="keyword">double</span> incoming = <span class="number">0.0</span>; <span class="keyword">double</span> outgoing = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 i = <span class="number">0</span>; i &lt; m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (uint32 l = <span class="number">0</span>; l &lt; qpiLinks; ++l)&#123;</span><br><span class="line">            incoming += <span class="number">100.</span> * getIncomingQPILinkUtilization(i, l, state1, state2);</span><br><span class="line">            outgoing += <span class="number">100.</span> * getOutgoingQPILinkUtilization(i, l, state1, state2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> overallIncomingQPILinkUitlization = incoming / (m-&gt;getNumSockets() * qpiLinks);</span><br><span class="line">    <span class="keyword">double</span> overallOutgoingQPILinkUitlization = outgoing / (m-&gt;getNumSockets() * qpiLinks);</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; (<span class="keyword">double</span>(getL2CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2)) * <span class="number">1000</span> &lt;&lt; <span class="string">&quot;,&quot;</span> </span><br><span class="line">    <span class="comment">// L3 MPKI</span></span><br><span class="line">    &lt;&lt; (<span class="keyword">double</span>(getL3CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2)) * <span class="number">1000</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getL2CacheHitRatio(state1, state2) &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getL3CacheHitRatio(state1, state2) &lt;&lt; <span class="string">&quot;,&quot;</span>   </span><br><span class="line">    &lt;&lt; (<span class="keyword">double</span>(getCycles(state1, state2))/getInvariantTSC(state1, state2)) * <span class="number">100</span>  &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getCoreCStateResidency(<span class="number">0</span>, state1, state2)*<span class="number">100.</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; overallIncomingQPILinkUitlization &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; overallOutgoingQPILinkUitlization &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">CounterStateType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_processor</span><span class="params">(<span class="keyword">const</span> PCM * m, <span class="keyword">const</span> CounterStateType &amp; state1, <span class="keyword">const</span> CounterStateType &amp; state2, <span class="keyword">bool</span> update)</span></span>&#123;</span><br><span class="line">    ofstream out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(update)&#123;</span><br><span class="line">        out.open(<span class="string">&quot;UpdateProcLevel.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app); </span><br><span class="line">        display_processor_level_stats(out, m, state1, state2); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        out.open(<span class="string">&quot;AlgProcLevel.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app); </span><br><span class="line">        display_processor_level_stats(out, m, state1, state2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out.close();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCMBasic_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="2-2-调用实现"><a href="#2-2-调用实现" class="headerlink" title="2.2 调用实现"></a>2.2 调用实现</h4><p>注意: 调用程序的源码中使用 <code>#include pcmBasic.h</code> 包含头文件 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ######################### PCM Memory initialization Start ########################</span></span><br><span class="line">    PCM* m = PCM::getInstance();    </span><br><span class="line">    <span class="keyword">bool</span> PMM = <span class="literal">false</span>, update = <span class="literal">false</span>; <span class="keyword">int</span> rankA = <span class="number">-1</span>, rankB = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;hasPCICFGUncore())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Unsupported processor model (&quot;</span> &lt;&lt; m-&gt;getCPUModel() &lt;&lt; <span class="string">&quot;).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (m-&gt;memoryTrafficMetricsAvailable())</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;For processor-level memory bandwidth statistics please use pcm.x&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    ServerUncorePowerState * BeforeState = <span class="keyword">new</span> ServerUncorePowerState[m-&gt;getNumSockets()];</span><br><span class="line">    ServerUncorePowerState * AfterState = <span class="keyword">new</span> ServerUncorePowerState[m-&gt;getNumSockets()];</span><br><span class="line">    uint64 BeforeTime = <span class="number">0</span>, AfterTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before counter states     </span></span><br><span class="line">    <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i&lt;m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        BeforeState[i] = m-&gt;getServerUncorePowerState(i); </span><br><span class="line">    &#125;</span><br><span class="line">    BeforeTime = m-&gt;getTickCount();        </span><br><span class="line">    <span class="comment">// ####################### PCM Memory initialization Done #######################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// ######################### PCM Memory finalization Start ########################</span></span><br><span class="line">    AfterTime = m-&gt;getTickCount();</span><br><span class="line">    <span class="comment">// after counter states     </span></span><br><span class="line">    <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i&lt;m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        AfterState[i] = m-&gt;getServerUncorePowerState(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calculate_bandwidth(m, BeforeState, AfterState, AfterTime-BeforeTime, update, PMM);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] BeforeState;</span><br><span class="line">    <span class="keyword">delete</span>[] AfterState;</span><br><span class="line">    m-&gt;cleanup();</span><br><span class="line">    <span class="comment">// ###################### PCM Memory finalization Done #################</span></span><br></pre></td></tr></table></figure><h3 id="三-测量内存带宽"><a href="#三-测量内存带宽" class="headerlink" title="三 测量内存带宽"></a>三 测量内存带宽</h3><h4 id="3-1-pcmMemory-h"><a href="#3-1-pcmMemory-h" class="headerlink" title="3.1 pcmMemory.h"></a>3.1 pcmMemory.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCMMemory_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCMMemory_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处更改为pcm的路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/cpucounters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Programmable iMC counter</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_RANK_A 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_RANK_A 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_RANK_B 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_RANK_B 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARTIAL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMM_READ 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMM_WRITE 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NM_HIT 0  <span class="comment">// NM :  Near Memory (DRAM cache) in Memory Mode</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_DELAY_DEFAULT 1.0 <span class="comment">// in seconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_DELAY_MIN 0.015 <span class="comment">// 15 milliseconds is practical on most modern CPUs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_CALIBRATION_INTERVAL 50 <span class="comment">// calibrate clock only every 50th iteration</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uint32 max_sockets = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> uint32 max_imc_channels = ServerUncorePowerState::maxChannels;</span><br><span class="line"><span class="keyword">const</span> uint32 max_edc_channels = ServerUncorePowerState::maxChannels;</span><br><span class="line"><span class="keyword">const</span> uint32 max_imc_controllers = ServerUncorePowerState::maxControllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">memdata</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> iMC_Rd_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_Wr_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Rd_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Wr_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_Wr_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Wr_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> M2M_NM_read_hit_rate[max_sockets][max_imc_controllers];</span><br><span class="line">    <span class="keyword">float</span> EDC_Rd_socket_chan[max_sockets][max_edc_channels];</span><br><span class="line">    <span class="keyword">float</span> EDC_Wr_socket_chan[max_sockets][max_edc_channels];</span><br><span class="line">    <span class="keyword">float</span> EDC_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> EDC_Wr_socket[max_sockets];</span><br><span class="line">    uint64 partial_write[max_sockets];</span><br><span class="line">    <span class="keyword">bool</span> PMM;</span><br><span class="line">&#125; <span class="keyword">memdata_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output format: </span></span><br><span class="line"><span class="comment">socket(i) read bW, socket(i) write BW for all i; system read BW; system write BW; system total BW</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_bandwidth_alg</span><span class="params">(PCM *m, <span class="keyword">memdata_t</span> *md)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sysReadDRAM = <span class="number">0.0</span>, sysWriteDRAM = <span class="number">0.0</span>, total = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;AlgMem.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)&#123;</span><br><span class="line">        out &lt;&lt; md-&gt;iMC_Rd_socket[skt] <span class="comment">/* socket read BW (MB/s) */</span> &lt;&lt;  <span class="string">&quot;,&quot;</span> &lt;&lt; md-&gt;iMC_Wr_socket[skt] <span class="comment">/* socket write BW (MB/s) */</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;       </span><br><span class="line">        sysReadDRAM += md-&gt;iMC_Rd_socket[skt];   <span class="comment">// system read BW (MB/s)</span></span><br><span class="line">        sysWriteDRAM += md-&gt;iMC_Wr_socket[skt];  <span class="comment">// system write BW (MB/s)      </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total = sysReadDRAM + sysWriteDRAM;</span><br><span class="line">    out &lt;&lt; sysReadDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sysWriteDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_bandwidth_update</span><span class="params">(PCM *m, <span class="keyword">memdata_t</span> *md)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sysReadDRAM = <span class="number">0.0</span>, sysWriteDRAM = <span class="number">0.0</span>, total = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;UpdateMem.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)&#123;</span><br><span class="line">        out &lt;&lt; md-&gt;iMC_Rd_socket[skt] <span class="comment">/* socket read BW (MB/s) */</span> &lt;&lt;  <span class="string">&quot;,&quot;</span> &lt;&lt; md-&gt;iMC_Wr_socket[skt] <span class="comment">/* socket write BW (MB/s) */</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;        </span><br><span class="line">        sysReadDRAM += md-&gt;iMC_Rd_socket[skt];   <span class="comment">// system read BW (MB/s)</span></span><br><span class="line">        sysWriteDRAM += md-&gt;iMC_Wr_socket[skt];  <span class="comment">// system write BW (MB/s)      </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total = sysReadDRAM + sysWriteDRAM;</span><br><span class="line">    out &lt;&lt; sysReadDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sysWriteDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate_bandwidth</span><span class="params">(PCM *m, <span class="keyword">const</span> ServerUncorePowerState uncState1[], <span class="keyword">const</span> ServerUncorePowerState uncState2[], uint64 elapsedTime, <span class="keyword">bool</span> update, <span class="keyword">bool</span> PMM)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//const uint32 num_imc_channels = m-&gt;getMCChannelsPerSocket();</span></span><br><span class="line">    <span class="comment">//const uint32 num_edc_channels = m-&gt;getEDCChannelsPerSocket();</span></span><br><span class="line">    <span class="keyword">memdata_t</span> md;</span><br><span class="line">    md.PMM = PMM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)</span><br><span class="line">    &#123;</span><br><span class="line">        md.iMC_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_PMM_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_PMM_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.EDC_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.EDC_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.partial_write[skt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i &lt; max_imc_controllers; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            md.M2M_NM_read_hit_rate[skt][i] = <span class="number">0.</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> uint32 numChannels1 = m-&gt;getMCChannels(skt, <span class="number">0</span>); <span class="comment">// number of channels in the first controller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(m-&gt;getCPUModel()) &#123;</span><br><span class="line"><span class="keyword">case</span> PCM::KNL:</span><br><span class="line">            <span class="keyword">for</span>(uint32 channel = <span class="number">0</span>; channel &lt; max_edc_channels; ++channel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getEDCCounter(channel,READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getEDCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.EDC_Rd_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                    md.EDC_Wr_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                md.EDC_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getEDCCounter(channel,READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                md.EDC_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getEDCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                md.EDC_Rd_socket[skt] += md.EDC_Rd_socket_chan[skt][channel];</span><br><span class="line">                md.EDC_Wr_socket[skt] += md.EDC_Wr_socket_chan[skt][channel];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">for</span>(uint32 channel = <span class="number">0</span>; channel &lt; max_imc_channels; ++channel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getMCCounter(channel,READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getMCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>) <span class="comment">//In case of JKT-EN, there are only three channels. Skip one and continue.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!PMM || (getMCCounter(channel,PMM_READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getMCCounter(channel,PMM_WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        md.iMC_Rd_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                        md.iMC_Wr_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                md.iMC_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                md.iMC_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                md.iMC_Rd_socket[skt] += md.iMC_Rd_socket_chan[skt][channel];</span><br><span class="line">                md.iMC_Wr_socket[skt] += md.iMC_Wr_socket_chan[skt][channel];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(PMM)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.iMC_PMM_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,PMM_READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                    md.iMC_PMM_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,PMM_WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                    md.iMC_PMM_Rd_socket[skt] += md.iMC_PMM_Rd_socket_chan[skt][channel];</span><br><span class="line">                    md.iMC_PMM_Wr_socket[skt] += md.iMC_PMM_Wr_socket_chan[skt][channel];</span><br><span class="line"></span><br><span class="line">                    md.M2M_NM_read_hit_rate[skt][(channel &lt; numChannels1)?<span class="number">0</span>:<span class="number">1</span>] += (<span class="keyword">float</span>)getMCCounter(channel,READ,uncState1[skt],uncState2[skt]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    md.partial_write[skt] += (uint64) (getMCCounter(channel,PARTIAL,uncState1[skt],uncState2[skt]) / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span> (PMM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(uint32 c = <span class="number">0</span>; c &lt; max_imc_controllers; ++c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(md.M2M_NM_read_hit_rate[skt][c] != <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.M2M_NM_read_hit_rate[skt][c] = ((<span class="keyword">float</span>)getM2MCounter(c, NM_HIT, uncState1[skt],uncState2[skt]))/ md.M2M_NM_read_hit_rate[skt][c];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(update) display_bandwidth_update(m, &amp;md);</span><br><span class="line">    <span class="keyword">else</span> display_bandwidth_alg(m, &amp;md);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCMMemory_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="3-2-调用实现"><a href="#3-2-调用实现" class="headerlink" title="3.2 调用实现"></a>3.2 调用实现</h4><p>注意: 调用程序的源码中使用 <code>#include pcmMemory.h</code> 包含头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// #################### PCM Processor Level Stats initialization Start #######################</span></span><br><span class="line">    PCM* m = PCM::getInstance();    </span><br><span class="line">    <span class="keyword">bool</span> update = <span class="literal">false</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CoreCounterState&gt; cstates1, cstates2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SocketCounterState&gt; sktstate1, sktstate2;</span><br><span class="line">    SystemCounterState sstate1, sstate2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before counter states     </span></span><br><span class="line">    m-&gt;getAllCounterStates(sstate1, sktstate1, cstates1);        </span><br><span class="line">    <span class="comment">// #################### PCM Processor Level Stats initialization Done ###################</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ################### PCM Processor Level Stats finalization Start ####################</span></span><br><span class="line">    <span class="comment">// after counter states     </span></span><br><span class="line">    m-&gt;getAllCounterStates(sstate2, sktstate2, cstates2);</span><br><span class="line"></span><br><span class="line">    display_processor(m, sstate1, sstate2, update);    </span><br><span class="line">    </span><br><span class="line">    m-&gt;cleanup();</span><br><span class="line">    <span class="comment">// ######################## PCM Processor Level Stats finalization Done ###################</span></span><br></pre></td></tr></table></figure><h3 id="四-编译连接"><a href="#四-编译连接" class="headerlink" title="四 编译连接"></a>四 编译连接</h3><p>makefile 的编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PCM_DIR := /home/server2/pcm</span><br><span class="line"></span><br><span class="line">PCM_HDR := $(wildcard $(PCM_DIR)/*.h)</span><br><span class="line">PCM_SRC := $(wildcard $(PCM_DIR)/*.cpp)</span><br><span class="line"><span class="meta">#</span><span class="bash">PCM_OBJ := $(patsubst %.cpp,%.o,$(wildcard $(PCM_DIR)/*.cpp))</span></span><br><span class="line">PCM_OBJ := msr.o cpucounters.o pci.o mmio.o client_bw.o utils.o</span><br><span class="line">PCM_OBJ := $(addprefix $(PCM_DIR)/,$(PCM_OBJ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALL= memory_footprint run_static_algorithm run_batch_updates run_simultaneous_updates_queries</span><br><span class="line">all: $(ALL)</span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash"> : tools/%.cpp $(PCM_OBJ)</span></span><br><span class="line">        $(CC) $(CFLAGS) $(PFLAGS) -o $@ $^ $(JEMALLOC)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(PCM_OBJ) : $(PCM_SRC)</span></span><br><span class="line">cd $(PCM_DIR) &amp;&amp; make -f $(PCM_DIR)/Makefile</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f *.o $(ALL)</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/abasak24/SAGA-Bench/tree/master/pcmResource">saga-Bench pcmResource</a> 的代码实现</li><li><a href="https://chhzh123.github.io/blogs/2019-02-19-pcm/">CPU/内存监视器</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Processor-Counter-Monitor测量cache及带宽&quot;&gt;&lt;a href=&quot;#Processor-Counter-Monitor测量cache及带宽&quot; class=&quot;headerlink&quot; title=&quot;Processor-Counter-Moni</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="http://okeyia.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Cache" scheme="http://okeyia.github.io/tags/Cache/"/>
    
    <category term="Bandwidth" scheme="http://okeyia.github.io/tags/Bandwidth/"/>
    
  </entry>
  
  <entry>
    <title>图处理相关论文</title>
    <link href="http://okeyia.github.io/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    <id>http://okeyia.github.io/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/</id>
    <published>2022-05-15T03:43:57.000Z</published>
    <updated>2023-03-23T06:38:41.585Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图处理的相关论文"><a href="#图处理的相关论文" class="headerlink" title="图处理的相关论文"></a>图处理的相关论文</h2><blockquote><p>Benchmark：主要是对比别人的方法，这个方法不一定是最好的，但一定是最具有代表性且被广泛认可的（一种标准和规范）。其所用的数据就是benchmark data，其方法就是benchmark method，你提出的方法在benchmark data上得出的结果与benchmark method 的结果对比才知道你的方法是否足够好。</p><p>baseline:  主要关注自己提出的方法，比最原始最简单的方法出来的结果（参照物）。然后在这个基础上改进，增加各种组件，可以看出提升多少，通过baseline我们可以知道这个方法能不能work, 有多少提升。</p></blockquote><h3 id="STINGER-流图的高性能数据结构"><a href="#STINGER-流图的高性能数据结构" class="headerlink" title="STINGER: 流图的高性能数据结构"></a>STINGER: 流图的高性能数据结构</h3><hr><blockquote><p> Stinger的关键属性是具有偏斜度分布的语义图上的快速插入，删除和更新。提出了一种新的数据结构，能够达到比较快的更新速度。</p></blockquote><p>正是由于在偏斜度分布的图上面进行的，所有才会使用batch 更新的方法，在batch 中  STINGER 的后续实现首先对批次进行排序（通常一次 100,000 条边更新），以便将发生在特定顶点上的所有边更新与插入分开的删除分组在一起。</p><p><strong>为什么会有batch</strong>        </p><blockquote><p>在具有许多线程上下文和内存库的系统上，数据结构中的工作量或并行性通常不足以一次处理单个更新。为了解决这个问题，我们开始批量处理边缘更新。一个批次摊销了进入数据结构的成本，并提供了大量的独立工作要做。</p></blockquote><p><strong>实验：</strong> 为什么采用batch 更新的方式，当batch 的大小发生变化的时候，每秒更新的变数会提高？ 每秒更新的边的个数是怎么计算的？</p><blockquote><p>我们测量处理数据结构中每个边缘更新所花费的时间。我们测量了几个批次，并以每秒更新的形式报告了性能。</p></blockquote><p><strong>进一步的优化:</strong>  </p><blockquote><p>然而，在无标度图中，少数顶点将面临多次更新，而大多数顶点只有一次更新或根本没有更新。这种工作负载不平衡限制了我们可以利用的并行量，并迫使大多数线程等待少数线程完成。</p></blockquote><p>为了解决这个问题，跳过了对边进行分类，并行的处理每条边的插入。但是，处理同一顶点上的两个边更新事件会引入竞争条件，必须通过适当的同步来处理。 并没有在软件商提出解决办法，而是使用Cray XMT 是这个场景的完美系统。（Cray XMT（Cray eXtreme MultiThreading，[1] 代号 Eldorado[2]）是 Cray 公司基于第三代 Tera MTA 架构的可扩展多线程共享内存超级计算机架构，针对大型图问题），但是这个系统近10年没有消息。</p><p><strong>缺点:</strong>  在整篇论文中只提到了更新，没有考虑查询的情况。</p><h3 id="图处理工作负载内存层次结构的分析与优化"><a href="#图处理工作负载内存层次结构的分析与优化" class="headerlink" title="图处理工作负载内存层次结构的分析与优化"></a>图处理工作负载内存层次结构的分析与优化</h3><p align = "right" > ——2019年发表在 `HPCA` 上面的一篇论文<p/><hr><p>Analysis and Optimization of the Memory Hierarchy for Graph Processing Workloads。</p><p><strong>提出问题:</strong> 在微架构级别，性能受到单机内存图分析的内存子系统效率低下的限制。本文的目标是解决单机内存图分析的内存效率低下问题。</p><ol><li>首先，我们在模拟的多核架构上对图形处理工作负载进行深入的数据类型感知表征。我们分析 1) 乱序内核中的内存级并行性和 2) 缓存层次结构中的请求重用距离。我们发现，涉及不同应用程序数据类型的加载-加载依赖链构成了实现高内存级并行性的主要瓶颈。我们还观察到不同的图数据类型表现出异构的重用距离。因此，私有 L2 缓存对性能的贡献可以忽略不计，而共享 L3 缓存表现出更高的性能敏感度。</li><li>基于他们的观察结构，提出了 DROPLET，这是一种用于图应用程序的数据感知解耦 预取器。 DROPLET 根据其固有的重用距离以不同的方式预取不同的图形数据类型。</li></ol><p>这里通过 <code>Using Cycle Stacks to Understand Scaling Bottlenecks in Multi-Threaded Workloads</code> 介绍的方法，使用pagerank 在 orkut上面 得到了 ==Cycle stack==。  45% 的周期是 DRAM 绑定的停顿周期，而内核被充分利用而仅在 15% 的周期内没有停顿。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221114164748773.png" class="" title="image-20221114164748773"><h4 id="一-借鉴的方向"><a href="#一-借鉴的方向" class="headerlink" title="一 借鉴的方向"></a>一 <strong>借鉴的方向</strong></h4><blockquote><p>现代 CPU 中使用的三种关键延迟容忍技术是 OoO 执行产生的 MLP、片上缓存(常说的三级cache)和预取。</p><p>OoO 执行依赖于重新排序缓冲区 (ROB) 向前看指令流，它可以在加载/存储队列、非阻塞缓存和 DRAM 中的并行性的帮助下支持多个正在运行的内存请求。</p></blockquote><p>这里主要参考优化的第一个方向,  通过两个特征来深入了解fig 1中的内存受限行为</p><ol><li>乱序执行中的内存级并行性（MLP）</li><li>cache层次结构中的重用距离</li></ol><blockquote><p>参考知乎: <a href="https://www.zhihu.com/question/28611947">https://www.zhihu.com/question/28611947</a></p><p><strong>instruction size 的概念:</strong>  标量乱序执行的核心就是不断的检查未来的指令，并从中发掘可以并行执行的指令，从而最终提升IPC。这个可以乱序执行的指令窗口叫做instruction window，这是衡量现代CPU性能的一个重要指标（举个不太恰当的例子，以前参加智能车比赛，摄像头看得越远理论上可以跑的越快）。</p><p>有两个关键因素影响着不断增加的instruction window size，一个是<strong>分支预测</strong>（branch prediction），准确的分支预测（目前的指标可以做到小于10MPKI，MPKI是没1000条指令中预测错误数目）可以保证绝大多数情况下instruction window 中的指令都是在正确的 程序路径 上。否则总是错误的预测执行（speculative execution）反而会降低IPC。 另外一个关键就是<strong>寄存器重命名和 reorder buffer 的大小</strong>。reorder buffer是实现乱序执行同时保持程序正确性和精确异常的关键，每条指令在译码之后会分配一个reorder buffer的entry，reorder buffer后面会按照指令顺序commit保证程序正确性。通常指令窗口大小（instruction window size）就是reorder buffer entry size，intel的几个关键节点的微架构的instruction window大小如下，Nehalem（45nm）128， Haswell（22nm）192，Sunny Cove（10nm）352。苹果的M1目前达到了~600（一部分原因是ARM不需要micro-ops译码，从而可以实现更高的instruction译码带宽8-wide）。</p></blockquote><h4 id="二-特征描述"><a href="#二-特征描述" class="headerlink" title="二 特征描述"></a>二 特征描述</h4><h5 id="2-1-指令窗口大小不是阻碍-MLP-的因素"><a href="#2-1-指令窗口大小不是阻碍-MLP-的因素" class="headerlink" title="2.1 指令窗口大小不是阻碍 MLP 的因素"></a>2.1 指令窗口大小不是阻碍 MLP 的因素</h5><ol><li>之前有论文说 ROB是影响MLP的主要因素，他们通过扩大指令窗口的大小，发现==带宽==并没有明显的增加。</li><li>第二个是发现加速比也没有明显的增加。</li></ol><h5 id="2-2-负载依赖链阻止实现高-MLP"><a href="#2-2-负载依赖链阻止实现高-MLP" class="headerlink" title="2.2 负载依赖链阻止实现高 MLP"></a>2.2 负载依赖链阻止实现高 MLP</h5><blockquote><p>laod-load dependency chains prevent achieving high MLP</p></blockquote><p>为了理解为什么大的ROB不能提升内存间的并行, 我们跟踪 ROB 中加载指令的依赖关系, MLP 受固有的应用程序级依赖特性的限制。</p><h5 id="2-3-图属性数据是依赖链中的消费者"><a href="#2-3-图属性数据是依赖链中的消费者" class="headerlink" title="2.3 图属性数据是依赖链中的消费者"></a>2.3 图属性数据是依赖链中的消费者</h5><p>平均而言，我们发现图形属性数据主要是消费者（53.6%）而不是生产者（5.9%）。发布(issuing)图形属性数据加载被延迟并且不能并行化，因为它必须依赖生产者加载来计算地址。</p><h5 id="2-4-私有-L2-缓存表现出可忽略的性能敏感性，而共享-LLC-表现出更高的性能敏感性"><a href="#2-4-私有-L2-缓存表现出可忽略的性能敏感性，而共享-LLC-表现出更高的性能敏感性" class="headerlink" title="2.4 私有 L2 缓存表现出可忽略的性能敏感性，而共享 LLC 表现出更高的性能敏感性"></a>2.4 私有 L2 缓存表现出可忽略的性能敏感性，而共享 LLC 表现出更高的性能敏感性</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221116195030491.png" class="" title="image-20221116195030491"><p>如图 4a 所示，我们将 LLC 大小从 8MB 更改为 64MB，并找到 17.4%（最大 3.25X）性能改进的最佳点，LLC 容量增加 4 倍。平均 LLC MPKI（每千克指令缺失）从基线中的 20 减少到 16 (16MB) 到 12 (32MB) 到 10 (64MB)。相应的加速比分别为 7%、17.4% 和 7.6%。最佳点是在降低的未命中率和更大的 LLC 访问延迟之间取得平衡。</p><p>图 4b(i) 显示 L2 命中率（在基线中已经非常低，为 10.6%）在容量增加 2 倍后增加到仅 15.3%，而集关联性增加 4 倍没有影响（命中率升至仅 10.9%）。</p><p>图 4b(ii) 显示系统性能对不同的 L2 缓存配置（容量和集合关联性）表现出很小的敏感性。最左边的条表示没有私有 L2 缓存的架构，与 256KB 缓存相比没有减速。因此，没有私有 L2 缓存的架构同样适用于图形处理。</p><h5 id="2-5-属性数据是-LLC-容量的主要受益者"><a href="#2-5-属性数据是-LLC-容量的主要受益者" class="headerlink" title="2.5 属性数据是 LLC 容量的主要受益者"></a>2.5 属性数据是 LLC 容量的主要受益者</h5><p>为了了解哪种数据类型受益于更大的 LLC，图 4c 显示了对于每种数据类型，最终从 DRAM 获取数据的内存引用的百分比。属性数据下降最为明显.</p><h5 id="2-6-图结构缓存行在所有数据类型中具有最大的重用距离。-Graph-property-cacheline-具有比-L2-缓存服务更大的重用距离"><a href="#2-6-图结构缓存行在所有数据类型中具有最大的重用距离。-Graph-property-cacheline-具有比-L2-缓存服务更大的重用距离" class="headerlink" title="2.6 图结构缓存行在所有数据类型中具有最大的重用距离。 Graph property cacheline 具有比 L2 缓存服务更大的重用距离"></a>2.6 图结构缓存行在所有数据类型中具有最大的重用距离。 Graph property cacheline 具有比 L2 缓存服务更大的重用距离</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221116195837647.png" class="" title="image-20221116195837647"><blockquote><p>Graph structure cacheline has the largest reuse distance among all the data types. Graph property cacheline has a larger reuse distance than that serviced by the L2 cache.</p></blockquote><p>为了进一步了解 L2 和 L3 缓存的不同性能敏感性，我们按应用程序数据类型分解内存层次结构使用情况，如图 7 所示。</p><ol><li>在大多数基准测试中，对结构数据的访问由 L1 缓存和 DRAM 提供服务，这表明 L1 中丢失的缓存行是在遥远的过去引用的缓存行，因此它已从 L2 和 L3 缓存中被逐出。 重用距离超出 LLC 的服务能力这一事实解释了为什么更大的 LLC 无法显着降低图 4c 中片外结构访问的比例。</li><li>另一方面，L1 缓存中丢失的大部分属性数据加载不能由 L2 缓存提供服务，但可以由 LLC 和 DRAM 提供服务。总的来说，LLC 在服务属性访问方面比结构访问更有用。因此，property cacheline 的重用距离相对较小，但仍大于 L2 缓存捕获的重用距离</li><li>最后，图 7 提供的证据表明，对中间(顶点)数据的访问主要是 L1 缓存和 LLC 中的片上缓存命中。</li></ol><p>**最终: ** 三种数据类型的重用距离解释了为什么私有 L2 缓存无法为内存请求提供服务并且显示出微不足道的好处。</p><h4 id="三-总结与机遇"><a href="#三-总结与机遇" class="headerlink" title="三 总结与机遇"></a>三 总结与机遇</h4><p>图形分析中内存限制的停顿行为是由两个问题引起的：</p><ol><li>不同数据类型的异构重用距离导致密集的 DRAM 访问以检索结构和属性数据。</li><li>由于负载依赖链导致的低 MLP，限制了重叠 DRAM 访问的可能性</li></ol><hr><h3 id="Graphfire：为图处理协同获取、插入和替换策略"><a href="#Graphfire：为图处理协同获取、插入和替换策略" class="headerlink" title="Graphfire：为图处理协同获取、插入和替换策略"></a>Graphfire：为图处理协同获取、插入和替换策略</h3><blockquote><p>已经开发了专门的图形定制预取机制、处理器设计和内存层次结构引擎，以容忍此类访问的长时间延迟. ==但是==这些方法要么过于占用带宽，要么需要进行侵入性硬件更改，从而抑制通用计算的灵活性，要么依赖于限制真正加速的软件预处理。</p></blockquote><p>这项工作引入了 Graphfire，这是一种灵活的内存层次结构方法，可以学习图形处理中的不同访问模式，并利用专门的获取、插入和替换优化的协同作用来解决有问题的间接访问，而无需依赖软件或 ISA 支持。</p><h4 id="一-已有工作的问题"><a href="#一-已有工作的问题" class="headerlink" title="一 已有工作的问题"></a>一 已有工作的问题</h4><ul><li>大量工作涉及缓存管理技术 这些技术都没有考虑图形应用程序的特定访问模式，而是专注于那些在更常规的工作负载中众所周知和常见的模式，例如streaming、strided、thrashing、mixed 等。因此，当这些技术应用于图形分析时，这些技术产生的任何硬件开销都被浪费了。</li><li>GRASP [15] 提出了针对图分析的领域专业化 LLC 管理的第一步，但会产生基于度的图重新排序的软件预处理成本 [14]。软件预处理使得该技术对于大图不太实用，例如在许多应用场景中，输入图只被处理一次 [5]，或者甚至没有完全遍历图，例如在搜索算法中。</li></ul><p>据我们所知，对于图形应用程序<strong>，不存在可以在没有软件支持的情况下学习和优化其访问模式的内存层次结构方法</strong>。</p><h4 id="二-我们的工作"><a href="#二-我们的工作" class="headerlink" title="二 我们的工作"></a>二 我们的工作</h4><p>以优化图形应用程序的缓存性能为目标，我们的工作做出以下==关键观察==：</p><ol><li>内存层次结构必须专门针对有问题的间接访问（ problematic indirect accesses）来缓解它们的瓶颈。</li><li>要与软件无关，==轻量级机制==必须自动识别 PIA，这可以在每个指令的基础上实现。</li><li>虽然 PIA 是不规则的，但其中的一个子集具有很高的重用性，因此 LLC 必须保留它们。</li></ol><p><strong>所用的方法：</strong></p><p>鉴于这些观察结果，本文提出了 Graphfire，这是一种灵活的、基于硬件的内存层次结构方法</p><ul><li>了解图形应用程序中何时出现 PIA</li><li>通过定制的获取、插入和替换策略优化它们的性能。</li></ul><h4 id="三-MOTIVATION"><a href="#三-MOTIVATION" class="headerlink" title="三 MOTIVATION"></a>三 MOTIVATION</h4><h5 id="3-1-内存访问模式"><a href="#3-1-内存访问模式" class="headerlink" title="3.1 内存访问模式"></a>3.1 内存访问模式</h5><p>图形应用程序因数据遍历引起的不规则内存访问而臭名昭著。最先进、高效的算法实现通过两个嵌套的内核循环迭代地执行图形遍历，并利用压缩稀疏行 (CSR) 格式将输入数据集有效地存储为一维密集数组 [45]。</p><p>指针间接访问发生在顶点属性数组中，该数组存储每个顶点的结果，例如距离或等级 [6]。 CSR 数组存储图形信息，例如顶点和边缘位置，但经常和/或不经常访问。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117103412358.png" class="" title="image-20221117103412358"><p><strong>上图是图处理内核的伪代码</strong>， 外部循环（第 2-5 行）遍历顶点工作列表（针对当前算法迭代），而内部循环（第 6-13 行）分析当前顶点的邻居以潜在地更新它们的数据，具体取决于算法的目标。如果更新了邻居，则将其添加到下一次算法迭代的工作列表中（第 12-13 行）。该算法在工作列表为空（第 1 行）时终止，即图已遍历且更新已稳定。</p><p>==外循环中的指令==相对于内循环中的指令很少出现，特别是对于具有高边顶点比的图。访问是流式的或间接的（这里的访问是流失的是什么意思? 一直访问吗?） </p><h6 id="3-1-1-Infrequent-Streaming"><a href="#3-1-1-Infrequent-Streaming" class="headerlink" title="3.1.1 Infrequent, Streaming"></a>3.1.1 Infrequent, Streaming</h6><p>这些访问出现在外部 for 循环或内部循环的条件内部，并具有流式行为。如图 1 的第 2 行所示，该算法遍历顶点工作列表并以流方式加载每个顶点索引。然而，这种访问并没有表现出良好的局部性，因为在内核的内部循环中，每次访问都可以被多次内存访问分开。</p><h6 id="3-1-2-Infrequent-Indirect"><a href="#3-1-2-Infrequent-Indirect" class="headerlink" title="3.1.2 Infrequent, Indirect"></a>3.1.2 Infrequent, Indirect</h6><p>这些指针间接访问出现在外部 for 循环或内部循环中的条件。当前顶点 v 索引到 vertex_ptr 数组以加载其邻居列表索引（第 4-5 行）并确定内循环迭代次数。对起始索引的第一个加载（第 4 行）是指针间接的，而第二个（第 5 行）具有局部性。另一个间接访问来自有条件地更新顶点属性数据（第 10 行）。但是，这些不规则访问不会对性能产生重大影响，因为它们很少发生。</p><h6 id="3-1-3-Primary-Streaming-Accesses-PSAs"><a href="#3-1-3-Primary-Streaming-Accesses-PSAs" class="headerlink" title="3.1.3 Primary Streaming Accesses (PSAs)"></a>3.1.3 Primary Streaming Accesses (PSAs)</h6><p>这些访问发生在内部 for 循环的关键路径中，并执行流式加载或存储到相邻索引（第 6 行）。这些是真正的流式访问，同时展示了时间和空间局部性，并且它们经常且定期发生。因此，它们是缓存友好的，不会造成数据供应瓶颈。我们将这些访问称为主要流访问 (PSA) 来描述这些特征。</p><h6 id="3-1-4-Primary-Indirect-Accesses"><a href="#3-1-4-Primary-Indirect-Accesses" class="headerlink" title="3.1.4 Primary Indirect Accesses"></a>3.1.4 Primary Indirect Accesses</h6><p>这些访问也发生在内部 for 循环的关键路径中，并执行指针间接加载（在第 8 行中突出显示）到顶点属性数组，以便为给定的邻居加载数据。由于这些间接访问发生在每个循环迭代中，并且具有导致性能成本的较长延迟，因此它们是图应用程序的数据供应瓶颈的原因。我们将它们称为主要间接访问 (PIA)，并在下一节中详细介绍它们的特性。</p><h5 id="3-2-The-Problems-with-PIAs"><a href="#3-2-The-Problems-with-PIAs" class="headerlink" title="3.2 The Problems with PIAs"></a>3.2 The Problems with PIAs</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117112612220.png" class="" title="image-20221117112612220"><p>顶点属性数组是 PIA 的主要来源，但是分析footprint, 发现只占应用程序总内存占用量的很小一部分。（这里的内存占用是指什么？）然后做实验发现了<strong>尽管 PIA 的数据占用空间相对较小，但它们本身占应用程序访问总数的很大一部分。</strong> 当应用程序遍历图形时，必须对顶点属性数组进行频繁更新。将不规则性与频率相结合会产生==内存延迟性能瓶颈==。</p><p>图 3 将总内存延迟分解为 PIA 与其他内存访问。在所有应用程序和输入中，PIA 的延迟平均占总内存延迟的 88%，构成了主要的应用程序性能瓶颈。因此，必须在内存层次结构中进行创新，以解决这些引用所表现出的缺乏规律性和局部性的问题。</p><h6 id="3-2-1-Lack-of-Locality"><a href="#3-2-1-Lack-of-Locality" class="headerlink" title="3.2.1 Lack of Locality"></a>3.2.1 Lack of Locality</h6><p>不幸的是，PIA 的不规则性导致它们表现出较差的局部性。对于上述应用程序/输入组合，平均而言，在 64B 逐出缓存行中有 54.1 (L1)、59.9 (L2) 和 59.5 (L3) 字节未使用。因此，为 PIA 获取整个缓存行的数据是一种浪费。这个没有具体的数据来表示？ 是怎么计算出来的？</p><h6 id="3-2-2-访问模式之间的干扰"><a href="#3-2-2-访问模式之间的干扰" class="headerlink" title="3.2.2 访问模式之间的干扰"></a>3.2.2 访问模式之间的干扰</h6><p>同一缓存集中不同内存访问模式的共存会损害性能。 PIA 可能会被 PSA 或其他不频繁访问逐出，从而导致多次冲突未命中，尤其是具有高重用性的 PIA 应保留在 LLC [6] 中。由于其不规则性和频率，PIA 是 LLC 中的主要驱逐对象。平均而言，21% 的驱逐是由其他类型的访问造成的。消除这种干扰可以提高 PIA 的缓存性能。</p><h6 id="3-2-3-变量-PIA-重用"><a href="#3-2-3-变量-PIA-重用" class="headerlink" title="3.2.3 变量 PIA 重用"></a>3.2.3 变量 PIA 重用</h6><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117112845107.png" class="" title="image-20221117112845107"><p>图 4 展示了 BFS 在 Kronecker 网络上运行时的 PIA 访问和重用直方图。这捕捉了许多现实世界数据集的幂律趋势。图 4a 显示很少有顶点被频繁访问，而大多数顶点很少被访问。具有高重用性的顶点不应被低重用性 PIA 逐出。图 4b 说明了 PIA 重用距离的可变性。许多被重用，但大多数重用距离太长（相对于缓存关联性）以防止 PIA 被逐出。因此，PIA 的替换策略应适应顶点特征。</p><h3 id="用于图形分析的领域专用缓存管理"><a href="#用于图形分析的领域专用缓存管理" class="headerlink" title="用于图形分析的领域专用缓存管理"></a>用于图形分析的领域专用缓存管理</h3><p>Domain-Specialized Cache Management for Graph Analytics                                              ——HPCA 20</p><hr><h3 id="多核系统中处理内存干扰的技术-17-浙大"><a href="#多核系统中处理内存干扰的技术-17-浙大" class="headerlink" title="多核系统中处理内存干扰的技术 17 浙大"></a>多核系统中处理内存干扰的技术 17 浙大</h3><p>在多核系统中，同时运行的多个应用程序相互竞争访问共享的资源，如互连、高速缓 存和内存等。如果对可用的共享高速缓存容量和内存带宽的管理不恰当的话，不同应用程 序相互干扰，严重影响对方的运行。</p><blockquote><p>例如，在内存处，应用程序原有的行缓冲命中率和阵列级并行度会受到破坏，同时请求在读写队列中等待的时间也会因竞争激烈程度的加剧而 大幅增加；在高速缓存处，不同应用程序可能相互驱逐对方在高速缓存中的块，导致原有 命中率的破坏。</p></blockquote><p>请求在内存处的时延主要包含在队列中的等待时间和在DRAM中执行时间，这两 个部分受内存调度算法的影响特别大。</p><h4 id="创新-基于动态多层次优-先级的内存访问调度算法-DMPS"><a href="#创新-基于动态多层次优-先级的内存访问调度算法-DMPS" class="headerlink" title="创新: 基于动态多层次优 先级的内存访问调度算法 DMPS"></a>创新: 基于动态多层次优 先级的内存访问调度算法 DMPS</h4><p>识别应用程序的内存访问调度算法一般 由三部分组成：</p><ol><li>检测应用程序的内存访问特征；</li><li>基于内存访问特征来将应用程序分 类，以至于易受干扰的应用程序拥有更高的优先级；</li><li>选择优先级最高的就绪命令来执 行。</li></ol><h4 id="一-DRAM-访问过程"><a href="#一-DRAM-访问过程" class="headerlink" title="一 DRAM 访问过程"></a>一 DRAM 访问过程</h4><p>行缓冲是阵列中感应放大器单元的集合，是DRAM和内存控制器交互的接口。一般来说，行缓冲的大小为 <code>2-16KB</code>。</p><p>在行缓冲的行没有被关掉之前，行缓冲类似于高速缓存， 命中的话可减小访问延迟。到DRAM的访问可分为三步：</p><ol><li>激活命令，在目标阵列中打 开目标行，将其内容转移到行缓冲中</li><li>读写命令，在行缓冲中访问目标列；</li><li>预充电 命令，将行缓冲中的内容写回阵列的数组，关闭行缓冲的行。</li></ol><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220727095026744.png" class=""><h4 id="二-页管理策略"><a href="#二-页管理策略" class="headerlink" title="二 页管理策略"></a>二 页管理策略</h4><p>页管理策略管理行缓冲中感应放大器的操作，基本的策略有两种：开页策略和关页策 略</p><p>在开页策略中，<strong>行缓冲只在没 有到打开行的访问且有到其他行的访问时才关闭。</strong>开页策略的重要假设是一旦某一行数 据移到行缓冲中，那么在不久的将来该行的其他列会被访问，即偏爱到同一行的访问，适 合于空间局部性好的应用程序。访问类型主要是行命中和行冲突，对于行命中率高的程 序，开页策略能大幅提高性能。</p><p>在关页策略中，行缓冲在每个访问结束后都会关闭，访问 类型只有行关闭。关页策略适合到不同行的随机访问，同时每个访问的时延一样，有利于 带宽分配和实时控制</p><h4 id="三-地址映射机制"><a href="#三-地址映射机制" class="headerlink" title="三 地址映射机制"></a>三 地址映射机制</h4><p>地址映射机制负责将系统的内存地址空间映射到DRAM的逻辑结构中，具体来说，地 址映射机制将访问的物理地址转换成通道、排、阵列、行、列等值，具体化数据的放置位 置，对于性能有巨大的影响。当某块放置在某阵列中，下一块可以放置在同一行中、或者 同一阵列的下一行中、或者同一排的下一阵列中、或者同一通道的下一排中、又或者下一 通道中，所以地址映射机制决定了内存系统中可利用的并行度。</p><p>常见的地址映射机制有两 种：块交叉(Cacheline Interleaving)和行交叉(Row Interleaving)，如图2．3所示。行交叉将 连续的块放置在同一行中，试图最大化行缓冲命中率，适用于开页策略；而块交叉将连续 的块分散到不同的通道、排和阵列中，从而最大化内存访问并行度，适用于关页策略。最 小化开页(Minimalist Open Page) 则在两者之间做了权衡，通过少量的行命中实现开页 的增益，同时提高并行度来防止访问饥饿的现象和保证公平性。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220727103932041.png" class="" title="image-20220727103932041"><hr><h3 id="基于依赖感知的动态有向图处理加速器-20-华科"><a href="#基于依赖感知的动态有向图处理加速器-20-华科" class="headerlink" title="基于依赖感知的动态有向图处理加速器 20 华科"></a>基于依赖感知的动态有向图处理加速器 20 华科</h3><p>图算法通常需要对整个图进行反复迭代处理，不断地更新图顶点状态值，最终使 得所有图顶点状态值都不再发生改变，才停止迭代处理过程。因此，现有动态图处理 系统通常采用图迭代模型对最新图镜像执行增量计算。</p><p>目前的图迭代模型通常包括 批量同步迭代方法（Bulk Synchronous Parallel，BSP）模型和异步迭代模型。</p><h4 id="1-同步迭代模型"><a href="#1-同步迭代模型" class="headerlink" title="1 同步迭代模型"></a>1 同步迭代模型</h4><p>如图 1.3 所示，同步 BSP 迭代模型使用同步屏障机制将整个执行流程划分为数 个迭代周期。在每轮迭代中，基本并行处理单元被分配给各线程并行处理，通过对图 顶点及其相连的边执行运算以获得图顶点状态值（即，算法结果）。然而，由于同步 屏障的限制，各个图顶点都只能使用其前序图顶点在前一轮迭代中的旧状态值来计 算各自的新状态值，所有图顶点都完成各自的计算才能开始新的一轮迭代。迭代周期 交错进行，直到达到收敛状态。当 图处理系统并行处理图数据时，图数据被划分为并 行块并且分配给不同的处理单元。不同并行块之间通过共享内存或者消息通信机制 进行数据交换。</p><p>近年来，软件图处理系统和图加速器提出许多图划分方法，运行时负 载均衡策略和访存优化策略以提高每一轮迭代中图处理系统的吞吐率，并且已经达 到很好的效果。然而，受限于同步 BSP 迭代模型，图顶点的状态值在每轮迭代中只 能到达其直接后代图顶点，造成图顶点状态值的缓慢传播。因此，现有的同步 BSP 迭代模型不能有效支持动态图增量计算对低延迟和实时性的要求。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801201253986.png" class="" title="image-20220801201253986"><h4 id="2-异步迭代模型"><a href="#2-异步迭代模型" class="headerlink" title="2 异步迭代模型"></a>2 异步迭代模型</h4><p>不同于同步 BSP 迭代模型，如图 1.4 所示，异步迭代模型消除了同步屏障，当 前迭代计算得到的结果可以立即用于同一迭代中其它图顶点的状态值更新。因此，在 采用异步迭代模型的情况下，动态图中的图顶点的状态值传递速度通常快于同步 BSP 迭代模型，能够加快迭代收敛速度。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801201340527.png" class="" title="image-20220801201340527"><p>然而在异步迭代中，同时处理相邻图顶点会导致共享内存的读写冲突。为保证 异步迭代的顺序一致性，一些工作[20]对共享数据加锁以避免相邻图顶点的同时处 理。这导致大量锁开销，严重影响了大度图顶点的执行效率，对异步迭代处理性能 产生影响。为了减少原子开销，一些子图中心的异步迭代方法针对系统资源数 量，将有向图划分为图数据块并且分配图数据块给各个并行处理单元。不同图数据 块被并行地处理，通过消息通信机制同步不同图数据块之间的图顶点状态值。在各 个数据块内部，图顶点被串行地，异步地执行以快速传递图顶点状态值。</p><h4 id="3-设计动机"><a href="#3-设计动机" class="headerlink" title="3 设计动机"></a>3 设计动机</h4><blockquote><p>现有的同步 BSP 迭代模型和异步迭代模型能够提升有向图算法的并行度， 广泛应用于多种图处理系统和图加速器中。然而，由于动态有向图增量计算对实时性 要求极高，现有的迭代模型仍然面临着收敛速度缓慢和冗余数据计算和访问等问题， 无法满足用户对动态有向图处理的实时性需求。</p></blockquote><p>在动态有向图增量计算中，受到动态图变化影响的图顶点会沿着有向路径不断 地传递各自的状态值，因此，动态有向图处理的实时性直接受到图顶点的状态值传递 速度的影响。对于迭代有向图算法，每个图顶点都需要读取其前序图顶点的状态值以 重复更新自身的最新状态值，直到迭代收敛为止。但是，当在现有平台上并行执行图 算法时，大多数图顶点和它的前序图顶点被多个并行处理单元同时处理，在每轮迭代 中根据其前序图顶点的过时状态值更新以更新自身的状态值。结果，当使用现有的同 步/异步迭代模型时，活跃图顶点的最新状态值只能够缓慢地沿着有向路径传播到其 他的图顶点，并且根据其它图顶点的陈旧状态值来重复进行计算以更新自身。这不仅 浪费了大量时间用于处理冗余图顶点，还需要高额访存开销以反复加载这些图数据。</p><h5 id="3-1-同步BSP迭代过程"><a href="#3-1-同步BSP迭代过程" class="headerlink" title="3.1 同步BSP迭代过程"></a>3.1 同步BSP迭代过程</h5><p>如图 2.1 所示，动态图处理系统采用同步 BSP 迭代模型执行增量计算。在初始 状态时，动态有向图中所有的图顶点都达到收敛状态，并且相应的计算结果被维护。 当动态有向图结构发生变化时，例如，新增加了指向𝑣&amp;、𝑣’和𝑣(的边，需要重新进行 增量计算以获得最新图镜像的计算结果。图处理系统将激活图顶点，并且按照同步 BSP 迭代方式处理这些图顶点。在第一轮同步迭代中，𝑣&amp;的状态值首先被传递给其 后代图顶点𝑣’。然而，由于同步屏障，活跃图顶点的新状态值不能够立即被同一轮同 步迭代中的其它图顶点使用，因此，𝑣’不能够立即使用𝑣&amp;的状态值，也无法将𝑣&amp;的状态值立即传递给其后代图顶点𝑣(。当新的一轮迭代开始后，𝑣’才将自己接收到的𝑣&amp;传 递来的状态值后得到的结果传递给𝑣(。按照这种方式，在图数据块 P2 中的图顶点需 要至少三轮同步迭代才能将状态值传递给其它图数据块，造成了大量的冗余图数据 计算和访问，导致图顶点状态值缓慢地在有向图中传播。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801204827566.png" class="" title="image-20220801204827566"><h5 id="3-2-异步迭代模型"><a href="#3-2-异步迭代模型" class="headerlink" title="3.2 异步迭代模型"></a>3.2 异步迭代模型</h5><blockquote><p>由于传统的 round-robin 异步迭代模型[21]通常按照图顶点索引次序依次异步串行地处理活跃图顶 点，这忽略了有向图结构本身的更新依赖关系，导致低拓扑顺序的图顶点比高拓扑顺 序的图顶点先被处理。已经处理过的图顶点的状态值只能在下一轮异步迭代中才能 再次被处理，因此，在传统的异步迭代模型下，图顶点状态值仍然缓慢地在有向图中 传播，造成冗余图顶点更新。</p></blockquote><p>如图 2.2 所示，当动态图处理系统采用 round-robin 异步迭代模型执行增量计算 时，在其中一轮异步迭代过程中，一条已经被动态图改变量激活的有向路径（即， 𝑣&amp; → 𝑣’ → 𝑣(）上的图顶点可能被分配任意的图顶点索引次序，当图数据块 P2 被调 度处理时，其中的图顶点被按照图顶点索引次序依次异步串行地更新图顶点状态值。 然而，在每一轮异步迭代中，图顶点按照𝑣(，𝑣’，𝑣&amp;的顺序依次向后代图顶点传递各 自的图顶点状态值。由于已经处理过的图顶点的状态值只能在下一轮异步迭代中才 能再次被更新，因此在本轮异步迭代中，尽管图顶点可以立即使用并传递其前序图顶 点的状态值，但是其后代图顶点只能在下一轮迭代才能被重新更新。由于有向路径 (𝑣&amp; → 𝑣’ → 𝑣( → 𝑣))中包含 3 条边，因此至少需要进行三轮异步迭代（包含线程间同 步），图数据块 P2 才能将图顶点状态值完全传递给其它图数据块。因此，无论是同 步迭代模型，还是传统异步迭代模型，都 无法有效感知动态有向图的更新依赖关系，无法利用拓扑结构来加速动态有向图增量计算中的图顶点状态值传递。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801204945409.png" class="" title="image-20220801204945409"><h4 id="二-实验部分"><a href="#二-实验部分" class="headerlink" title="二 实验部分"></a>二 实验部分</h4><blockquote><p>The Aspen interface is an extension of Ligra’s interface. It includes the full Ligra interface-vertexSubsets, edgeMap, and various other functionality on a fixed graph. </p><p>On top of Ligra, we add a set of functions for updating the graph - in particular, for inserting or deleting sets of edges or sets of vertices. We also add a flat-snapshot function.  所有处理和更新的函数都是工作在固定大小的、不变的图镜像版本上面.</p></blockquote><h3 id="四-RisGraph-A-Real-Time-Streaming-System-for-Evolving-Graphs-to-Support-Sub-millisecond-Per-update-Analysis-at-Millions-Ops-s"><a href="#四-RisGraph-A-Real-Time-Streaming-System-for-Evolving-Graphs-to-Support-Sub-millisecond-Per-update-Analysis-at-Millions-Ops-s" class="headerlink" title="四 RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s"></a>四 RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s</h3><blockquote><p>单调算法（例如可达性和最短路径）在实时分析中广泛使用，以获得 both static and temporal insights(见解)，并且可以通过增量计算加速。现有的 streaming system 采用增量计算模型，并实现低潜伏期或高吞吐量，但不能两者兼而有之。</p><p>RisGraph 通过局部数据访问和更新的并行性解决挑战.</p><p>单调算法在不断 evolving graph 中经常使用,  其中包括可及性，广度搜索，最短路径，连接的组件（和最小/最大标签传播(Connected Components, and Min/Max Label Propagation)。它需要扫描大量数据甚至整个图表，以重新计算不断发展的图的每个快照上的单调算法。增量计算的想法可以通过利用先前的结果来减少冗余计算来加速单调算法。</p></blockquote><p>RisGraph 单边更新， 与批处理相比，Per-Update分析对延迟友好，产生最新结果，并提供最准确，最详细的信息。它只留下一个开放的问题：如何在per-update analysis 中提供高吞吐量。</p><h4 id="一-motivation"><a href="#一-motivation" class="headerlink" title="一 motivation"></a>一 motivation</h4><p>已有的解决方案：<code>Kickstarter</code> 和 <code>Differential Dataflow</code> 是最先进的代表, <code>Kickstarter</code> 提出了单调算法的增量图计算模型，而<code>Differential Dataflow</code>则呈现了无图形意识的广义增量模型。</p><p><strong>不足:</strong>  如果<code>Kickstarter</code> 和 <code>Differential Dataflow</code> 每次更改图形时都（Per Update Analysis）进行分析，则每秒只能处理大约1000个更新。they rely on batching to trade latency for higher throughput(以延迟换吞吐量), benefiting from larger concurrency and lower overheads.  此外，它们提供了批处理模式以进一步优化吞吐量，从而降低了分析的频率，并仅对每批批次产生一个汇总的最终结果。</p><p><strong>不足举例:</strong>  我们以2010年Twitter-2010 [48]的范围进行广度优先搜索（<code>BFS</code>）。为了满足20 ms延迟需求（实时分析[65]），这些系统的吞吐量仅为1K OPS/s。为了提供 100K OPS/s的吞吐量，它们需要批量超过 <code>20k</code> 的更新，并且平均处理时间增长到150毫秒以上。因此，现有的流图系统不能同时通过批处理满足延迟和吞吐量要求。尽管如此，批处理模式还是整个更新，跳过了中间状态，这些状态在某些情况下可能有用，例如财务欺诈检测和交易综合性。</p><p><strong>单边更新的挑战：</strong> </p><ol><li>无法像 batch 更新那样，均摊开销</li><li>高吞吐量和低延迟 的目标要求系统有效地进行两种工作负载。修改图表时，它需要将每个更新应用于数据结构，并提供更新的图表，以便在短时间内进行分析。为了启用每个更新的实时分析，系统需要一个图形感知的设计，以利用单个更新的局部性，而不是利用整个图形扫描的典型技术。此外，它需要一种新的机制才能使平行性进行PerDate Processing，这对于在不批处理的情况下实现高吞吐量也很重要。</li></ol><p><strong>guiding idea：</strong></p><ol><li>局部数据访问的想法来自以下观察结果：图形流系统的常用图形感知技术仍然需要不必要的整个图形扫描[43，54，68，77]。如果我们仅通过访问受更新影响的必要顶点来避免这些扫描，我们将获得更好的性能，因此我们建议使用称为索引的邻接列表和稀疏阵列的数据结构来启用本地化访问。</li><li>我们通过并行处理更新（跨越并行性），同时维护应用程序的每个语义，进一步改善了吞吐量。我们提出了一种算法，以识别可以并行执行的更新，并一个一个更新以保持低延迟，以及原子能，隔离和Per Update分析的正确性。</li></ol><h4 id="二-实验结果"><a href="#二-实验结果" class="headerlink" title="二 实验结果"></a>二 实验结果</h4><p>四种算法： BFS、SSSP、SSWP、WCC</p><p>我们首先加载90％的边缘，选择10％的边缘作为从加载边缘的删除更新，然后将其余（10％）边缘视为插入更新。删除和更新占比1:1。</p><p>与<code>Kickstarter</code>相比，<code>Risgraph</code>的性能改进主要是我们本地化数据访问的信用（第3节）。 <code>Risgraph</code>的表现优于差异数据流，这主要是由于专门的图形感知引擎和增量模型。例如，与<code>Risgraph</code>相比，在Twitter-2010上重新计算<code>BFS</code>的处理时间为78倍。</p><h4 id="三-相关工作"><a href="#三-相关工作" class="headerlink" title="三 相关工作"></a>三 相关工作</h4><ol><li><code>Kickstarter</code> 通过追踪依赖关系和修剪近似值，为单调算法提供了正确的增量计算。 </li><li><code>Grapu</code>  by components-based classification and in-buffer <code>precomputation</code> 加速批处理单调算法。</li><li><code>Graphin</code> 结合了一个I-GAS模型，该模型会逐步处理固定尺寸的更新。</li><li><code>GraphBolt</code> 提出了一个通用的增量模型来 处理 non-monotonic algorithms like Belief Propagation,，但比单调算法的 <code>kickstarter</code> 涉及更多的开销。</li></ol><h3 id="五-GraphPulse-An-Event-Driven-Hardware-Accelerator-for-Asynchronous-Graph-Processing"><a href="#五-GraphPulse-An-Event-Driven-Hardware-Accelerator-for-Asynchronous-Graph-Processing" class="headerlink" title="五 GraphPulse: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing"></a>五 <code>GraphPulse</code>: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing</h3><p>​                                                                                                                                                                                                ——2020 MICRO</p><blockquote><p>大规模的图处理带来了一些问题:</p><ol><li>首先，内存密集型处理会给内存系统带来压力, 和计算型系统相比, 内存占用更大, 频率更高. 大型内存占用还会导致内存带宽瓶颈并加剧长期访问延迟.</li><li>其次，由于顶点的并发更新，大多数计算模型中访问共享图状态的同步开销很高.</li><li>跟踪活动顶点或者边缘的开销很大, 这种跟踪是必不可少的，因为计算是不规则的，而在每次迭代中都有不同的顶点和边缘的子集。</li></ol><p>综上, 我们认为，现代处理体系结构不太适合按大规模进行图形处理应用程序</p></blockquote><p><code>GraphPulse</code> 围绕事件驱动计算的想法, 它表示计算为event， when the value of a  vertex changes to update vertices on all outgoing edges(当顶点的值更改为更新所有传出边上的顶点时)通常生成.</p><h3 id="六-JetStream-Graph-Analytics-on-Streaming-Data-with-Event-Driven-Hardware-Accelerator"><a href="#六-JetStream-Graph-Analytics-on-Streaming-Data-with-Event-Driven-Hardware-Accelerator" class="headerlink" title="六 JetStream: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator"></a>六 <code>JetStream</code>: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator</h3><blockquote><p><code>Jetstream</code> 扩展了最近提出的基于事件的加速器，用于图形工作负载，以支持流更新。它通过事件驱动的计算模型来处理累积和单调图算法，该模型限制了访问图形顶点的较小子集，有效地重用以前的查询结果以消除冗余，并优化了增强内存存储器带宽利用率的内存访问模式。</p></blockquote><p><code>Jetstream在Kickstarter和GraphBolt</code> 软件框架上达到了约18倍的速度，这些系统在较小的批次尺寸下具有明显较高的加速度。</p><p>更新的 batch 大小只占原始图大小的很小一部分, 如果重头计算的话势必会带来一些不必要的冗余。逐步支持删除的问题更具挑战性，只有Kickstarter [45]，GraphBolt [26]和DZIG [25]支持它。</p><p>支持的算法：supports all algorithms compatible with delta-accumulative computation。</p><p>相对于增加，删除操作更加麻烦，我们在两个阶段中支持删除：</p><ol><li>将图形的上一个版本的逐步转换为更新图的可恢复状态</li><li>bringing the results to convergence again.</li></ol><h3 id="七-图处理相关论文"><a href="#七-图处理相关论文" class="headerlink" title="七 图处理相关论文"></a>七 图处理相关论文</h3><h4 id="三-how怎么解决这个问题"><a href="#三-how怎么解决这个问题" class="headerlink" title="三 how怎么解决这个问题"></a>三 how怎么解决这个问题</h4><p>GRASP augments existing cache policies to maximize reuse of hot vertices by protecting them against cache thrashing, while maintaining sufficient flexibility to capture the reuse of other vertices as needed.</p><ul><li><h4 id="论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别"><a href="#论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别" class="headerlink" title="论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别"></a>论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别</h4></li></ul><blockquote><p>这并未提出新的重排序方法, 而是使用已有的重排序方法,  引用下面两篇论文.</p><ul><li> [A Closer Look at Lightweight Graph Reordering](# A Closer Look at Lightweight Graph Reordering)</li><li>[Making caches work for graph analytics](# Making caches work for graph analytics)</li></ul></blockquote><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220511164905637.png" class="" title="image-20220511164905637"><center>(a) Software applies vertex reordering, which segregates hot vertices at the beginning of the array. (b) GRASP interface exposes an ABR pair per Property Array to be configured with the bounds of the array. (c) GRASP identifies regions exhibiting different reuse based on an LLC size. </center><ul><li>Page5  论文中是如何识别热数据顶点，如何pinpoint(准确找到)热数据区域以及如何对访问进行归类；</li></ul><blockquote><ul><li><p>Conveniently, the hottest vertices are located at the beginning of the Property Array in a contiguous region thanks to the application of skew-aware reordering as seen in Fig. 3(a).  <strong>也就是说, 热顶点是通过排序得到的</strong>。</p></li><li><p>会在属性数组起始地址抓两个LLC-sized 的子区域， 一个 HIgh Reuse Region, 另一个Moderate Reuse Region.</p></li><li><p>GRASP determines this by comparing the address with the bounds of the High Reuse Region of each Property Array. </p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220511165057988.png" class="" title="image-20220511165057988"><p>GRASP encodes the classification result (High-Reuse, Moderate-Reuse, Low-Reuse or Default) as a 2-bit Reuse Hint, and forwards it to the LLC along with each cache request, as shown in Fig. 4, to guide specialized insertion and hit-promotion policies as described next.</p></li></ul></blockquote><h4 id="四-what-解决之后得到什么结论"><a href="#四-what-解决之后得到什么结论" class="headerlink" title="四 what 解决之后得到什么结论"></a>四 what 解决之后得到什么结论</h4><h5 id="4-1-Graph-process-framework"><a href="#4-1-Graph-process-framework" class="headerlink" title="4.1 Graph process framework"></a>4.1 Graph process framework</h5><blockquote><p>ligra, a widely used graph processing framework that supports both pull- and push-based computations, including switching from pull to push (and vice versa) at the start of every iteration. </p></blockquote><h5 id="4-2-Software-evaluation"><a href="#4-2-Software-evaluation" class="headerlink" title="4.2  Software evaluation"></a>4.2  Software evaluation</h5><p>论文中涉及的重排序技术</p><blockquote><p><strong>Sort</strong>  reorders vertices in the memory space by sorting them in the descending order of their degree.</p></blockquote><blockquote><p><strong>HubSort</strong>  segregates(隔离) hot vertices in a contiguous region by assigning them a continuous range of vertex IDs in their descending order of degree. In doing so, Hub Sorting essentially sorts all hot vertices, while largely preserving structure for the cold vertices.</p></blockquote><blockquote><p><strong>DBG</strong> , unlike Sort and HubSort, does not rely on sorting to segregate hot vertices. Instead, DBG coarsely(粗略的) partitions all vertices into a small number of groups based on their degree. Similar to Sort and HubSort, DBG is effective at improving spatial locality; however, unlike the other two techniques, DBG is able to largely preserve the existing graph structure.</p></blockquote><blockquote><p><strong>Gorder</strong> is evaluated as a representative of complex techniques. As Gorder is only available in a single-thread implementation, while reporting the net runtime of Gorder for a given dataset, we optimistically divide the reordering time by 40 (maximum number of threads supported on the server) to provide a fair comparison with skew-aware techniques whose reordering implementation is fully parallelized.</p></blockquote><h3 id="八-A-Closer-Look-at-Lightweight-Graph-Reordering"><a href="#八-A-Closer-Look-at-Lightweight-Graph-Reordering" class="headerlink" title="八 A Closer Look at Lightweight Graph Reordering"></a>八 A Closer Look at Lightweight Graph Reordering</h3><h4 id="二-why"><a href="#二-why" class="headerlink" title="二 why"></a>二 why</h4><p>To address the limitations of existing skew-aware reordering techniques, </p><ul><li> Sort achieves the maximum reduction in the cache footprint of hot vertices. However, in doing so, Sort completely decimates existing graph structure</li><li>Hub Sorting and Hub Clustering both classify vertices as hot or cold based on their degree and preserve the structure for cold vertices. However, in dealing with hot vertices, they resort to inefficient extremes. </li><li>At one extreme, Hub Sorting employs fine-grain reordering that sorts all hot vertices, destroying existing graph structure. At the other extreme, Hub Clustering does not apply any kind of reordering among hot vertices, sacrificing significant opportunity in improving cache efficiency</li></ul><p>we propose Degree-Based Grouping <a href="https://github.com/faldupriyank/dbg">DBG</a>。</p><h4 id="三-how"><a href="#三-how" class="headerlink" title="三 how"></a>三 how</h4><h5 id="3-1-the-dbg-algorithm"><a href="#3-1-the-dbg-algorithm" class="headerlink" title="3.1 the dbg algorithm"></a>3.1 the dbg algorithm</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220512161706297.png" class="" title="image-20220512161706297"><center>  DBG algorithm. Degree can be in-degree or out-degreeor sum of both.</center><h5 id="3-2-the-dbg-example"><a href="#3-2-the-dbg-example" class="headerlink" title="3.2 the dbg example"></a>3.2 the dbg example</h5><p> Vertex degree is shown inside the box while original vertex ID is shown below the box.</p><p>Vertex ordering in memory after DBG. In this example, DBG partitions vertices into three groups with degree ranges [0, 20), [20, 40) and [40, 80). DBG maintains a relative order of vertices within a group. As a result, many vertices are placed nearby the same vertices as before the reordering such as vertex sets (P4, P5, P6), (P0, P1) and (P10, P11).</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220512162204354.png" class="" title="image-20220512162204354"><center>Vertex ordering in memory after DBG. </center><h5 id="3-3-运行作者实验"><a href="#3-3-运行作者实验" class="headerlink" title="3.3 运行作者实验"></a>3.3 运行作者实验</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1. 编译 这一步注意设置DBG_ROOT, 要不然下面第二部会出现错误</span></span><br><span class="line">export DBG_ROOT=&#x27;/home/server2/dbg&#x27;</span><br><span class="line">cd ~/dbg/apps</span><br><span class="line">make -j </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2. 下载数据集</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//el --&gt; edge list of the form (src, dst) <span class="keyword">in</span> text file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//bel --&gt; edge list of the form (src, dst) <span class="keyword">in</span> binary file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//vgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//cvgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges (no self or redundant edges)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//csvgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges (no self or redundant edges)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//         graph is symmetric -- so <span class="keyword">for</span> every edge (u, v) there also exist (v, u)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//cintgr --&gt; binary csr format with int weight <span class="keyword">for</span> edges (no slef or redundant edges)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">//edges are assumed to take 8 bytes and vertices (and edge weights) are assumed to take 4 bytes <span class="keyword">in</span> binary file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">//all *gr files contain a header of 24 bytes as follows:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//number of vertices</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//number of edges</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//major number</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//minor number</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//gr files are implemented based on the implementation from Galois.</span></span><br><span class="line"></span><br><span class="line">wget http://snap.stanford.edu/data/web-Google.txt.gz</span><br><span class="line">gunzip web-Google.txt.gz</span><br><span class="line">../graph-convert-utils/clean_edgelist.py web-Google.txt web-Google.el</span><br><span class="line">../graph-convert-utils/convert.sh web-Google</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3. Run individual application， 运行之前安装numactl，否则会出现错误。 安装命令 sudo apt install numactl</span></span><br><span class="line">make REORDERING_ALGO=5 DEGREE_USED_FOR_REORDERING=0 DATASET=web-Google run-PageRank</span><br></pre></td></tr></table></figure><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220513152610369.png" class="" title="image-20220513152610369"><h3 id="九-Making-caches-work-for-graph-analytics"><a href="#九-Making-caches-work-for-graph-analytics" class="headerlink" title="九 Making caches work for graph analytics"></a>九 Making caches work for graph analytics</h3><p>Hub sorting was proposed as a variant of Sort that aims to preserve some structure while reducing the cache footprint of hot vertices.</p><h3 id="十-Speedup-Graph-Processing-by-Graph-Ordering"><a href="#十-Speedup-Graph-Processing-by-Graph-Ordering" class="headerlink" title="十 Speedup Graph Processing by Graph Ordering"></a>十 Speedup Graph Processing by Graph Ordering</h3><p>Gorder—— the state-of-the-art structure-aware reordering technique.</p><h3 id="十一-如何直接对属性数组进行冷热数据分离"><a href="#十一-如何直接对属性数组进行冷热数据分离" class="headerlink" title="十一 如何直接对属性数组进行冷热数据分离"></a>十一 如何直接对属性数组进行冷热数据分离</h3><blockquote><p>这里对冷热数据分离是什么意思?  </p><p>是划分出high reuse region、Moderate （适度）Reuse Region， 不常用数据？</p></blockquote><h4 id="1-1-DBG-实验"><a href="#1-1-DBG-实验" class="headerlink" title="1.1 DBG 实验"></a>1.1 DBG 实验</h4><p>在dbg的实验中, 将el格式的图转为了cvgr –&gt; binary csr format with no weight for edges (no self or redundant edges), cintgr –&gt; binary csr format with int weight for edges (no slef or redundant edges)。pagerank算法应该是借助 ligra 使用了 cvgr格式的图。这里的话没有cache，还需要自己配置才能获取到冷热数据，因此还要看以前的grasp这个仓库。</p><h4 id="1-2-grasp实验"><a href="#1-2-grasp实验" class="headerlink" title="1.2 grasp实验"></a>1.2 grasp实验</h4><p>在[Domain-Specialized Cache Management for Graph Analytics ](# 图处理相关论文) 这篇论文中,  通过dbg重排序后，作者直接定义了两个cache大小的区域, 分别获取high、 moderate 区域。</p><h3 id="十二-Proceedings-of-the-ACM-on-Measurement-and-Analysis-of-Computing-Systems-Vol-3-No-3-Article-60"><a href="#十二-Proceedings-of-the-ACM-on-Measurement-and-Analysis-of-Computing-Systems-Vol-3-No-3-Article-60" class="headerlink" title="十二  Proceedings of the ACM on Measurement and Analysis of Computing Systems Vol. 3, No. 3, Article 60"></a>十二  Proceedings of the ACM on Measurement and Analysis of Computing Systems Vol. 3, No. 3, Article 60</h3><p>CHARACTERIZATION METRICS</p><h4 id="1-1-Performance-Metrics"><a href="#1-1-Performance-Metrics" class="headerlink" title="1.1 Performance Metrics"></a>1.1 Performance Metrics</h4><ol><li>We measure single-threaded application performance using instructions per cycle (IPC)</li><li>For multithreaded applications, we show parallel speedup (i.e., the single-threaded execution time divided by the parallel execution time), which accounts for synchronization overheads.</li><li>To quantify the memory intensity of an application, we use the number of misses per kilo-instruction (MPKI) issued by the last-level cache for that application to DRAM.</li></ol><h4 id="1-2-Parallelism-Metrics"><a href="#1-2-Parallelism-Metrics" class="headerlink" title="1.2 Parallelism Metrics"></a>1.2 Parallelism Metrics</h4><p>Prior works have used either memory-level parallelism (MLP) [26, 47, 137, 152, 181] or bank-level parallelism (BLP) to quantify the amount of parallelism across memory requests</p><p>MLP measures the average number of outstanding memory requests for an application, but this does not capture the amount of parallelism offered by the underlying hardware.</p><p>BLP measures the average number of memory requests that are actively being serviced for a single thread during a given time interval.</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221004152901298.png" class="" title="image-20221004152901298"><h4 id="1-3-Contention-Metrics"><a href="#1-3-Contention-Metrics" class="headerlink" title="1.3 Contention Metrics"></a>1.3 Contention Metrics</h4><p>An important measure of spatial and temporal locality in memory is the row buffer hit rate, also known as row buffer locality.</p><p>To quantify the row hit rate, prior works count the number of row buffer hits and the number of row buffer misses, which they define as any request that does not hit in the currently-open row.</p><blockquote><p>To accurately capture row buffer locality, we introduce a new characterization methodology where we break down memory requests into: (1) row buffer hits; (2) row buffer misses, which only include misses for a DRAM request where the bank does not have any row open; and (3) row buffer conflicts, which consist of misses where another row is currently open in the bank and must be closed (<code>i.e., precharged</code>) first. Row buffer conflicts provide us with important information about how the amount of parallelism exposed by a DRAM type can limit opportunities to concurrently serve multiple memory requests, which in turn hurts performance.</p></blockquote><p>为了准确捕获行缓冲区局部性，我们引入了一种新的特征方法，将内存请求分解为：</p><p>（1）行缓冲区命中；</p><p>（2）行缓冲区错过，其中仅包括银行没有任何行打开的DRAM请求的错过； </p><p>（3）行缓冲冲突，其中包括当前在银行中打开另一排，必须首先关闭（即预处理）的失误。行缓冲冲突为我们提供了有关DRAM类型暴露的并行量如何限制同时服务多个内存请求的机会，这反过来又损害了性能。</p><h3 id="十三-Graphfire-Synergizing-Fetch-Insertion-and-Replacement-Policies-for-Graph-Analytics"><a href="#十三-Graphfire-Synergizing-Fetch-Insertion-and-Replacement-Policies-for-Graph-Analytics" class="headerlink" title="十三 Graphfire: Synergizing Fetch, Insertion, and Replacement Policies for Graph Analytics"></a>十三 Graphfire: Synergizing Fetch, Insertion, and Replacement Policies for Graph Analytics</h3><blockquote><p> With the goal of optimizing cache performance for graph applications, our work makes the following key observations: (i) The memory hierarchy must specialize for the problematic indirect accesses (PIAs) to alleviate their bottlenecks. (ii) To be software-agnostic, a lightweight mechanism must automatically identify PIAs, which can be achieved on a perinstruction basis. (iii) While PIAs are irregular, a subset of them have high reuse, so the LLC must retain them.</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图处理的相关论文&quot;&gt;&lt;a href=&quot;#图处理的相关论文&quot; class=&quot;headerlink&quot; title=&quot;图处理的相关论文&quot;&gt;&lt;/a&gt;图处理的相关论文&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Benchmark：主要是对比别人的方法，这个方法不一定是最好的，</summary>
      
    
    
    
    <category term="学术论文" scheme="http://okeyia.github.io/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="图重排序" scheme="http://okeyia.github.io/tags/%E5%9B%BE%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenMP并行编程</title>
    <link href="http://okeyia.github.io/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    <id>http://okeyia.github.io/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-13T00:57:55.000Z</published>
    <updated>2022-11-21T05:14:00.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenMP并行编程"><a href="#OpenMP并行编程" class="headerlink" title="OpenMP并行编程"></a>OpenMP并行编程</h2><h3 id="一-编程模型"><a href="#一-编程模型" class="headerlink" title="一 编程模型"></a>一 编程模型</h3><p>OpenMP是共享存储体系结构上的一个并行编程模型。 适合于SMP共享内存多处理系统和多核处理器体系结构。</p><ul><li><p>OpenMP是基于线程的并行编程模型。 </p></li><li><p>OpenMP采用Fork-Join并行执行方式： </p><ul><li>OpenMP程序开始于一个单独的主线程（Master  Thread），然后主线程一直串行执行，直到遇见第 一个并行域(Parallel Region)，然后开始并行执行并行 区域。</li><li>其过程如下： Fork:主线程创建一个并行线程队列，然后，并行域中的代 码在不同的线程上并行执行； Join:当并行域执行完之后，它们或被同步或被中断，最后 只有主线程在</li></ul></li></ul><img src="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/image-20220422102521910.png" class="" title="image-20220422102521910"><hr><h3 id="二-Clion中-Cmake-文件"><a href="#二-Clion中-Cmake-文件" class="headerlink" title="二 Clion中 Cmake 文件"></a>二 Clion中 Cmake 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FIND_PACKAGE(OpenMP REQUIRED)</span><br><span class="line">if (OPENMP_FOUND)</span><br><span class="line">    message(&quot;OPENMP FOUND&quot;)</span><br><span class="line">    set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; $&#123;OpenMP_C_FLAGS&#125;&quot;)</span><br><span class="line">    set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;OpenMP_CXX_FLAGS&#125;&quot;)</span><br><span class="line">endif () </span><br></pre></td></tr></table></figure><h3 id="三-代码实例"><a href="#三-代码实例" class="headerlink" title="三 代码实例"></a>三 代码实例</h3><h4 id="3-1-pragma-omp-parallel"><a href="#3-1-pragma-omp-parallel" class="headerlink" title="3.1 #pragma omp parallel"></a>3.1 #pragma omp parallel</h4><p>parallel制导命令表示接下来由花括号括起来的区域将创建多个线程并行执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-制导指令-for"><a href="#3-2-制导指令-for" class="headerlink" title="3.2  制导指令 for"></a>3.2  制导指令 for</h4><p>在并行域里面用 <code>#pragma omp for</code>，在这条语句之后的一个for循环语句中每一个要循环的任务将被分配给不同的线程去执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有这行代码, 2个线程每一个都将运行一次for循环, 加完这条代码, 2个线程共同运行一次for循环</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码和下面的代码, 结果是相同的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-schdule指令"><a href="#3-3-schdule指令" class="headerlink" title="3.3 schdule指令"></a>3.3 schdule指令</h4><p>在以上的任务中，各个线程自动分配到要执行的任务标号，没有对任务做一些进一步的调度，接下来介绍的字句将会对for循环任务的调度做更细致一些的规定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schedule(type, size);</span><br><span class="line"><span class="comment">// type参数有四种：1.static, 2.dynamic, 3.guided, 4.runtime</span></span><br><span class="line"><span class="comment">// size参数是整形数据：表示循环迭代次数划分的单位。</span></span><br></pre></td></tr></table></figure><h5 id="3-3-1-静态调度"><a href="#3-3-1-静态调度" class="headerlink" title="3.3.1 静态调度"></a>3.3.1 静态调度</h5><p>静态调度，不用size参数时分配给每个程序的都是 <code>n/t</code> 次连续迭代，n 为迭代次数，t为并行的线程数目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(static)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-动态调度"><a href="#3-3-2-动态调度" class="headerlink" title="3.3.2 动态调度"></a>3.3.2 动态调度</h5><p>动态调度模式是先到先得的方式进行任务分配，不用size参数的时候，先把任务干完的线程先取下一个任务，以此类推，而不是一开始就分配固定的任务数。</p><p>使用size参数的时候，分配的任务以size为单位，一次性分配size个。虽然很智能，在任务难度不均衡的时候适合用dynamic，否则会引起过多的任务动态申请的开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(dynamic,3)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-section-指令"><a href="#3-4-section-指令" class="headerlink" title="3.4 section 指令"></a>3.4 section 指令</h4><p>sections 把不同的区域 交给不同的线程去执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel sections</span></span><br><span class="line">   &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-single指令"><a href="#3-5-single指令" class="headerlink" title="3.5 single指令"></a>3.5 single指令</h4><p>single制导指令所包含的代码段只有一个线程执行，别的线程跳过该代码，如果没有nowait子句，那么其他线程将会在single制导指令结束的隐式同步点等待。有 <code>nowait</code> 子句其他线程将跳过等待往下执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp single</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;single thread=&quot;</span> &lt;&lt; omp_get_thread_num()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-注意点-pargma-omp-for"><a href="#3-5-注意点-pargma-omp-for" class="headerlink" title="3.5  注意点 #pargma omp for"></a>3.5  注意点 #pargma omp for</h4><p>单独使用 <code>#pargma omp for</code>, 相当于没有并行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rank:&quot;</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// 有序输出100行, 全是进程0 相当于没有并行</span></span><br></pre></td></tr></table></figure><h3 id="四-使用OpenMp-实现-std-accumulate"><a href="#四-使用OpenMp-实现-std-accumulate" class="headerlink" title="四 使用OpenMp 实现 std:: accumulate"></a>四 使用OpenMp 实现 std:: accumulate</h3><blockquote><p>最近刚好在学习C++ 并行编程，学习到了怎么使用多线程实现 <code>std::accumulate</code> , 比较一下两者的差异。</p></blockquote><p>下面是直接运行的代码:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">sum += dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面这个程序中，试图用sum来累加变量和。#pragma omp parallel for告诉编译器要把这个for语句拆开来并行执行。</p><p>注意 sum 定义在并行块外面，所以在并行块中会共享这个变量。也就是说在四个核中用的是同一个变量，对于sum + = i 语句，是先把sum的值取出来和 i 相加后再把结果赋给sum变量。</p><p>既然四个线程用的是同一个sum，那么如果sum在线程0中取出来了，另一个线程中也同时取出来了同样值的sum，加完后值在两个线程中都会被送就回到sum，那么就会造成有一次操作被重写了（数据碰撞），也就是说最后的结果很可能小于正确的结果。</p></blockquote><h4 id="4-1-pragma-omp-critical"><a href="#4-1-pragma-omp-critical" class="headerlink" title="4.1 #pragma omp critical"></a>4.1 #pragma omp critical</h4><p>这条语句是告诉编译器下面的代码块很关键，任何时刻都只能有一个线程执行该代码块。不过这样的话<strong>代码会在多个核中的运行会相互影响</strong>，对性能有一定影响，最好的解决方法是用规约reduction。</p><blockquote></blockquote><h4 id="4-2-reducation-规约"><a href="#4-2-reducation-规约" class="headerlink" title="4.2 reducation(规约)"></a>4.2 reducation(规约)</h4><blockquote><p>reduction (+:sum) 告诉编译器，这并行块要用规约，+表示求和操作，sum是目标变量名。这样的话，编译器就会给每个线程一个sum的拷贝并正确初始化为0，然后<strong>每个线程执行完之后再合并</strong>。规约只适用于固定的操作符。</p><img src="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/image-20221121112738508.png" class="" title="image-20221121112738508"></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2022/11/21.</span></span><br><span class="line"><span class="comment">// 使用规约求和</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp=&#123;<span class="number">100</span>&#125;;</span><br><span class="line">srand(time(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成1千万个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">dp.push_back(rand() % <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for reducation(+:sum)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">sum += dp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;使用openmp所花费的时间为: &quot;</span> </span><br><span class="line">        &lt;&lt; (<span class="built_in">std</span>::chrono::system_clock::now() - start).count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-firstprivte和lastprivate"><a href="#4-3-firstprivte和lastprivate" class="headerlink" title="4.3 firstprivte和lastprivate"></a>4.3 firstprivte和lastprivate</h4><blockquote><p>如果我们不想要已经定义了的变量在多个线程中共享，想要让每个线程有自己的拷贝怎么办呢？</p><p>下面就简单介绍一个private从句，以及firstprivate和lastprivate。通过使用#pragma omp parallel private（variable list），告诉编译器在下面的并行块中每个线程都对variable list列出的变量进行拷贝。不过值得注意的时，每个线程中拷贝的变量的初始值是不确定的，执行完并行块后该变量的值也不确定。</p><p>所以就有了firstprivate和lastprivate，firstprivate 是说<strong>变量的初始值就是按照该变量进入并行块之前的值初始化</strong>；lastprivate 是说退出并行块后，按照串行情况最后的一个值给到主线程中的变量。如果同时使用firstprivate和lastprivate，那么该变量就会有和串行是一样的初始值和结束值。</p></blockquote><h3 id="五-参考链接"><a href="#五-参考链接" class="headerlink" title="五 参考链接"></a>五 参考链接</h3><ol><li><p><a href="https://www.jianshu.com/p/796d531c08ed">并行计算工具OpenMP 二</a></p></li><li><p><a href="https://cloud.tencent.com/developer/ask/sof/491657">使用clang-12时，CMake的find_package( OpenMP )找不到OpenMP</a> 保持clang版本与libomp版本一致,  如 clang版本为10, 安装对应的libomp版本.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libomp-10-dev</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.ibm.com/docs/en/xl-c-aix/13.1.2?topic=processing-pragma-omp-parallel">pragma omp parallel</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenMP并行编程&quot;&gt;&lt;a href=&quot;#OpenMP并行编程&quot; class=&quot;headerlink&quot; title=&quot;OpenMP并行编程&quot;&gt;&lt;/a&gt;OpenMP并行编程&lt;/h2&gt;&lt;h3 id=&quot;一-编程模型&quot;&gt;&lt;a href=&quot;#一-编程模型&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>How-to-read-papers</title>
    <link href="http://okeyia.github.io/2022/05/09/How-to-read-papers/"/>
    <id>http://okeyia.github.io/2022/05/09/How-to-read-papers/</id>
    <published>2022-05-09T09:29:40.000Z</published>
    <updated>2022-11-13T15:18:05.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何阅读论文"><a href="#如何阅读论文" class="headerlink" title="如何阅读论文"></a>如何阅读论文</h2><blockquote><p>研一萌新, 最近在读论文的时候, 读到后半部分，前面讲的什么东西都已经忘完了, 不得不重新回顾。这样读起来有种深陷泥潭、举步维艰的感觉，然后觉得可能是自己读论文的方法有问题——没有从整体上把握整篇论文，只陷于个细节里面去了。感觉自己是时候该学习一下读论文的方法,  提高自己效率。</p></blockquote><p>通常来说，读论文一般有以下四个要素：</p><ul><li>What 这篇论文要解决什么问题？</li><li>Why 这篇文章为什么要解决这个问题, 解决这个问题有什么意义?<ul><li>Importance, implication, relevance</li><li>切入点：现有文献、研究方法</li></ul></li><li>how 这篇文章如何解决了这个问题?<ul><li>Problem formulation, research methods, data, experiments, etc</li></ul></li><li>what 解决这篇文章之后得到怎么样的结论<ul><li>Conclusions, perspectives, outlook, etc.</li></ul></li></ul><h3 id="一-论文各部分的重要性"><a href="#一-论文各部分的重要性" class="headerlink" title="一 论文各部分的重要性"></a>一 论文各部分的重要性</h3><ol><li>摘要 abstract: 论文最重要的部分，一般由导师直接把关</li><li>引言 introduction: 重要性仅次于摘要，内容更加易懂</li><li>相关工作 related work: 对领域内工作的分类和总结</li><li>其他章节: 论文细节，对于理解本论文非常重要。</li><li>总结 conclusion: 全文总结和展望</li><li>参考文献 reference: 论文引用的文献列表</li><li>附录 Appendix: 部分无法放到正文中的内容，如过分细节的证明和算法</li></ol><h3 id="二-快速阅读（泛读）"><a href="#二-快速阅读（泛读）" class="headerlink" title="二 快速阅读（泛读）"></a>二 快速阅读（泛读）</h3><p><strong>观点：</strong></p><ul><li><strong>快速阅读其实是一种技巧，一个捷径。</strong>你可能从这些图片中以及标题中获取大约70%，80%甚至90%的论文信息。</li><li>对于<strong>作者</strong>来说，他会思考论文的任务是什么？研究发现是什么？是什么内容让这篇文章重要且有吸引力？一个论文需要帮助大家明白究竟是想表达什么。站在读者的视角，你需要理解文章的观点。写论文的准则：你必须要让论文易于阅读。你必须要让每个读者都可以轻松阅读。</li><li>对于<strong>读者</strong>来说，我需要学习这篇文章嘛？我有多需要从这篇文章中学习？ 我能学到什么？当我一定程度上理解了文章，对我有什么影响？</li><li><strong>一篇论文包含四个部分，标题，摘要，引言和剩下的部分。</strong>作者应该花等长的时间写这4个部分。 但对于学生来说，大家真的需要大部分精力在实验，公式上。</li></ul><p><strong>如何进行快速阅读：</strong></p><ol><li> <strong>整篇论文都是在概括浓缩（abstraction）的过程中</strong>，引言是文章的浓缩，摘要是引言的浓缩，标题是摘要的浓缩。</li><li><strong>引言：论文是关于什么的？解决什么问题？为什么论文有意思？有什么新的发现？文章为什么是好的？</strong></li><li>摘要：我们可以有层次地阅读论文。我们可以将论文分解并加上一些有趣的亮点，这有利于阅读。<strong>论文中摘要部分说了什么？之后你需要看看这篇论文真正的发现是什么？我为什么需要在意这些东西？</strong></li></ol><p>如果时间有限，直接读abstract是最高效的方法。如果时间还很充裕，那么就把introduction也读一遍。读完这两部分，就应该能基本理解论文的核心思想。</p><p><strong>WARNING</strong>:读得速度越快，对论文的理解越差，甚至会出现误解。因此，想要好好理解一篇论文，精读是非常必要的。</p><h3 id="三-精读"><a href="#三-精读" class="headerlink" title="三 精读"></a>三 精读</h3><p>通过泛读（快速）阅读筛选完论文之后，需要精读部分的重要论文。我个人建议将精读分为几个阶段进行:</p><ol><li>理解论文基本原理: motivation，所用的理论？</li><li>理解论文详细内容: 深入理解论文细节，包括定义、假设和相关公式等</li><li><del>能够重现实验</del>（未必需要）: 能否重现整个实验，并得到相同结果？</li><li>组织讨论: 与其他人进行讨论，可能有没有疏忽的地方？或者理解不到位的地方？</li><li>设计更好的方案: 能不能更进一步，设计更好的方法？</li></ol><p><strong>每个阶段可以对应一次或者多次阅读，通过多次阅读来加深对论文的理解</strong>。不要指望一口气能够理解整篇论文。很多原因会造成理解不够深入甚至理解错误，例如现阶段的知识面不够，或者对于某些概念理解错误等。所以需要多次阅读（如果有必要，多次讨论）来避免这类问题。</p><p><strong>WARNING</strong>:讨论是非常必要的（最好由阅读论文的人主讲），当其他人从他的角度提出疑问时，很可能会给意想不到的惊喜。</p><h3 id="四-沈向洋-经读论文的方法"><a href="#四-沈向洋-经读论文的方法" class="headerlink" title="四 沈向洋: 经读论文的方法"></a>四 沈向洋: 经读论文的方法</h3><ol><li><p>批判性阅读</p><ul><li><strong>批判性阅读的核心就是不断否定，不断质问，不断怀疑。</strong></li><li><strong>由于批判性阅读会花费很多时间，你可能时不时卡住。我建议你，不要惊慌失措！批判性阅读确实很难，但你要坚持下去，定能度过难关。</strong></li><li><strong>搞明白你可以到哪里获取帮助，可以求助谁。但要站在对方角度进行思考，不能过多占用对方的时间。</strong></li></ul></li><li><p>创造性阅读</p><ul><li>简单地说，如果我要根据这篇论文做一些研究，有什么新的东西我可以做？最终，你<strong>需要根据你所学的论文以及相关的论文思考，你是否有足够棒的想法能够让你在未来三到五月里进行相关研究？</strong></li><li><strong>真正理解论文是能够根据论文提出问题并回答问题。</strong></li></ul></li><li><p>问题列表</p><ul><li>客观性问题：论文是关于什么的？核心观点是什么？有什么局限性？作者有没有公开代码？数据是否可用？这个想法是否真的不错？论文中想法是否有违直觉？论文的贡献是否重要？实验做的如何？</li><li>主观性问题：关于这篇论文我有没有遗漏的地方？这篇论文对我有没有帮助？我是否可以直接用文中的方法解决问题？这篇论文是否值得持续研究下去？别人对这篇论文有什么想法呢？谁是这个领域的专家？<strong>如果我有机会见到论文的作者，我会问什么问题？</strong></li></ul></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/Richardyu114/How-to-Read-and-Write-Research-Paper">How-to-Read-and-Write-Research-Paper</a></li><li><a href="https://github.com/qiyuangong/How_to_Search_and_Read_a_Paper">How_to_Search_and_Read_a_Paper</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何阅读论文&quot;&gt;&lt;a href=&quot;#如何阅读论文&quot; class=&quot;headerlink&quot; title=&quot;如何阅读论文&quot;&gt;&lt;/a&gt;如何阅读论文&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;研一萌新, 最近在读论文的时候, 读到后半部分，前面讲的什么东西都已经忘完了, 不</summary>
      
    
    
    
    <category term="学术论文" scheme="http://okeyia.github.io/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="怎么读论文" scheme="http://okeyia.github.io/tags/%E6%80%8E%E4%B9%88%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>pinatrace</title>
    <link href="http://okeyia.github.io/2022/05/03/Pintool/"/>
    <id>http://okeyia.github.io/2022/05/03/Pintool/</id>
    <published>2022-05-03T01:35:30.000Z</published>
    <updated>2023-03-21T08:02:30.404Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-Inter-pin-使用简介"><a href="#一-Inter-pin-使用简介" class="headerlink" title="一 Inter pin 使用简介"></a>一 Inter pin 使用简介</h4><blockquote><p>其实在研一上学期，就接触pin了，但仅仅只停留在理论上，没有实践。本次主要使用pin来获取某一个段代码访问内存的trace。官网给出的examples中有一个pinatrace.cpp, 只能获取到<strong>整个代码的访问trace</strong>, 因此需要对pintrace.cpp做出一个更改。</p></blockquote><blockquote><p>现在pin版本已经更新到了pin 3.22, 下载链接:  <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html">Pin - A Binary Instrumentation Tool - Downloads</a></p></blockquote><blockquote><p>由于网上可以搜到的大多pintools工具都是几年前的,  因此提供一个旧版本的pin下载链接:  <a href="https://github.com/wangziqi2013/wangziqi2013.github.io/blob/master/static/pin-2.14.tar.gz">Pin 2.14 下载链接</a> <a href="http://software.intel.com/sites/landingpage/pintool/downloads/pin-3.5-97503-gac534ca30-gcc-linux.tar.gz">pin 3.5 下载链接</a> <a href="https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.7-97619-g0d0c92f4f-gcc-linux.tar.gz">pin 3.7 下载链接</a></p></blockquote><blockquote><p>用户手册: <a href="https://software.intel.com/sites/landingpage/pintool/docs/98547/Pin/html/index.html#BuildingInsideKit">Pin 3.22 User Guide</a></p></blockquote><h4 id="二-代码示例"><a href="#二-代码示例" class="headerlink" title="二 代码示例"></a>二 代码示例</h4><p>以下的代码演示了, 如何使用pin获取<strong>感兴趣部分</strong>的访存行为。</p><h5 id="2-1-pinatrace-cpp"><a href="#2-1-pinatrace-cpp" class="headerlink" title="2.1 pinatrace.cpp"></a>2.1 pinatrace.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pin.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CHAR * ROI_BEGIN = <span class="string">&quot;__app_roi_begin&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> CHAR * ROI_END = <span class="string">&quot;__app_roi_end&quot;</span>;</span><br><span class="line"></span><br><span class="line">FILE * trace;</span><br><span class="line"><span class="keyword">bool</span> isROI = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a memory read record</span></span><br><span class="line"><span class="function">VOID <span class="title">RecordMemRead</span><span class="params">(VOID * ip, VOID * addr, CHAR * rtn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return if not in ROI</span></span><br><span class="line">    <span class="keyword">if</span>(!isROI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Log memory access in CSV</span></span><br><span class="line">    <span class="comment">//fprintf(trace,&quot;%p,R,%p\n&quot;, ip, addr);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;%p\n&quot;</span>,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a memory write record</span></span><br><span class="line"><span class="function">VOID <span class="title">RecordMemWrite</span><span class="params">(VOID * ip, VOID * addr, CHAR * rtn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return if not in ROI</span></span><br><span class="line">    <span class="keyword">if</span>(!isROI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Log memory access in CSV</span></span><br><span class="line">    <span class="comment">//fprintf(trace,&quot;%p,W,%p\n&quot;, ip, addr);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;%p\n&quot;</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set ROI flag</span></span><br><span class="line"><span class="function">VOID <span class="title">StartROI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isROI = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set ROI flag</span></span><br><span class="line"><span class="function">VOID <span class="title">StopROI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isROI = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is called for every instruction and instruments reads and writes</span></span><br><span class="line"><span class="function">VOID <span class="title">Instruction</span><span class="params">(INS ins, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Instruments memory accesses using a predicated call, i.e.</span></span><br><span class="line">    <span class="comment">// the instrumentation is called iff the instruction will actually be executed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// On the IA-32 and Intel(R) 64 architectures conditional moves and REP</span></span><br><span class="line">    <span class="comment">// prefixed instructions appear as predicated instructions in Pin.</span></span><br><span class="line">    UINT32 memOperands = INS_MemoryOperandCount(ins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over each memory operand of the instruction.</span></span><br><span class="line">    <span class="keyword">for</span> (UINT32 memOp = <span class="number">0</span>; memOp &lt; memOperands; memOp++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get routine name if valid</span></span><br><span class="line">        <span class="keyword">const</span> CHAR * name = <span class="string">&quot;invalid&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(RTN_Valid(INS_Rtn(ins)))</span><br><span class="line">        &#123;</span><br><span class="line">            name = RTN_Name(INS_Rtn(ins)).c_str();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (INS_MemoryOperandIsRead(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            INS_InsertPredicatedCall(</span><br><span class="line">                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,</span><br><span class="line">                IARG_INST_PTR,</span><br><span class="line">                IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                IARG_ADDRINT, name,</span><br><span class="line">                IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Note that in some architectures a single memory operand can be</span></span><br><span class="line">        <span class="comment">// both read and written (for instance incl (%eax) on IA-32)</span></span><br><span class="line">        <span class="comment">// In that case we instrument it once for read and once for write.</span></span><br><span class="line">        <span class="keyword">if</span> (INS_MemoryOperandIsWritten(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            INS_InsertPredicatedCall(</span><br><span class="line">                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,</span><br><span class="line">                IARG_INST_PTR,</span><br><span class="line">                IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                IARG_ADDRINT, name,</span><br><span class="line">                IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pin calls this function every time a new rtn is executed</span></span><br><span class="line"><span class="function">VOID <span class="title">Routine</span><span class="params">(RTN rtn, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get routine name</span></span><br><span class="line">    <span class="keyword">const</span> CHAR * name = RTN_Name(rtn).c_str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,ROI_BEGIN) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Start tracing after ROI begin exec</span></span><br><span class="line">        RTN_Open(rtn);</span><br><span class="line">        RTN_InsertCall(rtn, IPOINT_AFTER, (AFUNPTR)StartROI, IARG_END);</span><br><span class="line">        RTN_Close(rtn);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name,ROI_END) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Stop tracing before ROI end exec</span></span><br><span class="line">        RTN_Open(rtn);</span><br><span class="line">        RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)StopROI, IARG_END);</span><br><span class="line">        RTN_Close(rtn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pin calls this function at the end</span></span><br><span class="line"><span class="function">VOID <span class="title">Fini</span><span class="params">(INT32 code, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fclose(trace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Print Help Message                                                    */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="function">INT32 <span class="title">Usage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIN_ERROR( <span class="string">&quot;This Pintool prints a trace of memory addresses\n&quot;</span></span><br><span class="line">              + KNOB_BASE::StringKnobSummary() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Main                                                                  */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize symbol table code, needed for rtn instrumentation</span></span><br><span class="line">    PIN_InitSymbols();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Usage</span></span><br><span class="line">    <span class="keyword">if</span> (PIN_Init(argc, argv)) <span class="keyword">return</span> Usage();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open trace file and write header</span></span><br><span class="line">    trace = fopen(<span class="string">&quot;roitrace.csv&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;pc,rw,addr,rtn\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add instrument functions</span></span><br><span class="line">    RTN_AddInstrumentFunction(Routine, <span class="number">0</span>);</span><br><span class="line">    INS_AddInstrumentFunction(Instruction, <span class="number">0</span>);</span><br><span class="line">    PIN_AddFiniFunction(Fini, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never returns</span></span><br><span class="line">    PIN_StartProgram();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改完pinatrace.cpp 后, 重新make, 生成pinatrace.so文件。</p></blockquote><h5 id="2-2-roi-h"><a href="#2-2-roi-h" class="headerlink" title="2.2 roi.h"></a>2.2 roi.h</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ROI_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _ROI_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* General Markers */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noinline)) __app_roi_begin()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noinline)) __app_roi_end()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="2-3-hello-world-cpp"><a href="#2-3-hello-world-cpp" class="headerlink" title="2.3 hello_world.cpp"></a>2.3 hello_world.cpp</h5><p><strong>注意</strong>: hello_world.cpp 中必须包含 <code>extern &quot;C&quot; &#123; #include &lt;roi.h&gt; &#125;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;roi.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __app_roi_begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;hello,world!\n&quot;</span>;</span><br><span class="line">    __app_roi_end();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;second line!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-编译链接"><a href="#2-4-编译链接" class="headerlink" title="2.4 编译链接"></a>2.4 编译链接</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对hello_world 进行编译, 此处-I.表示从当前目录寻找extern <span class="string">&quot;C&quot;</span> &#123;<span class="comment">#include &lt;roi.h&gt;&#125;中的roi.h。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I 头文件 例如xx.h， 寻找的顺序是：-I&#123;path&#125;–&gt;/usr/include–&gt;/usr/<span class="built_in">local</span>/include</span></span><br><span class="line">g++ -o hello_world hello_world.cpp -I.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">~/pin-3.21-bak/pin -t ~/pin-3.21-bak/source/tools/ManualExamples/obj-intel64/pinatrace.so -- ./hello_world</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">结果生成 roitrace.csv</span></span><br></pre></td></tr></table></figure><h3 id="三-参考链接："><a href="#三-参考链接：" class="headerlink" title="三 参考链接："></a>三 参考链接：</h3><ol><li><p><a href="https://github.com/vnaveen0/pin_tools">pin_tools</a></p></li><li><p><a href="https://stackoverflow.com/questions/32026456/how-can-i-specify-an-area-of-code-to-instrument-it-by-pintool/32029564#32029564">How can i specify an area of code to instrument it by pintool?</a></p></li><li><p><a href="https://bbs.pediy.com/thread-269711.htm">有毒的学Pin记录（一）</a></p></li><li><p><a href="http://brieflyx.me/2017/binary-analysis/intel-pin-intro/">Intel Pin 基本用法</a></p></li><li><p><a href="https://anhkgg.com/pin-use-note-function-analysis/">pin使用小记-函数分析</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一-Inter-pin-使用简介&quot;&gt;&lt;a href=&quot;#一-Inter-pin-使用简介&quot; class=&quot;headerlink&quot; title=&quot;一 Inter pin 使用简介&quot;&gt;&lt;/a&gt;一 Inter pin 使用简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;其</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="http://okeyia.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Gem5" scheme="http://okeyia.github.io/tags/Gem5/"/>
    
    <category term="pintools" scheme="http://okeyia.github.io/tags/pintools/"/>
    
    <category term="memtoryTrace" scheme="http://okeyia.github.io/tags/memtoryTrace/"/>
    
  </entry>
  
  <entry>
    <title>颈肩操</title>
    <link href="http://okeyia.github.io/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/"/>
    <id>http://okeyia.github.io/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/</id>
    <published>2022-04-17T07:30:36.000Z</published>
    <updated>2022-04-17T07:52:09.115Z</updated>
    
    <content type="html"><![CDATA[<h4 id="放松颈肩-环节疲劳"><a href="#放松颈肩-环节疲劳" class="headerlink" title="放松颈肩, 环节疲劳"></a>放松颈肩, 环节疲劳</h4><p>珍爱生命, 远离ICU, 经过本人测试, 本套颈肩操可以有效缓解颈部疲劳, 放在博客提醒自己。</p><h4 id="第一节-颈部捏按"><a href="#第一节-颈部捏按" class="headerlink" title="第一节 颈部捏按"></a>第一节 颈部捏按</h4><blockquote><p>3次为一组，连续捏按8组。</p><p>左右各8组，交替进行。</p><p>保持轻柔和缓，捏按力度，持续渗透。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153521407.png" class="" title="image-20220417153521407"><h4 id="第二节-左顾右盼"><a href="#第二节-左顾右盼" class="headerlink" title="第二节 左顾右盼"></a>第二节 左顾右盼</h4><blockquote><p>缓慢转向一侧，保持3秒钟。</p><p>左右各8组。</p><p>注意旋转要匀速和缓，切忌猛烈地转动</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153637390.png" class="" title="image-20220417153637390"><h4 id="第三节-前俯后仰"><a href="#第三节-前俯后仰" class="headerlink" title="第三节 前俯后仰"></a>第三节 前俯后仰</h4><blockquote><p>前后各自保持3秒钟。<br>重复做8次。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153737110.png" class="" title="image-20220417153737110"><h4 id="第四节-左右侧曲"><a href="#第四节-左右侧曲" class="headerlink" title="第四节 左右侧曲"></a>第四节 左右侧曲</h4><blockquote><p>左右到位后，各自坚持3秒。左右各8次.</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153845908.png" class="" title="image-20220417153845908"><h4 id="第五节-悬肩舒颈"><a href="#第五节-悬肩舒颈" class="headerlink" title="第五节 悬肩舒颈"></a>第五节 悬肩舒颈</h4><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153937510.png" class="" title="image-20220417153937510"><h4 id="第六节-头颈相抗"><a href="#第六节-头颈相抗" class="headerlink" title="第六节 头颈相抗"></a>第六节 头颈相抗</h4><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154028268.png" class="" title="image-20220417154028268"><h4 id="第七节-颈项争力"><a href="#第七节-颈项争力" class="headerlink" title="第七节 颈项争力"></a>第七节 颈项争力</h4><blockquote><p>左手置于胸前, 右手置于背后, 手掌向右平行推出, 颈部向左转动, 保持三秒钟.</p><p>再换右手, 重复八次。 </p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154105726.png" class="" title="image-20220417154105726"><h4 id="第八节-仰头忘掌"><a href="#第八节-仰头忘掌" class="headerlink" title="第八节 仰头忘掌"></a>第八节 仰头忘掌</h4><blockquote><p>仰视手背, 配合深呼吸, 重复八次。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154614780.png" class="" title="image-20220417154614780"><h4 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接:"></a>视频链接:</h4><p><a href="https://www.bilibili.com/video/BV1ci4y1S7en?spm_id_from=333.999.0.0">北汽颈肩操</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;放松颈肩-环节疲劳&quot;&gt;&lt;a href=&quot;#放松颈肩-环节疲劳&quot; class=&quot;headerlink&quot; title=&quot;放松颈肩, 环节疲劳&quot;&gt;&lt;/a&gt;放松颈肩, 环节疲劳&lt;/h4&gt;&lt;p&gt;珍爱生命, 远离ICU, 经过本人测试, 本套颈肩操可以有效缓解颈部疲劳, 放在</summary>
      
    
    
    
    
    <category term="放松自己" scheme="http://okeyia.github.io/tags/%E6%94%BE%E6%9D%BE%E8%87%AA%E5%B7%B1/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://okeyia.github.io/2022/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://okeyia.github.io/2022/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-04-15T12:11:17.000Z</published>
    <updated>2022-11-17T01:39:53.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是正则表达式-？"><a href="#什么是正则表达式-？" class="headerlink" title="什么是正则表达式 ？"></a>什么是正则表达式 ？</h2><blockquote><p>正则表达式是一种被用于从文本中检索符合某些特定模式的文本。</p></blockquote><p>正则表达式是从左到右来匹配一个字符串的。“Regular Expression”这个词太长了，我们通常使用它的缩写“regex”或者“regexp”。<br>正则表达式可以被用来替换字符串中的文本、验证表单、基于模式匹配从一个字符串中提取字符串等等。</p><p>想象一下，您正在编写应用程序，并且您希望在用户选择用户名时设置规则。我们希望用户名可以包含字母，数字，下划线和连字符。<br>为了让它看起来不丑，我们还想限制用户名中的字符数量。这时我们可以使用以下正则表达式来验证用户名：</p><p align="center"><img src="https://i.imgur.com/UrDb9qc.png" alt="Regular expression"></p><p>上面这个正则表达式可以匹配 <code>john_doe</code>，<code>jo-hn_doe</code> 和 <code>john12_as</code>。但是它不能匹配 <code>Jo</code>，因为该字符串里面包含大写字符，并且它太短了。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">基本匹配</a></li><li><a href="#2-%E5%85%83%E5%AD%97%E7%AC%A6">元字符</a><ul><li><a href="#21-%E8%8B%B1%E6%96%87%E5%8F%A5%E5%8F%B7">英文句号</a></li><li><a href="#22-%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a><ul><li><a href="#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86">否定字符集</a></li></ul></li><li><a href="#23-%E9%87%8D%E5%A4%8D">重复</a><ul><li><a href="#231-%E6%98%9F%E5%8F%B7">星号</a></li><li><a href="#232-%E5%8A%A0%E5%8F%B7">加号</a></li><li><a href="#233-%E9%97%AE%E5%8F%B7">问号</a></li></ul></li><li><a href="#24-%E8%8A%B1%E6%8B%AC%E5%8F%B7">花括号</a></li><li><a href="#25-%E5%AD%97%E7%AC%A6%E7%BB%84">字符组</a></li><li><a href="#26-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">分支结构</a></li><li><a href="#27-%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">转义特殊字符</a></li><li><a href="#28-%E5%AE%9A%E4%BD%8D%E7%AC%A6">定位符</a><ul><li><a href="#281-%E6%8F%92%E5%85%A5%E7%AC%A6%E5%8F%B7">插入符号</a></li><li><a href="#282-%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7">美元符号</a></li></ul></li></ul></li><li><a href="#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">简写字符集</a></li><li><a href="#4-%E6%96%AD%E8%A8%80">断言</a><ul><li><a href="#41-%E6%AD%A3%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">正向先行断言</a></li><li><a href="#42-%E8%B4%9F%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">负向先行断言</a></li><li><a href="#43-%E6%AD%A3%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">正向后行断言</a></li><li><a href="#44-%E8%B4%9F%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">负向后行断言</a></li></ul></li><li><a href="#5-%E6%A0%87%E8%AE%B0">标记</a><ul><li><a href="#51-%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99">不区分大小写</a></li><li><a href="#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2">全局搜索</a></li><li><a href="#53-%E5%A4%9A%E8%A1%8C%E5%8C%B9%E9%85%8D">多行匹配</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">常用正则表达式</a></li></ul><h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式只是我们用于在文本中检索字符串的模式。例如正则表达式 <code>cat</code>，表示：字母 <code>c</code> 后面跟着一个字母 <code>a</code>，再后面跟着一个字母 <code>t</code>。</p><pre>"cat" => The <a href="#learn-regex"><strong>cat</strong></a> sat on the mat</pre><p>正则表达式 <code>123</code> 会匹配字符串“123”。通过将正则表达式中的每个字符逐个与要匹配的字符串中的每个字符进行比较，来完成正则匹配。<br>正则表达式通常区分大小写，因此正则表达式 <code>Cat</code> 与字符串“cat”不匹配。</p><pre>"Cat" => The cat sat on the <a href="#learn-regex"><strong>Cat</strong></a></pre><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符在写在方括号内时有特殊含义。<br>元字符如下：</p><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配除换行符以外的任意字符。</td></tr><tr><td align="center">[ ]</td><td>字符类，匹配方括号中包含的任意字符。</td></tr><tr><td align="center">[^ ]</td><td>否定字符类。匹配方括号中不包含的任意字符</td></tr><tr><td align="center">*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td align="center">+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td align="center">?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr><tr><td align="center">{n,m}</td><td>花括号，匹配前面字符至少 n 次，但是不超过 m 次。</td></tr><tr><td align="center">(xyz)</td><td>字符组，按照确切的顺序匹配字符 xyz。</td></tr><tr><td align="center">&#124;</td><td>分支结构，匹配符号之前的字符或后面的字符。</td></tr><tr><td align="center">&#92;</td><td>转义符，它可以还原元字符原来的含义，允许你匹配保留字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ \ &#124;</code></td></tr><tr><td align="center">^</td><td>匹配行的开始</td></tr><tr><td align="center">$</td><td>匹配行的结束</td></tr></tbody></table><h2 id="2-1-英文句号"><a href="#2-1-英文句号" class="headerlink" title="2.1 英文句号"></a>2.1 英文句号</h2><p>英文句号 <code>.</code> 是元字符的最简单的例子。元字符 <code>.</code> 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 <code>.ar</code>，表示：任意字符后面跟着一个字母 <code>a</code>，<br>再后面跟着一个字母 <code>r</code>。</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也称为字符类。方括号被用于指定字符集。使用字符集内的连字符来指定字符范围。方括号内的字符范围的顺序并不重要。<br>例如正则表达式 <code>[Tt]he</code>，表示：大写 <code>T</code> 或小写 <code>t</code> ，后跟字母 <code>h</code>，再后跟字母 <code>e</code>。</p><pre>"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p>然而，字符集中的英文句号表示它字面的含义。正则表达式 <code>ar[.]</code>，表示小写字母 <code>a</code>，后面跟着一个字母 <code>r</code>，再后面跟着一个英文句号 <code>.</code> 字符。</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a></pre><h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说插入字符 <code>^</code> 表示一个字符串的开始，但是当它在方括号内出现时，它会取消字符集。例如正则表达式 <code>[^c]ar</code>，表示：除了字母 <code>c</code> 以外的任意字符，后面跟着字符 <code>a</code>，<br>再后面跟着一个字母 <code>r</code>。</p><pre>"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-3-重复"><a href="#2-3-重复" class="headerlink" title="2.3 重复"></a>2.3 重复</h2><p>以下元字符 <code>+</code>，<code>*</code> 或 <code>?</code> 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。</p><h3 id="2-3-1-星号"><a href="#2-3-1-星号" class="headerlink" title="2.3.1 星号"></a>2.3.1 星号</h3><p>星号 <code>*</code> 表示匹配上一个匹配规则零次或多次。正则表达式 <code>a*</code> 表示小写字母 <code>a</code> 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。<br>例如正则表达式 <code>[a-z]*</code>，表示：一行中可以包含任意数量的小写字母。</p><pre>"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.</pre><p>星号 <code>*</code> 可以与元符号 <code>.</code> 用在一起，用来匹配任意字符串 <code>.*</code>。星号 <code>*</code> 可以与空格符 <code>\s</code> 一起使用，用来匹配一串空格字符。<br>例如正则表达式 <code>\s*cat\s*</code>，表示：零个或多个空格，后面跟小写字母 <code>c</code>，再后面跟小写字母 <code>a</code>，再在后面跟小写字母 <code>t</code>，后面再跟零个或多个空格。</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex"><strong>cat</strong></a>.</pre><h3 id="2-3-2-加号"><a href="#2-3-2-加号" class="headerlink" title="2.3.2 加号"></a>2.3.2 加号</h3><p>加号 <code>+</code> 表示匹配上一个字符一次或多次。例如正则表达式 <code>c.+t</code>，表示：一个小写字母 <code>c</code>，后跟任意数量的字符，后跟小写字母 <code>t</code>。</p><pre>"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.</pre><h3 id="2-3-3-问号"><a href="#2-3-3-问号" class="headerlink" title="2.3.3 问号"></a>2.3.3 问号</h3><p>在正则表达式中，元字符 <code>?</code> 用来表示前一个字符是可选的。该符号匹配前一个字符零次或一次。<br>例如正则表达式 <code>[T]?he</code>，表示：可选的大写字母 <code>T</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><h2 id="2-4-花括号"><a href="#2-4-花括号" class="headerlink" title="2.4 花括号"></a>2.4 花括号</h2><p>在正则表达式中花括号（也被称为量词？）用于指定字符或一组字符可以重复的次数。例如正则表达式 <code>[0-9]&#123;2,3&#125;</code>，表示：匹配至少 2 位数字但不超过 3 位（0 到 9 范围内的字符）。</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p>我们可以省略第二个数字。例如正则表达式 <code>[0-9]&#123;2,&#125;</code>，表示：匹配 2 个或更多个数字。如果我们也删除逗号，则正则表达式 <code>[0-9]&#123;2&#125;</code>，表示：匹配正好为 2 位数的数字。</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><pre>"[0-9]{2}" => The number was 9.<a href="#learn-regex"><strong>99</strong></a><a href="#learn-regex"><strong>97</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><h2 id="2-5-字符组"><a href="#2-5-字符组" class="headerlink" title="2.5 字符组"></a>2.5 字符组</h2><p>字符组是一组写在圆括号内的子模式 <code>(...)</code>。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重复前一个字符。<br>但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。<br>例如正则表达式 <code>(ab)*</code> 表示匹配零个或多个的字符串“ab”。我们还可以在字符组中使用元字符 <code>|</code>。例如正则表达式 <code>(c|g|p)ar</code>，表示：小写字母 <code>c</code>、<code>g</code> 或 <code>p</code> 后面跟字母 <code>a</code>，后跟字母 <code>r</code>。</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-6-分支结构"><a href="#2-6-分支结构" class="headerlink" title="2.6 分支结构"></a>2.6 分支结构</h2><p>在正则表达式中垂直条 <code>|</code> 用来定义分支结构，分支结构就像多个表达式之间的条件。现在你可能认为这个字符集和分支结构的工作方式一样。<br>但是字符集和分支结构巨大的区别是字符集只在字符级别上有作用，然而分支结构在表达式级别上依然可以使用。<br>例如正则表达式 <code>(T|t)he|car</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>，或匹配小写字母 <code>c</code>，后跟小写字母 <code>a</code>，后跟小写字母 <code>r</code>。</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><h2 id="2-7-转义特殊字符"><a href="#2-7-转义特殊字符" class="headerlink" title="2.7 转义特殊字符"></a>2.7 转义特殊字符</h2><p>正则表达式中使用反斜杠 <code>\</code> 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code>。在特殊字符前面加 <code>\</code>，就可以使用它来做匹配字符。<br>例如正则表达式 <code>.</code> 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 <code>.</code> 字符，正则表达式 <code>(f|c|m)at\.?</code>，表示：小写字母 <code>f</code>、<code>c</code> 或者 <code>m</code> 后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟可选的 <code>.</code> 字符。</p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h2 id="2-8-定位符"><a href="#2-8-定位符" class="headerlink" title="2.8 定位符"></a>2.8 定位符</h2><p>在正则表达式中，为了检查匹配符号是否是起始符号或结尾符号，我们使用定位符。<br>定位符有两种类型：第一种类型是 <code>^</code> 检查匹配字符是否是起始字符，第二种类型是 <code>$</code>，它检查匹配字符是否是输入字符串的最后一个字符。</p><h3 id="2-8-1-插入符号"><a href="#2-8-1-插入符号" class="headerlink" title="2.8.1 插入符号"></a>2.8.1 插入符号</h3><p>插入符号 <code>^</code> 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 <code>^a</code>（如果 a 是起始符号）匹配字符串 <code>abc</code>，它会匹配到 <code>a</code>。<br>但是如果我们使用正则表达式 <code>^b</code>，它是匹配不到任何东西的，因为在字符串 <code>abc</code> 中“b”不是起始字符。<br>让我们来看看另一个正则表达式 <code>^(T|t)he</code>，这表示：大写字母 <code>T</code> 或小写字母 <code>t</code> 是输入字符串的起始符号，后面跟着小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><h3 id="2-8-2-美元符号"><a href="#2-8-2-美元符号" class="headerlink" title="2.8.2 美元符号"></a>2.8.2 美元符号</h3><p>美元 <code>$</code> 符号用于检查匹配字符是否是输入字符串的最后一个字符。例如正则表达式 <code>(at\.)$</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟一个 <code>.</code> 字符，且这个匹配器必须是字符串的结尾。</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><pre>"(at\.)$" => The fat cat sat on the m<a href="#learn-regex"><strong>at.</strong></a></pre><h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下：</p><table><thead><tr><th align="center">简写</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td align="center">\w</td><td>匹配所有字母和数字的字符：<code>[a-zA-Z0-9_]</code></td></tr><tr><td align="center">\W</td><td>匹配非字母和数字的字符：<code>[^\w]</code></td></tr><tr><td align="center">\d</td><td>匹配数字：<code>[0-9]</code></td></tr><tr><td align="center">\D</td><td>匹配非数字：<code>[^\d]</code></td></tr><tr><td align="center">\s</td><td>匹配空格符：<code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td align="center">\S</td><td>匹配非空格符：<code>[^\s]</code></td></tr></tbody></table><h2 id="4-断言"><a href="#4-断言" class="headerlink" title="4. 断言"></a>4. 断言</h2><p>后行断言和先行断言有时候被称为断言，它们是特殊类型的 <strong><em>非捕获组</em></strong>（用于匹配模式，但不包括在匹配列表中）。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。<br>例如我们想获取输入字符串 <code>$4.44 and $10.88</code> 中带有前缀 <code>$</code> 的所有数字。我们可以使用这个正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>，表示：获取包含 <code>.</code> 字符且前缀为 <code>$</code> 的所有数字。<br>以下是正则表达式中使用的断言：</p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center">?=</td><td>正向先行断言</td></tr><tr><td align="center">?!</td><td>负向先行断言</td></tr><tr><td align="center">?&lt;=</td><td>正向后行断言</td></tr><tr><td align="center">?&lt;!</td><td>负向后行断言</td></tr></tbody></table><h3 id="4-1-正向先行断言"><a href="#4-1-正向先行断言" class="headerlink" title="4.1 正向先行断言"></a>4.1 正向先行断言</h3><p>正向先行断言认为第一部分的表达式的后面必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。<br>要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 <code>(?=...)</code>。先行断言表达式写在括号中的等号后面。<br>例如正则表达式 <code>(T|t)he(?=\sfat)</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟字母 <code>h</code>，后跟字母 <code>e</code>。<br>在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配后面跟着 <code>fat</code> 的 <code>The</code> 或 <code>the</code>。</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><h3 id="4-2-负向先行断言"><a href="#4-2-负向先行断言" class="headerlink" title="4.2 负向先行断言"></a>4.2 负向先行断言</h3><p>当我们需要指定第一部分表达式的后面不跟随某一内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样，<br>唯一的区别在于我们使用否定符号 <code>!</code> 而不是等号 <code>=</code>，例如 <code>(?!...)</code>。<br>我们来看看下面的正则表达式 <code>(T|t)he(?!\sfat)</code>，表示：从输入字符串中获取全部 <code>The</code> 或者 <code>the</code> 且不匹配 <code>fat</code> 前面加上一个空格字符。</p><pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h3 id="4-3-正向后行断言"><a href="#4-3-正向后行断言" class="headerlink" title="4.3 正向后行断言"></a>4.3 正向后行断言</h3><p>正向后行断言用于获取跟随在特定模式之后的所有匹配内容。正向后行断言表示为 <code>(?&lt;=...)</code>。例如正则表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code>，表示：从输入字符串中获取在单词 <code>The</code> 或 <code>the</code> 之后的所有 <code>fat</code> 和 <code>mat</code> 单词。</p><pre>"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h3 id="4-4-负向后行断言"><a href="#4-4-负向后行断言" class="headerlink" title="4.4 负向后行断言"></a>4.4 负向后行断言</h3><p>负向后行断言是用于获取不跟随在特定模式之后的所有匹配的内容。负向后行断言表示为 <code>(?&lt;!...)</code>。例如正则表达式 <code>(?&lt;!(T|t)he\s)(cat)</code>，表示：在输入字符中获取所有不在 <code>The</code> 或 <code>the</code> 之后的所有单词 <code>cat</code>。</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><h2 id="5-标记"><a href="#5-标记" class="headerlink" title="5. 标记"></a>5. 标记</h2><p>标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。</p><table><thead><tr><th align="center">标记</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>不区分大小写：将匹配设置为不区分大小写。</td></tr><tr><td align="center">g</td><td>全局搜索：搜索整个输入字符串中的所有匹配。</td></tr><tr><td align="center">m</td><td>多行匹配：会匹配输入字符串每一行。</td></tr></tbody></table><h3 id="5-1-不区分大小写"><a href="#5-1-不区分大小写" class="headerlink" title="5.1 不区分大小写"></a>5.1 不区分大小写</h3><p><code>i</code> 修饰符用于执行不区分大小写匹配。例如正则表达式 <code>/The/gi</code>，表示：大写字母 <code>T</code>，后跟小写字母 <code>h</code>，后跟字母 <code>e</code>。<br>但是在正则匹配结束时 <code>i</code> 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 <code>g</code> 标记，因为我们要在整个输入字符串中搜索匹配。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h3 id="5-2-全局搜索"><a href="#5-2-全局搜索" class="headerlink" title="5.2 全局搜索"></a>5.2 全局搜索</h3><p><code>g</code> 修饰符用于执行全局匹配（会查找所有匹配，不会在查找到第一个匹配时就停止）。<br>例如正则表达式 <code>/.(at)/g</code>，表示：除换行符之外的任意字符，后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>。<br>因为我们在正则表达式的末尾使用了 <code>g</code> 标记，它会从整个输入字符串中找到每个匹配项。</p><pre>".(at)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h3 id="5-3-多行匹配"><a href="#5-3-多行匹配" class="headerlink" title="5.3 多行匹配"></a>5.3 多行匹配</h3><p><code>m</code> 修饰符被用来执行多行的匹配。正如我们前面讨论过的 <code>(^, $)</code>，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 <code>m</code> 修饰符。<br>例如正则表达式 <code>/at(.)?$/gm</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，匹配除了换行符以外任意字符零次或一次。而且因为 <code>m</code> 标记，现在正则表达式引擎匹配字符串中每一行的末尾。</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre><pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ul><li><strong>正整数</strong>：<code>^\d+$</code></li><li><strong>负整数</strong>：<code>^-\d+$</code></li><li><strong>电话号码</strong>：<code>^+?[\d\s]&#123;3,&#125;$</code></li><li><strong>电话代码</strong>：<code>^+?[\d\s]+(?[\d\s]&#123;10,&#125;$</code></li><li><strong>整数</strong>：<code>^-?\d+$</code></li><li><strong>用户名</strong>：<code>^[\w\d_.]&#123;4,16&#125;$</code></li><li><strong>字母数字字符</strong>：<code>^[a-zA-Z0-9]*$</code></li><li><strong>带空格的字母数字字符</strong>：<code>^[a-zA-Z0-9 ]*$</code></li><li><strong>密码</strong>：<code>^(?=^.&#123;6,&#125;$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li><li><strong>电子邮件</strong>：<code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;)*$</code></li><li><strong>IPv4 地址</strong>：<code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li><li><strong>小写字母</strong>：<code>^([a-z])*$</code></li><li><strong>大写字母</strong>：<code>^([A-Z])*$</code></li><li><strong>网址</strong>：<code>^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]])&#123;2,4&#125;([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$</code></li><li><strong>VISA 信用卡号码</strong>：<code>^(4[0-9]&#123;12&#125;(?:[0-9]&#123;3&#125;)?)*$</code></li><li><strong>日期（MM/DD/YYYY）</strong>：<code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]&#123;2&#125;$</code></li><li><strong>日期（YYYY/MM/DD）</strong>：<code>^(19|20)?[0-9]&#123;2&#125;[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li><li><strong>万事达信用卡号码</strong>：<code>^(5[1-5][0-9]&#123;14&#125;)*$</code></li></ul><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>Report issues</li><li>Open pull request with improvements</li><li>Spread the word </li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT © <a href="mailto:ziishaned@gmail.com">Zeeshan Ahmed</a></p><hr><p><strong><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-">⬆ top</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是正则表达式-？&quot;&gt;&lt;a href=&quot;#什么是正则表达式-？&quot; class=&quot;headerlink&quot; title=&quot;什么是正则表达式 ？&quot;&gt;&lt;/a&gt;什么是正则表达式 ？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;正则表达式是一种被用于从文本中检索符合某些特定模式</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Overview of DRAMs</title>
    <link href="http://okeyia.github.io/2022/04/15/DRAM%E6%80%BB%E7%BB%93/"/>
    <id>http://okeyia.github.io/2022/04/15/DRAM%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-15T12:05:15.000Z</published>
    <updated>2022-04-25T13:46:46.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Overview-of-DRAMs"><a href="#Overview-of-DRAMs" class="headerlink" title="Overview of DRAMs"></a><strong>Overview of DRAMs</strong></h3><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415150456153.png" class="" title="image-20220415150456153"><blockquote><p>DRAM子系统是一个相对复杂的整体的一部分。此图显示了一个双向多处理器，每个处理器都有自己的专用辅助缓存。与本章最相关的部分以深灰色阴影显示：CPU、内存控制器和单个DRAM</p></blockquote><h3 id="DRAM-Basics-Internals-Operation"><a href="#DRAM-Basics-Internals-Operation" class="headerlink" title="DRAM Basics: Internals, Operation"></a>DRAM Basics: Internals, Operation</h3><p>  <strong>DRAM</strong>: A random-access memory (RAM) that uses  a single transistor-capacitor(晶体管电容器) pair for each bit .  下图显示了DRAM内部存储单元的电路: </p><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415151328606.png" class="" title="image-20220415151328606"><p>DRAM内部的组织。DRAM内存阵列是一个由存储单元组成的网格，其中一行和一列的每个交叉点存储一位数据. </p><blockquote><p>This circuit is  dynamic because the capacitors storing electrons  are not perfect devices, and their eventual leakage  requires that, to retain information stored there, each  capacitor in the DRAM must be periodically refreshed (i.e. , read and rewritten)</p></blockquote><blockquote><p>Each DRAM die(芯片) contains one or more memory arrays, rectangular grids of storage cells with each cell  holding one bit of data.  By identifying the intersection of a row  and a column (by specifying a row address and a column address to the DRAM), a memory controller can  access an individual storage cell inside a DRAM chip  so as to read or write the data held there</p></blockquote><blockquote><p>the capacitor lies at the intersection  of a wordline and a bitline; <strong>it is connected to the bitline through a transistor controlled by the wordline</strong>.  A transistor is, among other things, a switch, and  when the voltage on a wordline goes high, all of the  transistors attached to that wordline become closed  switches (turned on), connecting their respective  capacitors to the associated bitlines. The capacitors at each intersection of wordline and bitline are  extremely small and hold a number of electrons that  are miniuscule relative(相对较小的) to the physical characteristics  of those bitlines.  </p></blockquote><blockquote><p>The capacitors at each intersection of wordline and bitline are  extremely small and hold a number of electrons that  are miniuscule relative to the physical characteristics  of those bitlines. Therefore, special circuits called  sense amplifiers are used to detect the values stored  on the capacitors when those capacitors become  connected to their associated bitlines. </p><p><strong>The sense  amplifiers first precharge the bitlines to a voltage level  that is halfway between logic level 0 and logic level 1.</strong>  When the capacitors are later connected to the bitlines through the transistors, the capacitors <strong>change  the voltage levels on those bitlines</strong> very slightly(轻微地). The  sense amplifiers detect the minute changes and pull the bitline voltages all the way to logic level 0 or 1.  Bringing the voltage on the bitlines to fully high or  fully low, as opposed to the precharged state between  high and low, actually recharges the capacitors as  long as the transistors remain on(连通). </p></blockquote><h4 id="Multiple-Memory-Arrays"><a href="#Multiple-Memory-Arrays" class="headerlink" title="Multiple Memory Arrays"></a>Multiple Memory Arrays</h4><blockquote><p> If the memory arrays  are designed to act in unison, they operate as a unit,  and the memory chip typically transmits or receives  a number of bits <strong>equal to</strong> the number of arrays each time the memory controller accesses the DRAM.</p></blockquote><p>For  example, in a simple organization, a x4 DRAM (pronounced “by four”) indicates that the DRAM has at  least <strong>four memory arrays</strong> and that a column width is  4 bits (each column read or write transmits 4 bits of  data). In a x4 DRAM part, four arrays each read 1 data  bit in unison, and the part sends out 4 bits of data  each time the memory controller makes a column  read request.</p><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415153809797.png" class="" title="image-20220415153809797"><p>NOTICE:   <strong>each of the DRAM illustrations in Figure  represents multiple arrays but a single bank. Each set of memory arrays that operates independently of other  sets is referred to as a bank, not an array .</strong></p><h4 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h4><blockquote><p>Because a system can have multiple DIMMs, each  of which can be thought of as an independent bank,  and the DRAM devices(内存颗粒) on each DIMM can implement internally multiple independent banks, the  word “rank” was introduced to distinguish DIMM-level independent operation versus(和) internal-bank-level independent operation. </p></blockquote><blockquote><p>A system is composed of potentially many  independent DIMMs. <strong>Each DIMM may contain one  or more independent ranks</strong>. Each rank is a set of  DRAM devices that operate in unison, and internally  each of these DRAM devices implements one or more  independent banks. Finally, <strong>each bank is composed  of slaved memory arrays</strong>, where the number of arrays  is equal to the data width of the DRAM part (i.e., a x4  part has four slaved arrays per bank)</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415155638103.png" class="" title="image-20220415155638103"><center>DIMMs, ranks, banks, and arrays </center><hr><h4 id="Memory-controller-and-Memory-modules"><a href="#Memory-controller-and-Memory-modules" class="headerlink" title="Memory controller and Memory modules"></a>Memory controller and Memory modules</h4><blockquote><p>The busses in a JEDEC-style organization are classified by their function and organization into data,  address, control, and chip-select busses. </p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415161510722.png" class="" title="image-20220415161510722"><center>a memory controller and two memory modules with a 16-bit data bus and an 8-bit address and command bus</center><blockquote><p>The data bus that transmits data to and from  the DRAMs is relatively wide. It is often 64 bits wide,  and it can be much wider in high-performance systems. A dedicated address bus carries row and column addresses to the DRAMs, and its width grows  with the physical storage on a DRAM device (typical  widths today are about 15 bits). A control bus is composed of the row and column strobes(选通), output enable,  clock, clock enable, and other related signals. These  signals are similar to the address-bus signals in that  they all connect from the memory controller to every  DRAM in the system. Finally, there is a chip-select  network that connects from the memory controller  to every DRAM in a rank (a separately addressable  set of DRAMs). </p></blockquote><h4 id="the-chip-select-bus"><a href="#the-chip-select-bus" class="headerlink" title="the chip-select bus"></a>the chip-select bus</h4><blockquote><p>The chip-select bus contains a separate wire(线路) for every rank of DRAM in  the system.  The chip-select signal passes over a wire  unique to each small set of DRAMs and enables or  disables the DRAMs in that rank so that they, respectively, either handle the request currently on the bus  or ignore the request currently on the bus. Thus, <strong>only  the DRAMs to which the request is directed handle  the request</strong>. Even though all DRAMs in the system  are connected to the same address and control busses and could, in theory, all respond to the same  request at the same time, the chip-select bus prevents this from happening. </p></blockquote><h4 id="the-Steps-of-a-DRAM-Read"><a href="#the-Steps-of-a-DRAM-Read" class="headerlink" title="the Steps of a DRAM  Read"></a>the Steps of a DRAM  Read</h4><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415164647716.png" class="" title="image-20220415164647716"><center> System organization and the steps of a DRAM  read </center><blockquote><p>As mentioned previously, a DRAM device connects indirectly to a microprocessor through a  memory controller; the microprocessor connects  to the memory controller through some form of  network (bus, point-to-point, crossbar, etc.); and  the memory controller connects to the DRAM  through another network (bus, point-to-point, etc.).  </p></blockquote><blockquote><p>Figure also illustrates the steps of a typical  DRAM read operation. After ordering and queueing  requests, the microprocessor sends a given request  to the memory controller. Once the request arrives at  the memory controller, it is queued until the DRAM is  ready and all previous and/or higher priority requests  have been handled. The memory controller’s interface to the DRAM is relatively complex (compared  to that of an SRAM, for instance); the row-address  strobe (RAS) and column-address strobe (CAS) components are shown in detail in next Figure. </p></blockquote><blockquote><p>The memory controller must decompose the provided data address into components that identify the  appropriate rank within the memory system, the bank  within that rank, and the row and column inside the  identified bank. The components identifying the row  and column are called the row address and the column address. <strong>The bank identifier is typically one or  more address bits</strong>. The rank number ends up causing  a chip-select signal to be sent out over a single one of  the separate chip-select lines. </p></blockquote><h4 id="the-Bitlines-Be-Precharged"><a href="#the-Bitlines-Be-Precharged" class="headerlink" title="the Bitlines Be Precharged"></a>the Bitlines Be Precharged</h4><blockquote><p>Once the rank, bank, and row are identified, the  bitlines in the appropriate bank must be precharged (set to a logic level halfway between 0 and 1). Once  the appropriate bank has been precharged, <strong>the second step</strong> is to activate the appropriate row inside the  identified rank and bank by setting the chip-select  signal to activate the set of DRAMs comprising the desired bank, sending the row address and bank  identifier over the address bus, and signaling the  DRAM’s  RAS pin (row-address strobe—the bar indicates that the signal is active when it is low). </p><p>This tells  the DRAM to <strong>send an entire row of data (thousands  of bits) into the DRAM’s sense amplifiers</strong> (circuits  that detect and amplify the tiny logic signals represented by the electric charges in the row’s storage  cells). This typically takes a few tens of nanoseconds,  and the step may have already been done (the row  or page could already be open or activated, meaning  that the sense amps might already have valid data in  them). </p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415165940565.png" class="" title="image-20220415165940565"><center> The multi-phase DRAM-access protocol. The row access drives a DRAM page onto the bitlines to be sensed by the  sense amps. The column address drives a subset of the DRAM page onto the bus (e.g., 4 bits).</center><p>NOTICE: separately transmitted row and  column addresses</p><blockquote><p>Once the sense amps have recovered the values,  and the bitlines are pulled to the appropriate logic  levels, the memory controller <strong>performs the last step</strong>,  which is to read the column (column being the name  given to the data subset of the row that is desired),  by setting the chip-select signal to activate the set of  DRAMs comprising the desired bank, sending the  column address and bank identifier over the address  bus, and signaling the DRAM’s  CAS pin (column address strobe—like  RAS , the bar indicates that it is active when low).  </p><p>This causes only a few select bits in the sense amplifiers to be connected to the output  drivers, where they will be driven onto the data bus.  Reading the column data takes on the order of tens of  nanoseconds. When the memory controller receives  the data, it forwards the data to the microprocessor. </p></blockquote><h4 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h4><blockquote><p>A clock transmits a continuous signal with regular  intervals of “high” and “low” values. It is usually illustrated as a square wave or semi-square wave with each  period identical to the next, as shown in Figure 7.9. The  upward portion of the square wave is called the positive  or rising edge of the clock, and the downward portion  of the square wave is called the negative or falling edge of the clock. The primary clock in a computer system is  called the system clock or global clock, and it typically  resides on the motherboard (the PCB that contains the  microprocessor and memory bus). The system clock  drives the microprocessor and memory controller and  many of the associated peripheral devices directly. If  the clock drives the DRAMs directly, the DRAMs are  called synchronous DRAMs. If the clock does not drive  the DRAMs directly, the DRAMs are called asynchronous DRAMs. In a synchronous DRAM, steps internal  to the DRAM happen in time with one or more edges  of this clock. In an asynchronous DRAM, operative  steps internal to the DRAM happen when the memory controller commands the DRAM to act, and those  commands typically happen in time with one or more  edges of the system clock.</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415190728890.png" class="" title="image-20220415190728890"><center> Example clock signals</center><blockquote><p>Clocks are typically shown as square waves (bottom) or sort of square waves (top). They  repeat ad infinitum, and the repeating shape is called a clock cycle. The two clocks pictured above have the same frequency—the  number of cycles in a given time period</p></blockquote><h3 id="DRAM-中文"><a href="#DRAM-中文" class="headerlink" title="DRAM 中文"></a>DRAM 中文</h3><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/Simplified-topology-of-DRAM-organization.png" class="" title="Simplified-topology-of-DRAM-organization"><p>影响DRAM的性能:</p><ul><li>内存容量</li><li>内存的延时周期</li><li>内存的带宽</li></ul><h4 id="内存带宽"><a href="#内存带宽" class="headerlink" title="内存带宽"></a>内存带宽</h4><p>内存带宽的影响是内存中现存的非常严重的问题，而影响内存带宽的主要因素是 行冲突</p><p>地址层级如下:</p><ol><li>通道（Channel） 通道是 DRAM 内存系统结构中最高的级别。独立内存控制器之间不同通道的运 行是没限制的。为了更优化的性能设计，连续的存取指令在缓存层已经被映射到不同 的通道了。</li><li>排（Rank） 排是通道的下一层，DRAM 的存取是在同一个通道的不同排之间也是可以并行 运行的</li><li>体（Bank）类似于连续的存取指令作用在不同的排上，当连续的指令作用在同一个排的不同 体时，DRAM 的内存系统仍然会有并行运行的存在。对于现在的 DRAM 设备而言， 将连续的存取指令通过调度方式分配到同一个排的不同体上，要比分配到同一个通道 的不同排上更加高效，因为这样不需要多余的周期来进行数据总线上的转换。</li><li>行（Row）在通用 DRAM 内存系统中，每个体在执行时，仅能激活（Active）一个行，当 有连续的指令通过调度映射到同一个体的不同行时，需要将第一个行进行预充电操作 （Precharge），再对第二个行进行激活操作，才能顺利进行连续指令的运行。这样做 便会造成大量的延迟，同时伴随的还有行冲突的数量会增加。想要降低行冲突出现的 概率，需要通过地址映射将连续的指令映射到同一个体的同一个行上面，这样行命中 的比例变化提升很多。从而能够有效的提升 DRAM 的性能</li><li>列（Column）当连续的指令作用在同一个体的同一个行时，此时不需要预充电操作，在获取数 据时，根据时间局部性和空间局部性 ，内存控制器会把整个行的数据都取出来放在 敏感放大器上。所以，第二个指令所映射的列也会以极高的效率获得。</li></ol><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410095244676.png" class="" title="image-20220410095244676"><p>地址映射不单单是内存中的地址翻译，它是连接着处理器、内存控制器和内存的 重要桥梁。因为地址在计算机系统中不同模块传输的状态不同，有物理地址和逻辑地 址，所以，需要地址映射来进行合理的转化。</p><h4 id="虚拟地址与物理地址"><a href="#虚拟地址与物理地址" class="headerlink" title="虚拟地址与物理地址"></a>虚拟地址与物理地址</h4><blockquote><p>虚拟地址（Virtual Address） 如果 CPU 启用了内存管理单元（Memory Management Unit，又称 MMU），CPU 核发出的地址将被内存管理单元截获，从 CPU 传输到内存管理单元的地址称为虚拟 地址(Virtual Address，简称 VA</p></blockquote><blockquote><p>物理地址（Physical Address）： 如果中央处理器不存在内存管理单元，或者未启用，则其核在获取指令或者访存 时发出的地址将被直接传到 CPU 的外部地址引脚上，被内存芯片接受，则称为物理 地址（Physical Address）。 内存管理单元将该地址译成另外地址发到 CPU 的外部地址引脚上，便意味着将 虚拟地址转化成了物理地址。内存管理单元是以页（Page）为单位的，对于 32 位 CPU 而言，通常一页为 4K。例如，虚拟地址 0xb700 1000<del>0xb700 1fff 是一个页，可能被 MMU 映射到物理地址 0x2000</del>0x2fff，物理内存中的一个物理页面也称为一个页框 (Page Frame)。 当内存控制器将虚拟地址转化成能够索引到具体 DRAM 每个数据模块的物理地 址后，DRAM 便会通过物理地址而索引到内存中具体的数据，再通过数据总线反馈 给 CPU[8]</p></blockquote><h4 id="内存带宽-1"><a href="#内存带宽-1" class="headerlink" title="内存带宽"></a>内存带宽</h4><h5 id="ROW-行"><a href="#ROW-行" class="headerlink" title="ROW 行"></a>ROW 行</h5><blockquote><p>在通用 DRAM 内存系统中，每个体在执行时，仅能激活（Active）一个行，当 有连续的指令通过调度映射到同一个体的不同行时，需要将第一个行进行预充电操作 （Precharge），再对第二个行进行激活操作，才能顺利进行连续指令的运行。这样做 便会造成大量的延迟，同时伴随的还有行冲突的数量会增加。想要降低行冲突出现的 概率，需要通过地址映射将连续的指令映射到同一个体的同一个行上面，这样行命中 的比例变化提升很多。从而能够有效的提升 DRAM 的性能</p></blockquote><h5 id="Column-列"><a href="#Column-列" class="headerlink" title="Column 列"></a>Column 列</h5><blockquote><p>当连续的指令作用在同一个体的同一个行时，此时不需要预充电操作，在获取数 据时，根据时间局部性和空间局部性 ，内存控制器会把整个行的数据都取出来放在 敏感放大器上。所以，第二个指令所映射的列也会以极高的效率获得</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410174402971.png" class="" title="image-20220410174402971"><h5 id="连续存取指令"><a href="#连续存取指令" class="headerlink" title="连续存取指令"></a>连续存取指令</h5><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410183659726.png" class="" title="image-20220410183659726"><h5 id="开页模式策略"><a href="#开页模式策略" class="headerlink" title="开页模式策略"></a>开页模式策略</h5><blockquote><p>开页的策略其 适用的环境是，如果有连续的指令到来，那么在执行完第一个指令后，并不会通过预 充电命令关掉该行。当内存控制器使用开页模式策略时，某行数据被取出存放在一个 DRAM 体的敏感放大器中的同一行的不同列，它可以快速的直接执行，此时会有最 小的延迟称为 Tcas。这种情况下，当另外一个读取指令指向了同一个行，因为该行已 经激活在敏感放大器中，所以它仅仅需要列命令，便可将数据从敏感放大器传递到内 存控制器中 ，这样的延迟是最小的。当然，另一方面，当连续的指令作用的是同一 个体的不同行时，内存控制器在执行第二个访问操作时，必须将第一个行通过预充电 指令关掉，同时再打开另外一个指令所指向的那个行，这样才可以执行第二个的列选取.  </p></blockquote><h5 id="关页策略"><a href="#关页策略" class="headerlink" title="关页策略"></a>关页策略</h5><p>关 页策略适用的环境是，当连续的指令到来以后，在执行完第一个指令，紧接着发布一 个预充电的指令来关掉该行，所以它适用于行冲突很多的情况下</p><h4 id="行冲突现象"><a href="#行冲突现象" class="headerlink" title="行冲突现象:"></a>行冲突现象:</h4><p>如果连续的地址存取指令，它们通过地址映射的算法后，指向的是同一个体的不同行，这会产生大量的延迟，因为上述第一个行需要激活的指令，才能执行第一个存取的请求，因为第二个不同于第一个行，因为同一个体一次仅能激活一个行，所以，需要将第一个行进行预充电的操作， 来使第一个行的状态变为关闭，紧接着再发布第二个指令来激活第二个请求所指向的行，在此两个行为以后，才可以执行第二个请求， 获取第二个行的数据，存放在行缓冲区中。因为这样的操作比第一种情况多出了一个 预充电与一个激活的指令延迟，所以效率是非常低的。这样的情况我们称之为行冲突现象. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Overview-of-DRAMs&quot;&gt;&lt;a href=&quot;#Overview-of-DRAMs&quot; class=&quot;headerlink&quot; title=&quot;Overview of DRAMs&quot;&gt;&lt;/a&gt;&lt;strong&gt;Overview of DRAMs&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="http://okeyia.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Computer Architecture" scheme="http://okeyia.github.io/tags/Computer-Architecture/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下实用工具配置</title>
    <link href="http://okeyia.github.io/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
    <id>http://okeyia.github.io/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</id>
    <published>2022-04-09T13:52:31.000Z</published>
    <updated>2022-11-05T02:22:36.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-shell配置"><a href="#一-shell配置" class="headerlink" title="一 shell配置"></a>一 shell配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装插件的脚本</span></span><br><span class="line">sudo apt install wget curl git zsh vim tldr -y</span><br><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line">sed -i &#x27;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting z)/&#x27; ~/.zshrc</span><br><span class="line"></span><br><span class="line">git clone https://github.com/okeyia/honukai-iterm-zsh.git ~/.oh-my-zsh/custom/themes</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/robbyrussell/honukai&#x27; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>好用的shell有很多, 如fish、zsh、Oh-my-zsh ，本教程以Oh-my-zsh为例，配置教程如下：</p><h3 id="1-安装zsh"><a href="#1-安装zsh" class="headerlink" title="1 安装zsh"></a>1 安装zsh</h3><p>以ubuntu为例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><h3 id="2-下载oh-my-zsh-源码"><a href="#2-下载oh-my-zsh-源码" class="headerlink" title="2 下载oh-my-zsh 源码"></a>2 下载oh-my-zsh 源码</h3><h4 id="2-1-脚本安装方式"><a href="#2-1-脚本安装方式" class="headerlink" title="2.1 脚本安装方式"></a>2.1 脚本安装方式</h4><p>使用curl或者wget</p><table><thead><tr><th>Method</th><th>Command</th></tr></thead><tbody><tr><td>curl</td><td><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td>wget</td><td><code>sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr></tbody></table><h4 id="2-2-手动安装"><a href="#2-2-手动安装" class="headerlink" title="2.2 手动安装"></a>2.2 手动安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.sh</span><br><span class="line">sudo sh install.sh</span><br></pre></td></tr></table></figure><h3 id="3-安装-oh-my-zsh插件及主题"><a href="#3-安装-oh-my-zsh插件及主题" class="headerlink" title="3 安装 oh-my-zsh插件及主题"></a>3 安装 oh-my-zsh插件及主题</h3><h4 id="3-1-插件—代码高亮"><a href="#3-1-插件—代码高亮" class="headerlink" title="3.1 插件—代码高亮"></a>3.1 插件—代码高亮</h4><ol><li>克隆源码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件 <code>~/.zshrc</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( [plugins...] zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><ol start="3"><li>是配置文件生效</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="3-2-插件—自动补全"><a href="#3-2-插件—自动补全" class="headerlink" title="3.2 插件—自动补全"></a>3.2 插件—自动补全</h4><ol><li><p>克隆源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( # other plugins... zsh-autosuggestions)</span><br></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-3-主题—honukai"><a href="#3-3-主题—honukai" class="headerlink" title="3.3 主题—honukai"></a>3.3 主题—honukai</h4><ol><li><p>主题配置文件一般存放于  <code>~/.oh-my-zsh/custom/themes</code> 文件夹, 进入到该文件夹, 执行该命令, 将下面的内容(复制内容如下)复制进去.  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim honukai.zsh-theme </span><br></pre></td></tr></table></figure><p><strong>复制内容如下:</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Based on the great ys theme (http://ysmood.org/wp/2013/03/my-ys-terminal-theme/)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Machine name.</span></span><br><span class="line"><span class="keyword">function</span> box_name &#123;</span><br><span class="line">    [ -f ~/.box-name ] &amp;&amp; cat ~/.box-name || <span class="built_in">echo</span> <span class="variable">$HOST</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory info.</span></span><br><span class="line"><span class="built_in">local</span> current_dir=<span class="string">&#x27;$&#123;PWD/#$HOME/~&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VCS</span></span><br><span class="line">YS_VCS_PROMPT_PREFIX1=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[white]%&#125;on%&#123;<span class="variable">$reset_color</span>%&#125; &quot;</span></span><br><span class="line">YS_VCS_PROMPT_PREFIX2=<span class="string">&quot;:%&#123;<span class="variable">$fg</span>[cyan]%&#125;&quot;</span></span><br><span class="line">YS_VCS_PROMPT_SUFFIX=<span class="string">&quot;%&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line">YS_VCS_PROMPT_DIRTY=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[red]%&#125;✖︎&quot;</span></span><br><span class="line">YS_VCS_PROMPT_CLEAN=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[green]%&#125;●&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Git info.</span></span><br><span class="line"><span class="built_in">local</span> git_info=<span class="string">&#x27;$(git_prompt_info)&#x27;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_PREFIX=<span class="string">&quot;<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX1&#125;</span>git<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX2&#125;</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_SUFFIX</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_DIRTY=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_DIRTY</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_CLEAN=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_CLEAN</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HG info</span></span><br><span class="line"><span class="built_in">local</span> hg_info=<span class="string">&#x27;$(ys_hg_prompt_info)&#x27;</span></span><br><span class="line"><span class="function"><span class="title">ys_hg_prompt_info</span></span>() &#123;</span><br><span class="line"><span class="comment"># make sure this is a hg dir</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&#x27;.hg&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX1&#125;</span>hg<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -n $(hg branch 2&gt;/dev/null)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="subst">$(hg status 2&gt;/dev/null)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_DIRTY</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_CLEAN</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_SUFFIX</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompt format: \n # USER at MACHINE in DIRECTORY on git:BRANCH STATE [TIME] \n $</span></span><br><span class="line">PROMPT=<span class="string">&quot;</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[blue]%&#125;#%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[cyan]%&#125;%n \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;at \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[green]%&#125;<span class="subst">$(box_name)</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;in \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;<span class="variable">$&#123;current_dir&#125;</span>%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;git_info&#125;</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;[%*]</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125;→ %&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$USER</span>&quot;</span> == <span class="string">&quot;root&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">PROMPT=<span class="string">&quot;</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[blue]%&#125;#%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$bg</span>[yellow]%&#125;%&#123;<span class="variable">$fg</span>[cyan]%&#125;%n%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;at \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[green]%&#125;<span class="subst">$(box_name)</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;in \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;<span class="variable">$&#123;current_dir&#125;</span>%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;git_info&#125;</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;[%*]</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125;→ %&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;honukai&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-用户默认使用zsh"><a href="#4-用户默认使用zsh" class="headerlink" title="4 用户默认使用zsh"></a>4 用户默认使用zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which zsh                #查看zsh的路径</span><br><span class="line">sudo vi /etc/passwd      #以用户sen为例, 将/bin/bash 改为/usr/bin/zsh</span><br></pre></td></tr></table></figure><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220924155931302.png" class="" title="image-20220924155931302"><h2 id="二-sudo-免密码"><a href="#二-sudo-免密码" class="headerlink" title="二 sudo 免密码"></a>二 sudo 免密码</h2><p>个别情况下，sudo 免密设置的特别麻烦，这里可对某个管理员用户设置sudo 免输入免密。本教程以<code>ubuntu 18.04</code> 为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br><span class="line"><span class="meta">#</span><span class="bash">在%sudo ALL=(ALL:ALL) ALL下面添加如下一行</span></span><br><span class="line">username  ALL=(ALL) NOPASSWD: ALL, 这里的username就是你自己的用户名</span><br><span class="line"><span class="meta">#</span><span class="bash">添加完成 如下图所示, 之后按Ctrl+O，接着按回车确定保存文件。最后Ctrl+X退出编辑</span></span><br></pre></td></tr></table></figure><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409220215145.png" class="" title="image-20220409220215145"><h2 id="三-vmware-配置git代理"><a href="#三-vmware-配置git代理" class="headerlink" title="三 vmware 配置git代理"></a>三 vmware 配置git代理</h2><h3 id="1-主机ip及虚拟机ip设置"><a href="#1-主机ip及虚拟机ip设置" class="headerlink" title="1 主机ip及虚拟机ip设置"></a>1 主机ip及虚拟机ip设置</h3><h4 id="1-1-VMware网络编辑器配置"><a href="#1-1-VMware网络编辑器配置" class="headerlink" title="1.1 VMware网络编辑器配置"></a>1.1 VMware网络编辑器配置</h4><p>如图所示: </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221141249.png" class="" title="网络编辑器配置"><h4 id="1-2-本机VMnet8-设置"><a href="#1-2-本机VMnet8-设置" class="headerlink" title="1.2 本机VMnet8 设置"></a>1.2 本机VMnet8 设置</h4><p>请确保本机VMnet8的本机ip地址和虚拟机IP地址处于同一网段, 如图中所示, 配置为: 192.168.1.1</p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221513434.png" class="" title="image-20220409221513434"><h4 id="1-3-测试与主机连接"><a href="#1-3-测试与主机连接" class="headerlink" title="1.3 测试与主机连接"></a>1.3 测试与主机连接</h4><p>在虚拟机中<code>ping</code>主机, 如果能<code>ping</code>通, 就代表连接无问题. </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221853038.png" class="" title="image-20220409221853038"><h3 id="2-gitconfig设置"><a href="#2-gitconfig设置" class="headerlink" title="2 .gitconfig设置"></a>2 .gitconfig设置</h3><h4 id="2-1-本机中运行代理软件"><a href="#2-1-本机中运行代理软件" class="headerlink" title="2.1 本机中运行代理软件"></a>2.1 本机中运行代理软件</h4><p>本次以v2rayN为例, 代理开启pac模式, 设置中打开允许局域网连接,</p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409222218684.png" class="" title="image-20220409222218684"><h4 id="2-2-查看所用协议"><a href="#2-2-查看所用协议" class="headerlink" title="2.2 查看所用协议"></a>2.2 查看所用协议</h4><p>在代理页面查看配置的协议及端口号。v2rayN中一般都是http协议和socks5协议, 记下配置的端口号. </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409222519626.png" class="" title="image-20220409222519626"><h4 id="2-3-编辑-gitconfig文件"><a href="#2-3-编辑-gitconfig文件" class="headerlink" title="2.3 编辑 .gitconfig文件"></a>2.3 编辑 <code>.gitconfig</code>文件</h4><p>使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global socks5://userName:userPwd@127.0.0.1:10809</span><br><span class="line">git config --global socks5://userName:userPwd@127.0.0.1:10809</span><br></pre></td></tr></table></figure><p><strong>或者</strong> 在用户目录下，编辑.gitconfig文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加以下内容, 这里的ip的值就是1.2节中配置的主机ip, 端口号就是2.2中的端口号, 注意端口号和协议保持一致, 可以配置socks5协议, 也可以配置http协议, 这里配置的是http协议。</span></span><br><span class="line">[http]</span><br><span class="line">    sslVerify = false</span><br><span class="line">    proxy = http://192.168.10.1:10809</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">注意：如果使用socks5协议的话，可能需要用户名和密码（默认是不需要的），socks5配置格式如下：</span></span><br><span class="line">[http]                                                                               </span><br><span class="line">    proxy = socks5://userName:userPwd@127.0.0.1:10809</span><br></pre></td></tr></table></figure><h2 id="四-github-clone-加速"><a href="#四-github-clone-加速" class="headerlink" title="四 github clone 加速"></a>四 github clone 加速</h2><p>如果自己本机没有配置代理,   可使用国内的某些代理网站.   <a href="https://gitclone.com/docs/howto/howto_github">github clone 加速</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-shell配置&quot;&gt;&lt;a href=&quot;#一-shell配置&quot; class=&quot;headerlink&quot; title=&quot;一 shell配置&quot;&gt;&lt;/a&gt;一 shell配置&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="工欲善其事, 必先利其器" scheme="http://okeyia.github.io/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B-%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="Tools" scheme="http://okeyia.github.io/tags/Tools/"/>
    
  </entry>
  
</feed>
