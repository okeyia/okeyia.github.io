<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>okeyia</title>
  
  
  <link href="http://okeyia.github.io/atom.xml" rel="self"/>
  
  <link href="http://okeyia.github.io/"/>
  <updated>2023-03-09T06:14:34.677Z</updated>
  <id>http://okeyia.github.io/</id>
  
  <author>
    <name>okeyia</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>一 TCP/IP协议详解</title>
    <link href="http://okeyia.github.io/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>http://okeyia.github.io/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</id>
    <published>2022-12-09T09:34:01.000Z</published>
    <updated>2023-03-09T06:14:34.677Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第一篇-TCP-IP协议详解"><a href="#第一篇-TCP-IP协议详解" class="headerlink" title="第一篇 TCP/IP协议详解"></a>第一篇 TCP/IP协议详解</h2><h3 id="第1章-TCP-IP协议族"><a href="#第1章-TCP-IP协议族" class="headerlink" title="第1章 TCP/IP协议族"></a>第1章 TCP/IP协议族</h3><p>本章则简单介绍其中几个相关协议：ICMP协议、ARP协 议和DNS协议，学习它们对于理解网络通信很有帮助。</p><h4 id="1-1-TCP-IP协议族体系结构以及主要协议"><a href="#1-1-TCP-IP协议族体系结构以及主要协议" class="headerlink" title="1.1 TCP/IP协议族体系结构以及主要协议"></a>1.1 TCP/IP协议族体系结构以及主要协议</h4><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223191117670.png" class="" title="image-20230223191117670"><h5 id="1-1-1-数据链路层"><a href="#1-1-1-数据链路层" class="headerlink" title="1.1.1 数据链路层"></a>1.1.1 数据链路层</h5><p>数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理 媒介（比如以太网、令牌环等）上的传输。</p><p>数据链路层两个常用的协议是ARP协议（Address Resolve Protocol，地址解析协议）和RARP协议（Reverse Address Resolve Protocol，逆地址解析协议）。它们实现了IP地址和机器物理地址（通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址） 之间的相互转换。</p><p>网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻 址一台机器，因此<strong>网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。</strong></p><p>RARP 协议仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作 站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网 络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服 务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p><h5 id="1-1-3-传输层"><a href="#1-1-3-传输层" class="headerlink" title="1.1.3 传输层"></a>1.1.3 传输层</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223203039797.png" class="" title="image-20230223203039797"><p>垂直的实线箭头表示TCP/IP协议族各层之间的实体通信 （数据包确实是沿着这些线路传递的），而水平的虚线箭头表示逻辑 通信线路。该图中还附带描述了不同物理网络的连接方法。</p><p>可见，数 据链路层（驱动程序）封装了物理网络的电气细节；网络层封装了网 络连接的细节；传输层则为应用程序封装了一条端到端的逻辑通信链 路，它负责数据的收发、链路的超时重连等。</p><p>传输层协议主要有三个：TCP协议、UDP协议和SCTP协议。</p><p>TCP协议（Transmission Control Protocol，传输控制协议）为应用 层提供可靠的、面向连接的和基于流（stream）的服务。</p><p>TCP协议使用 超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因 此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接， 并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读 写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以 释放这些内核数据。<strong>TCP服务是基于流的。基于流的数据没有边界（长 度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个 字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。</strong></p><p>UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协 议完全相反，它为应用层提供不可靠、无连接和基于数据报的服 务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目 的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误 而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此， 使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻 辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此 应用程序每次发送数据都要明确指定接收端的地址（IP地址等信 息）。<strong>基于数据报的服务，是相对基于流的服务而言的。每个UDP数 据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一 次性读出，否则数据将被截断。</strong></p><h4 id="1-7-socket和TCP-IP协议族的关系"><a href="#1-7-socket和TCP-IP协议族的关系" class="headerlink" title="1.7  socket和TCP/IP协议族的关系"></a>1.7  socket和TCP/IP协议族的关系</h4><p>由socket定义的这一组API提供如下两点功能：</p><ol><li>将应用程序数 据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，以交付内核来发 送数据（比如图1-5所示的send函数），或者是从内核TCP/UDP接收缓 冲区中复制数据到用户缓冲区，以读取数据；</li><li>应用程序可以通过 它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精 细地控制底层通信的行为。比如可以通过setsockopt函数来设置IP数据 报在网络上的存活时间。我们将在第5章详细讨论这一组API。</li></ol><h3 id="第2章-IP协议详解"><a href="#第2章-IP协议详解" class="headerlink" title="第2章 IP协议详解"></a>第2章 IP协议详解</h3><p>P协议是TCP/IP协议族的核心协议，也是socket网络编程的基础之 一。</p><p>本章从两个方面较为深入地探讨IP协议：</p><ul><li>IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通 信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分 通信行为。</li><li>IP数据报的路由和转发。IP数据报的路由和转发发生在除目标 机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及 如何转发。</li></ul><h4 id="2-1-IP服务的特点"><a href="#2-1-IP服务的特点" class="headerlink" title="2.1 IP服务的特点"></a>2.1 IP服务的特点</h4><p><strong>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</strong></p><ul><li><strong>无状态（stateless）是指IP通信双方不同步传输数据的状态信息， 因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。</strong>这种服务最大的缺点是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收 端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这 两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数 据报之间没有任何上下文关系。</li><li><strong>无连接（connectionless）是指IP通信双方都不长久地维持对方的 任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对 方的IP地址。</strong></li><li><strong>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是 承诺尽最大努力（best effort）。</strong>很多种情况都能导致IP数据报发送失 败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长 （根据IP数据报头部字段TTL判断，见后文），那么它将丢弃之，并 返回一个ICMP错误消息（超时错误）给发送端。又比如，接收端发现 收到的IP数据报不正确（通过校验机制），它也将丢弃之，并返回一 个ICMP错误消息（IP头部参数错误）给发送端。</li></ul><h4 id="2-2-IPv4头部结构"><a href="#2-2-IPv4头部结构" class="headerlink" title="2.2 IPv4头部结构"></a>2.2 IPv4头部结构</h4><h5 id="2-2-1-IPv4头部结构"><a href="#2-2-1-IPv4头部结构" class="headerlink" title="2.2.1 IPv4头部结构"></a>2.2.1 IPv4头部结构</h5><p>通常为20字节</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223192622355.png" class="" title="image-20230223192622355"><h4 id="2-3-IP分片"><a href="#2-3-IP分片" class="headerlink" title="2.3 IP分片"></a>2.3 IP分片</h4><p>前文曾提到，当IP数据报的长度超过帧的MTU时，它将被分片传 输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能 在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才 会被内核中的IP模块重新组装。</p><p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息：<strong>数据报标识、标志和片偏移</strong>。一个IP数据报的每个分片都具有自己的IP头 部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一 个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总 长度字段将被设置为该分片的长度。</p><p>以太网帧的MTU是1500字节（可以通过ifconfig命令或者netstat命 令查看），因此它携带的IP数据报的数据部分最多是1480字节（IP头部 占用20字节）。考虑用IP数据报封装一个长度为1481字节的ICMP报文 （包括8字节的ICMP头部，所以其数据部分长度为1473字节），则该 数据报在使用以太网帧传输时必须被分片，如图2-2所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223194207843.png" class="" title="image-20230223194207843"><p>图2-2中，长度为1501字节的IP数据报被拆分成两个IP分片，第一 个IP分片长度为1500字节，第二个IP分片的长度为21字节。每个IP分片 都包含自己的IP头部（20字节），且第一个IP分片的IP头部设置了MF 标志，而第二个IP分片的IP头部则没有设置该标志，因为它已经是最后 一个分片了。原始IP数据报中的ICMP头部内容被完整地复制到了第一 个IP分片中。第二个IP分片不包含ICMP头部信息，因为IP模块重组该 ICMP报文的时候只需要一份ICMP头部信息，重复传送这个信息没有 任何益处。1473字节的ICMP报文数据的前1472字节被IP模块复制到第 一个IP分片中，使其总长度为1500字节，从而满足MTU的要求；而多 出的最后1字节则被复制到第二个IP分片中。</p><h4 id="2-4-IP路由"><a href="#2-4-IP路由" class="headerlink" title="2.4 IP路由"></a>2.4 IP路由</h4><h3 id="第3章-TCP协议详解"><a href="#第3章-TCP协议详解" class="headerlink" title="第3章 TCP协议详解"></a>第3章 TCP协议详解</h3><p>和IP协议相比， TCP协议更靠近应用层，因此在应用程序中具有更强的可操作性。一些 重要的socket选项都和TCP协议相关。</p><p>本章从如下四方面来讨论TCP协议：</p><ol><li>TCP头部信息。TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的 数据流。</li><li>TCP状态转移过程。TCP连接的任意一端都是一个状态机。在 TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。</li><li>TCP数据流。通过分析TCP数据流，我们就可以从网络应用程序 外部来了解应用层协议和通信双方交换的应用程序数据。这一部分将 讨论两种类型的TCP数据流：交互数据流和成块数据流。TCP数据流中 有一种特殊的数据，称为紧急数据，我们也将简单讨论之。</li><li>TCP数据流的控制。为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。这一部分讨论TCP数据流控制的两个方 面：超时重传和拥塞控制。</li></ol><h4 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h4><p><strong>TCP协议相对于 UDP协议的特点是：面向连接、字节流和可靠传输。</strong>使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读 写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和 连接上数据的传输。TCP连接是全双工的，即双方的数据读写可以通过 一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放 系统资源。</p><p>TCP协议的这种连接是一对一的，所以基于广播和多播（目标是多 个主机地址）的应用程序不能使用TCP服务。而无连接协议UDP则非常 适合于广播和多播。</p><p>当接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应 用程序数据按照TCP报文段的序号（见后文）依次放入TCP接收缓冲区 中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收 缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的 应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模 块接收到的TCP报文段个数之间也没有固定的数量关系。</p><p>UDP则不然。发送端应用程序每执行一 次写操作，UDP模块就将其封装成一个UDP数据报并发送之。<strong>接收端 必须及时针对每一个UDP数据报执行读操作（通过recvfrom系统调 用），否则就会丢包（这经常发生在较慢的服务器上）。</strong>并且，如果 用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将 被截断。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223203748839.png" class="" title="image-20230223203748839"><p>TCP传输是可靠的。首先，TCP协议采用发送应答机制，即发送端 发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文 段传输成功。其次，TCP协议采用超时重传机制，发送端在发送出一个 TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发 该报文段。最后，因为TCP报文段最终是以IP数据报发送的，而IP数据 报到达接收端可能乱序、重复，所以TCP协议还会对接收到的TCP报文 段重排、整理，再交付给应用层。</p><h4 id="3-2-TCP头部结构"><a href="#3-2-TCP头部结构" class="headerlink" title="3.2 TCP头部结构"></a>3.2 TCP头部结构</h4><h4 id="3-3-TCP的建立与关闭"><a href="#3-3-TCP的建立与关闭" class="headerlink" title="3.3 TCP的建立与关闭"></a>3.3 TCP的建立与关闭</h4><h5 id="3-3-1-使用tcpdump观察TCP连接的建立和关闭"><a href="#3-3-1-使用tcpdump观察TCP连接的建立和关闭" class="headerlink" title="3.3.1 使用tcpdump观察TCP连接的建立和关闭"></a>3.3.1 使用tcpdump观察TCP连接的建立和关闭</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223204422693.png" class="" title="image-20230223204422693"><p>因为整个过程并没有发生应用层数据的交换，所以TCP报文段的数 据部分的长度（length）总是0。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223204455397.png" class="" title="image-20230223204455397"><p>第1个TCP报文段包含SYN标志，因此它是一个同步报文段，即 ernest-laptop（客户端）向Kongming20（服务器）发起连接请求。同 时，该同步报文段包含一个ISN值为535734930的序号。</p><p>第2个TCP报文 段也是同步报文段，表示Kongming20同意与ernest-laptop建立连接。同 时它发送自己的ISN值为2159701207的序号，并对第1个同步报文段进 行确认。确认值是535734931，即第1个同步报文段的序号值加1。</p><p>第3个TCP报文段是ernest-laptop对第2个同步报文段的确认。至 此，TCP连接就建立起来了。建立TCP连接的这3个步骤被称为TCP三 次握手。 （从第3个TCP报文段开始，tcpdump输出的序号值和确认值都是相对 初始ISN值的偏移。当然，我们可以开启tcpdump的-S选项来选择打印 序号的绝对值。)</p><p><strong>后面4个TCP报文段是关闭连接的过程。</strong></p><p>第4个TCP报文段包含FIN 标志，因此它是一个结束报文段，即ernest-laptop要求关闭连接。结束 报文段和同步报文段一样，也要占用一个序号值。</p><p>Kongming20用TCP 报文段5来确认该结束报文段。</p><p>紧接着Kongming20发送自己的结束报文 段6，ernest-laptop则用TCP报文段7给予确认。实际上，仅用于确认目 的的确认报文段5是可以省略的，因为结束报文段6也携带了该确认信 息。确认报文段5是否出现在连接断开的过程中，取决于TCP的延迟确 认特性。延迟确认将在后面讨论。</p><h5 id="3-3-2-半关闭状态"><a href="#3-3-2-半关闭状态" class="headerlink" title="3.3.2 半关闭状态"></a>3.3.2 半关闭状态</h5><p>TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。换言之，<strong>通信的一端可以发送结束报文段给对方，告诉它本端已 经完成了数据的发送，但允许继续接收来自对方的数据，</strong>直到对方也 发送结束报文段以关闭连接。TCP连接的这种状态称为半关闭（half close）状态，如图3-7所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223204900972.png" class="" title="image-20230223204900972"><p>在图3-7中，服务器和客户端应用程序判断对方是否已经 关闭连接的方法是：read系统调用返回0（收到结束报文段）。当然， Linux还提供其他检测连接是否被对方关闭的方法，这将在后续章节讨 论。</p><h4 id="3-6-TCP交互数据流"><a href="#3-6-TCP交互数据流" class="headerlink" title="3.6 TCP交互数据流"></a>3.6 TCP交互数据流</h4><p>TCP报文段所携带的应用程序数据按照长度 分为两种：交互数据和成块数据。</p><ul><li><p>交互数据仅包含很少的字节。使用 交互数据的应用程序（或协议）对实时性要求高，比如telnet、ssh等。</p></li><li><p>成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块 数据的应用程序（或协议）对传输效率要求高，比如ftp。本节我们讨 论交互数据流。</p></li></ul><h4 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据"></a>3.8 带外数据</h4><p>有些传输层协议具有带外（Out Of Band，OOB）数据的概念，用 于迅速通告对方本端发生的重要事件。</p><p>因此，带外数据比普通数据 （也称为带内数据）有更高的优先级，它应该总是立即被发送，而不 论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可 以使用一条独立的传输层连接，也可以映射到传输普通数据的连接 中。实际应用中，带外数据的使用很少见，已知的仅有telnet、ftp等远 程非活跃程序。</p><p>UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过 TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提 供了一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧 急数据。这种紧急数据的含义和带外数据类似，因此后文也将TCP紧急 数据称为带外数据。</p><ul><li>我们先来介绍TCP发送带外数据的过程。假设一个进程已经往某个 TCP连接的发送缓冲区中写入了N字节的普通数据，并等待其发送。</li><li>在 数据被发送前，该进程又向这个连接写入了3字节的带外数据“abc”。</li><li>此 时，待发送的TCP报文段的<strong>头部将被设置URG标志</strong>，并且紧急指针被 设置为指向最后一个带外数据的下一字节（进一步减去当前TCP报文段 的序号值得到其头部中的紧急偏移值），如图3-10所示。<img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224211617697.png" class="" title="image-20230224211617697"></li></ul><p>由图3-10可见，发送端一次发送的多字节的带外数据中只有最后一 字节被当作带外数据（字母c），而其他数据（字母a和b）被当成了普 通数据。<strong>如果TCP模块以多个TCP报文段来发送图3-10所示TCP发送缓 冲区中的内容，则每个TCP报文段的头部都将设置URG标志，并且它们的紧 急指针指向同一个位置（数据流中带外数据的下一个位置），但只有 一个TCP报文段真正携带带外数据。</strong></p><p>现在考虑TCP接收带外数据的过程。TCP接收端只有在接收到紧急 指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外 数据的位置，并将它读入一个特殊的缓存中。<strong>这个缓存只有1字节，称 为带外缓存。</strong>如果上层应用程序没有及时将带外数据从带外缓存中读 出，则后续的带外数据（如果有的话）将覆盖它。</p><h4 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h4><p>慢启动（slow start）、</p><p>拥塞避免（congestion avoidance）、</p><p>快速重传（fast retransmit）</p><p>快速恢复（fast recovery）。</p><p><strong>拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其 中第一个数据的确认之前）的数据量，我们称为SWND（Send Window，发送窗口[1]）。不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。</strong>这些TCP 报文段的最大长度（仅指数据部分）称为SMSS（Sender Maximum Segment Size，发送者最大段大小），其值一般等于MSS。</p><h3 id="第4章-TCP-IP通信案例：访问Internet上的Web服务器"><a href="#第4章-TCP-IP通信案例：访问Internet上的Web服务器" class="headerlink" title="第4章 TCP/IP通信案例：访问Internet上的Web服务器"></a>第4章 TCP/IP通信案例：访问Internet上的Web服务器</h3><h4 id="4-1-实例综图"><a href="#4-1-实例综图" class="headerlink" title="4.1 实例综图"></a>4.1 实例综图</h4><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224091619497.png" class="" title="image-20230224091619497"><p>wget客户端程序和代理服务器之间，以及代理服务 器与Web服务器之间都是使用HTTP协议通信的。</p><h4 id="4-2-部署代理服务器"><a href="#4-2-部署代理服务器" class="headerlink" title="4.2 部署代理服务器"></a>4.2 部署代理服务器</h4><p>在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代 理服务器，它们提供对目标资源的中转访问。一个HTTP请求可能被多 个代理服务器转发，后面的服务器称为前面服务器的上游服务器。</p><p>代 理服务器按照其使用方式和作用，分为<strong>正向代理服务器、反向代理服 务器和透明代理服务器。</strong></p><ul><li>正向代理要求客户端自己设置代理服务器的地址。客户的每次请 求都将直接发送到该代理服务器，并由代理服务器来请求目标资源。</li><li>反向代理则被设置在服务器端，因而客户端无须进行任何设置。 反向代理是指用代理服务器来接收Internet上的连接请求，然后将请求 转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给 客户端。</li><li>透明代理只能设置在网关上。用户访问Internet的数据报必然都经 过网关，如果在网关上设置代理，则该代理对用户来说显然是透明 的。透明代理可以看作正向代理的一种特殊情况。</li></ul><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224091945626.png" class="" title="image-20230224091945626"><h4 id="4-3-使用tcpdump抓取传输数据包"><a href="#4-3-使用tcpdump抓取传输数据包" class="headerlink" title="4.3 使用tcpdump抓取传输数据包"></a>4.3 使用tcpdump抓取传输数据包</h4><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224101238917.png" class="" title="image-20230224101238917"><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224092256808.png" class="" title="image-20230224092256808"><p>但为了讨论问题的方便，我们将这43个数据包按照其逻辑关 系分为如下4个部分：</p><ul><li>代理服务器访问DNS服务器以查询域名<a href="http://www.baidu.com对应的ip/">www.baidu.com对应的IP</a> 地址，包括数据包8、9。</li><li>代理服务器查询路由器MAC地址的ARP请求和应答，包括数据 包6、7。</li><li>wget客户端（192.168.1.109）和代理服务器（192.168.1.108）之 间的HTTP通信，包括数据包1～5、23～25、32～40、42和43。</li><li>代理服务器和Web服务器（119.75.218.77）之间的HTTP通信， 包括数据包10～22、26～31和41。</li></ul><h4 id="4-4-访问DNS服务器"><a href="#4-4-访问DNS服务器" class="headerlink" title="4.4 访问DNS服务器"></a>4.4 访问DNS服务器</h4><p>数据包8、9表示代理服务器ernest-laptop向DNS服务器 （219.239.26.42，首选DNS服务器的IP地址，见1.6.2节）查询域名 <a href="http://www.baidu.com对应的ip地址,并得到了回复.该回复包括一个主机别/">www.baidu.com对应的IP地址，并得到了回复。该回复包括一个主机别</a> 名（<a href="http://www.a.shifen.com)和两个ip地址(119.75.218.77和/">www.a.shifen.com）和两个IP地址（119.75.218.77和</a> 119.75.217.56）。</p><p>代理服务器执行DNS查询的完整过程如图4-3所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224093159050.png" class="" title="image-20230224093159050"><p>根据路由策略，目标IP地址（219.239.26.42）仅能匹配路由表 中的默认路由项，因此该IP数据报先被发送至路由器（IP地址为 192.168.1.1），然后通过路由器来转发。<strong>因为ernest-laptop的ARP缓存 中没有与路由器对应的缓存项（我们手动将其删除了），所以ernest-aptop需要发起一个ARP广播以查询路由器的IP地址，而这正是数据包6 描述的内容。</strong></p><p><strong>路由器则通过ARP应答告诉ernest-laptop自己的MAC地址 是14:e6:e4:93:5b:78，如数据包7所示。</strong>最终，以太网驱动程序将IP数据 报封装成以太网帧发送给路由器。此后，代理服务器再次发送数据到 Internet时将不再需要ARP查询，因为ernest-laptop的ARP高速缓存中已 经记录了路由器的IP地址和MAC地址的映射关系。</p><p>==注意:== 虽然IP数据报是先发送到路由器，再由它转发给 目标主机，但是其头部的目标IP地址却是最终的目标主机（DNS服务 器）的IP地址，而不是中转路由器的IP地址（192.168.1.1）。</p><p>这说明， IP头部的源端IP地址和目的端IP地址在转发过程中是始终不变的（一种 例外是源路由选择）。但帧头部的源端物理地址和目的端物理地址在 转发过程中则是一直在变化的。</p><h4 id="4-5-本地名称查询"><a href="#4-5-本地名称查询" class="headerlink" title="4.5 本地名称查询"></a>4.5 本地名称查询</h4><p>Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件 中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文 件。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224094308966.png" class="" title="image-20230224094308966"><p>当wget访问某个Web服务器时，它先读取环境变 量http_proxy。如果该环境变量被设置，并且我们没有阻止wget使用代 理服务，则wget将通过http_proxy指定的代理服务器来访问Web服务。 但http_proxy环境变量中包含主机名ernest-laptop，因此wget将首先读 取/etc/hosts配置文件，试图通过它来解析主机名ernest-laptop对应的IP 地址。其结果正如wget的输出所示，解析成功。</p><p>如果程序在/etc/hosts文件中未找到目标机器名对应的IP地址，它 将求助于DNS服务。</p><h4 id="4-6-HTTP通信"><a href="#4-6-HTTP通信" class="headerlink" title="4.6 HTTP通信"></a>4.6 HTTP通信</h4><p>为了方便讨论，我们将wget客户端和代理服务器之间的通信过程 画成图4-4所示的TCP时序图</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224095552897.png" class="" title="image-20230224095552897"><p>首先应该注意的是，TCP连接从建立到关闭的过程中，客户端仅给 服务器发送了一个HTTP请求（即TCP报文段4），该请求的长度为136 字节（见代码清单4-2中TCP报文段4的length值）。</p><p>代理服务器则用6个 TCP报文段（23、24、25、33、35和36）给客户端返回了总长度为8522 字节（<strong>这可以从对方的最后一个确认报文段42的确认值计算得到，考虑同步报文段和结束报文段各占用一个序号</strong>）的HTTP应答。客户端使 用了7个TCP报文段（32、34、37、38、39、40和42）来确认这8522字 节的HTTP应答数据。</p><p>下面我们简单分析一下这136字节的HTTP请求和8522字节的HTTP 应答的部分主要内容（开启tcpdump的-X选项来查看）。</p><h5 id="4-6-1-HTTP-请求"><a href="#4-6-1-HTTP-请求" class="headerlink" title="4.6.1 HTTP 请求"></a>4.6.1 HTTP 请求</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224100629900.png" class="" title="image-20230224100629900"><p>第1行是请求行。其中“GET”是请求方法，表示客户端以只读的方 式来申请资源。常见的HTTP请求方法有9种，如表4-1所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224100838654.png" class="" title="image-20230224100838654"><p>GET、HEAD、OPTIONS、TRACE、PUT和DELETE 等请求方法被认为是等幂的（idempotent），即多次连续的、重复的请 求和只发送一次该请求具有完全相同的效果。而POST方法则不同，连 续多次发送同样一个请求可能进一步影响服务器上的资源。</p><p>“<a href="http://www.baidu.com/index.html%E2%80%9D%E6%98%AF%E7%9B%AE%E6%A0%87%E8%B5%84%E6%BA%90%E7%9A%84URL%E3%80%82%E5%85%B6">http://www.baidu.com/index.html”是目标资源的URL。其</a> 中“http”是所谓的scheme，表示获取目标资源需要使用的应用层协议。 其他常见的scheme还有ftp、rtsp和file等。“<a href="http://www.baidu.com”指定资源所/">www.baidu.com”指定资源所</a> 在的目标主机。<strong>“index.html”指定资源文件的名称，这里指的是服务器 根目录（站点的根目录，而不是服务器的文件系统根目录“/”）中的索 引文件。</strong></p><ul><li><p>“HTTP/1. 0”表示客户端（wget程序）使用的HTTP的版本号是1.0。 目前的主流HTTP版本是1.1。</p></li><li><p>HTTP请求内容中的第2～4行都是HTTP请求的头部字段。一个 HTTP请求可以包含多个头部字段。一个头部字段用一行表示，包含字 段名称、冒号、空格和字段的值。HTTP请求中的头部字段可按任意顺 序排列。</p></li><li><p>“User-Agent:Wget/1. 12(linux-gnu)”表示客户端使用的程序是wget。 </p></li><li><p>“Host:www. baidu.com”表示目标主机名是<a href="http://www.baidu.com.http/">www.baidu.com。HTTP</a> 协议规定HTTP请求中必须包含的头部字段就是目标主机名。</p></li><li><p>“Connection:close”是我们执行wget命令时传入的（见代码清单4- 1），用以告诉服务器处理完这个HTTP请求之后就关闭连接。</p><blockquote><p>在旧的 HTTP协议中，Web客户端和Web服务器之间的一个TCP连接只能为一 个HTTP请求服务。当处理完客户的一个HTTP请求之后，Web服务器就 （主动）将TCP连接关闭了。此后，同一客户如果要再发送一个HTTP 请求的话，必须与服务器建立一个新的TCP连接。也就是说，<strong>同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为短连接。</strong></p><p><strong>长连接与之相反，是指多个请求可以使用同一个TCP连接。长连接在编程上稍微复杂一些，但性能上却有很大提高：它极大地减少了网络上 为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。</strong></p></blockquote></li></ul><p><strong>在所有头部字段之后，HTTP请求必须包含一个空行，以标识头部 字段的结束。</strong>请求行和每个头部字段都必须以＜CR＞＜LF＞结束（回 车符和换行符）；而空行则必须只包含一个＜CR＞＜LF＞，不能有其 他字符，甚至是空白字符。 </p><p>在空行之后，HTTP请求可以包含可选的消息体。如果消息体非 空，则HTTP请求的头部字段中必须包含描述该消息体长度的字 段“Content-Length”。我们的实例只是获取目标服务器上的资源，所以 没有消息体。</p><h5 id="4-6-2-HTTP应答"><a href="#4-6-2-HTTP应答" class="headerlink" title="4.6.2 HTTP应答"></a>4.6.2 HTTP应答</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224101613564.png" class="" title="image-20230224101613564"><p><strong>第一行是状态行。</strong>“HTTP/1.0”是服务器使用的HTTP协议的版本 号。通常，服务器需要使用和客户端相同的HTTP协议版本。“200 OK”是状态码和状态信息。常见的状态码和状态信息及其含义如表4-2 所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224101716998.png" class="" title="image-20230224101716998"><p>第2～7行是HTTP应答的头部字段。其表示方法与HTTP请求中的 头部字段相同。</p><ul><li>“Server:BWS/1. 0”表示目标Web服务器程序的名字是BWS（Baidu Web Server）。 </li><li>“Content-Length:8024”表示目标文档的长度为8024字节。这个值和 wget输出的文档长度一致。</li><li>“Content-Type:text/html;charset=gbk”表示目标文档的MIME类型。 其中“text”是主文档类型，“html”是子文档类型。“text/html”表示目标文 档index.html是text类型中的html文档。“charset”是text文档类型的一个参 数，用于指定文档的字符编码。</li><li>“Set-Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expires=Wed,04-Jul-42 00:10:47 GMT;path=/;domain=. baidu.com”表示服务器 传送一个Cookie给客户端。其中，“BAIDUID”指定Cookie的名 字，“expires”指定Cookie的生存时间，“domain”和“path”指定该Cookie 生效的域名和路径。下面我们简单分析一下Cookie的作用。</li><li>“Via:1. 0 localhost(squid/3.0 STABLE18)”表示HTTP应答在返回过程 中经历过的所有代理服务器的地址和名称。这里的localhost实际上指的 是“192.168.1.108”。这个头部字段的功能有点类似于IP协议的记录路由 功能。</li></ul><p>第2章中曾提到，<strong>HTTP协议是一种无状态的协议，即每个HTTP请求之间没有任何上下文关系。</strong>如果服务器处理后续HTTP请求时需要用 到前面的HTTP请求的相关信息，客户端必须重传这些信息。这样就导 致HTTP请求必须传输更多的数据。</p><p>在交互式Web应用程序兴起之后，HTTP协议的这种无状态特性就显得不适应了，因为交互程序通常要承上启下。因此，我们要使用额 外的手段来保持HTTP连接状态，常见的解决方法就是Cookie。<strong>Cookie 是服务器发送给客户端的特殊信息（通过HTTP应答的头部字段“Set-Cookie”），客户端每次向服务器发送请求的时候都需要带上这些信息 （通过HTTP请求的头部字段“Cookie”）。这样服务器就可以区分不同 的客户了。基于浏览器的自动登录就是用Cookie实现的。</strong></p><p>在所有头部字段之后，HTTP应答必须包含一个空行，以标识头部 字段的结束。状态行和每个头部字段都必须以＜CR＞＜LF＞结束；而 空行则必须只包含一个＜CR＞＜LF＞，不能有其他字符，甚至是空白 字符。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第一篇-TCP-IP协议详解&quot;&gt;&lt;a href=&quot;#第一篇-TCP-IP协议详解&quot; class=&quot;headerlink&quot; title=&quot;第一篇 TCP/IP协议详解&quot;&gt;&lt;/a&gt;第一篇 TCP/IP协议详解&lt;/h2&gt;&lt;h3 id=&quot;第1章-TCP-IP协议族&quot;&gt;&lt;a</summary>
      
    
    
    
    <category term="Linux" scheme="http://okeyia.github.io/categories/Linux/"/>
    
    
    <category term="服务器编程" scheme="http://okeyia.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>现代 C++ 教程</title>
    <link href="http://okeyia.github.io/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/"/>
    <id>http://okeyia.github.io/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/</id>
    <published>2022-11-18T07:32:08.000Z</published>
    <updated>2023-02-27T07:37:24.729Z</updated>
    
    <content type="html"><![CDATA[<h2 id="现代-C-教程"><a href="#现代-C-教程" class="headerlink" title="现代 C++ 教程"></a>现代 C++ 教程</h2><p><strong>现代 C++</strong> (本书中均指 C++11/14/17/20) 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。</p><h3 id="一-迈向现代C"><a href="#一-迈向现代C" class="headerlink" title="一 迈向现代C++"></a>一 迈向现代C++</h3><h4 id="1-1-被弃用的特性"><a href="#1-1-被弃用的特性" class="headerlink" title="1.1 被弃用的特性"></a>1.1 被弃用的特性</h4><p><strong>注意</strong>：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽 量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分 特性其实会『永久』保留。</p><ul><li>不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。 如 char *str = “hello world!”;    // 将出现弃用警告</li><li>auto_ptr 被弃用，应使用 unique_ptr。</li><li>特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 <code>&lt;ccomplex&gt;</code>与**<cstdalign>**  等</li></ul><h4 id="1-2-与C的兼容性"><a href="#1-2-与C的兼容性" class="headerlink" title="1.2 与C的兼容性"></a>1.2 与C的兼容性</h4><p>出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码，例如 Linux 系统调用。</p><p>从现在开始，你的脑子里应该树立『C++ 不是 C 的一个超集』这个观念。在编写 C++ 时，也应该尽可能 的避免使用诸如 void* 之类的程序风格。</p><p>而在不得不使用 C 时，应该注意使用 ==extern “C”== 这种特性， 将 C 语言的代码与 C++ 代码进行分离编译，再统一链接这种做法。</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118155902628.png" class="" title="image-20221118155902628"><p>标识: <code>-std=c++2a</code> 启用预先批准的部分C++ 特性</p><h3 id="二-语言可用性的强化"><a href="#二-语言可用性的强化" class="headerlink" title="二 语言可用性的强化"></a>二 语言可用性的强化</h3><p>当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都 是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及语言可用性，是 指那些发生在运行时之前的语言行为。</p><h4 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h4><h5 id="2-1-1-nullptr"><a href="#2-1-1-nullptr" class="headerlink" title="2.1.1 nullptr"></a>2.1.1 nullptr</h5><blockquote><p>在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东 西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义 为 0。但是C++ 不允许直接将 void * 隐式转换到其他类型。</p><p>但如果编译器尝试把 NULL 定义为 ((void*)0)， 那么在下面这句代码中： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ch = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p> 没有了 void * 隐式转换的 C++ 只好将 NULL 定义为 0。而这依然会产生新的问题，将 NULL 定义 成 0 将导致 C++ 中重载特性发生混乱。 <strong>那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直觉。</strong></p></blockquote><p>C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型 为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><p>下面的程序会判断 **NULL, nullptr, 0是否是同一种类型: **</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="keyword">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="built_in">std</span>::<span class="keyword">nullptr_t</span>&gt;::value)</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-constexpr"><a href="#2-1-2-constexpr" class="headerlink" title="2.1.2  constexpr"></a>2.1.2  constexpr</h5><blockquote><p>常量表达式：比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。</p></blockquote><p>C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这 个关键字明确的告诉编译器应该去验证 foo 在编译期就应该是一个常量表达式。</p><p>从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码在C++ 11 中编译不过, 因为含有分支, 改为以下代码可以编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h4><h5 id="2-2-1-if-switch-变量声明强化"><a href="#2-2-1-if-switch-变量声明强化" class="headerlink" title="2.2.1 if/switch 变量声明强化"></a>2.2.1 if/switch 变量声明强化</h5><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终<strong>没有办法在 if 和 switch 语句中声明一个临时的变量。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 c++17 之前</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>);</span><br><span class="line">itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和Go 语言有点像</span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-初始化列表"><a href="#2-2-2-初始化列表" class="headerlink" title="2.2.2 初始化列表"></a>2.2.2 初始化列表</h5><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。这就为类对象的初始化与普通数组和 POD(Plain Old Data，即没有构造、析构和虚函 数的类或结构体) 的初始化方法提供了<strong>统一的桥梁</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicFoo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">MagicFoo(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">it != <span class="built_in">list</span>.end(); ++it)</span><br><span class="line">vec.push_back(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// after C++11</span></span><br><span class="line">MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = magicFoo.vec.begin();</span><br><span class="line">it != magicFoo.vec.end(); ++it)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。</p><h5 id="2-2-3-结构化绑定"><a href="#2-2-3-结构化绑定" class="headerlink" title="2.2.3 结构化绑定"></a>2.2.3 结构化绑定</h5><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。C++11 新 增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。</p><p>但是，C++11/14 并没有提供一种 ==简单的方法== 直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p><p>C++ 17进行了完善, 给出的结构化绑定可以让我们写出这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int, double, std::string&gt; f() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = f();   <span class="comment">// 简单的进行拆包</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-类型推导"><a href="#2-3-类型推导" class="headerlink" title="2.3 类型推导"></a>2.3 类型推导</h4><p>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这 使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p><h5 id="2-3-1-auto"><a href="#2-3-1-auto" class="headerlink" title="2.3.1 auto"></a>2.3.1 auto</h5><p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11 之前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = vec.cbegin(); it != vec.cend(); ++it)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// C++ 11, 避免代码臭长</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.begin(); it != <span class="built_in">list</span>.end(); ++it)</span><br></pre></td></tr></table></figure><p>从C++ 20 起, auto 还支持函数传参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(i, j) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-decltype"><a href="#2-3-2-decltype" class="headerlink" title="2.3.2 decltype"></a>2.3.2 decltype</h5><p>decltype 关键字是为了解决 auto 关键字只能对<strong>变量</strong>进行类型推导的缺陷而出现的。它的用法和 typeof 很相似：decltype(表达式)。</p><p>有时候，我们可能需要计算某个表达式的类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-3-3-尾返回类型推导"><a href="#2-3-3-尾返回类型推导" class="headerlink" title="2.3.3 尾返回类型推导"></a>2.3.3 尾返回类型推导</h5><p>typename 和 class 在模板参数列表中<strong>没有区别</strong>，在 typename 这个关键字出现之前，都 是使用 class 来定义模板参数的。但在模板中定义有==嵌套依赖类型的变量==时，需要用 ==typename消除歧义== 。</p><p>在介绍 auto 时，我们已经提过 auto 不能用于函数形参进行类型推导，那么 auto 能不能用于推导函数的返回类型呢？例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码很差，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 decltype 推导 x+y 的类型，写出这样的代码：</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) add(T x, U y)</span><br></pre></td></tr></table></figure><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定 义。</p><p>C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键 字将返回类型后置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add2(T x, U y) -&gt; decltype(x+y)&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  C++14 开始是可以直接让普通函数具备返回值推导, 直接写成</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-decltype-auto"><a href="#2-3-4-decltype-auto" class="headerlink" title="2.3.4 decltype(auto)"></a>2.3.4 decltype(auto)</h5><p>decltype(auto) 是 C++14 开始提供的一个略微复杂的用法。</p><p>简单来说，decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的 指定 decltype 的参数表达式。</p><p>学完语言运行时强化  再回头看</p><h4 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h4><h5 id="2-4-1-if-constexpr"><a href="#2-4-1-if-constexpr" class="headerlink" title="2.4.1 if constexpr"></a>2.4.1 if constexpr</h5><p>C++11 引入了 constexpr 关键字，它将表达式或函数编译为常量结果。</p><p>一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断， 岂不是能让程序效率更高？</p><p>C++17 将 constexpr 这个关键字引入到 if 语句中，<strong>允许在代码中声明常量表达式的判断条件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在编译时，实际代码就会表现为如下：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-2-区间for循环"><a href="#2-4-2-区间for循环" class="headerlink" title="2.4.2 区间for循环"></a>2.4.2 区间for循环</h5><p>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">element += <span class="number">1</span>; <span class="comment">// writeable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h4><p>模板的哲学在于将一切能够在编译期处理的问题丢到<strong>编译期</strong>进行处理，仅在运行时处理那些最核心的动 态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</p><h5 id="2-5-1-外部模板"><a href="#2-5-1-外部模板" class="headerlink" title="2.5.1 外部模板"></a>2.5.1 外部模板</h5><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中 编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。 并且，我们没有办法通知编译器不要触发模板的实例化。 </p><p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能 够显式的通知编译器何时进行模板的实例化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>; <span class="comment">// 强行实例化 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure><h5 id="2-5-2-类型别名模板"><a href="#2-5-2-类型别名模板" class="headerlink" title="2.5.2 类型别名模板"></a>2.5.2 类型别名模板</h5><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的</strong>。在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一 个新的名称。因为，模板不是类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T dark;</span><br><span class="line">U magic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法, 因为模板不是类型, 所以使用typedef 不能定义新的名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MagicType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; FakeDarkMagic;</span><br></pre></td></tr></table></figure><p>C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，</span></span><br><span class="line"><span class="comment">// 但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*process)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">using</span> NewProcess = <span class="keyword">int</span>(*)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TrueDarkMagic&lt;<span class="keyword">bool</span>&gt; you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-3-变长参数模板"><a href="#2-5-3-变长参数模板" class="headerlink" title="2.5.3 变长参数模板"></a>2.5.3 变长参数模板</h5><p>在 C++11 之前，无论是类模板 还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数, 所以也可以是0个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;</span><span class="keyword">int</span>,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; darkMagic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;</span>&gt; nothing;</span><br></pre></td></tr></table></figure><p>定义了变长的模板参数，如何对==参数解包==呢？</p><p>首先，我们可以使用 <strong>sizeof…</strong> 来计算参数的个数，：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理 手法：</p><ol><li><p>递归模板函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，</span></span><br><span class="line"><span class="comment">// 进而达到递归遍历所有模板参数的目的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">printf1(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">printf1(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变参模板展开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 printf 的编写</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t0 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化列表展开</p><p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">(<span class="keyword">void</span>) <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行</span></span><br><span class="line"><span class="comment">//前面的 lambda 表达式，完成参数的输出。为了避免编译器警告，我们可以将 std::initializer_list</span></span><br><span class="line"><span class="comment">//显式的转为 void。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h5 id="2-5-4-非类型模板参数推导"><a href="#2-5-4-非类型模板参数推导" class="headerlink" title="2.5.4 非类型模板参数推导"></a>2.5.4 非类型模板参数推导</h5><p>前面我们主要提及的是模板参数的一种形式：类型模板参数。<strong>其中模板的参数 T 和 U 为具体的类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但还有一种常见模板参数形式可以<strong>让不同字面量成为模板参数</strong>，即非类型模板参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> BufSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">buffer_t</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T data[BufSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">buffer_t</span>&lt;<span class="keyword">int</span>, <span class="number">100</span>&gt; buf; <span class="comment">// 100 作为模板参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 C++11 引入了类型推导这 一特性后，我们会很自然的问，既然此处的模板参数以具体的字面量进行传递，能否让编译器辅助我们 进行类型推导，通过使用占位符 auto 从而不再需要明确指明类型？</p><p>C++17 引入了这一特性， 我们的确可以 auto 关键字，让编译器辅助完成具体类型的推导，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">foo&lt;<span class="number">10</span>&gt;(); <span class="comment">// value 被推导为 int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-面向对象"><a href="#2-6-面向对象" class="headerlink" title="2.6 面向对象"></a>2.6 面向对象</h4><h5 id="2-6-1-委托构造"><a href="#2-6-1-委托构造" class="headerlink" title="2.6.1 委托构造"></a>2.6.1 委托构造</h5><p>C++11 引入了委托构造的概念，这使得<strong>构造函数可以在同一个类中一个构造函数调用另一个构造函数</strong>，从而达到简化代码的目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value1;</span><br><span class="line"><span class="keyword">int</span> value2;</span><br><span class="line">Base() &#123;</span><br><span class="line">value1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> value) : Base() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">value2 = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-2-继承构造"><a href="#2-6-2-继承构造" class="headerlink" title="2.6.2 继承构造"></a>2.6.2 继承构造</h5><p>在传统 C++ 中，<strong>构造函数如果需要继承</strong>是需要将参数一一传递的，这将导致效率低下。C++11 利 用关键字 using 引入了继承构造函数的概念：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value1;</span><br><span class="line"><span class="keyword">int</span> value2;</span><br><span class="line">Base() &#123;</span><br><span class="line">value1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> value) : Base() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">value2 = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-3-显式虚函数重载"><a href="#2-6-3-显式虚函数重载" class="headerlink" title="2.6.3 显式虚函数重载"></a>2.6.3 显式虚函数重载</h5><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SubClass::foo 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。</p><p>另 一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成 为了一个普通的类方法，这将造成灾难性的后果。</p><p>C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生。</p><ul><li><p>override 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass1</span> <span class="keyword">final</span>:</span> Base &#123;</span><br><span class="line">&#125;; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass2</span> :</span> SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass3</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-6-4-显式禁用默认函数"><a href="#2-6-4-显式禁用默认函数" class="headerlink" title="2.6.4 显式禁用默认函数"></a>2.6.4 显式禁用默认函数</h5><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成<strong>默认构造函数、复制构造、赋值 算符以及析构函数</strong>。另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。当程序员有需要时， 可以重载这部分函数。</p><p>这就引发了一些需求：无法精确控制默认函数的生成行为。例如禁止类的拷贝时，必须将复制构造 函数与赋值算符声明为 private。尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p><p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Magic() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">Magic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">Magic(<span class="keyword">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-5-强类型枚举"><a href="#2-6-5-强类型枚举" class="headerlink" title="2.6.5 强类型枚举"></a>2.6.5 强类型枚举</h5><p>在传统 C++ 中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类 型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型 的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p><p>C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3 = <span class="number">100</span>,</span><br><span class="line">value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数 字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那 么可以进行比较。</p><p>如果我们希望获得枚举值的时候， 将必须显式的进行类型转换，不过我们可以通过重载 &lt;&lt; 这个算符来 进行输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_enum&lt;T&gt;::value,</span><br><span class="line"><span class="built_in">std</span>::ostream&gt;::type&amp; stream, <span class="keyword">const</span> T&amp; e)&#123;</span><br><span class="line"><span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&#123;</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3 = <span class="number">100</span>,</span><br><span class="line">value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (new_enum::value3 == new_enum::value4)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;new_enum::value3 == new_enum::value4&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; new_enum::value3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-语言运行期的强化"><a href="#三-语言运行期的强化" class="headerlink" title="三 语言运行期的强化"></a>三 语言运行期的强化</h3><h4 id="3-1-Lambda-表达式"><a href="#3-1-Lambda-表达式" class="headerlink" title="3.1 Lambda 表达式"></a>3.1 Lambda 表达式</h4><p>Lambda 表达式，实际上就是提供了一个类 似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用 的。</p><p>Lambda 表达式的基本语法如下：</p><p><code>[捕获列表](参数列表)</code> mutable(可选) 异常属性 -&gt; 返回类型 { // 函数体 }</p><p> 所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下<strong>是不能够使用函数体外部的变量</strong>的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列 表也分为以下几种：</p><ol><li><p>值捕获 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被<strong>创建时拷贝</strong>，而非调用时才拷贝。</p></li><li><p>引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化。</p></li><li><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时 候可以在捕获列表中写一个 &amp; 或 = 向编译器声明采用引用捕获或者值捕获.</p><p>捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表 </li><li>[name1, name2, . . . ] 捕获一系列变量 </li><li>[&amp;] 引用捕获, 让编译器自行推导引用列表 </li><li> [=] 值捕获, 让编译器自行推导值捕获列表</li></ul></li><li><p>表达式捕获</p><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的<strong>均为左值</strong>，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被 声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> important = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = <span class="built_in">std</span>::move(important)](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h4><h5 id="3-2-1-std-function"><a href="#3-2-1-std-function" class="headerlink" title="3.2.1 std::function"></a>3.2.1 std::function</h5><p>Lambda 表达式的本质是一个和<strong>函数对象类型相似的类类型</strong>（称为闭包类型）的对象（称为闭包对象），当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void(int), 参考https://stackoverflow.com/questions/34437557/difference-between-voidint-void-int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo = <span class="keyword">void</span>(<span class="keyword">int</span>); <span class="comment">// 定义 函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于 </span></span><br><span class="line"><span class="comment">//void functional(void(*f)(int) ) &#123; </span></span><br><span class="line"><span class="comment">//f(1); // 通过函数指针调用函数</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">functional(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    </span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用，而另一种 则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，<strong>将能够被调用的对象的类型，统一称之为可调用类型</strong>。而这种类型，便是通过 std::function 引入的。</p><p>C++11 std::function 是一种通用、多态的函数封装，<strong>它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作</strong>，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数 指针的调用不是类型安全的），换句话说，就是函数的容器。</p><p>当我们有了函数的容器之后便能够更加方便 的将函数、函数指针作为对象进行处理。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func = foo;</span><br><span class="line"><span class="keyword">int</span> important = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func2 = [&amp;](<span class="keyword">int</span> value) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func2(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-std-bind-和-std-placeholder"><a href="#3-2-2-std-bind-和-std-placeholder" class="headerlink" title="3.2.2 std::bind 和 std::placeholder"></a>3.2.2 std::bind 和 std::placeholder</h5><p>std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以<strong>将部分调用参数提前绑定到函数身上</strong>成为一 个新的对象，然后在参数齐全后，完成调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将参数 1,2 绑定到函数 foo 上，</span></span><br><span class="line"><span class="comment">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line"><span class="keyword">auto</span> bindFoo = <span class="built_in">std</span>::bind(foo, <span class="built_in">std</span>::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">bindFoo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h4><p>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大 量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能。</p><h5 id="3-3-1-左值、右值、纯右值、将亡值"><a href="#3-3-1-左值、右值、纯右值、将亡值" class="headerlink" title="3.3.1 左值、右值、纯右值、将亡值"></a>3.3.1 左值、右值、纯右值、将亡值</h5><p><strong>左值</strong> (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋 值表达式）后依然存在的持久对象。</p><p><strong>右值</strong> (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。</p><p>也有人将左值翻译为locator value, 意思是可以在内存中找到地址。右值为read value。而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p><p><strong>纯右值</strong> (prvalue, pure rvalue)，纯粹的右值，要么是<strong>纯粹的字面量</strong>，例如 10, true；要么是<strong>求值结果相当于字面量或匿名临时对象</strong>，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。==需要注意的是==，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 正确，&quot;01234&quot; 类型为 const char [6]，因此是左值</span></span><br><span class="line">const char (&amp;left)[6] = &quot;01234&quot;;</span><br><span class="line"><span class="comment">// 断言正确，确实是 const char [6] 类型，注意 decltype(expr) 在 expr 是左值</span></span><br><span class="line"><span class="comment">// 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="string">&quot;01234&quot;</span>), <span class="keyword">const</span> <span class="keyword">char</span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 错误，&quot;01234&quot; 是左值，不可被右值引用</span></span><br><span class="line"><span class="comment">// const char (&amp;&amp;right)[6] = &quot;01234&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将亡值</strong> (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中，纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = foo();</span><br></pre></td></tr></table></figure><blockquote><p>在这样的代码中，就传统的理解而言，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，<strong>会将整个 temp 拷贝一份，然后把 temp 销毁</strong>，如果这个 temp 非常大，这将造成大量 额外的开销（这也就是传统 C++ 一直被诟病的问题）。</p><p>在最后一行中，v 是左值、foo() 返回的值就是 右值（也是纯右值）。但是，v 可以被别的变量捕获到，而 foo() 产生的那个返回值作为一个临时值，一 旦被 v 复制后，将立即被销毁，无法获取、也不能修改。</p><p>而将亡值就定义了这样一种行为：<strong>临时的值能够被识别、同时又能够被移动。</strong></p></blockquote><p>在 C++11 之后，编译器为我们做了一些工作，<strong>此处的左值 temp 会被进行此隐式右值转换</strong>，等价于 static_cast &amp;&amp;&gt;(temp)，进而此处的 v 会将 foo 局部返回的值进行移动。也就是 后面我们将会提到的移动语义。</p><h5 id="3-3-2-右值引用和左值引用"><a href="#3-3-2-右值引用和左值引用" class="headerlink" title="3.3.2 右值引用和左值引用"></a>3.3.2 右值引用和左值引用</h5><p><strong>要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。</strong>右值引用的声明让这个临时值的 生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p><p> C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> lv1 = <span class="string">&quot;string,&quot;</span>; <span class="comment">// lv1 是一个左值</span></span><br><span class="line"><span class="comment">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv1 = <span class="built_in">std</span>::move(lv1); <span class="comment">// 合法, std::move 可以将左值转移为右值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; lv2 = lv1 + lv1; <span class="comment">// 合法, 常量左值引用能够延长临时变量的生命周期</span></span><br><span class="line"><span class="comment">// lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">rv2 += <span class="string">&quot;Test&quot;</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,string,Test</span></span><br><span class="line">    </span><br><span class="line">reference(rv2); <span class="comment">// 输出左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。</p><h5 id="3-3-3-移动语义"><a href="#3-3-3-移动语义" class="headerlink" title="3.3.3 移动语义"></a>3.3.3 移动语义</h5><p>传统 C++ 通过<strong>拷贝构造函数和赋值操作符</strong>为类对象设计了<strong>拷贝/复制</strong>的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> *pointer;</span><br><span class="line"></span><br><span class="line">A() : pointer(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 构造&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A(A &amp;a) : pointer(<span class="keyword">new</span> <span class="keyword">int</span>(*a.pointer)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 拷贝&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">// 无意义的对象拷贝</span></span><br><span class="line">    </span><br><span class="line">A(A &amp;&amp;a) : pointer(a.pointer) &#123;</span><br><span class="line">a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 移动&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 析构&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止编译器优化</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="keyword">bool</span> test)</span> </span>&#123;</span><br><span class="line">A a, b;</span><br><span class="line"><span class="keyword">if</span> (test) <span class="keyword">return</span> a; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A obj = return_rvalue(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; obj.pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *obj.pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 运行结果</span><br><span class="line"></span><br><span class="line">构造 0x2353eb0</span><br><span class="line"> 构造 0x2354ee0</span><br><span class="line"> 移动 0x2354ee0</span><br><span class="line"> 析构 0</span><br><span class="line"> 析构 0x2353eb0</span><br><span class="line">cout obj:</span><br><span class="line">0x2354ee0</span><br><span class="line">1</span><br><span class="line"> 析构 0x2354ee0</span><br></pre></td></tr></table></figure><ol><li>首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出；</li><li><strong>函数返回后，产生一个将亡值</strong>，被 A 的移动构造（A(A&amp;&amp;)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。</li></ol><p>从而避免了无意义的拷贝构造，加强了性能。</p></blockquote><h5 id="3-3-4-完美转发"><a href="#3-3-4-完美转发" class="headerlink" title="3.3.4 完美转发"></a>3.3.4 完美转发</h5><p>前面我们提到了(3.3.2 小节)，<strong>一个声明的右值引用其实是一个左值</strong>。这就为我们进行参数转发（传递）造成了 问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 普通传参:&quot;</span>;</span><br><span class="line">reference(v); <span class="comment">// 始终调用 reference(int&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">pass(<span class="number">1</span>); <span class="comment">// 1 是右值, 但输出是左值</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">pass(l); <span class="comment">// l 是左值, 输出左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于 pass(1) 来说，虽然传递的是右值，但由于 <strong>v 是一个引用，所以同时也是左值</strong>。因此 reference(v) 会调用 reference(int&amp;)，输出『左值』。而对于 pass(l) 而言，l 是一个左值，为什么 会成功传递给 pass(T&amp;&amp;) 呢？</p><p>这是基于引用坍缩规则的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由 于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，既能左引 用，又能右引用。但是却遵循如下规则：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118225944987.png" class="" title="image-20221118225944987"><p>准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为 右引用类型。这才使得 v 作为左值的成功传递。</p><p><strong>完美转发就是基于上述规律产生的。</strong>所谓完美转发，就是为了让我们在传递参数的时候，保持原来的参数类型（左引用保持左引用，右引用保持右引用）。为了解决这个问题，我们应该使用 std::forward 来进行参数的转发（传递）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值引用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值引用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 普通传参: &quot;</span>;</span><br><span class="line">reference(v);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; std::move 传参: &quot;</span>;</span><br><span class="line">reference(<span class="built_in">std</span>::move(v));</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; std::forward 传参: &quot;</span>;</span><br><span class="line">reference(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;</span>;</span><br><span class="line">reference(<span class="keyword">static_cast</span>&lt;T &amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">pass(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">    pass(v);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，所以 std::move 总会接受到一个左值，从而转发调用了 reference(int&amp;&amp;) 输出右值引用。 </p><p>唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发 (传递) 了函数的实参给了内部调用 的其他函数。</p><p> std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值， std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看，std::forward(v) 和 static_cast(v) 是完全一样的。</p></blockquote><h3 id="四-容器"><a href="#四-容器" class="headerlink" title="四 容器"></a>四 容器</h3><h4 id="4-1-线性容器"><a href="#4-1-线性容器" class="headerlink" title="4.1 线性容器"></a>4.1 线性容器</h4><h5 id="4-1-1-std-array"><a href="#4-1-1-std-array" class="headerlink" title="4.1.1 std::array"></a>4.1.1 std::array</h5><ol><li><p>为什么要引入 std::array 而不是直接使用 std::vector？ </p><blockquote><p>与 std::vector 不同，std::array 对象的大小是固定的，<strong>如果容器大小是固定的，那么可以优先考虑使用 std::array 容器</strong>。另外由于 std::vector 是自动扩容的，当存入大量的 数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候就需要手动 运行 shrink_to_fit() 释放这部分内存。</p></blockquote></li><li><p>已经有了传统数组，为什么要用 std::array?</p><blockquote><p>使用 std::array 能够让代码变得更加 ‘‘现代化’’，而且封装了一些操作函 数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort。</p></blockquote></li></ol><h5 id="4-1-2-std-forward-list"><a href="#4-1-2-std-forward-list" class="headerlink" title="4.1.2 std::forward_list"></a>4.1.2 std::forward_list</h5><p>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进 行介绍了。 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一 个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</p><h4 id="4-2-无序容器"><a href="#4-2-无序容器" class="headerlink" title="4.2 无序容器"></a>4.2 无序容器</h4><p>传统 C++ 中的<strong>有序容器 std::map/std::set</strong>，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 &lt; 操作符比较元素大小并判断元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 &lt; 操作符的顺序来逐个遍历。</p><p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。</p><p>C++11 引入了的两组无序容器分别是：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。</p><h4 id="4-3-元组"><a href="#4-3-元组" class="headerlink" title="4.3 元组"></a>4.3 元组</h4><p>关于元组的使用有三个核心的函数： </p><ol><li>std::make_tuple: 构造元组 </li><li>std::get: 获得元组某个位置的值</li><li>std::tie: 元组拆包</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">3.8</span>, ’A’, <span class="string">&quot; 张三&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">2.9</span>, ’C’, <span class="string">&quot; 李四&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1.7</span>, ’D’, <span class="string">&quot; 王五&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">0.0</span>, ’D’, <span class="string">&quot;null&quot;</span>);</span><br><span class="line"><span class="comment">// 如果只写 0 会出现推断错误, 编译失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> student = get_student(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: 0, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(student) &lt;&lt; ’\n’;</span><br><span class="line"><span class="keyword">double</span> gpa;</span><br><span class="line"><span class="keyword">char</span> grade;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="comment">// 元组进行拆包</span></span><br><span class="line"><span class="built_in">std</span>::tie(gpa, grade, name) = get_student(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: 1, &quot;</span> &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; gpa &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名: &quot;</span> &lt;&lt; name &lt;&lt; ’\n’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::get 除了使用常量获取元组对象外，C++14 增加了<strong>使用类型来获取元组中的对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;std::string, double, double, int&gt; t(&quot;123&quot;, 4.5, 6.7, 8);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">double</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 非法, 引发编译期错误</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">3</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="4-3-1-运行期索引"><a href="#4-3-1-运行期索引" class="headerlink" title="4.3.1 运行期索引"></a>4.3.1 运行期索引</h5><p>如果你仔细思考一下可能就会发现上面代码的问题，std::get&lt;&gt; 依赖一个编译期的常量，所以下面 的方式是不合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::get&lt;index&gt;(t);</span><br></pre></td></tr></table></figure><p>那么要怎么处理？答案是，使用 std::variant&lt;&gt;（C++ 17 引入），提供给 variant&lt;&gt; 的类型模板参数可以让一个 variant&lt;&gt; 从而容纳提供的几种类型的变量:</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118232359960.png" class="" title="image-20221118232359960"><p>这样就可以:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tuple_index(t, i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-元组合并与遍历"><a href="#4-3-2-元组合并与遍历" class="headerlink" title="4.3.2 元组合并与遍历"></a>4.3.2 元组合并与遍历</h5><p>还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;std::string, double, double, int&gt; t(&quot;123&quot;, 4.5, 6.7, 8);</span><br><span class="line"><span class="keyword">auto</span> new_tuple = <span class="built_in">std</span>::tuple_cat(get_student(<span class="number">1</span>), <span class="built_in">std</span>::move(t));</span><br></pre></td></tr></table></figure><h3 id="五-智能指针"><a href="#五-智能指针" class="headerlink" title="五 智能指针"></a>五 智能指针</h3><h4 id="5-1-RALL与引用计数"><a href="#5-1-RALL与引用计数" class="headerlink" title="5.1 RALL与引用计数"></a>5.1 RALL与引用计数</h4><p>引用计数这种计数是为了防止内存泄 露而产生的。基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那 么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减 为零时，就自动删除指向的堆内存。</p><p><strong>『记得』手动释放资源，总不是最佳实践。</strong>因为我们很有可能就忘记了去释放资源 而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在 离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。</p><p>而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序 员不再需要关心手动释放内存。这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr， 使用它们需要包含头文件 。</p><h4 id="5-2-std-shared-ptr"><a href="#5-2-std-shared-ptr" class="headerlink" title="5.2 std::shared_ptr"></a>5.2 std::shared_ptr</h4><p>std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当<strong>引用计数变为零</strong>的时候就会将对象自动删除。</p><p>但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。 </p><p>std::make_shared 就能够用来消除显式的使用 new，所以 std::make_shared 会分配创建传入参 数中的对象，并返回这个对象类型的 std::shared_ptr 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; i)</span> </span>&#123;</span><br><span class="line">(*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// auto pointer = new int(10); // illegal, no direct assignment</span></span><br><span class="line"><span class="comment">// Constructed a std::shared_ptr</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> pointer = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">foo(pointer);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// The shared_ptr will be destructed before leaving the scope</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::shared_ptr 可以通过 <strong>get() 方法</strong>来获取原始指针，通过 <strong>reset()</strong> 来减少一个引用计数，并 通过 <strong>use_count()</strong> 来查看一个对象的引用计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数 +1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = pointer.get(); <span class="comment">// 这样不会增加引用计数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">pointer2.reset();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reset pointer2:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="5-3-std-unique-ptr"><a href="#5-3-std-unique-ptr" class="headerlink" title="5.3 std::unique_ptr"></a>5.3 std::unique_ptr</h4><p>std::unique_ptr 是一种<strong>独占的智能指针</strong>，它禁止其他智能指针与其共享同一个对象，从而保证代 码的安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pointer = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_unique 从 C++14 引入</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pointer2 = pointer; <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是C++ 11 中没有实现make_unique, 据说是忘记了, 可以自己实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp; ...args )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;( <span class="keyword">new</span> T( <span class="built_in">std</span>::forward&lt;Args&gt;(args)... ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr。</p><h4 id="5-4-weak-ptr"><a href="#5-4-weak-ptr" class="headerlink" title="5.4 weak_ptr"></a>5.4 weak_ptr</h4><p>如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;B&gt; pointer;</span><br><span class="line"></span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;A&gt; pointer;</span><br><span class="line"></span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">std</span>::make_shared&lt;A&gt;();</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">std</span>::make_shared&lt;B&gt;();</span><br><span class="line">a-&gt;pointer = b;</span><br><span class="line">b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引 用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却只能造成这块区域的引用计数减一，这样 就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了 内存泄露，如图:</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119152443945.png" class="" title="image-20221119152443945"></blockquote><p>解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr 是一种弱引用（相比较 而言 std::shared_ptr 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的 释放流程如图 5.2 所示：<img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119152600314.png" class="" title="image-20221119152600314"></p><p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。 </p><p>*<em>std::weak_ptr 没有 * 运算符和 -&gt; 运算符*</em>，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true； 除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未 被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回 nullptr。</p><h3 id="六-正则表达式"><a href="#六-正则表达式" class="headerlink" title="六 正则表达式"></a>六 正则表达式</h3><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p><ul><li>检查一个串是否包含某种形式的子串；</li><li>将匹配的子串替换</li><li>从某个串中取出符合条件的子串。</li></ul><h4 id="6-1-正则表达式简介"><a href="#6-1-正则表达式简介" class="headerlink" title="6.1 正则表达式简介"></a>6.1 正则表达式简介</h4><h5 id="6-1-1-特殊字符"><a href="#6-1-1-特殊字符" class="headerlink" title="6.1.1 特殊字符"></a>6.1.1 特殊字符</h5><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153031490.png" class="" title="image-20221119153031490"><h5 id="6-1-2-限定符"><a href="#6-1-2-限定符" class="headerlink" title="6.1.2 限定符"></a>6.1.2 限定符</h5><p>限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153120714.png" class="" title="image-20221119153120714"><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153137416.png" class="" title="image-20221119153137416"><h4 id="6-2-std-regex-及其相关"><a href="#6-2-std-regex-及其相关" class="headerlink" title="6.2 std::regex 及其相关"></a>6.2 std::regex 及其相关</h4><p>对字符串内容进行匹配的最常见手段就是使用正则表达式。可惜在传统 C++ 中正则表达式一直没 有得到语言层面的支持，没有纳入标准库，而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时，使用正则表达式也是工业界最为成熟的普遍做法。</p><p><strong>C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex) 进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch（本质是 std::match_results 对象）。</strong></p><p>示例: </p><ul><li><code>[a-z]+\.txt</code>: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多 次，因此 [a-z]+ 能够匹配一个小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字 符，而 <code>\.</code> 则表示匹配字符 .，最后的 txt 表示严格匹配 txt 则三个字母。因此这个正则表达式的 所要匹配的内容就是由纯小写字母组成的文本文件。</li><li>std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是 传入 std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fnames[] = &#123;<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;a0.txt&quot;</span>, <span class="string">&quot;AAA.txt&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 在 C++ 中 \ 会被作为字符串内的转义符，</span></span><br><span class="line"><span class="comment">// 为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">txt_regex</span><span class="params">(<span class="string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">std</span>::regex_match(fname, txt_regex) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;现代-C-教程&quot;&gt;&lt;a href=&quot;#现代-C-教程&quot; class=&quot;headerlink&quot; title=&quot;现代 C++ 教程&quot;&gt;&lt;/a&gt;现代 C++ 教程&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;现代 C++&lt;/strong&gt; (本书中均指 C++11/14/17/20)</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>现代化Cmake</title>
    <link href="http://okeyia.github.io/2022/11/06/Modern_CMake/"/>
    <id>http://okeyia.github.io/2022/11/06/Modern_CMake/</id>
    <published>2022-11-06T06:29:04.000Z</published>
    <updated>2022-11-06T15:12:38.069Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Modern-CMake"><a href="#Modern-CMake" class="headerlink" title="Modern CMake"></a>Modern CMake</h2><blockquote><p>现代的 CMake 是指 CMake 3.4+ ，甚至是 CMake 3.21+ ！ 它简洁、强大、优雅，所以你能够花费你的大部分时间在编写代码上，而不是在一个不可读、不可维护的 Make （或 CMake 2） 文件上浪费时间。 并且 CMake 3.11+ 的构建速度应该也会更加的快！！！</p></blockquote><h3 id="一-基础知识简介"><a href="#一-基础知识简介" class="headerlink" title="一 基础知识简介"></a>一 基础知识简介</h3><hr><h4 id="1-1-最低版本要求"><a href="#1-1-最低版本要求" class="headerlink" title="1.1 最低版本要求"></a>1.1 最低版本要求</h4><p>这是每个 <code>CMakeLists.txt</code> 都必须包含的第一行，默认小写</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br></pre></td></tr></table></figure><p><code>CMake</code> 的版本与它的特性（policies）相互关联，这意味着它也定义了 <code>CMake</code> 行为的变化。</p><h4 id="1-2-设置一个项目"><a href="#1-2-设置一个项目" class="headerlink" title="1.2 设置一个项目"></a>1.2 设置一个项目</h4><p>每一个顶层 CMakelists 文件都应该有下面这一行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(MyProject VERSION <span class="number">1.0</span></span><br><span class="line">                  DESCRIPTION <span class="string">&quot;Very nice project&quot;</span></span><br><span class="line">                  LANGUAGES CXX)</span><br></pre></td></tr></table></figure><p>项目名称是这里的第一个参数。所有的关键字参数都可选的。<code>VERSION</code> 设置了一系列变量，例如 <code>MyProject_VERSION</code> 和 <code>PROJECT_VERSION</code>。<code>DESCRIPTION</code>，对项目进行简单介绍。语言最好不写，英文c++中项目中，可能存在个别的C文件。</p><h4 id="1-3-生成可执行文件"><a href="#1-3-生成可执行文件" class="headerlink" title="1.3 生成可执行文件"></a>1.3 生成可执行文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(one two.cpp three.h)</span><br></pre></td></tr></table></figure><p><code>one</code> 既是生成的可执行文件的名称，也是创建的 <code>CMake</code> 目标(target)的名称。</p><p>紧接着的是源文件的列表，你想列多少个都可以。CMake 很聪明 ，它根据拓展名只编译源文件。</p><p>在大多数情况下，<strong>头文件将会被忽略</strong>；列出他们的唯一原因是为了让他们在 IDE 中被展示出来，目标文件在许多 IDE 中被显示为文件夹。</p><h4 id="1-4-生成一个库"><a href="#1-4-生成一个库" class="headerlink" title="1.4 生成一个库"></a>1.4 生成一个库</h4><p>制作一个库是通过 <code>add_library</code> 命令完成的，并且非常简单：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(one STATIC two.cpp three.h)</span><br></pre></td></tr></table></figure><p>你可以选择库的类型，可以是 <code>STATIC</code>,<code>SHARED</code>, 或者<code>MODULE</code>. </p><ul><li>STATIC 库是链接其他目标时使用的目标文件档案（archives）。</li><li>SHARED 库是动态链接的，并在运行时加载。</li><li>MODULE 库是未链接到其他目标但可以在运行时使用类似 dlopen 的功能动态加载的插件。</li></ul><p><strong>生成的library名会根据<code>STATIC</code>或<code>SHARED</code>成为<code>name.a</code>或<code>name.lib</code>。</strong></p><p>如果你不选择它，CMake 将会通过 <code>BUILD_SHARED_LIBS</code> 的值来选择构建 STATIC 还是 SHARED 类型的库。</p><h4 id="1-5-目标时常伴随着你"><a href="#1-5-目标时常伴随着你" class="headerlink" title="1.5 目标时常伴随着你"></a>1.5 目标时常伴随着你</h4><p>现在我们已经指定了一个目标，那我们如何添加关于它的信息呢？例如，它可能需要包含一个目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(one PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><blockquote><p>The <code>INTERFACE</code>, <code>PUBLIC</code> and <code>PRIVATE</code> keywords are required to specify the scope of the following arguments.</p></blockquote><p><code>target_include_directories</code>  指定编译给定目标时要使用的包含目录。命名的 <code>&lt;target&gt;</code> 必须是由 <code>add_executable()</code> 或  <code>add_library()</code>  等命令创建的，并且不能是 ALIAS 目标。</p><p> <code>PUBLIC</code> 对于一个二进制目标没有什么含义；但对于库来说，它让 CMake 知道，任何链接到这个目标的目标也必须包含这个目录。</p><p>其他选项还有 <code>PRIVATE</code>（只影响当前目标，不影响依赖），以及 <code>INTERFACE</code>（只影响依赖）。</p><p>接下来我们可以将目标之间链接起来：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(another STATIC another.cpp another.h)</span><br><span class="line"></span><br><span class="line"><span class="comment">#target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...)</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(another PUBLIC one)</span><br></pre></td></tr></table></figure><p><code>target_link_libraries</code> 指定一个目标，并且在给出目标的情况下添加一个依赖关系。</p><p>如果不存在名称为 <code>one</code> 的目标，那他会添加一个链接到你路径中 <code>one</code> 库（这也是命令叫 <code>target_link_libraries</code> 的原因）。<strong>或者</strong>你可以给定一个库的完整路径，或者是链接器标志。</p><p><em>最后再说一个有些迷惑性的知识：），经典的 CMake 允许你省略 <code>PUBLIC</code> 关键字，但是你在目标链中省略与不省略混用，那么 CMake 会报出错误。</em></p><h4 id="1-6-include-directories"><a href="#1-6-include-directories" class="headerlink" title="1.6 include_directories"></a>1.6 include_directories</h4><blockquote><p><strong><code>include_directories</code> ([<code>AFTER|BEFORE</code>] [<code>SYSTEM</code>] dir1 [dir2 …])</strong><br> 将指定目录添加到编译器的头文件搜索路径之下，指定的目录被解释成当前源码路径的相对路径。</p></blockquote><p>使用 <code>include_directories</code> 后, 不需在 <code>add_executable()</code> 里面添加 <code>test.h</code>, 编译器会自动寻找, 默认顺序是</p><p><strong><code>/usr/include</code></strong> -&gt; <strong><code>/usr/local/include</code></strong> -&gt; <strong><code>dir1</code></strong> -&gt; **<code>dir2</code>**。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">→ tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include       </span><br><span class="line">│   ├── test.cpp  </span><br><span class="line">│   └── test.h    </span><br><span class="line">└── main.cpp      </span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure><p>cmakeList.txt写法:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><p>有以下两种方式都可以让main函数运行成功:</p><ol><li>在main函数中, 直接使用<code>#include &quot;test.cpp&quot;</code></li><li>在main函数中, 使用#include “test.h”, 但是test.h 必须实现main调用的函数。</li></ol><h4 id="1-7-设置编译器选项以及编译选项"><a href="#1-7-设置编译器选项以及编译选项" class="headerlink" title="1.7 设置编译器选项以及编译选项"></a>1.7 设置编译器选项以及编译选项</h4><p>CMAKE_C_COMPILER：指定C编译器</p><p>CMAKE_CXX_COMPILER：指定C++编译器</p><p>CMAKE_C_FLAGS：指定编译C文件时编译选项，也可以通过add_definitions命令添加编译选项</p><p>在cmake脚本中，设置编译选项（配置编译器）有如下三种方法：</p><p><code>-Wall选项意思是编译后显示所有警告</code>; <code>-Werror选项意思是所有警告当做错误处理</code>。</p><ul><li><p>add_compile_options命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-Wall -Werror )</span><br></pre></td></tr></table></figure></li><li><p>add_definitions 命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_DEFINITIONS</span>(<span class="string">&quot;-Wall -Werror&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>set命令修改CMAKE_CXX_FLAGS 或 CMAKE_C_FLAGS</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;-Wall -Werror -Wstrict-prototypes -Wmissing-prototypes&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>使用这三种方式在有的情况下效果是一样的，但请注意它们还是有区别的：</p><p>add_compile_options命令和add_definitions添加的编译选项是针对所有编译器的(包括c和c++编译器)，而set命令设置CMAKE_C_FLAGS或CMAKE_CXX_FLAGS变量则是分别只针对c和c++编译器的。</p><h3 id="二-变量与缓存"><a href="#二-变量与缓存" class="headerlink" title="二 变量与缓存"></a>二 变量与缓存</h3><hr><h4 id="2-1-本地变量"><a href="#2-1-本地变量" class="headerlink" title="2.1 本地变量"></a>2.1 本地变量</h4><p>你可以这样声明一个本地 ( local ) 变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">&quot;value&quot;</span>)</span><br></pre></td></tr></table></figure><p>变量名通常全部用大写，变量值跟在其后。你可以通过 <code>$&#123;&#125;</code> 来解析一个变量，例如 <code>$&#123;MY_VARIABLE&#125;</code>.</p><p>列表就是简单地包含一系列变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;one&quot;</span> <span class="string">&quot;two&quot;</span>)</span><br></pre></td></tr></table></figure><p>你也可以通过 <code>;</code> 分隔变量，这和空格的作用是一样的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;one;two&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-2-缓存变量"><a href="#2-2-缓存变量" class="headerlink" title="2.2 缓存变量"></a>2.2 缓存变量</h4><p>CMake 提供了一个缓存变量来允许你从命令行中设置变量。CMake 中已经有一些预置的变量，像 <code>CMAKE_BUILD_TYPE</code>。</p><p>通过 <code>set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</code>这个命令来设置的变量就是 Cache Variables。例如 <code>set(MY_CACHE_VAL &quot;666&quot; CACHE STRING INTERNAL)</code>，此时 MY_CACHE_VAL 就是一个 CACHE 变量。相当于一个全局变量，我们在同一个 cmake 工程中都可以使用。</p><ul><li>Cache 变量 CMAKE_INSTALL_PREFIX 默认值是 /usr/local (可以在生成的 CMakeCache.txt 文件中查看)，这时候如果我们 在某个 CMakeLists.txt 中，仍然使用 set(CMAKE_INSTALL_PREFIX “/usr”)，那么此时我们 install 的时候，CMake 以后面的 /usr 作为 CMAKE_INSTALL_PREFIX 的值，这是因为 CMake 规定，有一个与 Cache 变量同名的 Normal 变量出现时，后面使用这个变量的值都是以 Normal 为准，如果没有同名的 Normal 变量，CMake 才会自动使用 Cache 变量。</li><li>所有的 Cache 变量都会出现在 CMakeCache.txt 文件中。这个文件是我们键入 <code>cmake .</code>命令后自动出现的文件。打开这个文件发现，CMake 本身会有一些默认的全局 Cache 变量。例如：CMAKE_INSTALL_PREFIX、CMAKE_BUILD_TYPE、CMAKE_CXX_FLAGSS 等等。可以自行查看。当然，我们自己定义的 Cache 变量也会出现在这个文件中。Cache 变量定义格式为 <code>set(&lt;variable&gt; &lt;value&gt; CACHE STRING INTERNAL)</code>。这里的 <code>STRING</code>可以替换为 <code>BOOL</code> <code>FILEPATH</code> <code>PATH</code> ，但是要根据前面 value 类型来确定。参考。</li><li>修改 Cache 变量。可以通过 <code>set(&lt;variable&gt; &lt;value&gt; CACHE INSTERNAL FORCE)</code>，另一种方式是直接在终端中使用 <code>cmake -D var=value ..</code>来设定默认存在的CMake Cache 变量。</li></ul><h4 id="3-3-环境变量、缓存"><a href="#3-3-环境变量、缓存" class="headerlink" title="3.3 环境变量、缓存"></a>3.3 环境变量、缓存</h4><ul><li>你也可以通过 <code>set(ENV&#123;variable_name&#125; value)</code> 和 <code>$ENV&#123;variable_name&#125;</code> 来设置和获取环境变量，不过一般来说，我们最好避免这么用。</li><li>缓存实际上就是个文本文件，<code>CMakeCache.txt</code> ，当你运行 CMake 构建目录时会创建它。 CMake 可以通过它来记住你设置的所有东西，因此你可以不必在重新运行 CMake 的时候再次列出所有的选项。</li></ul><h3 id="三-寻找其他库"><a href="#三-寻找其他库" class="headerlink" title="三 寻找其他库"></a>三 寻找其他库</h3><h4 id="3-1-OpenMP"><a href="#3-1-OpenMP" class="headerlink" title="3.1 OpenMP"></a>3.1 OpenMP</h4><p><a href="https://cmake.org/cmake/help/latest/module/FindOpenMP.html">OpenMP</a> support was drastically improved in CMake 3.9+. The Modern(TM) way to add OpenMP to a target is:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenMP)</span><br><span class="line"><span class="keyword">if</span>(OpenMP_CXX_FOUND)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(MyTarget PUBLIC OpenMP::OpenMP_CXX)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h4 id="3-2-MPI"><a href="#3-2-MPI" class="headerlink" title="3.2 MPI"></a>3.2 MPI</h4><p>To add MPI, like OpenMP, you’ll be best off with CMake 3.9+.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MPI REQUIRED)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Run: $&#123;MPIEXEC&#125; $&#123;MPIEXEC_NUMPROC_FLAG&#125; $&#123;MPIEXEC_MAX_NUMPROCS&#125; $&#123;MPIEXEC_PREFLAGS&#125; EXECUTABLE $&#123;MPIEXEC_POSTFLAGS&#125; ARGS&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyTarget PUBLIC MPI::MPI_CXX)</span><br></pre></td></tr></table></figure><h3 id="四-参考链接"><a href="#四-参考链接" class="headerlink" title="四 参考链接"></a>四 参考链接</h3><ol><li><a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/">Modern CMake 简体中文版</a></li><li><a href="https://cliutils.gitlab.io/modern-cmake/">An Introduction to Modern CMake</a></li><li><a href="https://cmake.org/cmake/help/v3.15/manual/cmake-commands.7.html#id2">cmake-commands(7)</a></li><li><a href="https://www.cnblogs.com/lidabo/p/16661713.html">cmake cache变量_反复研究好几遍，我才发现关于 CMake 变量还可以这样理解！ </a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Modern-CMake&quot;&gt;&lt;a href=&quot;#Modern-CMake&quot; class=&quot;headerlink&quot; title=&quot;Modern CMake&quot;&gt;&lt;/a&gt;Modern CMake&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;现代的 CMake 是指 CMak</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="cmake" scheme="http://okeyia.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>Git学习以及配置</title>
    <link href="http://okeyia.github.io/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
    <id>http://okeyia.github.io/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/</id>
    <published>2022-11-05T06:11:13.000Z</published>
    <updated>2022-11-06T00:39:46.909Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Git学习以及配置"><a href="#Git学习以及配置" class="headerlink" title="Git学习以及配置"></a>Git学习以及配置</h2><h3 id="一-Git学习"><a href="#一-Git学习" class="headerlink" title="一 Git学习"></a>一 Git学习</h3><p>可视化 git 学习网站 <a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p><h4 id="1-1-git-checkout"><a href="#1-1-git-checkout" class="headerlink" title="1.1 git checkout"></a>1.1 git checkout</h4><p>用来切换分支,  表明当前所在的分支</p><p><em>在 Git2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）</em></p><h4 id="1-2-git-merge"><a href="#1-2-git-merge" class="headerlink" title="1.2 git merge"></a>1.2 git merge</h4><p>将其他的分支合并到当前的分支,   比如将bugFix 合并到main</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先切换到main分支</span></span><br><span class="line">git checkout main</span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105131530367.png" class="" title="image-20221105131530367"><h4 id="1-3-git-rebase"><a href="#1-3-git-rebase" class="headerlink" title="1.3 git rebase"></a>1.3 git rebase</h4><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p><strong>使用命令 git rebase main 后 发生的变化:</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140803587.png" class="" title="image-20221105140803587"><p>现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。<strong>注意</strong>，提交记录 C3 依然存在（树上那个半透明的节点），而 C3’ 是我们 Rebase 到 main 分支上的 C3 的副本。</p><p>此时main还未更新, 使用下列操作更新main。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105131320406.png" class="" title="image-20221105131320406"><p>由于 <code>bugFix</code> 继承自 <code>main</code>，所以 Git只是简单的把 <code>main</code> 分支的引用向前移动了一下而已。</p><h4 id="1-4-HEAD"><a href="#1-4-HEAD" class="headerlink" title="1.4 HEAD"></a>1.4 HEAD</h4><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p><p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git命令都是从改变 HEAD 的指向开始的。</p><p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p><p><strong>分离的HEAD:</strong> 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。</p><p><strong>举例说明：</strong></p><p><strong>执行以下操作：</strong> 发生的变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout c1</span><br><span class="line">git checkout main</span><br><span class="line">git commit</span><br><span class="line">git checkout c2 </span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140632320.png" class="" title="image-20221105140632320"><h4 id="1-5-撤销变更"><a href="#1-5-撤销变更" class="headerlink" title="1.5 撤销变更"></a>1.5 撤销变更</h4><p> Git里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p><p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p><h5 id="1-5-1-git-reset"><a href="#1-5-1-git-reset" class="headerlink" title="1.5.1 git reset"></a>1.5.1 git reset</h5><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105133031370.png" class="" title="image-20221105133031370"><p>原本的main 是指向c2的, 使用<code>git reset HEAD~1</code>后，main分支有迁回了c1，本地代码库就不知道c2的存在了。</p><h5 id="1-5-2-Git-Revert"><a href="#1-5-2-Git-Revert" class="headerlink" title="1.5.2 Git Revert"></a>1.5.2 Git Revert</h5><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><p><strong>使用命令： git revert HEAD</strong> 进行撤销。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140357585.png" class="" title="image-20221105140357585"><p>在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code>是相同的。</p><p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><h4 id="1-6-远程分支"><a href="#1-6-远程分支" class="headerlink" title="1.6 远程分支"></a>1.6 远程分支</h4><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p><p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><p><strong>远程仓库（在图示中）的样子：</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140500408.png" class="" title="image-20221105140500408"><h4 id="1-7-git-fetch"><a href="#1-7-git-fetch" class="headerlink" title="1.7 git fetch"></a>1.7 git fetch</h4><p>Git远程仓库相当的操作实际可以归纳为两点：</p><p><strong>向远程仓库传输数据以及从远程仓库获取数据</strong>。既然我们能与远程仓库同步，那么就可以分享任何能被 Git管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p>执行 <strong>git fetch</strong> 的变化：</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105134417699.png" class="" title="image-20221105134417699"><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><h4 id="1-8-git-pull"><a href="#1-8-git-pull" class="headerlink" title="1.8 git pull"></a>1.8 git pull</h4><p>然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/main</code></li><li><code>git rebase o/main</code></li><li><code>git merge o/main</code></li><li>等等</li></ul><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><ol><li><p>使用命令 <code>git fetch; git merge o/main</code></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105135236346.png" class="" title="image-20221105135236346"><p>我们用 <code>fetch</code> 下载了 <code>C3</code>, 然后通过 <code>git merge o/main</code> 合并了这一提交记录。现在我们的 <code>main</code> 分支包含了远程仓库中的更新（在本例中远程仓库名为 <code>origin</code>）</p></li><li><p>使用 <code>git pull</code> 可以达到同样的效果</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105135555684.png" class="" title="image-20221105135555684"></li></ol><h4 id="1-9-git-push"><a href="#1-9-git-push" class="headerlink" title="1.9 git push"></a>1.9 git push</h4><p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code> 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p><p>*注意 —— <code>git push</code> 不带任何参数时的行为与 Git的一个名为 <code>push.default</code> 的配置有关。它的默认值取决于你正使用的 Git的版本，但是在教程中我们使用的是 <code>upstream</code>*。</p><p><strong>使用 git push 后的变化：</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140045762.png" class="" title="image-20221105140045762"><p>远程仓库接收了 <code>C2</code>，远程仓库中的 <code>main</code> 分支也被更新到指向 <code>C2</code> 了，我们的远程分支 (o/main) 也同样被更新了。所有的分支都同步了！</p><h3 id="二-ssh-key-配置"><a href="#二-ssh-key-配置" class="headerlink" title="二 ssh-key 配置"></a>二 ssh-key 配置</h3><hr><h4 id="2-1-github-使用-token"><a href="#2-1-github-使用-token" class="headerlink" title="2.1 github 使用 token"></a>2.1 github 使用 token</h4><p>为了安全起见，github不再支持密码登录，改为了token，token就相当于一个比较安全的密码，获取到的token是全局的，可以对所有仓库进行操作</p><ol><li><p>获取token，在个人设置下，Developer settings中，新增token</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105112248257.png" class="" title="image-20221105112248257"></li><li><p>拿到token后，有两种使用方式</p><ul><li><p>使用git的时候，每次输入账号密码，这里的密码就是token，但是每次使用都要输入，比较麻烦</p></li><li><p>在git中的远程分支添加token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除原来的分支</span></span><br><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加由token构成的新分支</span></span><br><span class="line">git remote add origin https://token(这里改为自己的token)/okeyia/gem5_vans.git</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105112958726.png" class="" title="image-20221105112958726"></li><li><p>然后就可以愉快的 <code>git push origin master</code>了</p></li></ul></li></ol><h4 id="2-2-github-添加私钥"><a href="#2-2-github-添加私钥" class="headerlink" title="2.2 github 添加私钥"></a>2.2 github 添加私钥</h4><p>这里的话配置的是 <strong>某个仓库</strong> 的私钥，只允许对某个仓库进行操作。第 <strong>2.1</strong> 章节 配置的全局的私钥，可以对账号下面的所有仓库进行操作。</p><p>建议新建一个demo的仓库，在demo中进行配置</p><ol><li><p>在终端中生成一个 github 的 <code>ssh-key</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;xxxxx@qq.com&#x27; -f ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>将私钥对应的公钥,也就是 <strong>github_id_rsa.pub</strong> 的内容copy到github中某个仓库</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105105215110.png" class="" title="image-20221105105215110"></li><li><p>按照<strong>第2.3章节</strong>，配置 config 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.ssh/config</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">内容如下</span></span><br><span class="line">Host github.com</span><br><span class="line">   HostName github.com</span><br><span class="line">   IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line">   </span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 600 ~/.ssh/config</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>配置完成后, 测试一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现一下内容, 则说明配置成功</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Hi 用户名/仓库名! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span>  </span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3-为主机指定私钥"><a href="#2-3-为主机指定私钥" class="headerlink" title="2.3 为主机指定私钥"></a>2.3 为主机指定私钥</h4><p>主机上可能存在多个私钥, 但是连接的时候默认使用的是<code>id_rsa</code>,  如果不匹配的话, 则连接失败。有三种方法实现为主机指定密钥：</p><ul><li><p>ssh -i xxxx 用户@ip地址，（这里xxx是指密钥文件），这样的话每次都要输入密钥文件，比较麻烦</p></li><li><p>将密钥交给 <strong>ssh-agent</strong> 进行管理，但是ssh-agent在系统中并没有开启自启，每次都需要手动开启，不推荐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-agent bash   <span class="comment">#启动 ssh-agent</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add Identity_Linux  <span class="comment"># 为 ssh-agent 添加私钥。这里的 Identity_Linux 是我的私钥文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add -l   <span class="comment">#查看已添加的私钥</span></span></span><br></pre></td></tr></table></figure></li><li><p>配置 <strong>config</strong> 文件，一劳永逸，强烈推荐</p></li></ul><p>SSH的配置文件有两个:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ~/.ssh/config            <span class="comment"># 用户配置文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/ssh/ssh_config      <span class="comment"># 系统配置文件</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 个人建议只配置用户配置文件</span></span><br><span class="line">chmod 600 ~/.ssh/config</span><br></pre></td></tr></table></figure><p>常用的配置参数:</p><ul><li><p><strong>Host</strong></p><p>用于我们执行 SSH 命令的时候如何匹配到该配置。</p><ul><li><code>*</code>，匹配所有主机名。</li><li><code>*.example.com</code>，匹配以 .example.com 结尾。</li><li><code>!*.dialup.example.com,*.example.com</code>，以 ! 开头是排除的意思。</li><li><code>192.168.0.?</code>，匹配 192.168.0.[0-9] 的 IP。</li></ul></li><li><p><strong>HostName</strong></p><p>真实的主机名，默认值为命令行输入的值（允许 IP）</p></li><li><p><strong>Port</strong></p><p>默认端口为22, 使用其他端口的话加上 <code>-p xxx</code></p></li><li><p><strong>User</strong></p><p>登录的用户名</p></li><li><p><strong>IdentityFile</strong></p><p>指定连接的私钥</p></li></ul><p><strong>本地配置实例如下:</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104210515209.png" class="" title="image-20221104210515209"><h3 id="三-gitignore-文件"><a href="#三-gitignore-文件" class="headerlink" title="三 .gitignore 文件"></a>三 .gitignore 文件</h3><p>本地仓库的文件目录结构如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── a.cpp</span><br><span class="line">├── afs</span><br><span class="line">│   └── bfs</span><br><span class="line">├── b.c</span><br><span class="line">├── b.cpp</span><br><span class="line">├── bfs</span><br><span class="line">│   ├── a.cpp</span><br><span class="line">│   └── b.c</span><br><span class="line">├── b.o</span><br><span class="line">└── cfs</span><br><span class="line">    └── fs</span><br><span class="line">        └── bfs</span><br><span class="line">            └── test.txt</span><br></pre></td></tr></table></figure><h4 id="3-1-忽略文件"><a href="#3-1-忽略文件" class="headerlink" title="3.1 忽略文件"></a>3.1 忽略文件</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># this is .gitignore file.</span><br><span class="line"># 以下是忽略的文件</span><br><span class="line">bfs</span><br></pre></td></tr></table></figure><p>只写bfs的话, 忽略同名的文件夹以及文件。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213043599.png" class="" title="image-20221104213043599"><h4 id="3-2-忽略文件而不忽略目录"><a href="#3-2-忽略文件而不忽略目录" class="headerlink" title="3.2 忽略文件而不忽略目录"></a>3.2 忽略文件而不忽略目录</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">bfs</span><br><span class="line">!bfs/</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213424804.png" class="" title="image-20221104213424804"><h4 id="3-3-忽略目录而不忽略文件"><a href="#3-3-忽略目录而不忽略文件" class="headerlink" title="3.3 忽略目录而不忽略文件"></a>3.3 忽略目录而不忽略文件</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">bfs/</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213251537.png" class="" title="image-20221104213251537"><h4 id="3-4-通配符"><a href="#3-4-通配符" class="headerlink" title="3.4 通配符"></a>3.4 通配符</h4><hr><p>常用的通配符有：</p><p>（1）星号“*” ：匹配多个字符；</p><p>（2）问号“?”：匹配除 ‘/’外的任意一个字符；</p><p>（3）方括号“[xxxx]”：匹配多个列表中的字符；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">*.[co]</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104214535749.png" class="" title="image-20221104214535749"><h4 id="3-5-其他规则"><a href="#3-5-其他规则" class="headerlink" title="3.5 其他规则"></a>3.5 其他规则</h4><ol><li>空行不匹配任何文件；</li><li>git 跟踪文件，而不是目录；</li><li>在 .gitignore 文件中，每行表示一种模式；</li><li>如果本地仓库文件已被跟踪，那么即使在 .gitignore 中设置了忽略，也不起作用。这个时候使用 <code>git rm -rf --cached .</code> 先将git cache中的内容全部删除, 然后再重新添加。</li><li>.gitignore 文件也会被上传的到远程仓库，所以，同一个仓库的人可以使用同一个.gitignore 文件。</li></ol><h3 id="四-参考链接"><a href="#四-参考链接" class="headerlink" title="四 参考链接"></a>四 参考链接</h3><ol><li><a href="https://linux.die.net/man/5/ssh_config">ssh_config(5) - Linux man page</a></li><li><a href="https://blog.csdn.net/senlin1202/article/details/122081089">SSH Config 使用</a></li><li><a href="https://gitee.com/help/articles/4229#article-header0">Gitee git 配置多个SSH-KEY</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Git学习以及配置&quot;&gt;&lt;a href=&quot;#Git学习以及配置&quot; class=&quot;headerlink&quot; title=&quot;Git学习以及配置&quot;&gt;&lt;/a&gt;Git学习以及配置&lt;/h2&gt;&lt;h3 id=&quot;一-Git学习&quot;&gt;&lt;a href=&quot;#一-Git学习&quot; class=&quot;he</summary>
      
    
    
    
    <category term="工欲善其事, 必先利其器" scheme="http://okeyia.github.io/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B-%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="git配置" scheme="http://okeyia.github.io/tags/git%E9%85%8D%E7%BD%AE/"/>
    
  </entry>
  
  <entry>
    <title>求职算法总结</title>
    <link href="http://okeyia.github.io/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://okeyia.github.io/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2022-10-24T07:52:03.000Z</published>
    <updated>2022-12-23T12:04:52.388Z</updated>
    
    <content type="html"><![CDATA[<hr><p>还没有总结完!   待续……..</p><hr><h2 id="求职算法总结"><a href="#求职算法总结" class="headerlink" title="求职算法总结"></a>求职算法总结</h2><p>为什么选择c++ 作为主攻语言?   C/C++ 能让我见识到整个计算机体系结构是如何被搭建起来的、程序是如何跑起来的、程序是如何被编译链接在一起的、函数的底层构造是怎样的。</p><h3 id="〇-递归中的时间复杂度"><a href="#〇-递归中的时间复杂度" class="headerlink" title="〇 递归中的时间复杂度"></a>〇 递归中的时间复杂度</h3><p>递归算法的时间复杂度表达式：O(T) = R * O(s)。</p><p>O(T) 表示时间复杂度， R表示递归调用的次数， O(s)每次递归调用计算的时间复杂度。</p><blockquote><p> 斐波那契函数,  它的递归关系是f(n) = f(n-1) + f(n-2),  这里将 n = 5 作为输入,  </p><p>递归过程 抽象成一棵递归树,  在这棵二叉树中每一个节点都是一次递归，那么这棵树有多少个节点呢？  </p><p>一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点, 所以该递归算法的时间复杂度为O(2^n)。</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220921_195136.png" class="" title="Clip_20220921_195136"></blockquote><h3 id="一-二分法"><a href="#一-二分法" class="headerlink" title="一 二分法"></a>一 二分法</h3><hr><h4 id="1-1-找下界"><a href="#1-1-找下界" class="headerlink" title="1.1 找下界"></a>1.1 找下界</h4><p><strong>问题定义：</strong>给定一个升序数组，我们将满足  <code>x ≥ target</code> 的第一个元素定义为 <strong>下界</strong> 。</p><p><code>C++ STL</code>中的 <code>lower_bound()</code> 函数就实现了这个功能。</p><h5 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h5><p>对于数组 <code>[1,2,3,5,5,5,6,7,9]</code>，令 <code>target=5</code>，则满足 <code>x ≥ target</code> 的下界的下标应该是 <code>3</code>。</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_141823.jpg" class="" title="Clip_20220919_141823"><p>可以看到，从这个位置将数组分为左右两部分，**左侧的元素都「小于」<code>target</code>，右侧的元素都「大于等于」<code>target</code>**。</p><p><strong>定义变量 ：</strong></p><ul><li>区间范围为 <code>[left,right]</code>，<code>left</code>、<code>right</code> 是区间的左右边界的下标</li><li><code>mid</code> 是 <code>[left,right]</code> 的中间位置</li><li>初始时，<code>left</code>、<code>right</code> 分别指向数组的第一个和最后一个元素</li><li><strong>当 <code>left &gt; right</code> 时，表示区间为空</strong></li></ul><p>如果我们在二分查找的过程中，<strong>不断右移 <code>left</code>，左移 <code>right</code>，使得所有「小于」<code>target</code> 的元素都在 <code>left</code> 左侧，所有「大于等于」<code>target</code> 的元素都在 <code>right</code> 右侧，那么当区间为空时，<code>left</code> 就是要查找的下界</strong></p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_142137.jpg" class="" title="Clip_20220919_142137"><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><p>根据上述思路，<strong>算法步骤</strong>如下：</p><ul><li>若 <code>nums[mid] &gt;= target</code>，说明 <code>[mid,right]</code> 区间的所有元素均「大于等于」<code>target</code>，因此 <code>right</code> 左移，有 <code>right = mid-1</code></li><li>否则，说明 <code>[left,mid]</code> 区间的所有元素均「小于」<code>target</code>，因此 <code>left</code> 右移，有 <code>left = mid+1</code></li><li>重复上述步骤，直到区间为空，表示找到了下界，**返回 <code>left</code>**。因此循环条件为 <code>left &lt;= right</code>，表示“区间不为空”</li><li>注意，上述两个赋值语句均跳过了中间元素 <code>mid</code></li></ul><p>上述的查找过程如下： </p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_142436.jpg" class="" title="Clip_20220919_142436"><h5 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找满足 x ≥ target 的下界的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> search（<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] &gt;= target)&#123;  <span class="comment">// 这里的比较运算符与题目要求一致</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;   <span class="comment">// 返回下界的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，**<code>if</code> 的判定条件和给定的比较规则是一致的<strong>：要找满足 <code>x &gt;= target</code> 的第一个元素，所以是 <code>if nums[m] &gt;= target</code>。如果要找满足 <code>x &gt; target</code> 的第一个元素，那么只需改为 <code>if nums[m] &gt; target</code>。</strong><code>if</code> 为真时更新 <code>right</code>**。</p><p>最后注意一些细节：</p><ul><li><code>left</code>、<code>right</code> 的初值为 <code>0</code>、<code>n-1</code>，表示「闭区间」</li><li>循环的判定条件是 <code>left &lt;= right</code>，表示区间不为空</li><li>更新 <code>left</code> 和 <code>right</code> 时均跳过了中间元素 <code>mid</code></li></ul><h4 id="1-2-找上界"><a href="#1-2-找上界" class="headerlink" title="1.2 找上界"></a>1.2 找上界</h4><p>定义：满足 <code>x &lt; target</code> 的<strong>最后一个元素</strong>为「上界」。</p><p>给定一个 <code>target</code>，要求返回升序数组中上界的下标。比如：对于数组 <code>[0,1,2,3,4]</code>，当 <code>target=3</code> 时，返回下标 <code>2</code>；当 <code>target=5</code> 时，返回下标 <code>4</code>。</p><p>根据上界和下界的定义，我们可以发现：<strong>上界和「互补的」下界是相邻的，并且 <code>上界 = 下界 - 1</code>**。比如 <code>x ≤ target</code> 的上界和 <code>x &gt; target</code> 的下界相邻。因此，</strong>所有找上界的问题，都可以转换为「互补的」找下界的问题。**</p><p>对于 <code>x &lt; target</code> 而言，要找上界，套用上文的模板，实现 <code>x &gt;= target</code> 的下界, 参考 <a href="#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81">模板代码</a>。</p><p>然后再将下界 减一, 就是我们要找的上界。</p><h4 id="1-3-参考例题"><a href="#1-3-参考例题" class="headerlink" title="1.3 参考例题"></a>1.3 参考例题</h4><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 寻找下界, 第一个 x &gt;= target的位置</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt;= target) right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= nums.size() || nums[left] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找 x == taget 最后一次出现的位置, 只需查找 x &lt;= target的上界 </span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断一下是否越界，或者不相等</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;searchFirst(nums,target),searchLast(nums,target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-4-二分参考链接"><a href="#1-4-二分参考链接" class="headerlink" title="1.4 二分参考链接"></a>1.4 二分参考链接</h4><ol><li></li></ol><h3 id="二-回溯"><a href="#二-回溯" class="headerlink" title="二 回溯"></a>二 回溯</h3><p>回溯法解决的问题</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯解决的问题都可以抽象为树形结构，因为回溯解决的都是在集合中查找子集，集合的大小构成了树的宽度，递归的深度。</p><h4 id="2-1-回溯算法模板"><a href="#2-1-回溯算法模板" class="headerlink" title="2.1 回溯算法模板"></a>2.1 回溯算法模板</h4><ol><li>回溯函数模板返回值以及参数</li><li>回归函数终止条件</li><li>回溯搜索的遍历过程</li></ol><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_200402.png" class="" title="Clip_20220919_200402"><p>综上，回溯算法模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-startIndex-开始位置"><a href="#2-2-startIndex-开始位置" class="headerlink" title="2.2 startIndex 开始位置"></a>2.2 <code>startIndex</code> 开始位置</h4><p>如果是一个集合来求组合的话，就需要<code>startIndex</code>, 例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！</a></p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用<code>startIndex</code>, 如 <a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">回溯算法：电话号码的字母组合</a></p><h4 id="2-3-去重"><a href="#2-3-去重" class="headerlink" title="2.3 去重"></a>2.3 去重</h4><p>分为:  <strong>“树层去重”和“树枝去重”</strong></p><h3 id="三-哈希表"><a href="#三-哈希表" class="headerlink" title="三 哈希表"></a>三 哈希表</h3><h4 id="3-1-set-集合"><a href="#3-1-set-集合" class="headerlink" title="3.1 set(集合)"></a>3.1 set(集合)</h4><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><h4 id="3-2-map-映射"><a href="#3-2-map-映射" class="headerlink" title="3.2 map(映射)"></a>3.2 map(映射)</h4><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><h3 id="四-动态规划"><a href="#四-动态规划" class="headerlink" title="四 动态规划"></a>四 动态规划</h3><p>模板:</p><ol><li>确定<code>dp</code> 数组 (<code>dp table</code>) 以及下表的含义</li><li>确定递推公式</li><li><code>dp</code> 数组初始化</li><li>确定遍历顺序</li><li>举例推导 数组</li></ol><p><strong>分类解题模板</strong><br>背包问题大体的解题模板是两层循环，分别遍历物品<code>nums</code>和背包容量target，然后写转移方程，<br>根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法</p><p><strong>首先是背包分类的模板：</strong><br>1、0/1背包：外循环 <code>nums</code> ,内循环 target, target 倒序且 <code>target&gt;=nums[i]</code> ;<br>2、完全背包：外循环 <code>nums</code> ,内循环 target, target 正序且<code>target&gt;=nums[i]</code>;<br>3、组合背包(考虑顺序)：外循环target,内循环 <code>nums</code>, target正序且 <code>target&gt;=nums[i]</code>;<br>4、分组背包：这个比较特殊，需要三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板</p><p><strong>然后是问题分类的模板：</strong><br>1、最值问题: <code>dp[i] = max/min(dp[i], dp[i-nums]+1)</code>或<code>dp[i] = max/min(dp[i], dp[i-num]+nums)</code>;<br>2、存在问题**<code>(bool)</code>**：<code>dp[i]=dp[i]||dp[i-num]</code>;<br>3、组合问题：<code>dp[i]+=dp[i-num]</code>;</p><p>这样遇到问题将两个模板往上一套大部分问题就可以迎刃而解</p><h4 id="4-1-01-背包问题"><a href="#4-1-01-背包问题" class="headerlink" title="4.1 01 背包问题"></a>4.1 01 背包问题</h4><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221001190410813.png" class="" title="image-20221001190410813"><p><code>dp[i][j]</code> : <strong>表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>对于<code>物品i</code>来说,  有两种状态,  <strong>放入</strong> 或者 <strong>不放</strong>:</p><ol><li>不放的话, <code>dp[i][j]就是dp[i - 1][j]</code></li><li>放入的话, 由<code>dp[i - 1][j - weight[i]]</code>推出</li></ol><p>所以递推公式为:  <code> dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code> </p><p>初始化数组:</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20221001_191233.png" class="" title="Clip_20221001_191233"><p>遍历代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-滚动数组"><a href="#4-2-滚动数组" class="headerlink" title="4.2 滚动数组"></a>4.2 滚动数组</h4><blockquote><p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><p>每一行的 <code>dp[i][∗]</code> 状态值都只与上一行的 <code>dp[i-1][*]</code>状态值有关，因此可基于滚动数组的思想进行对状态空间 <code>dp</code> 进行优化而省去第一维度</p><p><strong>其实可以发现如果把<code>dp[i - 1]</code>那一层拷贝到<code>dp[i]</code>上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p></blockquote><p>滚动数组:  需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p><p>在一维<code>dp</code>数组中，<code>dp[j]</code>表示：容量为j的背包，所背的物品价值可以最大为<code>dp[j]</code>。</p><p><code>dp[j]</code>可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为<code>j - weight[i]</code>的背包所背的最大价值。</p><p>所以递推公式为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量, 从大到小</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历背包是倒序的</strong>,  仔细想一想为为什么要倒叙 ?</p><blockquote><p>考虑到我我们在更新 <code>dp[j]</code>时，使用的其实是上一行的 <code>dp</code>值；而如果第二层循环从小到大计算的话，那么 <code>dp[j−nums[i-1]]</code> 先于 <code>dp[j]</code> 被更新，因此当我们计算 <code>dp[j]</code>值的时候，<code>dp[j−nums[i-1]]</code>已经是被更新过的状态，而不再是上一行的 <code>dp</code> 值了。</p><p>而在第二层循环中，通过从大到小计算则可巧妙地保证在计算 <code>dp[j]</code> 时所用到的 <code>dp[j]</code>]和 <code>dp[j-nums[i-1]]</code>均来自上一行。</p></blockquote><h4 id="4-3-完全背包"><a href="#4-3-完全背包" class="headerlink" title="4.3 完全背包"></a>4.3 完全背包</h4><h4 id="4-4-典型例题"><a href="#4-4-典型例题" class="headerlink" title="4.4 典型例题"></a>4.4 典型例题</h4><p> <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>    <a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">题解</a></p><p>怎么将数学思维和代码结合起来</p><blockquote><p> 题目要求是计算不同二叉搜索树的个数。定义两个函数：</p><p>G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。</p><p>F(i, n) 以 ii为根、序列长度为 n 的不同二叉搜索树个数 (1≤i≤n)</p><p>G(n) 可以从 F(i, n) 得到，而 F(i, n) 又会递归地依赖于 G(n)。</p></blockquote><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20220930214755016.png" class="" title="image-20220930214755016"><h4 id="4-5-参考链接"><a href="#4-5-参考链接" class="headerlink" title="4.5 参考链接"></a>4.5 参考链接</h4><ol><li><a href="https://leetcode.cn/problems/coin-change/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-sq9n/">一篇文章吃透背包问题！（细致引入+解题模板+例题分析+代码呈现）</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;hr&gt;
&lt;p&gt;还没有总结完!   待续……..&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;求职算法总结&quot;&gt;&lt;a href=&quot;#求职算法总结&quot; class=&quot;headerlink&quot; title=&quot;求职算法总结&quot;&gt;&lt;/a&gt;求职算法总结&lt;/h2&gt;&lt;p&gt;为什么选择c++ 作为主攻语言?   C</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://okeyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C/C++常用刷题技巧</title>
    <link href="http://okeyia.github.io/2022/09/17/C_C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://okeyia.github.io/2022/09/17/C_C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2022-09-17T00:28:27.000Z</published>
    <updated>2022-11-14T02:39:55.475Z</updated>
    
    <content type="html"><![CDATA[<h2 id="C-C-常用刷题技巧"><a href="#C-C-常用刷题技巧" class="headerlink" title="C/C++常用刷题技巧"></a>C/C++常用刷题技巧</h2><p><strong>万能头文件</strong></p><blockquote><p>万能头文件</p><p>基本包括了大部分的STL库函数，使用方便快捷</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="一-vector"><a href="#一-vector" class="headerlink" title="一  vector"></a>一  vector</h3><h4 id="1-1-一维vector初始化"><a href="#1-1-一维vector初始化" class="headerlink" title="1.1  一维vector初始化"></a>1.1  一维vector初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first; <span class="comment">// 空的vector，只是一个列表的头，里面没有元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">second</span> <span class="params">(<span class="number">4</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 初始化一个具有4个元素的vector，每个元素的值都是100</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">third</span> <span class="params">(second.begin(), second.end())</span></span>; <span class="comment">// 通过其他vector的迭代器的方式，进行拷贝复制初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fourth</span> <span class="params">(third)</span></span>; <span class="comment">// 直接对其他vector的拷贝复制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>, <span class="number">2</span>, <span class="number">77</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fifth</span> <span class="params">(myints, myints+<span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>; <span class="comment">// 将数组转化成vector，需要提供的是数组的首地址和地址偏移。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sixth = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>&#125;; <span class="comment">// 指定内容进行构造，内容为1,5,4,6的vector</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vars;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;<span class="comment">//建立一个vector</span></span><br><span class="line"></span><br><span class="line">test.push_back(<span class="number">1</span>);</span><br><span class="line">test.push_back(<span class="number">2</span>);<span class="comment">//把1和2压入vector，这样test[0]就是1,test[1]就是2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//使用下标访问元素</span></span><br><span class="line"><span class="comment">//使用迭代器访问元素.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++)&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec.insert(vec.begin()+i,a);<span class="comment">//在第i+1个元素前面插入a;</span></span><br><span class="line">vec.erase(vec.begin()+<span class="number">2</span>);<span class="comment">//删除第3个元素</span></span><br><span class="line">vec.erase(vec.begin()+i,vec.end()+j);<span class="comment">//删除区间[i,j-1];区间从0开始</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.size()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//向量大小</span></span><br><span class="line">vec.clear();<span class="comment">//清空</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sort(v.begin(),v.end());              <span class="comment">//用sort()函数从小到大进行排序</span></span><br><span class="line">reverse(v.begin(),v.end());          <span class="comment">// 用reverse()函数翻转数组</span></span><br><span class="line">v.size()                             <span class="comment">// 返回容器的大小</span></span><br><span class="line">v.empty()                             <span class="comment">//判断容器是否为空，为空返回0，不为空则为1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v[<span class="number">0</span>];                          <span class="comment">// 打印第一个元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v[v.size()]                     <span class="comment">//打印最后一个元素</span></span><br><span class="line">lower_bound(v.begin(),v.end(),a)      <span class="comment">//在有序数组中返回第一个大于等于a的元素的下标,返回值的是地址</span></span><br><span class="line">upper_bound(v.begin(),v.end(),a)-v.begin()  <span class="comment">//在有序数组中返回第一个大于a的元素的下标,这里通过减去首地址，得到了下标位置</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  <span class="comment">//定义迭代器方便得到元素值，相当于指针</span></span><br><span class="line">it=upper_bound(v.begin,v.end(),a)    </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(*it)                          <span class="comment">//这里返回的是第一个大于a的元素的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-二维数组初始化"><a href="#1-2-二维数组初始化" class="headerlink" title="1.2 二维数组初始化"></a>1.2 二维数组初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维vector的初始化</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vars(size, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size, <span class="number">0</span>)); <span class="comment">// （size,size）的矩阵，元素全部是0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; a(<span class="number">3</span>);<span class="comment">//初始化的是3*3的矩阵,注意我们所申请的矩阵行数和列数默认相等的</span></span><br><span class="line"><span class="comment">//如果我们需要行数和列数不相等的二维数组，那么我们可以对每一行所包含的元素个数加以限制；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)<span class="comment">//利用resize函数将每一行的元素个数设置为5个，即5列 </span></span><br><span class="line">a[i].resize(<span class="number">5</span>);<span class="comment">//此时我们得到的就是一个3行5列的二维数组</span></span><br></pre></td></tr></table></figure><p>如果我们采用size函数来得到数组规模，那么我们所得到的结果是矩阵的行数，如果需要得到列数可以使用<code>a[0].size()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; a(<span class="number">3</span>);<span class="comment">//初始化的是3*3的矩阵 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)<span class="comment">//利用resize函数将每一行的元素个数设置为5个，即5列 </span></span><br><span class="line">a[i].resize(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//打印的是vector的行数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>除上述初始化行列数不同的二维数组之外，我们也可以直接定义</strong>，结果也是3行5列的二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Array(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Array[<span class="number">0</span>].size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下也可以</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;num =</span><br><span class="line">&#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="二-字符串部分"><a href="#二-字符串部分" class="headerlink" title="二 字符串部分"></a>二 字符串部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">string</span> t=<span class="string">&quot;m&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;<span class="comment">//不包括空格</span></span><br><span class="line">getline(<span class="built_in">cin</span>,s);<span class="comment">//读取一行，可以包含空格</span></span><br><span class="line">s.append(t);<span class="comment">//将字符t添加到s  </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s+t;  <span class="comment">//同上述效果一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//find(“字符串”) / find(&quot;字符串&quot;,postion)   ---找不到就返回很大很大的数,可以与-1比较</span></span><br><span class="line"><span class="keyword">if</span>(s1.find(s2)==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;在s1中未找到s2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.find(t)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//找子序列t在s中出现的首次位置</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.find(t,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//从第二个位置开始找，找子序列t在s中出现的首次位置</span></span><br><span class="line"><span class="keyword">int</span> len = s.size();<span class="comment">//字符串s的⻓度</span></span><br><span class="line"><span class="keyword">int</span> len = s.length();<span class="comment">//字符串s的⻓度</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*s1.begin()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指向字符串的第一个元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(s1.end()<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指向字符串的最后一个元素</span></span><br><span class="line"></span><br><span class="line">reverse(s.begin(), s.end());<span class="comment">//字符串反转</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> sTemp=s1.substr(<span class="number">1</span>);<span class="comment">//下标1开始到结束</span></span><br><span class="line"><span class="comment">//截取substr（pos,num） ----在哪个位置截取，截取多少字符</span></span><br><span class="line"><span class="built_in">string</span> sTemp2 = s1.substr(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//下标1开始，截取3个字符</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sTemp&lt;&lt;<span class="string">&quot;----&quot;</span>&lt;&lt;sTemp2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//访问字符串的0处的位置</span></span><br><span class="line"><span class="built_in">string</span> s1,s2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个字符串之间的大小关系</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1==s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1&gt;s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1&lt;s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//插入insert(position,&quot;字符串&quot;)</span></span><br><span class="line">s1.insert(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br><span class="line"><span class="comment">//删除 erase(pos,num)----在哪个位置删除多少字符</span></span><br><span class="line">s1.earse(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将123456转为字符串</span></span><br><span class="line">s1 = to_string(<span class="number">123456</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br><span class="line"><span class="comment">//将字符型1234转为int类型   ---string to int</span></span><br><span class="line"><span class="keyword">int</span> x=stoi(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三-栈"><a href="#三-栈" class="headerlink" title="三 栈"></a>三 栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;  //要引入库函数</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">      s.push(i);<span class="comment">//入栈操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问s的栈顶元素</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.size()&lt;&lt;<span class="built_in">endl</span>;  输出s的元素个数</span><br><span class="line">   s.pop(); <span class="comment">// 删除栈顶元素但不返回其值</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.empty()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//非空返回0，是空返回1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四-队列"><a href="#四-队列" class="headerlink" title="四 队列"></a>四 队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;//要引入库函数</span></span></span><br><span class="line">   <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        s.push(i);<span class="comment">//将i元素接到队列的末端；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;首元素为：&quot;</span>&lt;&lt;s.front()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问队首元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;队尾元素：&quot;</span>&lt;&lt;s.back()&lt;&lt;<span class="built_in">endl</span>;  访问队尾元素</span><br><span class="line">     s.pop(); <span class="comment">// 弹出队列的第一个元素，并不会返回元素的值；</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.empty()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//非空返回0，是空返回1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五-set"><a href="#五-set" class="headerlink" title="五 set"></a>五 set</h3><blockquote><p>⼀个<code>set</code>⾥⾯的各元素是各不相同的（重复元素自动删除），⽽且<code>set</code>会按照元素进⾏从⼩到⼤排序</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">  s.insert(<span class="number">2</span>);<span class="comment">//插入元素</span></span><br><span class="line"></span><br><span class="line">  s.insert(<span class="number">100</span>);<span class="comment">//插入元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    s.insert(i);<span class="comment">//插入元素</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//迭代变量set&lt;int&gt;::iterator it</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s.begin();it!=s.end();it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//集合的遍历，it是一个迭代的指针</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span> v: s)  <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//输入结果：0 1 2 3 4 5 100</span></span><br><span class="line"><span class="comment">//按照从小到大排序，且删除相同元素</span></span><br><span class="line"></span><br><span class="line">s.erase(<span class="number">3</span>);<span class="comment">//删除元素为3的</span></span><br><span class="line">s.clear();<span class="comment">//清空</span></span><br><span class="line">s.size();<span class="comment">//长度</span></span><br><span class="line">s.empty();<span class="comment">//判空</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*s.find(<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//查找某一个num值，返回的是迭代器，因此需要*来输出</span></span><br></pre></td></tr></table></figure><h3 id="六-哈希表"><a href="#六-哈希表" class="headerlink" title="六 哈希表"></a>六 哈希表</h3><h4 id="6-1-map"><a href="#6-1-map" class="headerlink" title="6.1 map"></a>6.1 map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">  mp[x] =i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v: mp) <span class="built_in">cout</span>&lt;&lt;v.first&lt;&lt;<span class="string">&quot; ： &quot;</span>&lt;&lt;v.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-2-unordered-map"><a href="#6-2-unordered-map" class="headerlink" title="6.2 unordered_map"></a>6.2 unordered_map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">//2. 初始化</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 插入元素</span></span><br><span class="line"><span class="comment">//3.1 数组形式</span></span><br><span class="line"><span class="built_in">map</span>[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//3.2 直接插入</span></span><br><span class="line"><span class="built_in">map</span>.insert( &#123; &#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; , &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>&#125; &#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 修改元素</span></span><br><span class="line"><span class="built_in">map</span>[<span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 删除元素</span></span><br><span class="line"><span class="comment">//5.1 删除key为&#x27;a&#x27;的元素</span></span><br><span class="line"><span class="built_in">map</span>.erase(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line"><span class="comment">//5.2删除第一个元素</span></span><br><span class="line"><span class="built_in">map</span>.erase(<span class="built_in">map</span>.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 判断元素是否存在</span></span><br><span class="line"><span class="comment">//6.1 如果元素存在</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">&#x27;a&#x27;</span>)!=<span class="built_in">map</span>.end())</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>.count(<span class="string">&#x27;a&#x27;</span>)!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 清空所有元素    </span></span><br><span class="line"><span class="built_in">map</span>.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 遍历取值并取出键和值</span></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span>&amp; a : <span class="built_in">map</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> key= a.first;</span><br><span class="line">    <span class="keyword">int</span>  value= a.second;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); it++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> key = it-&gt;first;</span><br><span class="line">        <span class="keyword">int</span>  value = it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9. 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>.empty() )</span><br><span class="line">    </span><br><span class="line"><span class="comment">//10. 求元素个数</span></span><br><span class="line"><span class="built_in">map</span>.size();</span><br></pre></td></tr></table></figure><h3 id="七-ACM模式输入输出参考书程序"><a href="#七-ACM模式输入输出参考书程序" class="headerlink" title="七 ACM模式输入输出参考书程序"></a>七 ACM模式输入输出参考书程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;  //INT_MIN 和 INT_MAX的头文件  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 直接输入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 直接输入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 只读取一个字符 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2： cin.get(ch) 或者 ch = cin.get() 或者 cin.get()</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch)) &#123;   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式3 ：ch = getchar()  </span></span><br><span class="line"><span class="keyword">while</span> (getchar()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1给定一个数，表示有多少组数（可能是数字和字符串的组合），然后读取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;   <span class="comment">//每次读取1 + n 个数，即一个样例有n+1个数 </span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理这组数/字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2 首先给一个数字，表示需读取n个字符，然后顺序读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;  <span class="comment">//输入数量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">strs.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理这组字符串</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.未给定数据个数，但是每一行代表一组数据，每个数据之间用空格隔开</span></span><br><span class="line"><span class="comment">//4.1使用getchar() 或者 cin.get() 读取判断是否是换行符，若是的话，则表示该组数（样例）结束了，需进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ele;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ele) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = ele;</span><br><span class="line"><span class="comment">// getchar()   //读取单个字符</span></span><br><span class="line"><span class="comment">/*while (cin.get() != &#x27;\n&#x27;) &#123;*/</span>   <span class="comment">//判断换行符号</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) &#123;  <span class="comment">//如果不是换行符号的话，读到的是数字后面的空格或者table</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.2 给定一行字符串，每个字符串用空格间隔，一个样例为一行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line"><span class="keyword">if</span> (getchar() == <span class="string">&#x27;\n&#x27;</span>) &#123;  <span class="comment">//控制测试样例</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">strs.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.3 使用getline 读取一整行数字到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> input;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, input)) &#123;  <span class="comment">//读取一行</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">data</span><span class="params">(input)</span></span>;  <span class="comment">//使用字符串流</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (data &gt;&gt; num) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.4 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> words;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, words)) &#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">data</span><span class="params">(words)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (data &gt;&gt; str) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.5 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。每个字符中间用&#x27;,&#x27;间隔</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while (cin &gt;&gt; line) &#123;  //因为加了“，”所以可以看出一个字符串读取</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (getline(ss, str, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言读取字符、数字</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch)) &#123; <span class="comment">//获得单个字符</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;  <span class="comment">//遇到空白停止</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str);  <span class="comment">//读入一行字符串</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="八-其他"><a href="#八-其他" class="headerlink" title="八 其他"></a>八 其他</h3><h4 id="自带的宏常量"><a href="#自带的宏常量" class="headerlink" title="自带的宏常量"></a>自带的宏常量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = INT_MIN;</span><br><span class="line"><span class="keyword">int</span> N = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">//通常用来代替最大值，防止运算过程中溢出  0x16进制</span></span><br></pre></td></tr></table></figure><h4 id="字符串判断函数"><a href="#字符串判断函数" class="headerlink" title="字符串判断函数"></a>字符串判断函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isdigit</span>(c)  <span class="comment">//判断c字符是不是数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)  <span class="comment">//判断c字符是不是字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(c)  <span class="comment">//判断c字符是不是数字或者字母</span></span><br><span class="line"><span class="built_in">tolower</span>(c)  <span class="comment">//转为小写</span></span><br><span class="line"><span class="built_in">toupper</span>(c)  <span class="comment">//转为大写</span></span><br></pre></td></tr></table></figure><h4 id="字符串和数值间的转换"><a href="#字符串和数值间的转换" class="headerlink" title="字符串和数值间的转换"></a>字符串和数值间的转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">string</span> str = to_string(num); <span class="comment">//整形转字符串</span></span><br><span class="line"><span class="keyword">int</span> number = stoi(str);  <span class="comment">//字符串转为整形 stol()是字符串转为长整形</span></span><br></pre></td></tr></table></figure><h4 id="迭代器的二分"><a href="#迭代器的二分" class="headerlink" title="迭代器的二分"></a>迭代器的二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">44</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k = lower_bound(nums.begin(), nums.end(), <span class="number">56</span>) - nums.begin(); <span class="comment">//第一个大于等于目标值的迭代器位置</span></span><br><span class="line"><span class="keyword">int</span> k = upper_bound(nums.begin(), nums.end(), <span class="number">56</span>) - nums.begin(); <span class="comment">// 找到第一个大于目标值的迭代器位置</span></span><br></pre></td></tr></table></figure><h4 id="字符串转为小写"><a href="#字符串转为小写" class="headerlink" title="字符串转为小写"></a>字符串转为小写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**op作用的范围[str1.begin(), str1.end], 作用完成后，存储位置的开头为：str2.begin()，op为toupper/tolower*/</span></span><br><span class="line">transform(str1.begin(), str1.end(), str2.begin(), ::<span class="built_in">toupper</span>);</span><br><span class="line">transform(str1.begin(), str1.end(), str2.begin(), ::<span class="built_in">tolower</span>);</span><br></pre></td></tr></table></figure><h4 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">//默认是大根堆</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq; <span class="comment">//小根堆</span></span><br></pre></td></tr></table></figure><h4 id="快速初始化数组"><a href="#快速初始化数组" class="headerlink" title="快速初始化数组"></a>快速初始化数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这个函数是按字节初始化的</span></span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">-1</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> nums);</span><br></pre></td></tr></table></figure><h4 id="C-11的特性"><a href="#C-11的特性" class="headerlink" title="C++11的特性"></a>C++11的特性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> ListNode(); <span class="comment">// auto 关键字</span></span><br><span class="line">Node* pre = <span class="literal">nullptr</span>   <span class="comment">// nullptr代替NULL</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp; <span class="comment">//哈希表 内部是无序的</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">//无序集合</span></span><br></pre></td></tr></table></figure><h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(n).to_string();</span><br><span class="line">    reverse(s.begin(), s.end());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(s).to_ulong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><p>将字符串按照空格分割</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world my name is yao jun&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; str)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>hello</p><p>world</p><p>my</p><p>name</p><p>is</p><p>yao</p><p>jun</p><p>7</p></blockquote><h4 id="四舍五入保留小数"><a href="#四舍五入保留小数" class="headerlink" title="四舍五入保留小数"></a>四舍五入保留小数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">double</span> num = <span class="number">22.23434</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;%.2f&quot;</span>, num);</span><br><span class="line"><span class="built_in">string</span> s = str;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串按格式拆分"><a href="#字符串按格式拆分" class="headerlink" title="字符串按格式拆分"></a>字符串按格式拆分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;12:59:36&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(str2, a.c_str(), <span class="built_in">strlen</span>(a.c_str()));</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">sscanf</span>(str2, <span class="string">&quot;%d:%d:%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;w&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>12 59 36</p></blockquote><h4 id="相同字符的字符串"><a href="#相同字符的字符串" class="headerlink" title="相同字符的字符串"></a>相同字符的字符串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果:</p><p>aaaaaaaaaa</p></blockquote><h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; node_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; tt;</span><br><span class="line">    tt.push_back(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    tt.push_back(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    sort(tt.begin(), tt.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node: tt)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;node.b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>1 5</p><p>2 3</p></blockquote><h4 id="优先队列自定义排序"><a href="#优先队列自定义排序" class="headerlink" title="优先队列自定义排序"></a>优先队列自定义排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="comment">// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; node_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line">    pq.push(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    pq.push(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    pq.push(&#123;<span class="number">2</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pq.top().a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pq.top().b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果</p><p>2 5</p><p>2 3</p><p>1 5</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;C-C-常用刷题技巧&quot;&gt;&lt;a href=&quot;#C-C-常用刷题技巧&quot; class=&quot;headerlink&quot; title=&quot;C/C++常用刷题技巧&quot;&gt;&lt;/a&gt;C/C++常用刷题技巧&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;万能头文件&lt;/strong&gt;&lt;/p&gt;
&lt;blockquo</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
    <category term="算法" scheme="http://okeyia.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>QT学习笔记</title>
    <link href="http://okeyia.github.io/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>http://okeyia.github.io/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2022-08-16T08:08:03.000Z</published>
    <updated>2022-11-26T03:05:37.626Z</updated>
    
    <content type="html"><![CDATA[<h2 id="QT学习笔记"><a href="#QT学习笔记" class="headerlink" title="QT学习笔记"></a>QT学习笔记</h2><hr><p>未完待续。。。。。。 预计寒假期间完成</p><hr><h3 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h3><h4 id="pro-配置文件"><a href="#pro-配置文件" class="headerlink" title=".pro 配置文件"></a>.pro 配置文件</h4><h4 id="QT注意事项"><a href="#QT注意事项" class="headerlink" title="QT注意事项"></a>QT注意事项</h4><ul><li><p>命名规范</p><ul><li>类名 首字母大写，单词和单词之间首字母大写</li><li>函数名 变量名称 首字母小写,单词和单词之间首字母大写</li></ul></li><li><p>快捷键</p><ul><li>注释 ctrl + /</li><li>运行 ctrl + r</li><li>编译 ctrl + b</li><li>查找 ctrl + f</li><li>帮助文档 F1</li><li>自动对齐 ctrl + i</li><li>同名的.h和.cpp切换 F4</li></ul></li></ul><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><ul><li>按钮常用API</li></ul><ol><li>show() 以顶层方式弹出窗口控件</li><li>setParent() 选择依赖方式</li><li>setText() 设置文本</li><li>resize() 重置窗口大小</li><li>move() 移动</li><li>setWindowTitle() 设置窗口大小</li><li>setFixedSize() 设置固定窗口大小</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line"><span class="comment">// btn-&gt;show();</span></span><br><span class="line"><span class="comment">// 让 btn 对象依赖于myWidget 中</span></span><br><span class="line">btn-&gt;setParent(<span class="keyword">this</span>);</span><br><span class="line">btn-&gt;setText(<span class="string">&quot;第一个按钮&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="QT中的对象树"><a href="#QT中的对象树" class="headerlink" title="QT中的对象树"></a>QT中的对象树</h4><ol><li>当创建的对象在堆区的时候,如果指定的父亲是QObject 派生下来的类或者子类</li><li>派生下来的类,可以不需要管理释放操作,会将对象放入对象树一定程度上简化了内存回收机制</li></ol><p>这里的话 ,打印顺序是反的, 是先打印了代码, 但是对象还没有释放掉。 正确的理解过程是先释放 我的按钮类 析构， 然后myWidget类析构 调用。</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220818125200089.png" class="" title="image-20220818125200089"><h4 id="QT的窗口坐标系"><a href="#QT的窗口坐标系" class="headerlink" title="QT的窗口坐标系"></a>QT的窗口坐标系</h4><ol><li>笛卡尔坐标系[左上角为0,0点]</li></ol><h4 id="QT信号和槽"><a href="#QT信号和槽" class="headerlink" title="QT信号和槽"></a>QT信号和槽</h4><p>connect( 信号的发送者 ,信号的具体信息(函数的地址), 信号的接受者,信号的处理(槽)(也是函数的地址))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求:点击 &quot;我的按钮&quot; 关闭窗口</span></span><br><span class="line">connect(mybtn3,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;myWidget::close);</span><br></pre></td></tr></table></figure><ul><li>信号槽的优点 松散耦合,信号发送端 和 接收端本身是没有关联的,通过connectl连接,将两者耦合在一起<ul><li>信号关键字：Signals<ul><li>chlicked(bool) 点击</li><li>pressed() 按下</li><li>released() 释放</li><li>toggled(bool) 切换状态</li></ul></li><li>槽的关键字：Slots</li></ul></li><li>自定义信号和槽位函数<ul><li>自定义信号<ul><li>写在类的signals下,返回值为void,可以有参数,支持重载,不需要实现</li></ul></li><li>自定义槽函数<ul><li>不能写在signals下,public slots[公共的槽函数] 5.4版本以后全局函数或者public都行</li><li>返回值也是void,需要声明,也需要实现,可以有参数,支持重载</li></ul></li><li>然后用connect连接信号和槽</li><li>触发信号 emit</li><li>信号和槽重载，需要函数指针，明确指向函数的地址</li><li>QString 转char * 使用.toUtf8().data()</li><li>信号和槽连接：触发这个信号才能触发槽<ul><li>一个信号可以连接多个槽</li><li>多个信号也可以连接同一个槽函数</li><li>信号和槽的参数和类型必须对应</li><li>信号的参数个数可以多于槽的参数个数</li></ul></li><li>信号和信号连接 触发一个信号也能触发另外一个信号</li><li>断开信号 disconnect(参数一样)</li></ul></li></ul><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><ul><li>C++11版本特性 [CONFIG += c++11] 匿名函数对象<ul><li>Lambda表达式函数声明 <code>[]()&#123;&#125;</code><ul><li>[=] 允许使用局部变量</li><li>[&amp;] 允许使用引用传递变量</li><li>[变量] 允许变量使用值传递</li><li>mutable 可修改值传递进来的参数[虽然还是局部变量]<ul><li><code>[m]()mutable&#123;m+=100;打印&#125;;</code> 不加mutable会报错</li></ul></li><li>-&gt;类型 带返回值<ul><li><code>int ret = []()-&gt;int&#123;return 1000&#125;();</code></li></ul></li></ul></li><li>Lambda表达式函数调用 <code>[]()&#123;&#125;()</code></li><li>最常见的<code>[=]()&#123;&#125;</code></li></ul></li></ul><h3 id="MainWindow"><a href="#MainWindow" class="headerlink" title="MainWindow"></a>MainWindow</h3><h4 id="菜单栏-QMenuBar"><a href="#菜单栏-QMenuBar" class="headerlink" title="菜单栏 QMenuBar"></a>菜单栏 QMenuBar</h4><pre><code>* 菜单栏最多只能有一个    + QMenuBar * bar = menuBar(); setMenuBar(bar);    + 创建菜单        * QMenu * fileMenu = bar-&gt;addMenu(&quot;文件&quot;);            + 创建菜单栏目                * QAction * newAction =  fileMenu-&gt;addAction(&quot;新建&quot;);            + 添加分隔符                 * fileMenu-&gt;addSeparator();</code></pre><h4 id="工具栏-QToolBar"><a href="#工具栏-QToolBar" class="headerlink" title="工具栏 QToolBar"></a>工具栏 QToolBar</h4><pre><code>* 工具栏可以有多个    + QToolBar * toolBar = new QToolBar(this);      + addToolBar(toolBar);        * 可选参数 默认停靠范围            + addToolBar(Qt::BottomToolBarArea,toolBar);        * 只允许左右停靠            + toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea);        * 取消浮动            + toolBar-&gt;setFloatable(false);        * 设置禁止移动            + toolBar-&gt;setMovable(false);        * 给工具栏设置栏目            + toolBar-&gt;addAction(&quot;绝了&quot;或者QAction);        * 给工具栏添加控件            + toolBar-&gt;addWidget(QPushButton按钮);</code></pre><h4 id="状态栏-QStatusBar"><a href="#状态栏-QStatusBar" class="headerlink" title="状态栏 QStatusBar"></a>状态栏 QStatusBar</h4><pre><code>* 状态栏最多只能有一个    + QStatusBar * stBar = statusBar();    + setStatusBar(stBar);        * 添加标签控件            + QLabel * label = new QLabel(&quot;左侧提示的信息&quot;,this);            + QLabel * label1 = new QLabel(&quot;右侧提示的信息&quot;,this);            + stBar-&gt;addWidget(label);            + stBar-&gt;addPermanentWidget(label1);</code></pre><h4 id="铆接部件-QDockWidget"><a href="#铆接部件-QDockWidget" class="headerlink" title="铆接部件 QDockWidget"></a>铆接部件 QDockWidget</h4><pre><code>* 铆接部件可以有多个    + QDockWidget * dockWidget = new QDockWidget(&quot;浮动&quot;,this);    + addDockWidget(Qt::BottomDockWidgetArea,dockWidget); 放置位置下面 如果没有中心部件默认占满        + 只允许上下                * dockWidget-&gt;setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);  </code></pre><h4 id="中心部件"><a href="#中心部件" class="headerlink" title="中心部件"></a>中心部件</h4><pre><code>* 中心内容也只能有一个    + 文本窗口 QTextEdit        + QTextEdit * edit = new QTextEdit(this);        + setCentralWidget(edit); //设置中心部件</code></pre><h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><ol><li>将图片文件文件夹拷贝到项目下</li><li>右键项目-&gt;添加新文件-&gt;Qt-&gt;Qt recourse File</li><li>res 生成 res.qrc</li><li>右键res.qrc-&gt;open in editor 编辑资源</li><li>添加前缀 添加文件</li><li>使用 “: + 前缀名 + 文件名”</li></ol><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><pre><code>+ 只能有一个的是set 可以允许多个是add</code></pre><h4 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h4><ul><li>模态对话框 不可以对其他窗口进行操作<ul><li>QDialog dlg(this);</li><li>dlg.exec();</li><li>消息对话框<ul><li>错误对话框 QMessageBox::critical(this,”critical”,”错误”);</li><li>信息对话框 information</li><li>提问对话框 question</li><li>警告对话框warning</li><li>颜色对话框<ul><li>QColor a = QColorDialog::getColor(QColor(255,0,0));</li></ul></li><li>文件对话框 最后一个是过滤<ul><li>QString str = QFileDialog::getOpenFileName(this,”打开文件”,”./“,”(*.cpp)”);</li></ul></li><li>字体对话框<ul><li>bool flag;</li><li>QFont font = QFontDialog::getFont(&amp;flag,QFont(“华文彩云”,12));</li><li>setFont(font);//设置字体</li></ul></li></ul></li></ul></li><li>非模态对话框 可以对其他窗口进行操作<ul><li>QDialog *dlg2 = new QDialog(this); //为了确保不释放,开在堆上</li><li>dlg2-&gt;show();</li><li>dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose);//55号 用于按关闭键自动释放[QWidge的对象树是在关闭总的窗口才会全部释放]</li></ul></li></ul><h4 id="列表控件-listWidget"><a href="#列表控件-listWidget" class="headerlink" title="列表控件 listWidget"></a>列表控件 listWidget</h4><ul><li>QListWidgetItem * item = new QListWidgetItem(“锄禾日当午”);</li><li>ui-&gt;listWidget-&gt;addItem(item); //添加进去</li><li>item-&gt;setTextAlignment(Qt::AlignCenter); //居中</li></ul><h4 id="ui窗口自布局"><a href="#ui窗口自布局" class="headerlink" title="ui窗口自布局"></a>ui窗口自布局</h4><ol><li>Spacers 弹簧 Widget div盒子</li><li>Group Box 分组[适用于Radio Button]</li><li>主窗口设置垂直布局后可以在sizePolicy-&gt;垂直策略-&gt;Fixed来使组件高度合适</li><li>如果找不到某个组件的信号或者槽，找基类</li></ol><h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><ol><li>add new -&gt; 设计师类</li><li>使用自定义组件<ul><li>查看基类[如widget] 从界面库中拖出来一个widget组件,然后点击提升为,写入类名<ul><li>[设置全局后可以直接在右键中显示]<br>3 自定义组件只有同基类才能被提升</li></ul></li></ul></li></ol><h4 id="QT事件-QEvent"><a href="#QT事件-QEvent" class="headerlink" title="QT事件 QEvent"></a>QT事件 QEvent</h4><ul><li><p>鼠标事件</p><ul><li>事件是虚函数,可以进行重载<br>//鼠标进入事件<br>virtual void enterEvent(QEvent *event);<br>//鼠标离开事件<br>virtual void leaveEvent(QEvent *event);<br>//鼠标按下<br>virtual void mouseReleaseEvent(QMouseEvent *ev);<br>//鼠标释放<br>virtual void mousePressEvent(QMouseEvent *ev);<br>//鼠标移动<br>virtual void mouseMoveEvent(QMouseEvent *ev);  </li></ul></li><li><p>定时器 QTimeEvent</p><ul><li>利用事件实现定时器<ul><li>startTimer(1000); 启动定时器，单位毫秒,返回一个唯一定时器id</li><li>void timerEvent(QTimerEvent * ev)<ul><li>定时器函数,可以通过ev-&gt;timerId()== id1来判断当前是哪个id进来的</li></ul></li></ul></li><li>定时器类QTimer<ul><li>//通过定时器类<br>  QTimer * timer = new QTimer(this);<br>  //启动定时器 每隔500秒发一个信号<br>  timer-&gt;start(500);<br>  //连接信号<br>  connect(timer,&amp;QTimer::timeout,中括号小括号{<br>  static int num = 1;<br>  ui-&gt;label_5-&gt;setText(QString::number(num++));<br>  });  </li></ul></li></ul></li><li><p>event事件分发器</p><ul><li>bool event(QEvent * ev)<ul><li>返回值是bool类型，如果返回true，代表用户要处理这个事件,不向下分发事件了[类似于钩子]</li></ul></li><li>事件枚举QEvent<ul><li>ev.type();</li><li>拦截后使用子类的操作可以使用静态类型转换<ul><li>QMouseEvent *ev = static_cast&lt;QMouseEvent *&gt;(QEvent中行参);</li></ul></li></ul></li><li>但是尽量别拦截</li></ul></li><li><p>事件过滤器</p><ul><li>在app到事件分发器前还能做个过滤</li><li>使用方式<ul><li>给控件安装时间过滤器<ul><li>installEventFilter(this);</li></ul></li><li>重写eventfilter事件</li></ul></li></ul></li></ul><h4 id="绘图-QPainter"><a href="#绘图-QPainter" class="headerlink" title="绘图 QPainter"></a>绘图 QPainter</h4><ul><li>绘图事件 void paintEvent(QPaintEvent *)</li><li>画家类 QPainter(构图的设备)<ul><li>拿起笔 .setPen(笔)</li><li>拿起刷子 .setBrush(刷子)</li></ul></li><li>画笔类 QPen(笔的颜色)</li><li>画刷类 QBrush(笔的颜色)</li><li>高级操作<ul><li>效率降低的抗锯齿<ul><li>painter.setRenderHint()</li></ul></li><li>改变画家位置<ul><li>painter.save();保存当前位置</li><li>painter.restore(); 还原到保存的位置</li><li>painter.translate(); 移动画家</li></ul></li><li>画家绘制图片drawPixmap</li></ul></li></ul><h4 id="绘图设备"><a href="#绘图设备" class="headerlink" title="绘图设备"></a>绘图设备</h4><ul><li>QPixmap 专门对图像显示做了优化</li><li>QBitmap 色深限定为1</li><li>QImage 专门为图像的像素级访问做了优化</li><li>QPicture 可以记录和重视画家的QPainter的各类命令<ul><li>自定义绘图操作 </li></ul></li></ul><h4 id="文件读写-QFile"><a href="#文件读写-QFile" class="headerlink" title="文件读写 QFile"></a>文件读写 QFile</h4><ul><li>file.open(打开方式) QtODevice::readOnly</li><li>全部读取 file.readAll() 按行读 file.readLine() 判断文件末尾atend()</li><li>QFile默认支持的是utf-8 指定格式 QTextCodec<ul><li>QTextCodec *codec = QTextCodec::codecForName(“gbk”);</li><li>ui-&gt;textEdit-&gt;setText(codec-&gt;toUnicode(array)); </li></ul></li><li>关闭文件对象 file.close();</li></ul><h4 id="文件信息-QFileInfo"><a href="#文件信息-QFileInfo" class="headerlink" title="文件信息 QFileInfo"></a>文件信息 QFileInfo</h4><ul><li>QFileInfo info(path);</li><li>后缀名 info.suffix()</li><li>创建日期 info.birthTime().toString(“yyyy/MM/dd hh:mm:ss”);</li><li>修改日期 info.lastModified().toString(“yyyy/MM/dd hh:mm:ss”);</li></ul><h4 id="Qss-前端人狂喜"><a href="#Qss-前端人狂喜" class="headerlink" title="Qss 前端人狂喜"></a>Qss 前端人狂喜</h4><ul><li>#myButton 这里的id实际上就是objectName指定的值</li><li>伪状态<ul><li>:active 当小部件驻留在活动窗口中时，将设置此状态</li><li>:checked    该控件被选中时候的状态</li><li>:hover    鼠标在控件上方</li><li>:pressed    该控件被按下时的状态</li><li>:disabled    该控件禁用时的状态</li><li>:first    该控件是第一个（列表中）</li><li>:focus    该控件有输入焦点时</li></ul></li></ul><h4 id="动画-QPropertyAnimation"><a href="#动画-QPropertyAnimation" class="headerlink" title="动画 QPropertyAnimation"></a>动画 QPropertyAnimation</h4><p>//winLabel 你要对那个组件使用动画  geometry几何结构<br>QPropertyAnimation * an = new QPropertyAnimation(winLabel,”geometry”);<br>//动画时间<br>an-&gt;setDuration(1000);<br>//动画开始<br>an-&gt;setStartValue(QRect(winLabel-&gt;x(),winLabel-&gt;y(),winLabel-&gt;width(),winLabel-&gt;height()));<br>//动画结束<br>an-&gt;setEndValue(QRect(winLabel-&gt;x(),winLabel-&gt;y() + 300,winLabel-&gt;width(),winLabel-&gt;height()));<br>//动画方式<br>an-&gt;setEasingCurve(QEasingCurve::OutBounce);<br>an-&gt;start();  </p><h4 id="背景音乐-QSound"><a href="#背景音乐-QSound" class="headerlink" title="背景音乐 QSound"></a>背景音乐 QSound</h4><ul><li>qmake: QT += multimedia</li><li>QSound * startSound = new QSound(“:/res/TapButtonSound.wav”,this); 载入音效</li><li>startSound-&gt;play(); 播放</li><li>startSound-&gt;setLoops(-1); -1循环次数无限</li></ul><h4 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h4><ul><li>debug-&gt;release</li><li>运行 运行失败添加环境变量D:\QT\5.12.3\mingw73_64\lib</li><li>把 Goldreverse.exe 单独丢到一个文件夹下</li><li>cmd中路径后windeployqt .\Goldreverse.exe 运行</li><li>此时已经可以使用了</li><li>深入打包[hm nis edit][<a href="https://www.bilibili.com/video/BV1g4411H78N?p=63&amp;spm_id_from=pageDriver%5D">https://www.bilibili.com/video/BV1g4411H78N?p=63&amp;spm_id_from=pageDriver]</a></li><li>HM NIS Edit 和 NSIS</li></ul><h3 id="Qt-amp-Clion-配置"><a href="#Qt-amp-Clion-配置" class="headerlink" title="Qt &amp; Clion 配置"></a>Qt &amp; Clion 配置</h3><h4 id="工具链的配置"><a href="#工具链的配置" class="headerlink" title="工具链的配置"></a>工具链的配置</h4><p>主要是配置工具链中的工具集，注意选中qt安装路径中的mingw</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221105202452526.png" class="" title="image-20221105202452526"><h4 id="CmakeList中的设置"><a href="#CmakeList中的设置" class="headerlink" title="CmakeList中的设置"></a>CmakeList中的设置</h4><p>在CmakeList中设置CMAKE_PREFIX_PATH 为 Qt安装路径中的cmake</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221105202714141.png" class="" title="image-20221105202714141"><h4 id="关于乱码问题"><a href="#关于乱码问题" class="headerlink" title="关于乱码问题"></a>关于乱码问题</h4><p>写入到student.text中的数据, 打开是乱码, 暂时还没有解决</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://blog.csdn.net/qq_41622214/article/details/124776481?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-124776481-blog-115482634.pc_relevant_multi_platform_whitelistv3&spm=1001.2101.3001.4242.1&utm_relevant_index=3">CLion配置Qt环境</a></li></ol><h3 id="案例一-翻金币"><a href="#案例一-翻金币" class="headerlink" title="案例一: 翻金币"></a>案例一: 翻金币</h3><hr><p><a href="https://www.bilibili.com/video/BV1g4411H78N?p=52&vd_source=d4177fc7398a75956465a504f7fd3259">视频链接</a></p><ul><li>收获<ol><li>删除资源文件后需要删除debug文件,不然会报错</li><li>界面的切换可以使用信号和槽 即其它界面emit发送一个信号,主界面接收<ul><li>当然也可以选择记录父类指针,但是必须要在构造函数中多传个参数，而不是使用默认的parent</li></ul></li><li>在按钮上方有其他组件，可以使用label-&gt;setAttribute(Qt::WA_TransparentForMouseEvents);让其可以点到按钮[51号属性]</li><li>界面翻转金币 本质上是个按钮 <ul><li>人点击后 </li><li>金币触发翻转</li><li>定时器每隔30ms发送一次信号给金币</li><li>金币触发图片重新放置,到最大值或者最小值的时候关闭定时器</li><li>金币中有坐标i 和 j 以及一个flag 来确定该金币在页面中的位置</li></ul></li><li>锁定窗口 m_chooseScence-&gt;setGeometry(this-&gt;geometry()); 每次进入或者退出都锁定他的位置</li></ol></li><li>延时器<br>QTimer::singleShot(毫秒,拉姆达表达式);</li></ul><h3 id="案例二-学生管理"><a href="#案例二-学生管理" class="headerlink" title="案例二: 学生管理"></a>案例二: 学生管理</h3><hr><p>参考大佬的代码, 建议连接上数据库</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;QT学习笔记&quot;&gt;&lt;a href=&quot;#QT学习笔记&quot; class=&quot;headerlink&quot; title=&quot;QT学习笔记&quot;&gt;&lt;/a&gt;QT学习笔记&lt;/h2&gt;&lt;hr&gt;
&lt;p&gt;未完待续。。。。。。 预计寒假期间完成&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;QWidget&quot;&gt;&lt;a </summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Processor Counter Monitor</title>
    <link href="http://okeyia.github.io/2022/07/27/Processor_Counter_Monitor/"/>
    <id>http://okeyia.github.io/2022/07/27/Processor_Counter_Monitor/</id>
    <published>2022-07-26T16:08:58.000Z</published>
    <updated>2022-11-06T05:08:30.933Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Processor-Counter-Monitor测量cache及带宽"><a href="#Processor-Counter-Monitor测量cache及带宽" class="headerlink" title="Processor-Counter-Monitor测量cache及带宽"></a>Processor-Counter-Monitor测量cache及带宽</h2><p>Performance Counter Monitor（PCM）是一个由英特尔开发的，也是基于PMU(performance monitoring unit)一个性能检测工具。</p><p>它是运行在msr 内核模块(perf是内核系统调用吧？)上的，提供了C++ API。</p><ul><li>pcm：CPU、cache</li><li>pcm-memory：内存带宽（每频道及每个DRAM DIMM槽）</li><li>pcm-latency：L1 cahce</li><li>pcm-pcie：PCIe</li><li>pcm-numa：NUMA架构</li><li>pcm-power：能耗</li></ul><p><a href="https://github.com/opcm/pcm">最新版</a> , 复现论文[Saga-Bench: Software and Hardware Characterization of Streaming Graph Analytics Workloads] 的过程中, <a href="https://github.com/opcm/pcm/tree/91dbfaaf1a956c669de6cb705e033bd28e313ef7">用到的历史版本</a> 。 </p><h3 id="一-编译PCM"><a href="#一-编译PCM" class="headerlink" title="一 编译PCM"></a>一 编译PCM</h3><p>从 <code>github</code> 下载好源码, 进行编译,  编译完成后, 测试实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">0.1秒监测一次，结果输出为test.csv文件</span></span><br><span class="line">sudo ./pcm.x 0.1 -csv=test.csv --external-program Test</span><br></pre></td></tr></table></figure><p>第一次运行可能会出现如下错误:</p><blockquote><p>PCM Error: can’t open MSR handle for core 0<br>Can not access CPUs Model Specific Registers (MSRs).<br>Try to execute ‘modprobe msr’ as root user and then<br>you also must have read and write permissions for /dev/cpu/<em>/msr devices (/dev/msr</em> for Android). The ‘chown’ command can help.<br>Access to Processor Counter Monitor has denied (no MSR or PCI CFG space access).</p></blockquote><p>解决方法, 切换到 root 用户, 执行 modprobe msr 。</p><h3 id="二-测量L2-L3-cache的缺失率"><a href="#二-测量L2-L3-cache的缺失率" class="headerlink" title="二 测量L2 L3 cache的缺失率"></a>二 测量L2 L3 cache的缺失率</h3><h4 id="2-1-pcmBasic-h"><a href="#2-1-pcmBasic-h" class="headerlink" title="2.1 pcmBasic.h"></a>2.1 pcmBasic.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCMBasic_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCMBasic_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/cpucounters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">CounterStateType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_processor_level_stats</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; out, <span class="keyword">const</span> PCM * m, <span class="keyword">const</span> CounterStateType &amp; state1, <span class="keyword">const</span> CounterStateType &amp; state2)</span></span>&#123;</span><br><span class="line">    assert(out.is_open());</span><br><span class="line">    <span class="comment">/* Output format/order: L2 MPKI, L3 MPKI, L2 hit rate, LLC hit rate, TLP (active cycles method), TLP (C state method = BigBench paper&#x27;s method)</span></span><br><span class="line"><span class="comment">     incoming QPI link utilization, outgoing QPI link utilization */</span></span><br><span class="line">    assert(m-&gt;isL2CacheMissesAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL3CacheMissesAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL2CacheHitRatioAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL3CacheHitRatioAvailable());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> uint32 qpiLinks = (uint32)m-&gt;getQPILinksPerSocket();    </span><br><span class="line">    <span class="keyword">double</span> incoming = <span class="number">0.0</span>; <span class="keyword">double</span> outgoing = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 i = <span class="number">0</span>; i &lt; m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (uint32 l = <span class="number">0</span>; l &lt; qpiLinks; ++l)&#123;</span><br><span class="line">            incoming += <span class="number">100.</span> * getIncomingQPILinkUtilization(i, l, state1, state2);</span><br><span class="line">            outgoing += <span class="number">100.</span> * getOutgoingQPILinkUtilization(i, l, state1, state2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> overallIncomingQPILinkUitlization = incoming / (m-&gt;getNumSockets() * qpiLinks);</span><br><span class="line">    <span class="keyword">double</span> overallOutgoingQPILinkUitlization = outgoing / (m-&gt;getNumSockets() * qpiLinks);</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; (<span class="keyword">double</span>(getL2CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2)) * <span class="number">1000</span> &lt;&lt; <span class="string">&quot;,&quot;</span> </span><br><span class="line">    <span class="comment">// L3 MPKI</span></span><br><span class="line">    &lt;&lt; (<span class="keyword">double</span>(getL3CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2)) * <span class="number">1000</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getL2CacheHitRatio(state1, state2) &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getL3CacheHitRatio(state1, state2) &lt;&lt; <span class="string">&quot;,&quot;</span>   </span><br><span class="line">    &lt;&lt; (<span class="keyword">double</span>(getCycles(state1, state2))/getInvariantTSC(state1, state2)) * <span class="number">100</span>  &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getCoreCStateResidency(<span class="number">0</span>, state1, state2)*<span class="number">100.</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; overallIncomingQPILinkUitlization &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; overallOutgoingQPILinkUitlization &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">CounterStateType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_processor</span><span class="params">(<span class="keyword">const</span> PCM * m, <span class="keyword">const</span> CounterStateType &amp; state1, <span class="keyword">const</span> CounterStateType &amp; state2, <span class="keyword">bool</span> update)</span></span>&#123;</span><br><span class="line">    ofstream out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(update)&#123;</span><br><span class="line">        out.open(<span class="string">&quot;UpdateProcLevel.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app); </span><br><span class="line">        display_processor_level_stats(out, m, state1, state2); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        out.open(<span class="string">&quot;AlgProcLevel.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app); </span><br><span class="line">        display_processor_level_stats(out, m, state1, state2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out.close();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCMBasic_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="2-2-调用实现"><a href="#2-2-调用实现" class="headerlink" title="2.2 调用实现"></a>2.2 调用实现</h4><p>注意: 调用程序的源码中使用 <code>#include pcmBasic.h</code> 包含头文件 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ######################### PCM Memory initialization Start ########################</span></span><br><span class="line">    PCM* m = PCM::getInstance();    </span><br><span class="line">    <span class="keyword">bool</span> PMM = <span class="literal">false</span>, update = <span class="literal">false</span>; <span class="keyword">int</span> rankA = <span class="number">-1</span>, rankB = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;hasPCICFGUncore())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Unsupported processor model (&quot;</span> &lt;&lt; m-&gt;getCPUModel() &lt;&lt; <span class="string">&quot;).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (m-&gt;memoryTrafficMetricsAvailable())</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;For processor-level memory bandwidth statistics please use pcm.x&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    ServerUncorePowerState * BeforeState = <span class="keyword">new</span> ServerUncorePowerState[m-&gt;getNumSockets()];</span><br><span class="line">    ServerUncorePowerState * AfterState = <span class="keyword">new</span> ServerUncorePowerState[m-&gt;getNumSockets()];</span><br><span class="line">    uint64 BeforeTime = <span class="number">0</span>, AfterTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before counter states     </span></span><br><span class="line">    <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i&lt;m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        BeforeState[i] = m-&gt;getServerUncorePowerState(i); </span><br><span class="line">    &#125;</span><br><span class="line">    BeforeTime = m-&gt;getTickCount();        </span><br><span class="line">    <span class="comment">// ####################### PCM Memory initialization Done #######################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// ######################### PCM Memory finalization Start ########################</span></span><br><span class="line">    AfterTime = m-&gt;getTickCount();</span><br><span class="line">    <span class="comment">// after counter states     </span></span><br><span class="line">    <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i&lt;m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        AfterState[i] = m-&gt;getServerUncorePowerState(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calculate_bandwidth(m, BeforeState, AfterState, AfterTime-BeforeTime, update, PMM);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] BeforeState;</span><br><span class="line">    <span class="keyword">delete</span>[] AfterState;</span><br><span class="line">    m-&gt;cleanup();</span><br><span class="line">    <span class="comment">// ###################### PCM Memory finalization Done #################</span></span><br></pre></td></tr></table></figure><h3 id="三-测量内存带宽"><a href="#三-测量内存带宽" class="headerlink" title="三 测量内存带宽"></a>三 测量内存带宽</h3><h4 id="3-1-pcmMemory-h"><a href="#3-1-pcmMemory-h" class="headerlink" title="3.1 pcmMemory.h"></a>3.1 pcmMemory.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCMMemory_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCMMemory_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处更改为pcm的路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/cpucounters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Programmable iMC counter</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_RANK_A 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_RANK_A 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_RANK_B 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_RANK_B 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARTIAL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMM_READ 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMM_WRITE 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NM_HIT 0  <span class="comment">// NM :  Near Memory (DRAM cache) in Memory Mode</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_DELAY_DEFAULT 1.0 <span class="comment">// in seconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_DELAY_MIN 0.015 <span class="comment">// 15 milliseconds is practical on most modern CPUs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_CALIBRATION_INTERVAL 50 <span class="comment">// calibrate clock only every 50th iteration</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uint32 max_sockets = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> uint32 max_imc_channels = ServerUncorePowerState::maxChannels;</span><br><span class="line"><span class="keyword">const</span> uint32 max_edc_channels = ServerUncorePowerState::maxChannels;</span><br><span class="line"><span class="keyword">const</span> uint32 max_imc_controllers = ServerUncorePowerState::maxControllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">memdata</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> iMC_Rd_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_Wr_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Rd_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Wr_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_Wr_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Wr_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> M2M_NM_read_hit_rate[max_sockets][max_imc_controllers];</span><br><span class="line">    <span class="keyword">float</span> EDC_Rd_socket_chan[max_sockets][max_edc_channels];</span><br><span class="line">    <span class="keyword">float</span> EDC_Wr_socket_chan[max_sockets][max_edc_channels];</span><br><span class="line">    <span class="keyword">float</span> EDC_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> EDC_Wr_socket[max_sockets];</span><br><span class="line">    uint64 partial_write[max_sockets];</span><br><span class="line">    <span class="keyword">bool</span> PMM;</span><br><span class="line">&#125; <span class="keyword">memdata_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output format: </span></span><br><span class="line"><span class="comment">socket(i) read bW, socket(i) write BW for all i; system read BW; system write BW; system total BW</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_bandwidth_alg</span><span class="params">(PCM *m, <span class="keyword">memdata_t</span> *md)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sysReadDRAM = <span class="number">0.0</span>, sysWriteDRAM = <span class="number">0.0</span>, total = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;AlgMem.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)&#123;</span><br><span class="line">        out &lt;&lt; md-&gt;iMC_Rd_socket[skt] <span class="comment">/* socket read BW (MB/s) */</span> &lt;&lt;  <span class="string">&quot;,&quot;</span> &lt;&lt; md-&gt;iMC_Wr_socket[skt] <span class="comment">/* socket write BW (MB/s) */</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;       </span><br><span class="line">        sysReadDRAM += md-&gt;iMC_Rd_socket[skt];   <span class="comment">// system read BW (MB/s)</span></span><br><span class="line">        sysWriteDRAM += md-&gt;iMC_Wr_socket[skt];  <span class="comment">// system write BW (MB/s)      </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total = sysReadDRAM + sysWriteDRAM;</span><br><span class="line">    out &lt;&lt; sysReadDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sysWriteDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_bandwidth_update</span><span class="params">(PCM *m, <span class="keyword">memdata_t</span> *md)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sysReadDRAM = <span class="number">0.0</span>, sysWriteDRAM = <span class="number">0.0</span>, total = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;UpdateMem.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)&#123;</span><br><span class="line">        out &lt;&lt; md-&gt;iMC_Rd_socket[skt] <span class="comment">/* socket read BW (MB/s) */</span> &lt;&lt;  <span class="string">&quot;,&quot;</span> &lt;&lt; md-&gt;iMC_Wr_socket[skt] <span class="comment">/* socket write BW (MB/s) */</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;        </span><br><span class="line">        sysReadDRAM += md-&gt;iMC_Rd_socket[skt];   <span class="comment">// system read BW (MB/s)</span></span><br><span class="line">        sysWriteDRAM += md-&gt;iMC_Wr_socket[skt];  <span class="comment">// system write BW (MB/s)      </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total = sysReadDRAM + sysWriteDRAM;</span><br><span class="line">    out &lt;&lt; sysReadDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sysWriteDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate_bandwidth</span><span class="params">(PCM *m, <span class="keyword">const</span> ServerUncorePowerState uncState1[], <span class="keyword">const</span> ServerUncorePowerState uncState2[], uint64 elapsedTime, <span class="keyword">bool</span> update, <span class="keyword">bool</span> PMM)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//const uint32 num_imc_channels = m-&gt;getMCChannelsPerSocket();</span></span><br><span class="line">    <span class="comment">//const uint32 num_edc_channels = m-&gt;getEDCChannelsPerSocket();</span></span><br><span class="line">    <span class="keyword">memdata_t</span> md;</span><br><span class="line">    md.PMM = PMM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)</span><br><span class="line">    &#123;</span><br><span class="line">        md.iMC_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_PMM_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_PMM_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.EDC_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.EDC_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.partial_write[skt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i &lt; max_imc_controllers; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            md.M2M_NM_read_hit_rate[skt][i] = <span class="number">0.</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> uint32 numChannels1 = m-&gt;getMCChannels(skt, <span class="number">0</span>); <span class="comment">// number of channels in the first controller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(m-&gt;getCPUModel()) &#123;</span><br><span class="line"><span class="keyword">case</span> PCM::KNL:</span><br><span class="line">            <span class="keyword">for</span>(uint32 channel = <span class="number">0</span>; channel &lt; max_edc_channels; ++channel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getEDCCounter(channel,READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getEDCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.EDC_Rd_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                    md.EDC_Wr_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                md.EDC_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getEDCCounter(channel,READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                md.EDC_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getEDCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                md.EDC_Rd_socket[skt] += md.EDC_Rd_socket_chan[skt][channel];</span><br><span class="line">                md.EDC_Wr_socket[skt] += md.EDC_Wr_socket_chan[skt][channel];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">for</span>(uint32 channel = <span class="number">0</span>; channel &lt; max_imc_channels; ++channel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getMCCounter(channel,READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getMCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>) <span class="comment">//In case of JKT-EN, there are only three channels. Skip one and continue.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!PMM || (getMCCounter(channel,PMM_READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getMCCounter(channel,PMM_WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        md.iMC_Rd_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                        md.iMC_Wr_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                md.iMC_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                md.iMC_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                md.iMC_Rd_socket[skt] += md.iMC_Rd_socket_chan[skt][channel];</span><br><span class="line">                md.iMC_Wr_socket[skt] += md.iMC_Wr_socket_chan[skt][channel];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(PMM)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.iMC_PMM_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,PMM_READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                    md.iMC_PMM_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,PMM_WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                    md.iMC_PMM_Rd_socket[skt] += md.iMC_PMM_Rd_socket_chan[skt][channel];</span><br><span class="line">                    md.iMC_PMM_Wr_socket[skt] += md.iMC_PMM_Wr_socket_chan[skt][channel];</span><br><span class="line"></span><br><span class="line">                    md.M2M_NM_read_hit_rate[skt][(channel &lt; numChannels1)?<span class="number">0</span>:<span class="number">1</span>] += (<span class="keyword">float</span>)getMCCounter(channel,READ,uncState1[skt],uncState2[skt]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    md.partial_write[skt] += (uint64) (getMCCounter(channel,PARTIAL,uncState1[skt],uncState2[skt]) / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span> (PMM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(uint32 c = <span class="number">0</span>; c &lt; max_imc_controllers; ++c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(md.M2M_NM_read_hit_rate[skt][c] != <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.M2M_NM_read_hit_rate[skt][c] = ((<span class="keyword">float</span>)getM2MCounter(c, NM_HIT, uncState1[skt],uncState2[skt]))/ md.M2M_NM_read_hit_rate[skt][c];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(update) display_bandwidth_update(m, &amp;md);</span><br><span class="line">    <span class="keyword">else</span> display_bandwidth_alg(m, &amp;md);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCMMemory_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="3-2-调用实现"><a href="#3-2-调用实现" class="headerlink" title="3.2 调用实现"></a>3.2 调用实现</h4><p>注意: 调用程序的源码中使用 <code>#include pcmMemory.h</code> 包含头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// #################### PCM Processor Level Stats initialization Start #######################</span></span><br><span class="line">    PCM* m = PCM::getInstance();    </span><br><span class="line">    <span class="keyword">bool</span> update = <span class="literal">false</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CoreCounterState&gt; cstates1, cstates2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SocketCounterState&gt; sktstate1, sktstate2;</span><br><span class="line">    SystemCounterState sstate1, sstate2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before counter states     </span></span><br><span class="line">    m-&gt;getAllCounterStates(sstate1, sktstate1, cstates1);        </span><br><span class="line">    <span class="comment">// #################### PCM Processor Level Stats initialization Done ###################</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ################### PCM Processor Level Stats finalization Start ####################</span></span><br><span class="line">    <span class="comment">// after counter states     </span></span><br><span class="line">    m-&gt;getAllCounterStates(sstate2, sktstate2, cstates2);</span><br><span class="line"></span><br><span class="line">    display_processor(m, sstate1, sstate2, update);    </span><br><span class="line">    </span><br><span class="line">    m-&gt;cleanup();</span><br><span class="line">    <span class="comment">// ######################## PCM Processor Level Stats finalization Done ###################</span></span><br></pre></td></tr></table></figure><h3 id="四-编译连接"><a href="#四-编译连接" class="headerlink" title="四 编译连接"></a>四 编译连接</h3><p>makefile 的编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PCM_DIR := /home/server2/pcm</span><br><span class="line"></span><br><span class="line">PCM_HDR := $(wildcard $(PCM_DIR)/*.h)</span><br><span class="line">PCM_SRC := $(wildcard $(PCM_DIR)/*.cpp)</span><br><span class="line"><span class="meta">#</span><span class="bash">PCM_OBJ := $(patsubst %.cpp,%.o,$(wildcard $(PCM_DIR)/*.cpp))</span></span><br><span class="line">PCM_OBJ := msr.o cpucounters.o pci.o mmio.o client_bw.o utils.o</span><br><span class="line">PCM_OBJ := $(addprefix $(PCM_DIR)/,$(PCM_OBJ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALL= memory_footprint run_static_algorithm run_batch_updates run_simultaneous_updates_queries</span><br><span class="line">all: $(ALL)</span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash"> : tools/%.cpp $(PCM_OBJ)</span></span><br><span class="line">        $(CC) $(CFLAGS) $(PFLAGS) -o $@ $^ $(JEMALLOC)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(PCM_OBJ) : $(PCM_SRC)</span></span><br><span class="line">cd $(PCM_DIR) &amp;&amp; make -f $(PCM_DIR)/Makefile</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f *.o $(ALL)</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/abasak24/SAGA-Bench/tree/master/pcmResource">saga-Bench pcmResource</a> 的代码实现</li><li><a href="https://chhzh123.github.io/blogs/2019-02-19-pcm/">CPU/内存监视器</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Processor-Counter-Monitor测量cache及带宽&quot;&gt;&lt;a href=&quot;#Processor-Counter-Monitor测量cache及带宽&quot; class=&quot;headerlink&quot; title=&quot;Processor-Counter-Moni</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="http://okeyia.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Cache" scheme="http://okeyia.github.io/tags/Cache/"/>
    
    <category term="Bandwidth" scheme="http://okeyia.github.io/tags/Bandwidth/"/>
    
  </entry>
  
  <entry>
    <title>图处理相关论文</title>
    <link href="http://okeyia.github.io/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    <id>http://okeyia.github.io/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/</id>
    <published>2022-05-15T03:43:57.000Z</published>
    <updated>2022-11-17T09:45:45.113Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图处理的相关论文"><a href="#图处理的相关论文" class="headerlink" title="图处理的相关论文"></a>图处理的相关论文</h2><blockquote><p>Benchmark：主要是对比别人的方法，这个方法不一定是最好的，但一定是最具有代表性且被广泛认可的（一种标准和规范）。其所用的数据就是benchmark data，其方法就是benchmark method，你提出的方法在benchmark data上得出的结果与benchmark method 的结果对比才知道你的方法是否足够好。</p><p>baseline:  主要关注自己提出的方法，比最原始最简单的方法出来的结果（参照物）。然后在这个基础上改进，增加各种组件，可以看出提升多少，通过baseline我们可以知道这个方法能不能work, 有多少提升。</p></blockquote><h3 id="STINGER-流图的高性能数据结构"><a href="#STINGER-流图的高性能数据结构" class="headerlink" title="STINGER: 流图的高性能数据结构"></a>STINGER: 流图的高性能数据结构</h3><hr><blockquote><p> Stinger的关键属性是具有偏斜度分布的语义图上的快速插入，删除和更新。提出了一种新的数据结构，能够达到比较快的更新速度。</p></blockquote><p>正是由于在偏斜度分布的图上面进行的，所有才会使用batch 更新的方法，在batch 中  STINGER 的后续实现首先对批次进行排序（通常一次 100,000 条边更新），以便将发生在特定顶点上的所有边更新与插入分开的删除分组在一起。</p><p><strong>为什么会有batch</strong>        </p><blockquote><p>在具有许多线程上下文和内存库的系统上，数据结构中的工作量或并行性通常不足以一次处理单个更新。为了解决这个问题，我们开始批量处理边缘更新。一个批次摊销了进入数据结构的成本，并提供了大量的独立工作要做。</p></blockquote><p><strong>实验：</strong> 为什么采用batch 更新的方式，当batch 的大小发生变化的时候，每秒更新的变数会提高？ 每秒更新的边的个数是怎么计算的？</p><blockquote><p>我们测量处理数据结构中每个边缘更新所花费的时间。我们测量了几个批次，并以每秒更新的形式报告了性能。</p></blockquote><p><strong>进一步的优化:</strong>  </p><blockquote><p>然而，在无标度图中，少数顶点将面临多次更新，而大多数顶点只有一次更新或根本没有更新。这种工作负载不平衡限制了我们可以利用的并行量，并迫使大多数线程等待少数线程完成。</p></blockquote><p>为了解决这个问题，跳过了对边进行分类，并行的处理每条边的插入。但是，处理同一顶点上的两个边更新事件会引入竞争条件，必须通过适当的同步来处理。 并没有在软件商提出解决办法，而是使用Cray XMT 是这个场景的完美系统。（Cray XMT（Cray eXtreme MultiThreading，[1] 代号 Eldorado[2]）是 Cray 公司基于第三代 Tera MTA 架构的可扩展多线程共享内存超级计算机架构，针对大型图问题），但是这个系统近10年没有消息。</p><p><strong>缺点:</strong>  在整篇论文中只提到了更新，没有考虑查询的情况。</p><h3 id="图处理工作负载内存层次结构的分析与优化"><a href="#图处理工作负载内存层次结构的分析与优化" class="headerlink" title="图处理工作负载内存层次结构的分析与优化"></a>图处理工作负载内存层次结构的分析与优化</h3><p align = "right" > ——2019年发表在 `HPCA` 上面的一篇论文<p/><hr><p>Analysis and Optimization of the Memory Hierarchy for Graph Processing Workloads。</p><p><strong>提出问题:</strong> 在微架构级别，性能受到单机内存图分析的内存子系统效率低下的限制。本文的目标是解决单机内存图分析的内存效率低下问题。</p><ol><li>首先，我们在模拟的多核架构上对图形处理工作负载进行深入的数据类型感知表征。我们分析 1) 乱序内核中的内存级并行性和 2) 缓存层次结构中的请求重用距离。我们发现，涉及不同应用程序数据类型的加载-加载依赖链构成了实现高内存级并行性的主要瓶颈。我们还观察到不同的图数据类型表现出异构的重用距离。因此，私有 L2 缓存对性能的贡献可以忽略不计，而共享 L3 缓存表现出更高的性能敏感度。</li><li>基于他们的观察结构，提出了 DROPLET，这是一种用于图应用程序的数据感知解耦 预取器。 DROPLET 根据其固有的重用距离以不同的方式预取不同的图形数据类型。</li></ol><p>这里通过 <code>Using Cycle Stacks to Understand Scaling Bottlenecks in Multi-Threaded Workloads</code> 介绍的方法，使用pagerank 在 orkut上面 得到了 ==Cycle stack==。  45% 的周期是 DRAM 绑定的停顿周期，而内核被充分利用而仅在 15% 的周期内没有停顿。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221114164748773.png" class="" title="image-20221114164748773"><h4 id="一-借鉴的方向"><a href="#一-借鉴的方向" class="headerlink" title="一 借鉴的方向"></a>一 <strong>借鉴的方向</strong></h4><blockquote><p>现代 CPU 中使用的三种关键延迟容忍技术是 OoO 执行产生的 MLP、片上缓存(常说的三级cache)和预取。</p><p>OoO 执行依赖于重新排序缓冲区 (ROB) 向前看指令流，它可以在加载/存储队列、非阻塞缓存和 DRAM 中的并行性的帮助下支持多个正在运行的内存请求。</p></blockquote><p>这里主要参考优化的第一个方向,  通过两个特征来深入了解fig 1中的内存受限行为</p><ol><li>乱序执行中的内存级并行性（MLP）</li><li>cache层次结构中的重用距离</li></ol><blockquote><p>参考知乎: <a href="https://www.zhihu.com/question/28611947">https://www.zhihu.com/question/28611947</a></p><p><strong>instruction size 的概念:</strong>  标量乱序执行的核心就是不断的检查未来的指令，并从中发掘可以并行执行的指令，从而最终提升IPC。这个可以乱序执行的指令窗口叫做instruction window，这是衡量现代CPU性能的一个重要指标（举个不太恰当的例子，以前参加智能车比赛，摄像头看得越远理论上可以跑的越快）。</p><p>有两个关键因素影响着不断增加的instruction window size，一个是<strong>分支预测</strong>（branch prediction），准确的分支预测（目前的指标可以做到小于10MPKI，MPKI是没1000条指令中预测错误数目）可以保证绝大多数情况下instruction window 中的指令都是在正确的 程序路径 上。否则总是错误的预测执行（speculative execution）反而会降低IPC。 另外一个关键就是<strong>寄存器重命名和 reorder buffer 的大小</strong>。reorder buffer是实现乱序执行同时保持程序正确性和精确异常的关键，每条指令在译码之后会分配一个reorder buffer的entry，reorder buffer后面会按照指令顺序commit保证程序正确性。通常指令窗口大小（instruction window size）就是reorder buffer entry size，intel的几个关键节点的微架构的instruction window大小如下，Nehalem（45nm）128， Haswell（22nm）192，Sunny Cove（10nm）352。苹果的M1目前达到了~600（一部分原因是ARM不需要micro-ops译码，从而可以实现更高的instruction译码带宽8-wide）。</p></blockquote><h4 id="二-特征描述"><a href="#二-特征描述" class="headerlink" title="二 特征描述"></a>二 特征描述</h4><h4 id="2-1-指令窗口大小不是阻碍-MLP-的因素"><a href="#2-1-指令窗口大小不是阻碍-MLP-的因素" class="headerlink" title="2.1 指令窗口大小不是阻碍 MLP 的因素"></a>2.1 指令窗口大小不是阻碍 MLP 的因素</h4><ol><li>之前有论文说 ROB是影响MLP的主要因素，他们通过扩大指令窗口的大小，发现==带宽==并没有明显的增加。</li><li>第二个是发现加速比也没有明显的增加。</li></ol><h4 id="2-1-2-负载依赖链阻止实现高-MLP"><a href="#2-1-2-负载依赖链阻止实现高-MLP" class="headerlink" title="2.1.2 负载依赖链阻止实现高 MLP"></a>2.1.2 负载依赖链阻止实现高 MLP</h4><blockquote><p>laod-load dependency chains prevent achieving high MLP</p></blockquote><p>为了理解为什么大的ROB不能提升内存间的并行, 我们跟踪 ROB 中加载指令的依赖关系, MLP 受固有的应用程序级依赖特性的限制。</p><h4 id="2-1-3-图属性数据是依赖链中的消费者"><a href="#2-1-3-图属性数据是依赖链中的消费者" class="headerlink" title="2.1.3 图属性数据是依赖链中的消费者"></a>2.1.3 图属性数据是依赖链中的消费者</h4><p>平均而言，我们发现图形属性数据主要是消费者（53.6%）而不是生产者（5.9%）。发布(issuing)图形属性数据加载被延迟并且不能并行化，因为它必须依赖生产者加载来计算地址。</p><h4 id="2-1-4-私有-L2-缓存表现出可忽略的性能敏感性，而共享-LLC-表现出更高的性能敏感性"><a href="#2-1-4-私有-L2-缓存表现出可忽略的性能敏感性，而共享-LLC-表现出更高的性能敏感性" class="headerlink" title="2.1.4 私有 L2 缓存表现出可忽略的性能敏感性，而共享 LLC 表现出更高的性能敏感性"></a>2.1.4 私有 L2 缓存表现出可忽略的性能敏感性，而共享 LLC 表现出更高的性能敏感性</h4><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221116195030491.png" class="" title="image-20221116195030491"><p>如图 4a 所示，我们将 LLC 大小从 8MB 更改为 64MB，并找到 17.4%（最大 3.25X）性能改进的最佳点，LLC 容量增加 4 倍。平均 LLC MPKI（每千克指令缺失）从基线中的 20 减少到 16 (16MB) 到 12 (32MB) 到 10 (64MB)。相应的加速比分别为 7%、17.4% 和 7.6%。最佳点是在降低的未命中率和更大的 LLC 访问延迟之间取得平衡。</p><p>图 4b(i) 显示 L2 命中率（在基线中已经非常低，为 10.6%）在容量增加 2 倍后增加到仅 15.3%，而集关联性增加 4 倍没有影响（命中率升至仅 10.9%）。</p><p>图 4b(ii) 显示系统性能对不同的 L2 缓存配置（容量和集合关联性）表现出很小的敏感性。最左边的条表示没有私有 L2 缓存的架构，与 256KB 缓存相比没有减速。因此，没有私有 L2 缓存的架构同样适用于图形处理。</p><h4 id="2-1-5-属性数据是-LLC-容量的主要受益者"><a href="#2-1-5-属性数据是-LLC-容量的主要受益者" class="headerlink" title="2.1.5 属性数据是 LLC 容量的主要受益者"></a>2.1.5 属性数据是 LLC 容量的主要受益者</h4><p>为了了解哪种数据类型受益于更大的 LLC，图 4c 显示了对于每种数据类型，最终从 DRAM 获取数据的内存引用的百分比。属性数据下降最为明显.</p><h4 id="2-1-6-图结构缓存行在所有数据类型中具有最大的重用距离。-Graph-property-cacheline-具有比-L2-缓存服务更大的重用距离"><a href="#2-1-6-图结构缓存行在所有数据类型中具有最大的重用距离。-Graph-property-cacheline-具有比-L2-缓存服务更大的重用距离" class="headerlink" title="2.1.6 图结构缓存行在所有数据类型中具有最大的重用距离。 Graph property cacheline 具有比 L2 缓存服务更大的重用距离"></a>2.1.6 图结构缓存行在所有数据类型中具有最大的重用距离。 Graph property cacheline 具有比 L2 缓存服务更大的重用距离</h4><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221116195837647.png" class="" title="image-20221116195837647"><blockquote><p>Graph structure cacheline has the largest reuse distance among all the data types. Graph property cacheline has a larger reuse distance than that serviced by the L2 cache.</p></blockquote><p>为了进一步了解 L2 和 L3 缓存的不同性能敏感性，我们按应用程序数据类型分解内存层次结构使用情况，如图 7 所示。</p><ol><li>在大多数基准测试中，对结构数据的访问由 L1 缓存和 DRAM 提供服务，这表明 L1 中丢失的缓存行是在遥远的过去引用的缓存行，因此它已从 L2 和 L3 缓存中被逐出。 重用距离超出 LLC 的服务能力这一事实解释了为什么更大的 LLC 无法显着降低图 4c 中片外结构访问的比例。</li><li>另一方面，L1 缓存中丢失的大部分属性数据加载不能由 L2 缓存提供服务，但可以由 LLC 和 DRAM 提供服务。总的来说，LLC 在服务属性访问方面比结构访问更有用。因此，property cacheline 的重用距离相对较小，但仍大于 L2 缓存捕获的重用距离</li><li>最后，图 7 提供的证据表明，对中间(顶点)数据的访问主要是 L1 缓存和 LLC 中的片上缓存命中。</li></ol><p>**最终: ** 三种数据类型的重用距离解释了为什么私有 L2 缓存无法为内存请求提供服务并且显示出微不足道的好处。</p><h4 id="三-总结与机遇"><a href="#三-总结与机遇" class="headerlink" title="三 总结与机遇"></a>三 总结与机遇</h4><p>图形分析中内存限制的停顿行为是由两个问题引起的：</p><ol><li>不同数据类型的异构重用距离导致密集的 DRAM 访问以检索结构和属性数据。</li><li>由于负载依赖链导致的低 MLP，限制了重叠 DRAM 访问的可能性</li></ol><hr><h3 id="Graphfire：为图处理协同获取、插入和替换策略"><a href="#Graphfire：为图处理协同获取、插入和替换策略" class="headerlink" title="Graphfire：为图处理协同获取、插入和替换策略"></a>Graphfire：为图处理协同获取、插入和替换策略</h3><blockquote><p>已经开发了专门的图形定制预取机制、处理器设计和内存层次结构引擎，以容忍此类访问的长时间延迟. ==但是==这些方法要么过于占用带宽，要么需要进行侵入性硬件更改，从而抑制通用计算的灵活性，要么依赖于限制真正加速的软件预处理。</p></blockquote><p>这项工作引入了 Graphfire，这是一种灵活的内存层次结构方法，可以学习图形处理中的不同访问模式，并利用专门的获取、插入和替换优化的协同作用来解决有问题的间接访问，而无需依赖软件或 ISA 支持。</p><h4 id="一-已有工作的问题"><a href="#一-已有工作的问题" class="headerlink" title="一 已有工作的问题"></a>一 已有工作的问题</h4><ul><li>大量工作涉及缓存管理技术 这些技术都没有考虑图形应用程序的特定访问模式，而是专注于那些在更常规的工作负载中众所周知和常见的模式，例如streaming、strided、thrashing、mixed 等。因此，当这些技术应用于图形分析时，这些技术产生的任何硬件开销都被浪费了。</li><li>GRASP [15] 提出了针对图分析的领域专业化 LLC 管理的第一步，但会产生基于度的图重新排序的软件预处理成本 [14]。软件预处理使得该技术对于大图不太实用，例如在许多应用场景中，输入图只被处理一次 [5]，或者甚至没有完全遍历图，例如在搜索算法中。</li></ul><p>据我们所知，对于图形应用程序<strong>，不存在可以在没有软件支持的情况下学习和优化其访问模式的内存层次结构方法</strong>。</p><h4 id="二-我们的工作"><a href="#二-我们的工作" class="headerlink" title="二 我们的工作"></a>二 我们的工作</h4><p>以优化图形应用程序的缓存性能为目标，我们的工作做出以下==关键观察==：</p><ol><li>内存层次结构必须专门针对有问题的间接访问（ problematic indirect accesses）来缓解它们的瓶颈。</li><li>要与软件无关，==轻量级机制==必须自动识别 PIA，这可以在每个指令的基础上实现。</li><li>虽然 PIA 是不规则的，但其中的一个子集具有很高的重用性，因此 LLC 必须保留它们。</li></ol><p><strong>所用的方法：</strong></p><p>鉴于这些观察结果，本文提出了 Graphfire，这是一种灵活的、基于硬件的内存层次结构方法</p><ul><li>了解图形应用程序中何时出现 PIA</li><li>通过定制的获取、插入和替换策略优化它们的性能。</li></ul><h4 id="三-MOTIVATION"><a href="#三-MOTIVATION" class="headerlink" title="三 MOTIVATION"></a>三 MOTIVATION</h4><h5 id="3-1-内存访问模式"><a href="#3-1-内存访问模式" class="headerlink" title="3.1 内存访问模式"></a>3.1 内存访问模式</h5><p>图形应用程序因数据遍历引起的不规则内存访问而臭名昭著。最先进、高效的算法实现通过两个嵌套的内核循环迭代地执行图形遍历，并利用压缩稀疏行 (CSR) 格式将输入数据集有效地存储为一维密集数组 [45]。</p><p>指针间接访问发生在顶点属性数组中，该数组存储每个顶点的结果，例如距离或等级 [6]。 CSR 数组存储图形信息，例如顶点和边缘位置，但经常和/或不经常访问。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117103412358.png" class="" title="image-20221117103412358"><p><strong>上图是图处理内核的伪代码</strong>， 外部循环（第 2-5 行）遍历顶点工作列表（针对当前算法迭代），而内部循环（第 6-13 行）分析当前顶点的邻居以潜在地更新它们的数据，具体取决于算法的目标。如果更新了邻居，则将其添加到下一次算法迭代的工作列表中（第 12-13 行）。该算法在工作列表为空（第 1 行）时终止，即图已遍历且更新已稳定。</p><p>==外循环中的指令==相对于内循环中的指令很少出现，特别是对于具有高边顶点比的图。访问是流式的或间接的（这里的访问是流失的是什么意思? 一直访问吗?） </p><h6 id="3-1-1-Infrequent-Streaming"><a href="#3-1-1-Infrequent-Streaming" class="headerlink" title="3.1.1 Infrequent, Streaming"></a>3.1.1 Infrequent, Streaming</h6><p>这些访问出现在外部 for 循环或内部循环的条件内部，并具有流式行为。如图 1 的第 2 行所示，该算法遍历顶点工作列表并以流方式加载每个顶点索引。然而，这种访问并没有表现出良好的局部性，因为在内核的内部循环中，每次访问都可以被多次内存访问分开。</p><h6 id="3-1-2-Infrequent-Indirect"><a href="#3-1-2-Infrequent-Indirect" class="headerlink" title="3.1.2 Infrequent, Indirect"></a>3.1.2 Infrequent, Indirect</h6><p>这些指针间接访问出现在外部 for 循环或内部循环中的条件。当前顶点 v 索引到 vertex_ptr 数组以加载其邻居列表索引（第 4-5 行）并确定内循环迭代次数。对起始索引的第一个加载（第 4 行）是指针间接的，而第二个（第 5 行）具有局部性。另一个间接访问来自有条件地更新顶点属性数据（第 10 行）。但是，这些不规则访问不会对性能产生重大影响，因为它们很少发生。</p><h6 id="3-1-3-Primary-Streaming-Accesses-PSAs"><a href="#3-1-3-Primary-Streaming-Accesses-PSAs" class="headerlink" title="3.1.3 Primary Streaming Accesses (PSAs)"></a>3.1.3 Primary Streaming Accesses (PSAs)</h6><p>这些访问发生在内部 for 循环的关键路径中，并执行流式加载或存储到相邻索引（第 6 行）。这些是真正的流式访问，同时展示了时间和空间局部性，并且它们经常且定期发生。因此，它们是缓存友好的，不会造成数据供应瓶颈。我们将这些访问称为主要流访问 (PSA) 来描述这些特征。</p><h6 id="3-1-4-Primary-Indirect-Accesses"><a href="#3-1-4-Primary-Indirect-Accesses" class="headerlink" title="3.1.4 Primary Indirect Accesses"></a>3.1.4 Primary Indirect Accesses</h6><p>这些访问也发生在内部 for 循环的关键路径中，并执行指针间接加载（在第 8 行中突出显示）到顶点属性数组，以便为给定的邻居加载数据。由于这些间接访问发生在每个循环迭代中，并且具有导致性能成本的较长延迟，因此它们是图应用程序的数据供应瓶颈的原因。我们将它们称为主要间接访问 (PIA)，并在下一节中详细介绍它们的特性。</p><h5 id="3-2-The-Problems-with-PIAs"><a href="#3-2-The-Problems-with-PIAs" class="headerlink" title="3.2 The Problems with PIAs"></a>3.2 The Problems with PIAs</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117112612220.png" class="" title="image-20221117112612220"><p>顶点属性数组是 PIA 的主要来源，但是分析footprint, 发现只占应用程序总内存占用量的很小一部分。（这里的内存占用是指什么？）然后做实验发现了<strong>尽管 PIA 的数据占用空间相对较小，但它们本身占应用程序访问总数的很大一部分。</strong> 当应用程序遍历图形时，必须对顶点属性数组进行频繁更新。将不规则性与频率相结合会产生==内存延迟性能瓶颈==。</p><p>图 3 将总内存延迟分解为 PIA 与其他内存访问。在所有应用程序和输入中，PIA 的延迟平均占总内存延迟的 88%，构成了主要的应用程序性能瓶颈。因此，必须在内存层次结构中进行创新，以解决这些引用所表现出的缺乏规律性和局部性的问题。</p><h6 id="3-2-1-Lack-of-Locality"><a href="#3-2-1-Lack-of-Locality" class="headerlink" title="3.2.1 Lack of Locality"></a>3.2.1 Lack of Locality</h6><p>不幸的是，PIA 的不规则性导致它们表现出较差的局部性。对于上述应用程序/输入组合，平均而言，在 64B 逐出缓存行中有 54.1 (L1)、59.9 (L2) 和 59.5 (L3) 字节未使用。因此，为 PIA 获取整个缓存行的数据是一种浪费。这个没有具体的数据来表示？ 是怎么计算出来的？</p><h6 id="3-2-2-访问模式之间的干扰"><a href="#3-2-2-访问模式之间的干扰" class="headerlink" title="3.2.2 访问模式之间的干扰"></a>3.2.2 访问模式之间的干扰</h6><p>同一缓存集中不同内存访问模式的共存会损害性能。 PIA 可能会被 PSA 或其他不频繁访问逐出，从而导致多次冲突未命中，尤其是具有高重用性的 PIA 应保留在 LLC [6] 中。由于其不规则性和频率，PIA 是 LLC 中的主要驱逐对象。平均而言，21% 的驱逐是由其他类型的访问造成的。消除这种干扰可以提高 PIA 的缓存性能。</p><h6 id="3-2-3-变量-PIA-重用"><a href="#3-2-3-变量-PIA-重用" class="headerlink" title="3.2.3 变量 PIA 重用"></a>3.2.3 变量 PIA 重用</h6><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117112845107.png" class="" title="image-20221117112845107"><p>图 4 展示了 BFS 在 Kronecker 网络上运行时的 PIA 访问和重用直方图。这捕捉了许多现实世界数据集的幂律趋势。图 4a 显示很少有顶点被频繁访问，而大多数顶点很少被访问。具有高重用性的顶点不应被低重用性 PIA 逐出。图 4b 说明了 PIA 重用距离的可变性。许多被重用，但大多数重用距离太长（相对于缓存关联性）以防止 PIA 被逐出。因此，PIA 的替换策略应适应顶点特征。</p><h3 id="用于图形分析的领域专用缓存管理"><a href="#用于图形分析的领域专用缓存管理" class="headerlink" title="用于图形分析的领域专用缓存管理"></a>用于图形分析的领域专用缓存管理</h3><p>Domain-Specialized Cache Management for Graph Analytics                                              ——HPCA 20</p><hr><h3 id="多核系统中处理内存干扰的技术-17-浙大"><a href="#多核系统中处理内存干扰的技术-17-浙大" class="headerlink" title="多核系统中处理内存干扰的技术 17 浙大"></a>多核系统中处理内存干扰的技术 17 浙大</h3><p>在多核系统中，同时运行的多个应用程序相互竞争访问共享的资源，如互连、高速缓 存和内存等。如果对可用的共享高速缓存容量和内存带宽的管理不恰当的话，不同应用程 序相互干扰，严重影响对方的运行。</p><blockquote><p>例如，在内存处，应用程序原有的行缓冲命中率和阵列级并行度会受到破坏，同时请求在读写队列中等待的时间也会因竞争激烈程度的加剧而 大幅增加；在高速缓存处，不同应用程序可能相互驱逐对方在高速缓存中的块，导致原有 命中率的破坏。</p></blockquote><p>请求在内存处的时延主要包含在队列中的等待时间和在DRAM中执行时间，这两 个部分受内存调度算法的影响特别大。</p><h4 id="创新-基于动态多层次优-先级的内存访问调度算法-DMPS"><a href="#创新-基于动态多层次优-先级的内存访问调度算法-DMPS" class="headerlink" title="创新: 基于动态多层次优 先级的内存访问调度算法 DMPS"></a>创新: 基于动态多层次优 先级的内存访问调度算法 DMPS</h4><p>识别应用程序的内存访问调度算法一般 由三部分组成：</p><ol><li>检测应用程序的内存访问特征；</li><li>基于内存访问特征来将应用程序分 类，以至于易受干扰的应用程序拥有更高的优先级；</li><li>选择优先级最高的就绪命令来执 行。</li></ol><h4 id="一-DRAM-访问过程"><a href="#一-DRAM-访问过程" class="headerlink" title="一 DRAM 访问过程"></a>一 DRAM 访问过程</h4><p>行缓冲是阵列中感应放大器单元的集合，是DRAM和内存控制器交互的接口。一般来说，行缓冲的大小为 <code>2-16KB</code>。</p><p>在行缓冲的行没有被关掉之前，行缓冲类似于高速缓存， 命中的话可减小访问延迟。到DRAM的访问可分为三步：</p><ol><li>激活命令，在目标阵列中打 开目标行，将其内容转移到行缓冲中</li><li>读写命令，在行缓冲中访问目标列；</li><li>预充电 命令，将行缓冲中的内容写回阵列的数组，关闭行缓冲的行。</li></ol><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220727095026744.png" class=""><h4 id="二-页管理策略"><a href="#二-页管理策略" class="headerlink" title="二 页管理策略"></a>二 页管理策略</h4><p>页管理策略管理行缓冲中感应放大器的操作，基本的策略有两种：开页策略和关页策 略</p><p>在开页策略中，<strong>行缓冲只在没 有到打开行的访问且有到其他行的访问时才关闭。</strong>开页策略的重要假设是一旦某一行数 据移到行缓冲中，那么在不久的将来该行的其他列会被访问，即偏爱到同一行的访问，适 合于空间局部性好的应用程序。访问类型主要是行命中和行冲突，对于行命中率高的程 序，开页策略能大幅提高性能。</p><p>在关页策略中，行缓冲在每个访问结束后都会关闭，访问 类型只有行关闭。关页策略适合到不同行的随机访问，同时每个访问的时延一样，有利于 带宽分配和实时控制</p><h4 id="三-地址映射机制"><a href="#三-地址映射机制" class="headerlink" title="三 地址映射机制"></a>三 地址映射机制</h4><p>地址映射机制负责将系统的内存地址空间映射到DRAM的逻辑结构中，具体来说，地 址映射机制将访问的物理地址转换成通道、排、阵列、行、列等值，具体化数据的放置位 置，对于性能有巨大的影响。当某块放置在某阵列中，下一块可以放置在同一行中、或者 同一阵列的下一行中、或者同一排的下一阵列中、或者同一通道的下一排中、又或者下一 通道中，所以地址映射机制决定了内存系统中可利用的并行度。</p><p>常见的地址映射机制有两 种：块交叉(Cacheline Interleaving)和行交叉(Row Interleaving)，如图2．3所示。行交叉将 连续的块放置在同一行中，试图最大化行缓冲命中率，适用于开页策略；而块交叉将连续 的块分散到不同的通道、排和阵列中，从而最大化内存访问并行度，适用于关页策略。最 小化开页(Minimalist Open Page) 则在两者之间做了权衡，通过少量的行命中实现开页 的增益，同时提高并行度来防止访问饥饿的现象和保证公平性。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220727103932041.png" class="" title="image-20220727103932041"><hr><h3 id="基于依赖感知的动态有向图处理加速器-20-华科"><a href="#基于依赖感知的动态有向图处理加速器-20-华科" class="headerlink" title="基于依赖感知的动态有向图处理加速器 20 华科"></a>基于依赖感知的动态有向图处理加速器 20 华科</h3><p>图算法通常需要对整个图进行反复迭代处理，不断地更新图顶点状态值，最终使 得所有图顶点状态值都不再发生改变，才停止迭代处理过程。因此，现有动态图处理 系统通常采用图迭代模型对最新图镜像执行增量计算。</p><p>目前的图迭代模型通常包括 批量同步迭代方法（Bulk Synchronous Parallel，BSP）模型和异步迭代模型。</p><h4 id="1-同步迭代模型"><a href="#1-同步迭代模型" class="headerlink" title="1 同步迭代模型"></a>1 同步迭代模型</h4><p>如图 1.3 所示，同步 BSP 迭代模型使用同步屏障机制将整个执行流程划分为数 个迭代周期。在每轮迭代中，基本并行处理单元被分配给各线程并行处理，通过对图 顶点及其相连的边执行运算以获得图顶点状态值（即，算法结果）。然而，由于同步 屏障的限制，各个图顶点都只能使用其前序图顶点在前一轮迭代中的旧状态值来计 算各自的新状态值，所有图顶点都完成各自的计算才能开始新的一轮迭代。迭代周期 交错进行，直到达到收敛状态。当 图处理系统并行处理图数据时，图数据被划分为并 行块并且分配给不同的处理单元。不同并行块之间通过共享内存或者消息通信机制 进行数据交换。</p><p>近年来，软件图处理系统和图加速器提出许多图划分方法，运行时负 载均衡策略和访存优化策略以提高每一轮迭代中图处理系统的吞吐率，并且已经达 到很好的效果。然而，受限于同步 BSP 迭代模型，图顶点的状态值在每轮迭代中只 能到达其直接后代图顶点，造成图顶点状态值的缓慢传播。因此，现有的同步 BSP 迭代模型不能有效支持动态图增量计算对低延迟和实时性的要求。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801201253986.png" class="" title="image-20220801201253986"><h4 id="2-异步迭代模型"><a href="#2-异步迭代模型" class="headerlink" title="2 异步迭代模型"></a>2 异步迭代模型</h4><p>不同于同步 BSP 迭代模型，如图 1.4 所示，异步迭代模型消除了同步屏障，当 前迭代计算得到的结果可以立即用于同一迭代中其它图顶点的状态值更新。因此，在 采用异步迭代模型的情况下，动态图中的图顶点的状态值传递速度通常快于同步 BSP 迭代模型，能够加快迭代收敛速度。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801201340527.png" class="" title="image-20220801201340527"><p>然而在异步迭代中，同时处理相邻图顶点会导致共享内存的读写冲突。为保证 异步迭代的顺序一致性，一些工作[20]对共享数据加锁以避免相邻图顶点的同时处 理。这导致大量锁开销，严重影响了大度图顶点的执行效率，对异步迭代处理性能 产生影响。为了减少原子开销，一些子图中心的异步迭代方法针对系统资源数 量，将有向图划分为图数据块并且分配图数据块给各个并行处理单元。不同图数据 块被并行地处理，通过消息通信机制同步不同图数据块之间的图顶点状态值。在各 个数据块内部，图顶点被串行地，异步地执行以快速传递图顶点状态值。</p><h4 id="3-设计动机"><a href="#3-设计动机" class="headerlink" title="3 设计动机"></a>3 设计动机</h4><blockquote><p>现有的同步 BSP 迭代模型和异步迭代模型能够提升有向图算法的并行度， 广泛应用于多种图处理系统和图加速器中。然而，由于动态有向图增量计算对实时性 要求极高，现有的迭代模型仍然面临着收敛速度缓慢和冗余数据计算和访问等问题， 无法满足用户对动态有向图处理的实时性需求。</p></blockquote><p>在动态有向图增量计算中，受到动态图变化影响的图顶点会沿着有向路径不断 地传递各自的状态值，因此，动态有向图处理的实时性直接受到图顶点的状态值传递 速度的影响。对于迭代有向图算法，每个图顶点都需要读取其前序图顶点的状态值以 重复更新自身的最新状态值，直到迭代收敛为止。但是，当在现有平台上并行执行图 算法时，大多数图顶点和它的前序图顶点被多个并行处理单元同时处理，在每轮迭代 中根据其前序图顶点的过时状态值更新以更新自身的状态值。结果，当使用现有的同 步/异步迭代模型时，活跃图顶点的最新状态值只能够缓慢地沿着有向路径传播到其 他的图顶点，并且根据其它图顶点的陈旧状态值来重复进行计算以更新自身。这不仅 浪费了大量时间用于处理冗余图顶点，还需要高额访存开销以反复加载这些图数据。</p><h5 id="3-1-同步BSP迭代过程"><a href="#3-1-同步BSP迭代过程" class="headerlink" title="3.1 同步BSP迭代过程"></a>3.1 同步BSP迭代过程</h5><p>如图 2.1 所示，动态图处理系统采用同步 BSP 迭代模型执行增量计算。在初始 状态时，动态有向图中所有的图顶点都达到收敛状态，并且相应的计算结果被维护。 当动态有向图结构发生变化时，例如，新增加了指向𝑣&amp;、𝑣’和𝑣(的边，需要重新进行 增量计算以获得最新图镜像的计算结果。图处理系统将激活图顶点，并且按照同步 BSP 迭代方式处理这些图顶点。在第一轮同步迭代中，𝑣&amp;的状态值首先被传递给其 后代图顶点𝑣’。然而，由于同步屏障，活跃图顶点的新状态值不能够立即被同一轮同 步迭代中的其它图顶点使用，因此，𝑣’不能够立即使用𝑣&amp;的状态值，也无法将𝑣&amp;的状态值立即传递给其后代图顶点𝑣(。当新的一轮迭代开始后，𝑣’才将自己接收到的𝑣&amp;传 递来的状态值后得到的结果传递给𝑣(。按照这种方式，在图数据块 P2 中的图顶点需 要至少三轮同步迭代才能将状态值传递给其它图数据块，造成了大量的冗余图数据 计算和访问，导致图顶点状态值缓慢地在有向图中传播。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801204827566.png" class="" title="image-20220801204827566"><h5 id="3-2-异步迭代模型"><a href="#3-2-异步迭代模型" class="headerlink" title="3.2 异步迭代模型"></a>3.2 异步迭代模型</h5><blockquote><p>由于传统的 round-robin 异步迭代模型[21]通常按照图顶点索引次序依次异步串行地处理活跃图顶 点，这忽略了有向图结构本身的更新依赖关系，导致低拓扑顺序的图顶点比高拓扑顺 序的图顶点先被处理。已经处理过的图顶点的状态值只能在下一轮异步迭代中才能 再次被处理，因此，在传统的异步迭代模型下，图顶点状态值仍然缓慢地在有向图中 传播，造成冗余图顶点更新。</p></blockquote><p>如图 2.2 所示，当动态图处理系统采用 round-robin 异步迭代模型执行增量计算 时，在其中一轮异步迭代过程中，一条已经被动态图改变量激活的有向路径（即， 𝑣&amp; → 𝑣’ → 𝑣(）上的图顶点可能被分配任意的图顶点索引次序，当图数据块 P2 被调 度处理时，其中的图顶点被按照图顶点索引次序依次异步串行地更新图顶点状态值。 然而，在每一轮异步迭代中，图顶点按照𝑣(，𝑣’，𝑣&amp;的顺序依次向后代图顶点传递各 自的图顶点状态值。由于已经处理过的图顶点的状态值只能在下一轮异步迭代中才 能再次被更新，因此在本轮异步迭代中，尽管图顶点可以立即使用并传递其前序图顶 点的状态值，但是其后代图顶点只能在下一轮迭代才能被重新更新。由于有向路径 (𝑣&amp; → 𝑣’ → 𝑣( → 𝑣))中包含 3 条边，因此至少需要进行三轮异步迭代（包含线程间同 步），图数据块 P2 才能将图顶点状态值完全传递给其它图数据块。因此，无论是同 步迭代模型，还是传统异步迭代模型，都 无法有效感知动态有向图的更新依赖关系，无法利用拓扑结构来加速动态有向图增量计算中的图顶点状态值传递。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801204945409.png" class="" title="image-20220801204945409"><h4 id="二-实验部分"><a href="#二-实验部分" class="headerlink" title="二 实验部分"></a>二 实验部分</h4><blockquote><p>The Aspen interface is an extension of Ligra’s interface. It includes the full Ligra interface-vertexSubsets, edgeMap, and various other functionality on a fixed graph. </p><p>On top of Ligra, we add a set of functions for updating the graph - in particular, for inserting or deleting sets of edges or sets of vertices. We also add a flat-snapshot function.  所有处理和更新的函数都是工作在固定大小的、不变的图镜像版本上面.</p></blockquote><h3 id="四-RisGraph-A-Real-Time-Streaming-System-for-Evolving-Graphs-to-Support-Sub-millisecond-Per-update-Analysis-at-Millions-Ops-s"><a href="#四-RisGraph-A-Real-Time-Streaming-System-for-Evolving-Graphs-to-Support-Sub-millisecond-Per-update-Analysis-at-Millions-Ops-s" class="headerlink" title="四 RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s"></a>四 RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s</h3><blockquote><p>单调算法（例如可达性和最短路径）在实时分析中广泛使用，以获得 both static and temporal insights(见解)，并且可以通过增量计算加速。现有的 streaming system 采用增量计算模型，并实现低潜伏期或高吞吐量，但不能两者兼而有之。</p><p>RisGraph 通过局部数据访问和更新的并行性解决挑战.</p><p>单调算法在不断 evolving graph 中经常使用,  其中包括可及性，广度搜索，最短路径，连接的组件（和最小/最大标签传播(Connected Components, and Min/Max Label Propagation)。它需要扫描大量数据甚至整个图表，以重新计算不断发展的图的每个快照上的单调算法。增量计算的想法可以通过利用先前的结果来减少冗余计算来加速单调算法。</p></blockquote><p>RisGraph 单边更新， 与批处理相比，Per-Update分析对延迟友好，产生最新结果，并提供最准确，最详细的信息。它只留下一个开放的问题：如何在per-update analysis 中提供高吞吐量。</p><h4 id="一-motivation"><a href="#一-motivation" class="headerlink" title="一 motivation"></a>一 motivation</h4><p>已有的解决方案：<code>Kickstarter</code> 和 <code>Differential Dataflow</code> 是最先进的代表, <code>Kickstarter</code> 提出了单调算法的增量图计算模型，而<code>Differential Dataflow</code>则呈现了无图形意识的广义增量模型。</p><p><strong>不足:</strong>  如果<code>Kickstarter</code> 和 <code>Differential Dataflow</code> 每次更改图形时都（Per Update Analysis）进行分析，则每秒只能处理大约1000个更新。they rely on batching to trade latency for higher throughput(以延迟换吞吐量), benefiting from larger concurrency and lower overheads.  此外，它们提供了批处理模式以进一步优化吞吐量，从而降低了分析的频率，并仅对每批批次产生一个汇总的最终结果。</p><p><strong>不足举例:</strong>  我们以2010年Twitter-2010 [48]的范围进行广度优先搜索（<code>BFS</code>）。为了满足20 ms延迟需求（实时分析[65]），这些系统的吞吐量仅为1K OPS/s。为了提供 100K OPS/s的吞吐量，它们需要批量超过 <code>20k</code> 的更新，并且平均处理时间增长到150毫秒以上。因此，现有的流图系统不能同时通过批处理满足延迟和吞吐量要求。尽管如此，批处理模式还是整个更新，跳过了中间状态，这些状态在某些情况下可能有用，例如财务欺诈检测和交易综合性。</p><p><strong>单边更新的挑战：</strong> </p><ol><li>无法像 batch 更新那样，均摊开销</li><li>高吞吐量和低延迟 的目标要求系统有效地进行两种工作负载。修改图表时，它需要将每个更新应用于数据结构，并提供更新的图表，以便在短时间内进行分析。为了启用每个更新的实时分析，系统需要一个图形感知的设计，以利用单个更新的局部性，而不是利用整个图形扫描的典型技术。此外，它需要一种新的机制才能使平行性进行PerDate Processing，这对于在不批处理的情况下实现高吞吐量也很重要。</li></ol><p><strong>guiding idea：</strong></p><ol><li>局部数据访问的想法来自以下观察结果：图形流系统的常用图形感知技术仍然需要不必要的整个图形扫描[43，54，68，77]。如果我们仅通过访问受更新影响的必要顶点来避免这些扫描，我们将获得更好的性能，因此我们建议使用称为索引的邻接列表和稀疏阵列的数据结构来启用本地化访问。</li><li>我们通过并行处理更新（跨越并行性），同时维护应用程序的每个语义，进一步改善了吞吐量。我们提出了一种算法，以识别可以并行执行的更新，并一个一个更新以保持低延迟，以及原子能，隔离和Per Update分析的正确性。</li></ol><h4 id="二-实验结果"><a href="#二-实验结果" class="headerlink" title="二 实验结果"></a>二 实验结果</h4><p>四种算法： BFS、SSSP、SSWP、WCC</p><p>我们首先加载90％的边缘，选择10％的边缘作为从加载边缘的删除更新，然后将其余（10％）边缘视为插入更新。删除和更新占比1:1。</p><p>与<code>Kickstarter</code>相比，<code>Risgraph</code>的性能改进主要是我们本地化数据访问的信用（第3节）。 <code>Risgraph</code>的表现优于差异数据流，这主要是由于专门的图形感知引擎和增量模型。例如，与<code>Risgraph</code>相比，在Twitter-2010上重新计算<code>BFS</code>的处理时间为78倍。</p><h4 id="三-相关工作"><a href="#三-相关工作" class="headerlink" title="三 相关工作"></a>三 相关工作</h4><ol><li><code>Kickstarter</code> 通过追踪依赖关系和修剪近似值，为单调算法提供了正确的增量计算。 </li><li><code>Grapu</code>  by components-based classification and in-buffer <code>precomputation</code> 加速批处理单调算法。</li><li><code>Graphin</code> 结合了一个I-GAS模型，该模型会逐步处理固定尺寸的更新。</li><li><code>GraphBolt</code> 提出了一个通用的增量模型来 处理 non-monotonic algorithms like Belief Propagation,，但比单调算法的 <code>kickstarter</code> 涉及更多的开销。</li></ol><h3 id="五-GraphPulse-An-Event-Driven-Hardware-Accelerator-for-Asynchronous-Graph-Processing"><a href="#五-GraphPulse-An-Event-Driven-Hardware-Accelerator-for-Asynchronous-Graph-Processing" class="headerlink" title="五 GraphPulse: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing"></a>五 <code>GraphPulse</code>: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing</h3><p>​                                                                                                                                                                                                ——2020 MICRO</p><blockquote><p>大规模的图处理带来了一些问题:</p><ol><li>首先，内存密集型处理会给内存系统带来压力, 和计算型系统相比, 内存占用更大, 频率更高. 大型内存占用还会导致内存带宽瓶颈并加剧长期访问延迟.</li><li>其次，由于顶点的并发更新，大多数计算模型中访问共享图状态的同步开销很高.</li><li>跟踪活动顶点或者边缘的开销很大, 这种跟踪是必不可少的，因为计算是不规则的，而在每次迭代中都有不同的顶点和边缘的子集。</li></ol><p>综上, 我们认为，现代处理体系结构不太适合按大规模进行图形处理应用程序</p></blockquote><p><code>GraphPulse</code> 围绕事件驱动计算的想法, 它表示计算为event， when the value of a  vertex changes to update vertices on all outgoing edges(当顶点的值更改为更新所有传出边上的顶点时)通常生成.</p><h3 id="六-JetStream-Graph-Analytics-on-Streaming-Data-with-Event-Driven-Hardware-Accelerator"><a href="#六-JetStream-Graph-Analytics-on-Streaming-Data-with-Event-Driven-Hardware-Accelerator" class="headerlink" title="六 JetStream: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator"></a>六 <code>JetStream</code>: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator</h3><blockquote><p><code>Jetstream</code> 扩展了最近提出的基于事件的加速器，用于图形工作负载，以支持流更新。它通过事件驱动的计算模型来处理累积和单调图算法，该模型限制了访问图形顶点的较小子集，有效地重用以前的查询结果以消除冗余，并优化了增强内存存储器带宽利用率的内存访问模式。</p></blockquote><p><code>Jetstream在Kickstarter和GraphBolt</code> 软件框架上达到了约18倍的速度，这些系统在较小的批次尺寸下具有明显较高的加速度。</p><p>更新的 batch 大小只占原始图大小的很小一部分, 如果重头计算的话势必会带来一些不必要的冗余。逐步支持删除的问题更具挑战性，只有Kickstarter [45]，GraphBolt [26]和DZIG [25]支持它。</p><p>支持的算法：supports all algorithms compatible with delta-accumulative computation。</p><p>相对于增加，删除操作更加麻烦，我们在两个阶段中支持删除：</p><ol><li>将图形的上一个版本的逐步转换为更新图的可恢复状态</li><li>bringing the results to convergence again.</li></ol><h3 id="七-图处理相关论文"><a href="#七-图处理相关论文" class="headerlink" title="七 图处理相关论文"></a>七 图处理相关论文</h3><h4 id="三-how怎么解决这个问题"><a href="#三-how怎么解决这个问题" class="headerlink" title="三 how怎么解决这个问题"></a>三 how怎么解决这个问题</h4><p>GRASP augments existing cache policies to maximize reuse of hot vertices by protecting them against cache thrashing, while maintaining sufficient flexibility to capture the reuse of other vertices as needed.</p><ul><li><h4 id="论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别"><a href="#论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别" class="headerlink" title="论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别"></a>论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别</h4></li></ul><blockquote><p>这并未提出新的重排序方法, 而是使用已有的重排序方法,  引用下面两篇论文.</p><ul><li> [A Closer Look at Lightweight Graph Reordering](# A Closer Look at Lightweight Graph Reordering)</li><li>[Making caches work for graph analytics](# Making caches work for graph analytics)</li></ul></blockquote><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220511164905637.png" class="" title="image-20220511164905637"><center>(a) Software applies vertex reordering, which segregates hot vertices at the beginning of the array. (b) GRASP interface exposes an ABR pair per Property Array to be configured with the bounds of the array. (c) GRASP identifies regions exhibiting different reuse based on an LLC size. </center><ul><li>Page5  论文中是如何识别热数据顶点，如何pinpoint(准确找到)热数据区域以及如何对访问进行归类；</li></ul><blockquote><ul><li><p>Conveniently, the hottest vertices are located at the beginning of the Property Array in a contiguous region thanks to the application of skew-aware reordering as seen in Fig. 3(a).  <strong>也就是说, 热顶点是通过排序得到的</strong>。</p></li><li><p>会在属性数组起始地址抓两个LLC-sized 的子区域， 一个 HIgh Reuse Region, 另一个Moderate Reuse Region.</p></li><li><p>GRASP determines this by comparing the address with the bounds of the High Reuse Region of each Property Array. </p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220511165057988.png" class="" title="image-20220511165057988"><p>GRASP encodes the classification result (High-Reuse, Moderate-Reuse, Low-Reuse or Default) as a 2-bit Reuse Hint, and forwards it to the LLC along with each cache request, as shown in Fig. 4, to guide specialized insertion and hit-promotion policies as described next.</p></li></ul></blockquote><h4 id="四-what-解决之后得到什么结论"><a href="#四-what-解决之后得到什么结论" class="headerlink" title="四 what 解决之后得到什么结论"></a>四 what 解决之后得到什么结论</h4><h5 id="4-1-Graph-process-framework"><a href="#4-1-Graph-process-framework" class="headerlink" title="4.1 Graph process framework"></a>4.1 Graph process framework</h5><blockquote><p>ligra, a widely used graph processing framework that supports both pull- and push-based computations, including switching from pull to push (and vice versa) at the start of every iteration. </p></blockquote><h5 id="4-2-Software-evaluation"><a href="#4-2-Software-evaluation" class="headerlink" title="4.2  Software evaluation"></a>4.2  Software evaluation</h5><p>论文中涉及的重排序技术</p><blockquote><p><strong>Sort</strong>  reorders vertices in the memory space by sorting them in the descending order of their degree.</p></blockquote><blockquote><p><strong>HubSort</strong>  segregates(隔离) hot vertices in a contiguous region by assigning them a continuous range of vertex IDs in their descending order of degree. In doing so, Hub Sorting essentially sorts all hot vertices, while largely preserving structure for the cold vertices.</p></blockquote><blockquote><p><strong>DBG</strong> , unlike Sort and HubSort, does not rely on sorting to segregate hot vertices. Instead, DBG coarsely(粗略的) partitions all vertices into a small number of groups based on their degree. Similar to Sort and HubSort, DBG is effective at improving spatial locality; however, unlike the other two techniques, DBG is able to largely preserve the existing graph structure.</p></blockquote><blockquote><p><strong>Gorder</strong> is evaluated as a representative of complex techniques. As Gorder is only available in a single-thread implementation, while reporting the net runtime of Gorder for a given dataset, we optimistically divide the reordering time by 40 (maximum number of threads supported on the server) to provide a fair comparison with skew-aware techniques whose reordering implementation is fully parallelized.</p></blockquote><h3 id="八-A-Closer-Look-at-Lightweight-Graph-Reordering"><a href="#八-A-Closer-Look-at-Lightweight-Graph-Reordering" class="headerlink" title="八 A Closer Look at Lightweight Graph Reordering"></a>八 A Closer Look at Lightweight Graph Reordering</h3><h4 id="二-why"><a href="#二-why" class="headerlink" title="二 why"></a>二 why</h4><p>To address the limitations of existing skew-aware reordering techniques, </p><ul><li> Sort achieves the maximum reduction in the cache footprint of hot vertices. However, in doing so, Sort completely decimates existing graph structure</li><li>Hub Sorting and Hub Clustering both classify vertices as hot or cold based on their degree and preserve the structure for cold vertices. However, in dealing with hot vertices, they resort to inefficient extremes. </li><li>At one extreme, Hub Sorting employs fine-grain reordering that sorts all hot vertices, destroying existing graph structure. At the other extreme, Hub Clustering does not apply any kind of reordering among hot vertices, sacrificing significant opportunity in improving cache efficiency</li></ul><p>we propose Degree-Based Grouping <a href="https://github.com/faldupriyank/dbg">DBG</a>。</p><h4 id="三-how"><a href="#三-how" class="headerlink" title="三 how"></a>三 how</h4><h5 id="3-1-the-dbg-algorithm"><a href="#3-1-the-dbg-algorithm" class="headerlink" title="3.1 the dbg algorithm"></a>3.1 the dbg algorithm</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220512161706297.png" class="" title="image-20220512161706297"><center>  DBG algorithm. Degree can be in-degree or out-degreeor sum of both.</center><h5 id="3-2-the-dbg-example"><a href="#3-2-the-dbg-example" class="headerlink" title="3.2 the dbg example"></a>3.2 the dbg example</h5><p> Vertex degree is shown inside the box while original vertex ID is shown below the box.</p><p>Vertex ordering in memory after DBG. In this example, DBG partitions vertices into three groups with degree ranges [0, 20), [20, 40) and [40, 80). DBG maintains a relative order of vertices within a group. As a result, many vertices are placed nearby the same vertices as before the reordering such as vertex sets (P4, P5, P6), (P0, P1) and (P10, P11).</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220512162204354.png" class="" title="image-20220512162204354"><center>Vertex ordering in memory after DBG. </center><h5 id="3-3-运行作者实验"><a href="#3-3-运行作者实验" class="headerlink" title="3.3 运行作者实验"></a>3.3 运行作者实验</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1. 编译 这一步注意设置DBG_ROOT, 要不然下面第二部会出现错误</span></span><br><span class="line">export DBG_ROOT=&#x27;/home/server2/dbg&#x27;</span><br><span class="line">cd ~/dbg/apps</span><br><span class="line">make -j </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2. 下载数据集</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//el --&gt; edge list of the form (src, dst) <span class="keyword">in</span> text file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//bel --&gt; edge list of the form (src, dst) <span class="keyword">in</span> binary file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//vgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//cvgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges (no self or redundant edges)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//csvgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges (no self or redundant edges)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//         graph is symmetric -- so <span class="keyword">for</span> every edge (u, v) there also exist (v, u)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//cintgr --&gt; binary csr format with int weight <span class="keyword">for</span> edges (no slef or redundant edges)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">//edges are assumed to take 8 bytes and vertices (and edge weights) are assumed to take 4 bytes <span class="keyword">in</span> binary file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">//all *gr files contain a header of 24 bytes as follows:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//number of vertices</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//number of edges</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//major number</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//minor number</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//gr files are implemented based on the implementation from Galois.</span></span><br><span class="line"></span><br><span class="line">wget http://snap.stanford.edu/data/web-Google.txt.gz</span><br><span class="line">gunzip web-Google.txt.gz</span><br><span class="line">../graph-convert-utils/clean_edgelist.py web-Google.txt web-Google.el</span><br><span class="line">../graph-convert-utils/convert.sh web-Google</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3. Run individual application， 运行之前安装numactl，否则会出现错误。 安装命令 sudo apt install numactl</span></span><br><span class="line">make REORDERING_ALGO=5 DEGREE_USED_FOR_REORDERING=0 DATASET=web-Google run-PageRank</span><br></pre></td></tr></table></figure><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220513152610369.png" class="" title="image-20220513152610369"><h3 id="九-Making-caches-work-for-graph-analytics"><a href="#九-Making-caches-work-for-graph-analytics" class="headerlink" title="九 Making caches work for graph analytics"></a>九 Making caches work for graph analytics</h3><p>Hub sorting was proposed as a variant of Sort that aims to preserve some structure while reducing the cache footprint of hot vertices.</p><h3 id="十-Speedup-Graph-Processing-by-Graph-Ordering"><a href="#十-Speedup-Graph-Processing-by-Graph-Ordering" class="headerlink" title="十 Speedup Graph Processing by Graph Ordering"></a>十 Speedup Graph Processing by Graph Ordering</h3><p>Gorder—— the state-of-the-art structure-aware reordering technique.</p><h3 id="十一-如何直接对属性数组进行冷热数据分离"><a href="#十一-如何直接对属性数组进行冷热数据分离" class="headerlink" title="十一 如何直接对属性数组进行冷热数据分离"></a>十一 如何直接对属性数组进行冷热数据分离</h3><blockquote><p>这里对冷热数据分离是什么意思?  </p><p>是划分出high reuse region、Moderate （适度）Reuse Region， 不常用数据？</p></blockquote><h4 id="1-1-DBG-实验"><a href="#1-1-DBG-实验" class="headerlink" title="1.1 DBG 实验"></a>1.1 DBG 实验</h4><p>在dbg的实验中, 将el格式的图转为了cvgr –&gt; binary csr format with no weight for edges (no self or redundant edges), cintgr –&gt; binary csr format with int weight for edges (no slef or redundant edges)。pagerank算法应该是借助 ligra 使用了 cvgr格式的图。这里的话没有cache，还需要自己配置才能获取到冷热数据，因此还要看以前的grasp这个仓库。</p><h4 id="1-2-grasp实验"><a href="#1-2-grasp实验" class="headerlink" title="1.2 grasp实验"></a>1.2 grasp实验</h4><p>在[Domain-Specialized Cache Management for Graph Analytics ](# 图处理相关论文) 这篇论文中,  通过dbg重排序后，作者直接定义了两个cache大小的区域, 分别获取high、 moderate 区域。</p><h3 id="十二-Proceedings-of-the-ACM-on-Measurement-and-Analysis-of-Computing-Systems-Vol-3-No-3-Article-60"><a href="#十二-Proceedings-of-the-ACM-on-Measurement-and-Analysis-of-Computing-Systems-Vol-3-No-3-Article-60" class="headerlink" title="十二  Proceedings of the ACM on Measurement and Analysis of Computing Systems Vol. 3, No. 3, Article 60"></a>十二  Proceedings of the ACM on Measurement and Analysis of Computing Systems Vol. 3, No. 3, Article 60</h3><p>CHARACTERIZATION METRICS</p><h4 id="1-1-Performance-Metrics"><a href="#1-1-Performance-Metrics" class="headerlink" title="1.1 Performance Metrics"></a>1.1 Performance Metrics</h4><ol><li>We measure single-threaded application performance using instructions per cycle (IPC)</li><li>For multithreaded applications, we show parallel speedup (i.e., the single-threaded execution time divided by the parallel execution time), which accounts for synchronization overheads.</li><li>To quantify the memory intensity of an application, we use the number of misses per kilo-instruction (MPKI) issued by the last-level cache for that application to DRAM.</li></ol><h4 id="1-2-Parallelism-Metrics"><a href="#1-2-Parallelism-Metrics" class="headerlink" title="1.2 Parallelism Metrics"></a>1.2 Parallelism Metrics</h4><p>Prior works have used either memory-level parallelism (MLP) [26, 47, 137, 152, 181] or bank-level parallelism (BLP) to quantify the amount of parallelism across memory requests</p><p>MLP measures the average number of outstanding memory requests for an application, but this does not capture the amount of parallelism offered by the underlying hardware.</p><p>BLP measures the average number of memory requests that are actively being serviced for a single thread during a given time interval.</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221004152901298.png" class="" title="image-20221004152901298"><h4 id="1-3-Contention-Metrics"><a href="#1-3-Contention-Metrics" class="headerlink" title="1.3 Contention Metrics"></a>1.3 Contention Metrics</h4><p>An important measure of spatial and temporal locality in memory is the row buffer hit rate, also known as row buffer locality.</p><p>To quantify the row hit rate, prior works count the number of row buffer hits and the number of row buffer misses, which they define as any request that does not hit in the currently-open row.</p><blockquote><p>To accurately capture row buffer locality, we introduce a new characterization methodology where we break down memory requests into: (1) row buffer hits; (2) row buffer misses, which only include misses for a DRAM request where the bank does not have any row open; and (3) row buffer conflicts, which consist of misses where another row is currently open in the bank and must be closed (<code>i.e., precharged</code>) first. Row buffer conflicts provide us with important information about how the amount of parallelism exposed by a DRAM type can limit opportunities to concurrently serve multiple memory requests, which in turn hurts performance.</p></blockquote><p>为了准确捕获行缓冲区局部性，我们引入了一种新的特征方法，将内存请求分解为：</p><p>（1）行缓冲区命中；</p><p>（2）行缓冲区错过，其中仅包括银行没有任何行打开的DRAM请求的错过； </p><p>（3）行缓冲冲突，其中包括当前在银行中打开另一排，必须首先关闭（即预处理）的失误。行缓冲冲突为我们提供了有关DRAM类型暴露的并行量如何限制同时服务多个内存请求的机会，这反过来又损害了性能。</p><h3 id="十三-Graphfire-Synergizing-Fetch-Insertion-and-Replacement-Policies-for-Graph-Analytics"><a href="#十三-Graphfire-Synergizing-Fetch-Insertion-and-Replacement-Policies-for-Graph-Analytics" class="headerlink" title="十三 Graphfire: Synergizing Fetch, Insertion, and Replacement Policies for Graph Analytics"></a>十三 Graphfire: Synergizing Fetch, Insertion, and Replacement Policies for Graph Analytics</h3><blockquote><p> With the goal of optimizing cache performance for graph applications, our work makes the following key observations: (i) The memory hierarchy must specialize for the problematic indirect accesses (PIAs) to alleviate their bottlenecks. (ii) To be software-agnostic, a lightweight mechanism must automatically identify PIAs, which can be achieved on a perinstruction basis. (iii) While PIAs are irregular, a subset of them have high reuse, so the LLC must retain them.</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;图处理的相关论文&quot;&gt;&lt;a href=&quot;#图处理的相关论文&quot; class=&quot;headerlink&quot; title=&quot;图处理的相关论文&quot;&gt;&lt;/a&gt;图处理的相关论文&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;Benchmark：主要是对比别人的方法，这个方法不一定是最好的，</summary>
      
    
    
    
    <category term="学术论文" scheme="http://okeyia.github.io/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="图重排序" scheme="http://okeyia.github.io/tags/%E5%9B%BE%E9%87%8D%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>OpenMP并行编程</title>
    <link href="http://okeyia.github.io/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
    <id>http://okeyia.github.io/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</id>
    <published>2022-05-13T00:57:55.000Z</published>
    <updated>2022-11-21T05:14:00.572Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OpenMP并行编程"><a href="#OpenMP并行编程" class="headerlink" title="OpenMP并行编程"></a>OpenMP并行编程</h2><h3 id="一-编程模型"><a href="#一-编程模型" class="headerlink" title="一 编程模型"></a>一 编程模型</h3><p>OpenMP是共享存储体系结构上的一个并行编程模型。 适合于SMP共享内存多处理系统和多核处理器体系结构。</p><ul><li><p>OpenMP是基于线程的并行编程模型。 </p></li><li><p>OpenMP采用Fork-Join并行执行方式： </p><ul><li>OpenMP程序开始于一个单独的主线程（Master  Thread），然后主线程一直串行执行，直到遇见第 一个并行域(Parallel Region)，然后开始并行执行并行 区域。</li><li>其过程如下： Fork:主线程创建一个并行线程队列，然后，并行域中的代 码在不同的线程上并行执行； Join:当并行域执行完之后，它们或被同步或被中断，最后 只有主线程在</li></ul></li></ul><img src="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/image-20220422102521910.png" class="" title="image-20220422102521910"><hr><h3 id="二-Clion中-Cmake-文件"><a href="#二-Clion中-Cmake-文件" class="headerlink" title="二 Clion中 Cmake 文件"></a>二 Clion中 Cmake 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FIND_PACKAGE(OpenMP REQUIRED)</span><br><span class="line">if (OPENMP_FOUND)</span><br><span class="line">    message(&quot;OPENMP FOUND&quot;)</span><br><span class="line">    set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; $&#123;OpenMP_C_FLAGS&#125;&quot;)</span><br><span class="line">    set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;OpenMP_CXX_FLAGS&#125;&quot;)</span><br><span class="line">endif () </span><br></pre></td></tr></table></figure><h3 id="三-代码实例"><a href="#三-代码实例" class="headerlink" title="三 代码实例"></a>三 代码实例</h3><h4 id="3-1-pragma-omp-parallel"><a href="#3-1-pragma-omp-parallel" class="headerlink" title="3.1 #pragma omp parallel"></a>3.1 #pragma omp parallel</h4><p>parallel制导命令表示接下来由花括号括起来的区域将创建多个线程并行执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-制导指令-for"><a href="#3-2-制导指令-for" class="headerlink" title="3.2  制导指令 for"></a>3.2  制导指令 for</h4><p>在并行域里面用 <code>#pragma omp for</code>，在这条语句之后的一个for循环语句中每一个要循环的任务将被分配给不同的线程去执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有这行代码, 2个线程每一个都将运行一次for循环, 加完这条代码, 2个线程共同运行一次for循环</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码和下面的代码, 结果是相同的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-schdule指令"><a href="#3-3-schdule指令" class="headerlink" title="3.3 schdule指令"></a>3.3 schdule指令</h4><p>在以上的任务中，各个线程自动分配到要执行的任务标号，没有对任务做一些进一步的调度，接下来介绍的字句将会对for循环任务的调度做更细致一些的规定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schedule(type, size);</span><br><span class="line"><span class="comment">// type参数有四种：1.static, 2.dynamic, 3.guided, 4.runtime</span></span><br><span class="line"><span class="comment">// size参数是整形数据：表示循环迭代次数划分的单位。</span></span><br></pre></td></tr></table></figure><h5 id="3-3-1-静态调度"><a href="#3-3-1-静态调度" class="headerlink" title="3.3.1 静态调度"></a>3.3.1 静态调度</h5><p>静态调度，不用size参数时分配给每个程序的都是 <code>n/t</code> 次连续迭代，n 为迭代次数，t为并行的线程数目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(static)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-动态调度"><a href="#3-3-2-动态调度" class="headerlink" title="3.3.2 动态调度"></a>3.3.2 动态调度</h5><p>动态调度模式是先到先得的方式进行任务分配，不用size参数的时候，先把任务干完的线程先取下一个任务，以此类推，而不是一开始就分配固定的任务数。</p><p>使用size参数的时候，分配的任务以size为单位，一次性分配size个。虽然很智能，在任务难度不均衡的时候适合用dynamic，否则会引起过多的任务动态申请的开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(dynamic,3)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-section-指令"><a href="#3-4-section-指令" class="headerlink" title="3.4 section 指令"></a>3.4 section 指令</h4><p>sections 把不同的区域 交给不同的线程去执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel sections</span></span><br><span class="line">   &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-single指令"><a href="#3-5-single指令" class="headerlink" title="3.5 single指令"></a>3.5 single指令</h4><p>single制导指令所包含的代码段只有一个线程执行，别的线程跳过该代码，如果没有nowait子句，那么其他线程将会在single制导指令结束的隐式同步点等待。有 <code>nowait</code> 子句其他线程将跳过等待往下执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp single</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;single thread=&quot;</span> &lt;&lt; omp_get_thread_num()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-注意点-pargma-omp-for"><a href="#3-5-注意点-pargma-omp-for" class="headerlink" title="3.5  注意点 #pargma omp for"></a>3.5  注意点 #pargma omp for</h4><p>单独使用 <code>#pargma omp for</code>, 相当于没有并行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rank:&quot;</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// 有序输出100行, 全是进程0 相当于没有并行</span></span><br></pre></td></tr></table></figure><h3 id="四-使用OpenMp-实现-std-accumulate"><a href="#四-使用OpenMp-实现-std-accumulate" class="headerlink" title="四 使用OpenMp 实现 std:: accumulate"></a>四 使用OpenMp 实现 std:: accumulate</h3><blockquote><p>最近刚好在学习C++ 并行编程，学习到了怎么使用多线程实现 <code>std::accumulate</code> , 比较一下两者的差异。</p></blockquote><p>下面是直接运行的代码:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">sum += dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面这个程序中，试图用sum来累加变量和。#pragma omp parallel for告诉编译器要把这个for语句拆开来并行执行。</p><p>注意 sum 定义在并行块外面，所以在并行块中会共享这个变量。也就是说在四个核中用的是同一个变量，对于sum + = i 语句，是先把sum的值取出来和 i 相加后再把结果赋给sum变量。</p><p>既然四个线程用的是同一个sum，那么如果sum在线程0中取出来了，另一个线程中也同时取出来了同样值的sum，加完后值在两个线程中都会被送就回到sum，那么就会造成有一次操作被重写了（数据碰撞），也就是说最后的结果很可能小于正确的结果。</p></blockquote><h4 id="4-1-pragma-omp-critical"><a href="#4-1-pragma-omp-critical" class="headerlink" title="4.1 #pragma omp critical"></a>4.1 #pragma omp critical</h4><p>这条语句是告诉编译器下面的代码块很关键，任何时刻都只能有一个线程执行该代码块。不过这样的话<strong>代码会在多个核中的运行会相互影响</strong>，对性能有一定影响，最好的解决方法是用规约reduction。</p><blockquote></blockquote><h4 id="4-2-reducation-规约"><a href="#4-2-reducation-规约" class="headerlink" title="4.2 reducation(规约)"></a>4.2 reducation(规约)</h4><blockquote><p>reduction (+:sum) 告诉编译器，这并行块要用规约，+表示求和操作，sum是目标变量名。这样的话，编译器就会给每个线程一个sum的拷贝并正确初始化为0，然后<strong>每个线程执行完之后再合并</strong>。规约只适用于固定的操作符。</p><img src="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/image-20221121112738508.png" class="" title="image-20221121112738508"></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2022/11/21.</span></span><br><span class="line"><span class="comment">// 使用规约求和</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp=&#123;<span class="number">100</span>&#125;;</span><br><span class="line">srand(time(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成1千万个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">dp.push_back(rand() % <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for reducation(+:sum)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">sum += dp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;使用openmp所花费的时间为: &quot;</span> </span><br><span class="line">        &lt;&lt; (<span class="built_in">std</span>::chrono::system_clock::now() - start).count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-firstprivte和lastprivate"><a href="#4-3-firstprivte和lastprivate" class="headerlink" title="4.3 firstprivte和lastprivate"></a>4.3 firstprivte和lastprivate</h4><blockquote><p>如果我们不想要已经定义了的变量在多个线程中共享，想要让每个线程有自己的拷贝怎么办呢？</p><p>下面就简单介绍一个private从句，以及firstprivate和lastprivate。通过使用#pragma omp parallel private（variable list），告诉编译器在下面的并行块中每个线程都对variable list列出的变量进行拷贝。不过值得注意的时，每个线程中拷贝的变量的初始值是不确定的，执行完并行块后该变量的值也不确定。</p><p>所以就有了firstprivate和lastprivate，firstprivate 是说<strong>变量的初始值就是按照该变量进入并行块之前的值初始化</strong>；lastprivate 是说退出并行块后，按照串行情况最后的一个值给到主线程中的变量。如果同时使用firstprivate和lastprivate，那么该变量就会有和串行是一样的初始值和结束值。</p></blockquote><h3 id="五-参考链接"><a href="#五-参考链接" class="headerlink" title="五 参考链接"></a>五 参考链接</h3><ol><li><p><a href="https://www.jianshu.com/p/796d531c08ed">并行计算工具OpenMP 二</a></p></li><li><p><a href="https://cloud.tencent.com/developer/ask/sof/491657">使用clang-12时，CMake的find_package( OpenMP )找不到OpenMP</a> 保持clang版本与libomp版本一致,  如 clang版本为10, 安装对应的libomp版本.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libomp-10-dev</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.ibm.com/docs/en/xl-c-aix/13.1.2?topic=processing-pragma-omp-parallel">pragma omp parallel</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;OpenMP并行编程&quot;&gt;&lt;a href=&quot;#OpenMP并行编程&quot; class=&quot;headerlink&quot; title=&quot;OpenMP并行编程&quot;&gt;&lt;/a&gt;OpenMP并行编程&lt;/h2&gt;&lt;h3 id=&quot;一-编程模型&quot;&gt;&lt;a href=&quot;#一-编程模型&quot; class=&quot;</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>How-to-read-papers</title>
    <link href="http://okeyia.github.io/2022/05/09/How-to-read-papers/"/>
    <id>http://okeyia.github.io/2022/05/09/How-to-read-papers/</id>
    <published>2022-05-09T09:29:40.000Z</published>
    <updated>2022-11-13T15:18:05.685Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何阅读论文"><a href="#如何阅读论文" class="headerlink" title="如何阅读论文"></a>如何阅读论文</h2><blockquote><p>研一萌新, 最近在读论文的时候, 读到后半部分，前面讲的什么东西都已经忘完了, 不得不重新回顾。这样读起来有种深陷泥潭、举步维艰的感觉，然后觉得可能是自己读论文的方法有问题——没有从整体上把握整篇论文，只陷于个细节里面去了。感觉自己是时候该学习一下读论文的方法,  提高自己效率。</p></blockquote><p>通常来说，读论文一般有以下四个要素：</p><ul><li>What 这篇论文要解决什么问题？</li><li>Why 这篇文章为什么要解决这个问题, 解决这个问题有什么意义?<ul><li>Importance, implication, relevance</li><li>切入点：现有文献、研究方法</li></ul></li><li>how 这篇文章如何解决了这个问题?<ul><li>Problem formulation, research methods, data, experiments, etc</li></ul></li><li>what 解决这篇文章之后得到怎么样的结论<ul><li>Conclusions, perspectives, outlook, etc.</li></ul></li></ul><h3 id="一-论文各部分的重要性"><a href="#一-论文各部分的重要性" class="headerlink" title="一 论文各部分的重要性"></a>一 论文各部分的重要性</h3><ol><li>摘要 abstract: 论文最重要的部分，一般由导师直接把关</li><li>引言 introduction: 重要性仅次于摘要，内容更加易懂</li><li>相关工作 related work: 对领域内工作的分类和总结</li><li>其他章节: 论文细节，对于理解本论文非常重要。</li><li>总结 conclusion: 全文总结和展望</li><li>参考文献 reference: 论文引用的文献列表</li><li>附录 Appendix: 部分无法放到正文中的内容，如过分细节的证明和算法</li></ol><h3 id="二-快速阅读（泛读）"><a href="#二-快速阅读（泛读）" class="headerlink" title="二 快速阅读（泛读）"></a>二 快速阅读（泛读）</h3><p><strong>观点：</strong></p><ul><li><strong>快速阅读其实是一种技巧，一个捷径。</strong>你可能从这些图片中以及标题中获取大约70%，80%甚至90%的论文信息。</li><li>对于<strong>作者</strong>来说，他会思考论文的任务是什么？研究发现是什么？是什么内容让这篇文章重要且有吸引力？一个论文需要帮助大家明白究竟是想表达什么。站在读者的视角，你需要理解文章的观点。写论文的准则：你必须要让论文易于阅读。你必须要让每个读者都可以轻松阅读。</li><li>对于<strong>读者</strong>来说，我需要学习这篇文章嘛？我有多需要从这篇文章中学习？ 我能学到什么？当我一定程度上理解了文章，对我有什么影响？</li><li><strong>一篇论文包含四个部分，标题，摘要，引言和剩下的部分。</strong>作者应该花等长的时间写这4个部分。 但对于学生来说，大家真的需要大部分精力在实验，公式上。</li></ul><p><strong>如何进行快速阅读：</strong></p><ol><li> <strong>整篇论文都是在概括浓缩（abstraction）的过程中</strong>，引言是文章的浓缩，摘要是引言的浓缩，标题是摘要的浓缩。</li><li><strong>引言：论文是关于什么的？解决什么问题？为什么论文有意思？有什么新的发现？文章为什么是好的？</strong></li><li>摘要：我们可以有层次地阅读论文。我们可以将论文分解并加上一些有趣的亮点，这有利于阅读。<strong>论文中摘要部分说了什么？之后你需要看看这篇论文真正的发现是什么？我为什么需要在意这些东西？</strong></li></ol><p>如果时间有限，直接读abstract是最高效的方法。如果时间还很充裕，那么就把introduction也读一遍。读完这两部分，就应该能基本理解论文的核心思想。</p><p><strong>WARNING</strong>:读得速度越快，对论文的理解越差，甚至会出现误解。因此，想要好好理解一篇论文，精读是非常必要的。</p><h3 id="三-精读"><a href="#三-精读" class="headerlink" title="三 精读"></a>三 精读</h3><p>通过泛读（快速）阅读筛选完论文之后，需要精读部分的重要论文。我个人建议将精读分为几个阶段进行:</p><ol><li>理解论文基本原理: motivation，所用的理论？</li><li>理解论文详细内容: 深入理解论文细节，包括定义、假设和相关公式等</li><li><del>能够重现实验</del>（未必需要）: 能否重现整个实验，并得到相同结果？</li><li>组织讨论: 与其他人进行讨论，可能有没有疏忽的地方？或者理解不到位的地方？</li><li>设计更好的方案: 能不能更进一步，设计更好的方法？</li></ol><p><strong>每个阶段可以对应一次或者多次阅读，通过多次阅读来加深对论文的理解</strong>。不要指望一口气能够理解整篇论文。很多原因会造成理解不够深入甚至理解错误，例如现阶段的知识面不够，或者对于某些概念理解错误等。所以需要多次阅读（如果有必要，多次讨论）来避免这类问题。</p><p><strong>WARNING</strong>:讨论是非常必要的（最好由阅读论文的人主讲），当其他人从他的角度提出疑问时，很可能会给意想不到的惊喜。</p><h3 id="四-沈向洋-经读论文的方法"><a href="#四-沈向洋-经读论文的方法" class="headerlink" title="四 沈向洋: 经读论文的方法"></a>四 沈向洋: 经读论文的方法</h3><ol><li><p>批判性阅读</p><ul><li><strong>批判性阅读的核心就是不断否定，不断质问，不断怀疑。</strong></li><li><strong>由于批判性阅读会花费很多时间，你可能时不时卡住。我建议你，不要惊慌失措！批判性阅读确实很难，但你要坚持下去，定能度过难关。</strong></li><li><strong>搞明白你可以到哪里获取帮助，可以求助谁。但要站在对方角度进行思考，不能过多占用对方的时间。</strong></li></ul></li><li><p>创造性阅读</p><ul><li>简单地说，如果我要根据这篇论文做一些研究，有什么新的东西我可以做？最终，你<strong>需要根据你所学的论文以及相关的论文思考，你是否有足够棒的想法能够让你在未来三到五月里进行相关研究？</strong></li><li><strong>真正理解论文是能够根据论文提出问题并回答问题。</strong></li></ul></li><li><p>问题列表</p><ul><li>客观性问题：论文是关于什么的？核心观点是什么？有什么局限性？作者有没有公开代码？数据是否可用？这个想法是否真的不错？论文中想法是否有违直觉？论文的贡献是否重要？实验做的如何？</li><li>主观性问题：关于这篇论文我有没有遗漏的地方？这篇论文对我有没有帮助？我是否可以直接用文中的方法解决问题？这篇论文是否值得持续研究下去？别人对这篇论文有什么想法呢？谁是这个领域的专家？<strong>如果我有机会见到论文的作者，我会问什么问题？</strong></li></ul></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/Richardyu114/How-to-Read-and-Write-Research-Paper">How-to-Read-and-Write-Research-Paper</a></li><li><a href="https://github.com/qiyuangong/How_to_Search_and_Read_a_Paper">How_to_Search_and_Read_a_Paper</a></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;如何阅读论文&quot;&gt;&lt;a href=&quot;#如何阅读论文&quot; class=&quot;headerlink&quot; title=&quot;如何阅读论文&quot;&gt;&lt;/a&gt;如何阅读论文&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;研一萌新, 最近在读论文的时候, 读到后半部分，前面讲的什么东西都已经忘完了, 不</summary>
      
    
    
    
    <category term="学术论文" scheme="http://okeyia.github.io/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="怎么读论文" scheme="http://okeyia.github.io/tags/%E6%80%8E%E4%B9%88%E8%AF%BB%E8%AE%BA%E6%96%87/"/>
    
  </entry>
  
  <entry>
    <title>pinatrace</title>
    <link href="http://okeyia.github.io/2022/05/03/Pintool/"/>
    <id>http://okeyia.github.io/2022/05/03/Pintool/</id>
    <published>2022-05-03T01:35:30.000Z</published>
    <updated>2022-09-05T12:40:20.249Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一-Inter-pin-使用简介"><a href="#一-Inter-pin-使用简介" class="headerlink" title="一 Inter pin 使用简介"></a>一 Inter pin 使用简介</h4><blockquote><p>其实在研一上学期，就接触pin了，但仅仅只停留在理论上，没有实践。本次主要使用pin来获取某一个段代码访问内存的trace。官网给出的examples中有一个pinatrace.cpp, 只能获取到<strong>整个代码的访问trace</strong>, 因此需要对pintrace.cpp做出一个更改。</p></blockquote><blockquote><p>现在pin版本已经更新到了pin 3.22, 下载链接:  <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html">Pin - A Binary Instrumentation Tool - Downloads</a></p></blockquote><blockquote><p>由于网上可以搜到的大多pintools工具都是几年前的,  因此提供一个旧版本的pin下载链接:  <a href="https://github.com/wangziqi2013/wangziqi2013.github.io/blob/master/static/pin-2.14.tar.gz">Pin 2.14 下载链接</a> <a href="http://software.intel.com/sites/landingpage/pintool/downloads/pin-3.5-97503-gac534ca30-gcc-linux.tar.gz">pin 3.5 下载链接</a> <a href="https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.7-97619-g0d0c92f4f-gcc-linux.tar.gz">pin 3.7 下载链接</a></p></blockquote><blockquote><p>用户手册: <a href="https://software.intel.com/sites/landingpage/pintool/docs/98547/Pin/html/index.html#BuildingInsideKit">Pin 3.22 User Guide</a></p></blockquote><h4 id="二-代码示例"><a href="#二-代码示例" class="headerlink" title="二 代码示例"></a>二 代码示例</h4><h5 id="2-1-pinatrace-cpp"><a href="#2-1-pinatrace-cpp" class="headerlink" title="2.1 pinatrace.cpp"></a>2.1 pinatrace.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pin.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CHAR * ROI_BEGIN = <span class="string">&quot;__app_roi_begin&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> CHAR * ROI_END = <span class="string">&quot;__app_roi_end&quot;</span>;</span><br><span class="line"></span><br><span class="line">FILE * trace;</span><br><span class="line"><span class="keyword">bool</span> isROI = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a memory read record</span></span><br><span class="line"><span class="function">VOID <span class="title">RecordMemRead</span><span class="params">(VOID * ip, VOID * addr, CHAR * rtn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return if not in ROI</span></span><br><span class="line">    <span class="keyword">if</span>(!isROI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Log memory access in CSV</span></span><br><span class="line">    <span class="comment">//fprintf(trace,&quot;%p,R,%p\n&quot;, ip, addr);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;%p\n&quot;</span>,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a memory write record</span></span><br><span class="line"><span class="function">VOID <span class="title">RecordMemWrite</span><span class="params">(VOID * ip, VOID * addr, CHAR * rtn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return if not in ROI</span></span><br><span class="line">    <span class="keyword">if</span>(!isROI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Log memory access in CSV</span></span><br><span class="line">    <span class="comment">//fprintf(trace,&quot;%p,W,%p\n&quot;, ip, addr);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;%p\n&quot;</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set ROI flag</span></span><br><span class="line"><span class="function">VOID <span class="title">StartROI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isROI = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set ROI flag</span></span><br><span class="line"><span class="function">VOID <span class="title">StopROI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isROI = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is called for every instruction and instruments reads and writes</span></span><br><span class="line"><span class="function">VOID <span class="title">Instruction</span><span class="params">(INS ins, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Instruments memory accesses using a predicated call, i.e.</span></span><br><span class="line">    <span class="comment">// the instrumentation is called iff the instruction will actually be executed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// On the IA-32 and Intel(R) 64 architectures conditional moves and REP</span></span><br><span class="line">    <span class="comment">// prefixed instructions appear as predicated instructions in Pin.</span></span><br><span class="line">    UINT32 memOperands = INS_MemoryOperandCount(ins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over each memory operand of the instruction.</span></span><br><span class="line">    <span class="keyword">for</span> (UINT32 memOp = <span class="number">0</span>; memOp &lt; memOperands; memOp++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get routine name if valid</span></span><br><span class="line">        <span class="keyword">const</span> CHAR * name = <span class="string">&quot;invalid&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(RTN_Valid(INS_Rtn(ins)))</span><br><span class="line">        &#123;</span><br><span class="line">            name = RTN_Name(INS_Rtn(ins)).c_str();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (INS_MemoryOperandIsRead(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            INS_InsertPredicatedCall(</span><br><span class="line">                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,</span><br><span class="line">                IARG_INST_PTR,</span><br><span class="line">                IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                IARG_ADDRINT, name,</span><br><span class="line">                IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Note that in some architectures a single memory operand can be</span></span><br><span class="line">        <span class="comment">// both read and written (for instance incl (%eax) on IA-32)</span></span><br><span class="line">        <span class="comment">// In that case we instrument it once for read and once for write.</span></span><br><span class="line">        <span class="keyword">if</span> (INS_MemoryOperandIsWritten(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            INS_InsertPredicatedCall(</span><br><span class="line">                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,</span><br><span class="line">                IARG_INST_PTR,</span><br><span class="line">                IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                IARG_ADDRINT, name,</span><br><span class="line">                IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pin calls this function every time a new rtn is executed</span></span><br><span class="line"><span class="function">VOID <span class="title">Routine</span><span class="params">(RTN rtn, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get routine name</span></span><br><span class="line">    <span class="keyword">const</span> CHAR * name = RTN_Name(rtn).c_str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,ROI_BEGIN) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Start tracing after ROI begin exec</span></span><br><span class="line">        RTN_Open(rtn);</span><br><span class="line">        RTN_InsertCall(rtn, IPOINT_AFTER, (AFUNPTR)StartROI, IARG_END);</span><br><span class="line">        RTN_Close(rtn);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name,ROI_END) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Stop tracing before ROI end exec</span></span><br><span class="line">        RTN_Open(rtn);</span><br><span class="line">        RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)StopROI, IARG_END);</span><br><span class="line">        RTN_Close(rtn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pin calls this function at the end</span></span><br><span class="line"><span class="function">VOID <span class="title">Fini</span><span class="params">(INT32 code, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fclose(trace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Print Help Message                                                    */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="function">INT32 <span class="title">Usage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIN_ERROR( <span class="string">&quot;This Pintool prints a trace of memory addresses\n&quot;</span></span><br><span class="line">              + KNOB_BASE::StringKnobSummary() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Main                                                                  */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize symbol table code, needed for rtn instrumentation</span></span><br><span class="line">    PIN_InitSymbols();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Usage</span></span><br><span class="line">    <span class="keyword">if</span> (PIN_Init(argc, argv)) <span class="keyword">return</span> Usage();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open trace file and write header</span></span><br><span class="line">    trace = fopen(<span class="string">&quot;roitrace.csv&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;pc,rw,addr,rtn\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add instrument functions</span></span><br><span class="line">    RTN_AddInstrumentFunction(Routine, <span class="number">0</span>);</span><br><span class="line">    INS_AddInstrumentFunction(Instruction, <span class="number">0</span>);</span><br><span class="line">    PIN_AddFiniFunction(Fini, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never returns</span></span><br><span class="line">    PIN_StartProgram();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改完pinatrace.cpp 后, 重新make, 生成pinatrace.so文件。</p></blockquote><h5 id="2-2-roi-h"><a href="#2-2-roi-h" class="headerlink" title="2.2 roi.h"></a>2.2 roi.h</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ROI_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _ROI_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* General Markers */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noinline)) __app_roi_begin()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noinline)) __app_roi_end()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="2-3-hello-world-cpp"><a href="#2-3-hello-world-cpp" class="headerlink" title="2.3 hello_world.cpp"></a>2.3 hello_world.cpp</h5><p><strong>注意</strong>: hello_world.cpp 中必须包含 <code>extern &quot;C&quot; &#123; #include &lt;roi.h&gt; &#125;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;roi.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __app_roi_begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;hello,world!\n&quot;</span>;</span><br><span class="line">    __app_roi_end();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;second line!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对hello_world 进行编译, 此处-I.表示从当前目录寻找extern <span class="string">&quot;C&quot;</span> &#123;<span class="comment">#include &lt;roi.h&gt;&#125;中的roi.h。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I 头文件 例如xx.h， 寻找的顺序是：-I&#123;path&#125;–&gt;/usr/include–&gt;/usr/<span class="built_in">local</span>/include</span></span><br><span class="line">g++ -o hello_world hello_world.cpp -I.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">~/pin-3.21-bak/pin -t ~/pin-3.21-bak/source/tools/ManualExamples/obj-intel64/pinatrace.so -- ./hello_world</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">结果生成 roitrace.csv</span></span><br></pre></td></tr></table></figure><p>参考链接：</p><ol><li><p><a href="https://github.com/vnaveen0/pin_tools">pin_tools</a></p></li><li><p><a href="https://stackoverflow.com/questions/32026456/how-can-i-specify-an-area-of-code-to-instrument-it-by-pintool/32029564#32029564">How can i specify an area of code to instrument it by pintool?</a></p></li><li><p><a href="https://bbs.pediy.com/thread-269711.htm">有毒的学Pin记录（一）</a></p></li><li><p><a href="http://brieflyx.me/2017/binary-analysis/intel-pin-intro/">Intel Pin 基本用法</a></p></li><li><p><a href="https://anhkgg.com/pin-use-note-function-analysis/">pin使用小记-函数分析</a></p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;一-Inter-pin-使用简介&quot;&gt;&lt;a href=&quot;#一-Inter-pin-使用简介&quot; class=&quot;headerlink&quot; title=&quot;一 Inter pin 使用简介&quot;&gt;&lt;/a&gt;一 Inter pin 使用简介&lt;/h4&gt;&lt;blockquote&gt;
&lt;p&gt;其</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="http://okeyia.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Gem5" scheme="http://okeyia.github.io/tags/Gem5/"/>
    
    <category term="pintools" scheme="http://okeyia.github.io/tags/pintools/"/>
    
    <category term="memtoryTrace" scheme="http://okeyia.github.io/tags/memtoryTrace/"/>
    
  </entry>
  
  <entry>
    <title>颈肩操</title>
    <link href="http://okeyia.github.io/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/"/>
    <id>http://okeyia.github.io/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/</id>
    <published>2022-04-17T07:30:36.000Z</published>
    <updated>2022-04-17T07:52:09.115Z</updated>
    
    <content type="html"><![CDATA[<h4 id="放松颈肩-环节疲劳"><a href="#放松颈肩-环节疲劳" class="headerlink" title="放松颈肩, 环节疲劳"></a>放松颈肩, 环节疲劳</h4><p>珍爱生命, 远离ICU, 经过本人测试, 本套颈肩操可以有效缓解颈部疲劳, 放在博客提醒自己。</p><h4 id="第一节-颈部捏按"><a href="#第一节-颈部捏按" class="headerlink" title="第一节 颈部捏按"></a>第一节 颈部捏按</h4><blockquote><p>3次为一组，连续捏按8组。</p><p>左右各8组，交替进行。</p><p>保持轻柔和缓，捏按力度，持续渗透。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153521407.png" class="" title="image-20220417153521407"><h4 id="第二节-左顾右盼"><a href="#第二节-左顾右盼" class="headerlink" title="第二节 左顾右盼"></a>第二节 左顾右盼</h4><blockquote><p>缓慢转向一侧，保持3秒钟。</p><p>左右各8组。</p><p>注意旋转要匀速和缓，切忌猛烈地转动</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153637390.png" class="" title="image-20220417153637390"><h4 id="第三节-前俯后仰"><a href="#第三节-前俯后仰" class="headerlink" title="第三节 前俯后仰"></a>第三节 前俯后仰</h4><blockquote><p>前后各自保持3秒钟。<br>重复做8次。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153737110.png" class="" title="image-20220417153737110"><h4 id="第四节-左右侧曲"><a href="#第四节-左右侧曲" class="headerlink" title="第四节 左右侧曲"></a>第四节 左右侧曲</h4><blockquote><p>左右到位后，各自坚持3秒。左右各8次.</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153845908.png" class="" title="image-20220417153845908"><h4 id="第五节-悬肩舒颈"><a href="#第五节-悬肩舒颈" class="headerlink" title="第五节 悬肩舒颈"></a>第五节 悬肩舒颈</h4><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153937510.png" class="" title="image-20220417153937510"><h4 id="第六节-头颈相抗"><a href="#第六节-头颈相抗" class="headerlink" title="第六节 头颈相抗"></a>第六节 头颈相抗</h4><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154028268.png" class="" title="image-20220417154028268"><h4 id="第七节-颈项争力"><a href="#第七节-颈项争力" class="headerlink" title="第七节 颈项争力"></a>第七节 颈项争力</h4><blockquote><p>左手置于胸前, 右手置于背后, 手掌向右平行推出, 颈部向左转动, 保持三秒钟.</p><p>再换右手, 重复八次。 </p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154105726.png" class="" title="image-20220417154105726"><h4 id="第八节-仰头忘掌"><a href="#第八节-仰头忘掌" class="headerlink" title="第八节 仰头忘掌"></a>第八节 仰头忘掌</h4><blockquote><p>仰视手背, 配合深呼吸, 重复八次。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154614780.png" class="" title="image-20220417154614780"><h4 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接:"></a>视频链接:</h4><p><a href="https://www.bilibili.com/video/BV1ci4y1S7en?spm_id_from=333.999.0.0">北汽颈肩操</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;放松颈肩-环节疲劳&quot;&gt;&lt;a href=&quot;#放松颈肩-环节疲劳&quot; class=&quot;headerlink&quot; title=&quot;放松颈肩, 环节疲劳&quot;&gt;&lt;/a&gt;放松颈肩, 环节疲劳&lt;/h4&gt;&lt;p&gt;珍爱生命, 远离ICU, 经过本人测试, 本套颈肩操可以有效缓解颈部疲劳, 放在</summary>
      
    
    
    
    
    <category term="放松自己" scheme="http://okeyia.github.io/tags/%E6%94%BE%E6%9D%BE%E8%87%AA%E5%B7%B1/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://okeyia.github.io/2022/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://okeyia.github.io/2022/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-04-15T12:11:17.000Z</published>
    <updated>2022-11-17T01:39:53.988Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是正则表达式-？"><a href="#什么是正则表达式-？" class="headerlink" title="什么是正则表达式 ？"></a>什么是正则表达式 ？</h2><blockquote><p>正则表达式是一种被用于从文本中检索符合某些特定模式的文本。</p></blockquote><p>正则表达式是从左到右来匹配一个字符串的。“Regular Expression”这个词太长了，我们通常使用它的缩写“regex”或者“regexp”。<br>正则表达式可以被用来替换字符串中的文本、验证表单、基于模式匹配从一个字符串中提取字符串等等。</p><p>想象一下，您正在编写应用程序，并且您希望在用户选择用户名时设置规则。我们希望用户名可以包含字母，数字，下划线和连字符。<br>为了让它看起来不丑，我们还想限制用户名中的字符数量。这时我们可以使用以下正则表达式来验证用户名：</p><p align="center"><img src="https://i.imgur.com/UrDb9qc.png" alt="Regular expression"></p><p>上面这个正则表达式可以匹配 <code>john_doe</code>，<code>jo-hn_doe</code> 和 <code>john12_as</code>。但是它不能匹配 <code>Jo</code>，因为该字符串里面包含大写字符，并且它太短了。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">基本匹配</a></li><li><a href="#2-%E5%85%83%E5%AD%97%E7%AC%A6">元字符</a><ul><li><a href="#21-%E8%8B%B1%E6%96%87%E5%8F%A5%E5%8F%B7">英文句号</a></li><li><a href="#22-%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a><ul><li><a href="#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86">否定字符集</a></li></ul></li><li><a href="#23-%E9%87%8D%E5%A4%8D">重复</a><ul><li><a href="#231-%E6%98%9F%E5%8F%B7">星号</a></li><li><a href="#232-%E5%8A%A0%E5%8F%B7">加号</a></li><li><a href="#233-%E9%97%AE%E5%8F%B7">问号</a></li></ul></li><li><a href="#24-%E8%8A%B1%E6%8B%AC%E5%8F%B7">花括号</a></li><li><a href="#25-%E5%AD%97%E7%AC%A6%E7%BB%84">字符组</a></li><li><a href="#26-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">分支结构</a></li><li><a href="#27-%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">转义特殊字符</a></li><li><a href="#28-%E5%AE%9A%E4%BD%8D%E7%AC%A6">定位符</a><ul><li><a href="#281-%E6%8F%92%E5%85%A5%E7%AC%A6%E5%8F%B7">插入符号</a></li><li><a href="#282-%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7">美元符号</a></li></ul></li></ul></li><li><a href="#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">简写字符集</a></li><li><a href="#4-%E6%96%AD%E8%A8%80">断言</a><ul><li><a href="#41-%E6%AD%A3%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">正向先行断言</a></li><li><a href="#42-%E8%B4%9F%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">负向先行断言</a></li><li><a href="#43-%E6%AD%A3%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">正向后行断言</a></li><li><a href="#44-%E8%B4%9F%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">负向后行断言</a></li></ul></li><li><a href="#5-%E6%A0%87%E8%AE%B0">标记</a><ul><li><a href="#51-%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99">不区分大小写</a></li><li><a href="#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2">全局搜索</a></li><li><a href="#53-%E5%A4%9A%E8%A1%8C%E5%8C%B9%E9%85%8D">多行匹配</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">常用正则表达式</a></li></ul><h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式只是我们用于在文本中检索字符串的模式。例如正则表达式 <code>cat</code>，表示：字母 <code>c</code> 后面跟着一个字母 <code>a</code>，再后面跟着一个字母 <code>t</code>。</p><pre>"cat" => The <a href="#learn-regex"><strong>cat</strong></a> sat on the mat</pre><p>正则表达式 <code>123</code> 会匹配字符串“123”。通过将正则表达式中的每个字符逐个与要匹配的字符串中的每个字符进行比较，来完成正则匹配。<br>正则表达式通常区分大小写，因此正则表达式 <code>Cat</code> 与字符串“cat”不匹配。</p><pre>"Cat" => The cat sat on the <a href="#learn-regex"><strong>Cat</strong></a></pre><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符在写在方括号内时有特殊含义。<br>元字符如下：</p><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配除换行符以外的任意字符。</td></tr><tr><td align="center">[ ]</td><td>字符类，匹配方括号中包含的任意字符。</td></tr><tr><td align="center">[^ ]</td><td>否定字符类。匹配方括号中不包含的任意字符</td></tr><tr><td align="center">*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td align="center">+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td align="center">?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr><tr><td align="center">{n,m}</td><td>花括号，匹配前面字符至少 n 次，但是不超过 m 次。</td></tr><tr><td align="center">(xyz)</td><td>字符组，按照确切的顺序匹配字符 xyz。</td></tr><tr><td align="center">&#124;</td><td>分支结构，匹配符号之前的字符或后面的字符。</td></tr><tr><td align="center">&#92;</td><td>转义符，它可以还原元字符原来的含义，允许你匹配保留字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ \ &#124;</code></td></tr><tr><td align="center">^</td><td>匹配行的开始</td></tr><tr><td align="center">$</td><td>匹配行的结束</td></tr></tbody></table><h2 id="2-1-英文句号"><a href="#2-1-英文句号" class="headerlink" title="2.1 英文句号"></a>2.1 英文句号</h2><p>英文句号 <code>.</code> 是元字符的最简单的例子。元字符 <code>.</code> 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 <code>.ar</code>，表示：任意字符后面跟着一个字母 <code>a</code>，<br>再后面跟着一个字母 <code>r</code>。</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也称为字符类。方括号被用于指定字符集。使用字符集内的连字符来指定字符范围。方括号内的字符范围的顺序并不重要。<br>例如正则表达式 <code>[Tt]he</code>，表示：大写 <code>T</code> 或小写 <code>t</code> ，后跟字母 <code>h</code>，再后跟字母 <code>e</code>。</p><pre>"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p>然而，字符集中的英文句号表示它字面的含义。正则表达式 <code>ar[.]</code>，表示小写字母 <code>a</code>，后面跟着一个字母 <code>r</code>，再后面跟着一个英文句号 <code>.</code> 字符。</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a></pre><h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说插入字符 <code>^</code> 表示一个字符串的开始，但是当它在方括号内出现时，它会取消字符集。例如正则表达式 <code>[^c]ar</code>，表示：除了字母 <code>c</code> 以外的任意字符，后面跟着字符 <code>a</code>，<br>再后面跟着一个字母 <code>r</code>。</p><pre>"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-3-重复"><a href="#2-3-重复" class="headerlink" title="2.3 重复"></a>2.3 重复</h2><p>以下元字符 <code>+</code>，<code>*</code> 或 <code>?</code> 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。</p><h3 id="2-3-1-星号"><a href="#2-3-1-星号" class="headerlink" title="2.3.1 星号"></a>2.3.1 星号</h3><p>星号 <code>*</code> 表示匹配上一个匹配规则零次或多次。正则表达式 <code>a*</code> 表示小写字母 <code>a</code> 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。<br>例如正则表达式 <code>[a-z]*</code>，表示：一行中可以包含任意数量的小写字母。</p><pre>"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.</pre><p>星号 <code>*</code> 可以与元符号 <code>.</code> 用在一起，用来匹配任意字符串 <code>.*</code>。星号 <code>*</code> 可以与空格符 <code>\s</code> 一起使用，用来匹配一串空格字符。<br>例如正则表达式 <code>\s*cat\s*</code>，表示：零个或多个空格，后面跟小写字母 <code>c</code>，再后面跟小写字母 <code>a</code>，再在后面跟小写字母 <code>t</code>，后面再跟零个或多个空格。</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex"><strong>cat</strong></a>.</pre><h3 id="2-3-2-加号"><a href="#2-3-2-加号" class="headerlink" title="2.3.2 加号"></a>2.3.2 加号</h3><p>加号 <code>+</code> 表示匹配上一个字符一次或多次。例如正则表达式 <code>c.+t</code>，表示：一个小写字母 <code>c</code>，后跟任意数量的字符，后跟小写字母 <code>t</code>。</p><pre>"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.</pre><h3 id="2-3-3-问号"><a href="#2-3-3-问号" class="headerlink" title="2.3.3 问号"></a>2.3.3 问号</h3><p>在正则表达式中，元字符 <code>?</code> 用来表示前一个字符是可选的。该符号匹配前一个字符零次或一次。<br>例如正则表达式 <code>[T]?he</code>，表示：可选的大写字母 <code>T</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><h2 id="2-4-花括号"><a href="#2-4-花括号" class="headerlink" title="2.4 花括号"></a>2.4 花括号</h2><p>在正则表达式中花括号（也被称为量词？）用于指定字符或一组字符可以重复的次数。例如正则表达式 <code>[0-9]&#123;2,3&#125;</code>，表示：匹配至少 2 位数字但不超过 3 位（0 到 9 范围内的字符）。</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p>我们可以省略第二个数字。例如正则表达式 <code>[0-9]&#123;2,&#125;</code>，表示：匹配 2 个或更多个数字。如果我们也删除逗号，则正则表达式 <code>[0-9]&#123;2&#125;</code>，表示：匹配正好为 2 位数的数字。</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><pre>"[0-9]{2}" => The number was 9.<a href="#learn-regex"><strong>99</strong></a><a href="#learn-regex"><strong>97</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><h2 id="2-5-字符组"><a href="#2-5-字符组" class="headerlink" title="2.5 字符组"></a>2.5 字符组</h2><p>字符组是一组写在圆括号内的子模式 <code>(...)</code>。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重复前一个字符。<br>但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。<br>例如正则表达式 <code>(ab)*</code> 表示匹配零个或多个的字符串“ab”。我们还可以在字符组中使用元字符 <code>|</code>。例如正则表达式 <code>(c|g|p)ar</code>，表示：小写字母 <code>c</code>、<code>g</code> 或 <code>p</code> 后面跟字母 <code>a</code>，后跟字母 <code>r</code>。</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-6-分支结构"><a href="#2-6-分支结构" class="headerlink" title="2.6 分支结构"></a>2.6 分支结构</h2><p>在正则表达式中垂直条 <code>|</code> 用来定义分支结构，分支结构就像多个表达式之间的条件。现在你可能认为这个字符集和分支结构的工作方式一样。<br>但是字符集和分支结构巨大的区别是字符集只在字符级别上有作用，然而分支结构在表达式级别上依然可以使用。<br>例如正则表达式 <code>(T|t)he|car</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>，或匹配小写字母 <code>c</code>，后跟小写字母 <code>a</code>，后跟小写字母 <code>r</code>。</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><h2 id="2-7-转义特殊字符"><a href="#2-7-转义特殊字符" class="headerlink" title="2.7 转义特殊字符"></a>2.7 转义特殊字符</h2><p>正则表达式中使用反斜杠 <code>\</code> 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code>。在特殊字符前面加 <code>\</code>，就可以使用它来做匹配字符。<br>例如正则表达式 <code>.</code> 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 <code>.</code> 字符，正则表达式 <code>(f|c|m)at\.?</code>，表示：小写字母 <code>f</code>、<code>c</code> 或者 <code>m</code> 后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟可选的 <code>.</code> 字符。</p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h2 id="2-8-定位符"><a href="#2-8-定位符" class="headerlink" title="2.8 定位符"></a>2.8 定位符</h2><p>在正则表达式中，为了检查匹配符号是否是起始符号或结尾符号，我们使用定位符。<br>定位符有两种类型：第一种类型是 <code>^</code> 检查匹配字符是否是起始字符，第二种类型是 <code>$</code>，它检查匹配字符是否是输入字符串的最后一个字符。</p><h3 id="2-8-1-插入符号"><a href="#2-8-1-插入符号" class="headerlink" title="2.8.1 插入符号"></a>2.8.1 插入符号</h3><p>插入符号 <code>^</code> 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 <code>^a</code>（如果 a 是起始符号）匹配字符串 <code>abc</code>，它会匹配到 <code>a</code>。<br>但是如果我们使用正则表达式 <code>^b</code>，它是匹配不到任何东西的，因为在字符串 <code>abc</code> 中“b”不是起始字符。<br>让我们来看看另一个正则表达式 <code>^(T|t)he</code>，这表示：大写字母 <code>T</code> 或小写字母 <code>t</code> 是输入字符串的起始符号，后面跟着小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><h3 id="2-8-2-美元符号"><a href="#2-8-2-美元符号" class="headerlink" title="2.8.2 美元符号"></a>2.8.2 美元符号</h3><p>美元 <code>$</code> 符号用于检查匹配字符是否是输入字符串的最后一个字符。例如正则表达式 <code>(at\.)$</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟一个 <code>.</code> 字符，且这个匹配器必须是字符串的结尾。</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><pre>"(at\.)$" => The fat cat sat on the m<a href="#learn-regex"><strong>at.</strong></a></pre><h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下：</p><table><thead><tr><th align="center">简写</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td align="center">\w</td><td>匹配所有字母和数字的字符：<code>[a-zA-Z0-9_]</code></td></tr><tr><td align="center">\W</td><td>匹配非字母和数字的字符：<code>[^\w]</code></td></tr><tr><td align="center">\d</td><td>匹配数字：<code>[0-9]</code></td></tr><tr><td align="center">\D</td><td>匹配非数字：<code>[^\d]</code></td></tr><tr><td align="center">\s</td><td>匹配空格符：<code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td align="center">\S</td><td>匹配非空格符：<code>[^\s]</code></td></tr></tbody></table><h2 id="4-断言"><a href="#4-断言" class="headerlink" title="4. 断言"></a>4. 断言</h2><p>后行断言和先行断言有时候被称为断言，它们是特殊类型的 <strong><em>非捕获组</em></strong>（用于匹配模式，但不包括在匹配列表中）。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。<br>例如我们想获取输入字符串 <code>$4.44 and $10.88</code> 中带有前缀 <code>$</code> 的所有数字。我们可以使用这个正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>，表示：获取包含 <code>.</code> 字符且前缀为 <code>$</code> 的所有数字。<br>以下是正则表达式中使用的断言：</p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center">?=</td><td>正向先行断言</td></tr><tr><td align="center">?!</td><td>负向先行断言</td></tr><tr><td align="center">?&lt;=</td><td>正向后行断言</td></tr><tr><td align="center">?&lt;!</td><td>负向后行断言</td></tr></tbody></table><h3 id="4-1-正向先行断言"><a href="#4-1-正向先行断言" class="headerlink" title="4.1 正向先行断言"></a>4.1 正向先行断言</h3><p>正向先行断言认为第一部分的表达式的后面必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。<br>要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 <code>(?=...)</code>。先行断言表达式写在括号中的等号后面。<br>例如正则表达式 <code>(T|t)he(?=\sfat)</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟字母 <code>h</code>，后跟字母 <code>e</code>。<br>在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配后面跟着 <code>fat</code> 的 <code>The</code> 或 <code>the</code>。</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><h3 id="4-2-负向先行断言"><a href="#4-2-负向先行断言" class="headerlink" title="4.2 负向先行断言"></a>4.2 负向先行断言</h3><p>当我们需要指定第一部分表达式的后面不跟随某一内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样，<br>唯一的区别在于我们使用否定符号 <code>!</code> 而不是等号 <code>=</code>，例如 <code>(?!...)</code>。<br>我们来看看下面的正则表达式 <code>(T|t)he(?!\sfat)</code>，表示：从输入字符串中获取全部 <code>The</code> 或者 <code>the</code> 且不匹配 <code>fat</code> 前面加上一个空格字符。</p><pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h3 id="4-3-正向后行断言"><a href="#4-3-正向后行断言" class="headerlink" title="4.3 正向后行断言"></a>4.3 正向后行断言</h3><p>正向后行断言用于获取跟随在特定模式之后的所有匹配内容。正向后行断言表示为 <code>(?&lt;=...)</code>。例如正则表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code>，表示：从输入字符串中获取在单词 <code>The</code> 或 <code>the</code> 之后的所有 <code>fat</code> 和 <code>mat</code> 单词。</p><pre>"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h3 id="4-4-负向后行断言"><a href="#4-4-负向后行断言" class="headerlink" title="4.4 负向后行断言"></a>4.4 负向后行断言</h3><p>负向后行断言是用于获取不跟随在特定模式之后的所有匹配的内容。负向后行断言表示为 <code>(?&lt;!...)</code>。例如正则表达式 <code>(?&lt;!(T|t)he\s)(cat)</code>，表示：在输入字符中获取所有不在 <code>The</code> 或 <code>the</code> 之后的所有单词 <code>cat</code>。</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><h2 id="5-标记"><a href="#5-标记" class="headerlink" title="5. 标记"></a>5. 标记</h2><p>标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。</p><table><thead><tr><th align="center">标记</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>不区分大小写：将匹配设置为不区分大小写。</td></tr><tr><td align="center">g</td><td>全局搜索：搜索整个输入字符串中的所有匹配。</td></tr><tr><td align="center">m</td><td>多行匹配：会匹配输入字符串每一行。</td></tr></tbody></table><h3 id="5-1-不区分大小写"><a href="#5-1-不区分大小写" class="headerlink" title="5.1 不区分大小写"></a>5.1 不区分大小写</h3><p><code>i</code> 修饰符用于执行不区分大小写匹配。例如正则表达式 <code>/The/gi</code>，表示：大写字母 <code>T</code>，后跟小写字母 <code>h</code>，后跟字母 <code>e</code>。<br>但是在正则匹配结束时 <code>i</code> 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 <code>g</code> 标记，因为我们要在整个输入字符串中搜索匹配。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h3 id="5-2-全局搜索"><a href="#5-2-全局搜索" class="headerlink" title="5.2 全局搜索"></a>5.2 全局搜索</h3><p><code>g</code> 修饰符用于执行全局匹配（会查找所有匹配，不会在查找到第一个匹配时就停止）。<br>例如正则表达式 <code>/.(at)/g</code>，表示：除换行符之外的任意字符，后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>。<br>因为我们在正则表达式的末尾使用了 <code>g</code> 标记，它会从整个输入字符串中找到每个匹配项。</p><pre>".(at)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h3 id="5-3-多行匹配"><a href="#5-3-多行匹配" class="headerlink" title="5.3 多行匹配"></a>5.3 多行匹配</h3><p><code>m</code> 修饰符被用来执行多行的匹配。正如我们前面讨论过的 <code>(^, $)</code>，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 <code>m</code> 修饰符。<br>例如正则表达式 <code>/at(.)?$/gm</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，匹配除了换行符以外任意字符零次或一次。而且因为 <code>m</code> 标记，现在正则表达式引擎匹配字符串中每一行的末尾。</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre><pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ul><li><strong>正整数</strong>：<code>^\d+$</code></li><li><strong>负整数</strong>：<code>^-\d+$</code></li><li><strong>电话号码</strong>：<code>^+?[\d\s]&#123;3,&#125;$</code></li><li><strong>电话代码</strong>：<code>^+?[\d\s]+(?[\d\s]&#123;10,&#125;$</code></li><li><strong>整数</strong>：<code>^-?\d+$</code></li><li><strong>用户名</strong>：<code>^[\w\d_.]&#123;4,16&#125;$</code></li><li><strong>字母数字字符</strong>：<code>^[a-zA-Z0-9]*$</code></li><li><strong>带空格的字母数字字符</strong>：<code>^[a-zA-Z0-9 ]*$</code></li><li><strong>密码</strong>：<code>^(?=^.&#123;6,&#125;$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li><li><strong>电子邮件</strong>：<code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;)*$</code></li><li><strong>IPv4 地址</strong>：<code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li><li><strong>小写字母</strong>：<code>^([a-z])*$</code></li><li><strong>大写字母</strong>：<code>^([A-Z])*$</code></li><li><strong>网址</strong>：<code>^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]])&#123;2,4&#125;([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$</code></li><li><strong>VISA 信用卡号码</strong>：<code>^(4[0-9]&#123;12&#125;(?:[0-9]&#123;3&#125;)?)*$</code></li><li><strong>日期（MM/DD/YYYY）</strong>：<code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]&#123;2&#125;$</code></li><li><strong>日期（YYYY/MM/DD）</strong>：<code>^(19|20)?[0-9]&#123;2&#125;[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li><li><strong>万事达信用卡号码</strong>：<code>^(5[1-5][0-9]&#123;14&#125;)*$</code></li></ul><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>Report issues</li><li>Open pull request with improvements</li><li>Spread the word </li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT © <a href="mailto:ziishaned@gmail.com">Zeeshan Ahmed</a></p><hr><p><strong><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-">⬆ top</a></strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是正则表达式-？&quot;&gt;&lt;a href=&quot;#什么是正则表达式-？&quot; class=&quot;headerlink&quot; title=&quot;什么是正则表达式 ？&quot;&gt;&lt;/a&gt;什么是正则表达式 ？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;正则表达式是一种被用于从文本中检索符合某些特定模式</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Overview of DRAMs</title>
    <link href="http://okeyia.github.io/2022/04/15/DRAM%E6%80%BB%E7%BB%93/"/>
    <id>http://okeyia.github.io/2022/04/15/DRAM%E6%80%BB%E7%BB%93/</id>
    <published>2022-04-15T12:05:15.000Z</published>
    <updated>2022-04-25T13:46:46.517Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Overview-of-DRAMs"><a href="#Overview-of-DRAMs" class="headerlink" title="Overview of DRAMs"></a><strong>Overview of DRAMs</strong></h3><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415150456153.png" class="" title="image-20220415150456153"><blockquote><p>DRAM子系统是一个相对复杂的整体的一部分。此图显示了一个双向多处理器，每个处理器都有自己的专用辅助缓存。与本章最相关的部分以深灰色阴影显示：CPU、内存控制器和单个DRAM</p></blockquote><h3 id="DRAM-Basics-Internals-Operation"><a href="#DRAM-Basics-Internals-Operation" class="headerlink" title="DRAM Basics: Internals, Operation"></a>DRAM Basics: Internals, Operation</h3><p>  <strong>DRAM</strong>: A random-access memory (RAM) that uses  a single transistor-capacitor(晶体管电容器) pair for each bit .  下图显示了DRAM内部存储单元的电路: </p><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415151328606.png" class="" title="image-20220415151328606"><p>DRAM内部的组织。DRAM内存阵列是一个由存储单元组成的网格，其中一行和一列的每个交叉点存储一位数据. </p><blockquote><p>This circuit is  dynamic because the capacitors storing electrons  are not perfect devices, and their eventual leakage  requires that, to retain information stored there, each  capacitor in the DRAM must be periodically refreshed (i.e. , read and rewritten)</p></blockquote><blockquote><p>Each DRAM die(芯片) contains one or more memory arrays, rectangular grids of storage cells with each cell  holding one bit of data.  By identifying the intersection of a row  and a column (by specifying a row address and a column address to the DRAM), a memory controller can  access an individual storage cell inside a DRAM chip  so as to read or write the data held there</p></blockquote><blockquote><p>the capacitor lies at the intersection  of a wordline and a bitline; <strong>it is connected to the bitline through a transistor controlled by the wordline</strong>.  A transistor is, among other things, a switch, and  when the voltage on a wordline goes high, all of the  transistors attached to that wordline become closed  switches (turned on), connecting their respective  capacitors to the associated bitlines. The capacitors at each intersection of wordline and bitline are  extremely small and hold a number of electrons that  are miniuscule relative(相对较小的) to the physical characteristics  of those bitlines.  </p></blockquote><blockquote><p>The capacitors at each intersection of wordline and bitline are  extremely small and hold a number of electrons that  are miniuscule relative to the physical characteristics  of those bitlines. Therefore, special circuits called  sense amplifiers are used to detect the values stored  on the capacitors when those capacitors become  connected to their associated bitlines. </p><p><strong>The sense  amplifiers first precharge the bitlines to a voltage level  that is halfway between logic level 0 and logic level 1.</strong>  When the capacitors are later connected to the bitlines through the transistors, the capacitors <strong>change  the voltage levels on those bitlines</strong> very slightly(轻微地). The  sense amplifiers detect the minute changes and pull the bitline voltages all the way to logic level 0 or 1.  Bringing the voltage on the bitlines to fully high or  fully low, as opposed to the precharged state between  high and low, actually recharges the capacitors as  long as the transistors remain on(连通). </p></blockquote><h4 id="Multiple-Memory-Arrays"><a href="#Multiple-Memory-Arrays" class="headerlink" title="Multiple Memory Arrays"></a>Multiple Memory Arrays</h4><blockquote><p> If the memory arrays  are designed to act in unison, they operate as a unit,  and the memory chip typically transmits or receives  a number of bits <strong>equal to</strong> the number of arrays each time the memory controller accesses the DRAM.</p></blockquote><p>For  example, in a simple organization, a x4 DRAM (pronounced “by four”) indicates that the DRAM has at  least <strong>four memory arrays</strong> and that a column width is  4 bits (each column read or write transmits 4 bits of  data). In a x4 DRAM part, four arrays each read 1 data  bit in unison, and the part sends out 4 bits of data  each time the memory controller makes a column  read request.</p><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415153809797.png" class="" title="image-20220415153809797"><p>NOTICE:   <strong>each of the DRAM illustrations in Figure  represents multiple arrays but a single bank. Each set of memory arrays that operates independently of other  sets is referred to as a bank, not an array .</strong></p><h4 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h4><blockquote><p>Because a system can have multiple DIMMs, each  of which can be thought of as an independent bank,  and the DRAM devices(内存颗粒) on each DIMM can implement internally multiple independent banks, the  word “rank” was introduced to distinguish DIMM-level independent operation versus(和) internal-bank-level independent operation. </p></blockquote><blockquote><p>A system is composed of potentially many  independent DIMMs. <strong>Each DIMM may contain one  or more independent ranks</strong>. Each rank is a set of  DRAM devices that operate in unison, and internally  each of these DRAM devices implements one or more  independent banks. Finally, <strong>each bank is composed  of slaved memory arrays</strong>, where the number of arrays  is equal to the data width of the DRAM part (i.e., a x4  part has four slaved arrays per bank)</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415155638103.png" class="" title="image-20220415155638103"><center>DIMMs, ranks, banks, and arrays </center><hr><h4 id="Memory-controller-and-Memory-modules"><a href="#Memory-controller-and-Memory-modules" class="headerlink" title="Memory controller and Memory modules"></a>Memory controller and Memory modules</h4><blockquote><p>The busses in a JEDEC-style organization are classified by their function and organization into data,  address, control, and chip-select busses. </p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415161510722.png" class="" title="image-20220415161510722"><center>a memory controller and two memory modules with a 16-bit data bus and an 8-bit address and command bus</center><blockquote><p>The data bus that transmits data to and from  the DRAMs is relatively wide. It is often 64 bits wide,  and it can be much wider in high-performance systems. A dedicated address bus carries row and column addresses to the DRAMs, and its width grows  with the physical storage on a DRAM device (typical  widths today are about 15 bits). A control bus is composed of the row and column strobes(选通), output enable,  clock, clock enable, and other related signals. These  signals are similar to the address-bus signals in that  they all connect from the memory controller to every  DRAM in the system. Finally, there is a chip-select  network that connects from the memory controller  to every DRAM in a rank (a separately addressable  set of DRAMs). </p></blockquote><h4 id="the-chip-select-bus"><a href="#the-chip-select-bus" class="headerlink" title="the chip-select bus"></a>the chip-select bus</h4><blockquote><p>The chip-select bus contains a separate wire(线路) for every rank of DRAM in  the system.  The chip-select signal passes over a wire  unique to each small set of DRAMs and enables or  disables the DRAMs in that rank so that they, respectively, either handle the request currently on the bus  or ignore the request currently on the bus. Thus, <strong>only  the DRAMs to which the request is directed handle  the request</strong>. Even though all DRAMs in the system  are connected to the same address and control busses and could, in theory, all respond to the same  request at the same time, the chip-select bus prevents this from happening. </p></blockquote><h4 id="the-Steps-of-a-DRAM-Read"><a href="#the-Steps-of-a-DRAM-Read" class="headerlink" title="the Steps of a DRAM  Read"></a>the Steps of a DRAM  Read</h4><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415164647716.png" class="" title="image-20220415164647716"><center> System organization and the steps of a DRAM  read </center><blockquote><p>As mentioned previously, a DRAM device connects indirectly to a microprocessor through a  memory controller; the microprocessor connects  to the memory controller through some form of  network (bus, point-to-point, crossbar, etc.); and  the memory controller connects to the DRAM  through another network (bus, point-to-point, etc.).  </p></blockquote><blockquote><p>Figure also illustrates the steps of a typical  DRAM read operation. After ordering and queueing  requests, the microprocessor sends a given request  to the memory controller. Once the request arrives at  the memory controller, it is queued until the DRAM is  ready and all previous and/or higher priority requests  have been handled. The memory controller’s interface to the DRAM is relatively complex (compared  to that of an SRAM, for instance); the row-address  strobe (RAS) and column-address strobe (CAS) components are shown in detail in next Figure. </p></blockquote><blockquote><p>The memory controller must decompose the provided data address into components that identify the  appropriate rank within the memory system, the bank  within that rank, and the row and column inside the  identified bank. The components identifying the row  and column are called the row address and the column address. <strong>The bank identifier is typically one or  more address bits</strong>. The rank number ends up causing  a chip-select signal to be sent out over a single one of  the separate chip-select lines. </p></blockquote><h4 id="the-Bitlines-Be-Precharged"><a href="#the-Bitlines-Be-Precharged" class="headerlink" title="the Bitlines Be Precharged"></a>the Bitlines Be Precharged</h4><blockquote><p>Once the rank, bank, and row are identified, the  bitlines in the appropriate bank must be precharged (set to a logic level halfway between 0 and 1). Once  the appropriate bank has been precharged, <strong>the second step</strong> is to activate the appropriate row inside the  identified rank and bank by setting the chip-select  signal to activate the set of DRAMs comprising the desired bank, sending the row address and bank  identifier over the address bus, and signaling the  DRAM’s  RAS pin (row-address strobe—the bar indicates that the signal is active when it is low). </p><p>This tells  the DRAM to <strong>send an entire row of data (thousands  of bits) into the DRAM’s sense amplifiers</strong> (circuits  that detect and amplify the tiny logic signals represented by the electric charges in the row’s storage  cells). This typically takes a few tens of nanoseconds,  and the step may have already been done (the row  or page could already be open or activated, meaning  that the sense amps might already have valid data in  them). </p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415165940565.png" class="" title="image-20220415165940565"><center> The multi-phase DRAM-access protocol. The row access drives a DRAM page onto the bitlines to be sensed by the  sense amps. The column address drives a subset of the DRAM page onto the bus (e.g., 4 bits).</center><p>NOTICE: separately transmitted row and  column addresses</p><blockquote><p>Once the sense amps have recovered the values,  and the bitlines are pulled to the appropriate logic  levels, the memory controller <strong>performs the last step</strong>,  which is to read the column (column being the name  given to the data subset of the row that is desired),  by setting the chip-select signal to activate the set of  DRAMs comprising the desired bank, sending the  column address and bank identifier over the address  bus, and signaling the DRAM’s  CAS pin (column address strobe—like  RAS , the bar indicates that it is active when low).  </p><p>This causes only a few select bits in the sense amplifiers to be connected to the output  drivers, where they will be driven onto the data bus.  Reading the column data takes on the order of tens of  nanoseconds. When the memory controller receives  the data, it forwards the data to the microprocessor. </p></blockquote><h4 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h4><blockquote><p>A clock transmits a continuous signal with regular  intervals of “high” and “low” values. It is usually illustrated as a square wave or semi-square wave with each  period identical to the next, as shown in Figure 7.9. The  upward portion of the square wave is called the positive  or rising edge of the clock, and the downward portion  of the square wave is called the negative or falling edge of the clock. The primary clock in a computer system is  called the system clock or global clock, and it typically  resides on the motherboard (the PCB that contains the  microprocessor and memory bus). The system clock  drives the microprocessor and memory controller and  many of the associated peripheral devices directly. If  the clock drives the DRAMs directly, the DRAMs are  called synchronous DRAMs. If the clock does not drive  the DRAMs directly, the DRAMs are called asynchronous DRAMs. In a synchronous DRAM, steps internal  to the DRAM happen in time with one or more edges  of this clock. In an asynchronous DRAM, operative  steps internal to the DRAM happen when the memory controller commands the DRAM to act, and those  commands typically happen in time with one or more  edges of the system clock.</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415190728890.png" class="" title="image-20220415190728890"><center> Example clock signals</center><blockquote><p>Clocks are typically shown as square waves (bottom) or sort of square waves (top). They  repeat ad infinitum, and the repeating shape is called a clock cycle. The two clocks pictured above have the same frequency—the  number of cycles in a given time period</p></blockquote><h3 id="DRAM-中文"><a href="#DRAM-中文" class="headerlink" title="DRAM 中文"></a>DRAM 中文</h3><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/Simplified-topology-of-DRAM-organization.png" class="" title="Simplified-topology-of-DRAM-organization"><p>影响DRAM的性能:</p><ul><li>内存容量</li><li>内存的延时周期</li><li>内存的带宽</li></ul><h4 id="内存带宽"><a href="#内存带宽" class="headerlink" title="内存带宽"></a>内存带宽</h4><p>内存带宽的影响是内存中现存的非常严重的问题，而影响内存带宽的主要因素是 行冲突</p><p>地址层级如下:</p><ol><li>通道（Channel） 通道是 DRAM 内存系统结构中最高的级别。独立内存控制器之间不同通道的运 行是没限制的。为了更优化的性能设计，连续的存取指令在缓存层已经被映射到不同 的通道了。</li><li>排（Rank） 排是通道的下一层，DRAM 的存取是在同一个通道的不同排之间也是可以并行 运行的</li><li>体（Bank）类似于连续的存取指令作用在不同的排上，当连续的指令作用在同一个排的不同 体时，DRAM 的内存系统仍然会有并行运行的存在。对于现在的 DRAM 设备而言， 将连续的存取指令通过调度方式分配到同一个排的不同体上，要比分配到同一个通道 的不同排上更加高效，因为这样不需要多余的周期来进行数据总线上的转换。</li><li>行（Row）在通用 DRAM 内存系统中，每个体在执行时，仅能激活（Active）一个行，当 有连续的指令通过调度映射到同一个体的不同行时，需要将第一个行进行预充电操作 （Precharge），再对第二个行进行激活操作，才能顺利进行连续指令的运行。这样做 便会造成大量的延迟，同时伴随的还有行冲突的数量会增加。想要降低行冲突出现的 概率，需要通过地址映射将连续的指令映射到同一个体的同一个行上面，这样行命中 的比例变化提升很多。从而能够有效的提升 DRAM 的性能</li><li>列（Column）当连续的指令作用在同一个体的同一个行时，此时不需要预充电操作，在获取数 据时，根据时间局部性和空间局部性 ，内存控制器会把整个行的数据都取出来放在 敏感放大器上。所以，第二个指令所映射的列也会以极高的效率获得。</li></ol><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410095244676.png" class="" title="image-20220410095244676"><p>地址映射不单单是内存中的地址翻译，它是连接着处理器、内存控制器和内存的 重要桥梁。因为地址在计算机系统中不同模块传输的状态不同，有物理地址和逻辑地 址，所以，需要地址映射来进行合理的转化。</p><h4 id="虚拟地址与物理地址"><a href="#虚拟地址与物理地址" class="headerlink" title="虚拟地址与物理地址"></a>虚拟地址与物理地址</h4><blockquote><p>虚拟地址（Virtual Address） 如果 CPU 启用了内存管理单元（Memory Management Unit，又称 MMU），CPU 核发出的地址将被内存管理单元截获，从 CPU 传输到内存管理单元的地址称为虚拟 地址(Virtual Address，简称 VA</p></blockquote><blockquote><p>物理地址（Physical Address）： 如果中央处理器不存在内存管理单元，或者未启用，则其核在获取指令或者访存 时发出的地址将被直接传到 CPU 的外部地址引脚上，被内存芯片接受，则称为物理 地址（Physical Address）。 内存管理单元将该地址译成另外地址发到 CPU 的外部地址引脚上，便意味着将 虚拟地址转化成了物理地址。内存管理单元是以页（Page）为单位的，对于 32 位 CPU 而言，通常一页为 4K。例如，虚拟地址 0xb700 1000<del>0xb700 1fff 是一个页，可能被 MMU 映射到物理地址 0x2000</del>0x2fff，物理内存中的一个物理页面也称为一个页框 (Page Frame)。 当内存控制器将虚拟地址转化成能够索引到具体 DRAM 每个数据模块的物理地 址后，DRAM 便会通过物理地址而索引到内存中具体的数据，再通过数据总线反馈 给 CPU[8]</p></blockquote><h4 id="内存带宽-1"><a href="#内存带宽-1" class="headerlink" title="内存带宽"></a>内存带宽</h4><h5 id="ROW-行"><a href="#ROW-行" class="headerlink" title="ROW 行"></a>ROW 行</h5><blockquote><p>在通用 DRAM 内存系统中，每个体在执行时，仅能激活（Active）一个行，当 有连续的指令通过调度映射到同一个体的不同行时，需要将第一个行进行预充电操作 （Precharge），再对第二个行进行激活操作，才能顺利进行连续指令的运行。这样做 便会造成大量的延迟，同时伴随的还有行冲突的数量会增加。想要降低行冲突出现的 概率，需要通过地址映射将连续的指令映射到同一个体的同一个行上面，这样行命中 的比例变化提升很多。从而能够有效的提升 DRAM 的性能</p></blockquote><h5 id="Column-列"><a href="#Column-列" class="headerlink" title="Column 列"></a>Column 列</h5><blockquote><p>当连续的指令作用在同一个体的同一个行时，此时不需要预充电操作，在获取数 据时，根据时间局部性和空间局部性 ，内存控制器会把整个行的数据都取出来放在 敏感放大器上。所以，第二个指令所映射的列也会以极高的效率获得</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410174402971.png" class="" title="image-20220410174402971"><h5 id="连续存取指令"><a href="#连续存取指令" class="headerlink" title="连续存取指令"></a>连续存取指令</h5><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410183659726.png" class="" title="image-20220410183659726"><h5 id="开页模式策略"><a href="#开页模式策略" class="headerlink" title="开页模式策略"></a>开页模式策略</h5><blockquote><p>开页的策略其 适用的环境是，如果有连续的指令到来，那么在执行完第一个指令后，并不会通过预 充电命令关掉该行。当内存控制器使用开页模式策略时，某行数据被取出存放在一个 DRAM 体的敏感放大器中的同一行的不同列，它可以快速的直接执行，此时会有最 小的延迟称为 Tcas。这种情况下，当另外一个读取指令指向了同一个行，因为该行已 经激活在敏感放大器中，所以它仅仅需要列命令，便可将数据从敏感放大器传递到内 存控制器中 ，这样的延迟是最小的。当然，另一方面，当连续的指令作用的是同一 个体的不同行时，内存控制器在执行第二个访问操作时，必须将第一个行通过预充电 指令关掉，同时再打开另外一个指令所指向的那个行，这样才可以执行第二个的列选取.  </p></blockquote><h5 id="关页策略"><a href="#关页策略" class="headerlink" title="关页策略"></a>关页策略</h5><p>关 页策略适用的环境是，当连续的指令到来以后，在执行完第一个指令，紧接着发布一 个预充电的指令来关掉该行，所以它适用于行冲突很多的情况下</p><h4 id="行冲突现象"><a href="#行冲突现象" class="headerlink" title="行冲突现象:"></a>行冲突现象:</h4><p>如果连续的地址存取指令，它们通过地址映射的算法后，指向的是同一个体的不同行，这会产生大量的延迟，因为上述第一个行需要激活的指令，才能执行第一个存取的请求，因为第二个不同于第一个行，因为同一个体一次仅能激活一个行，所以，需要将第一个行进行预充电的操作， 来使第一个行的状态变为关闭，紧接着再发布第二个指令来激活第二个请求所指向的行，在此两个行为以后，才可以执行第二个请求， 获取第二个行的数据，存放在行缓冲区中。因为这样的操作比第一种情况多出了一个 预充电与一个激活的指令延迟，所以效率是非常低的。这样的情况我们称之为行冲突现象. </p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Overview-of-DRAMs&quot;&gt;&lt;a href=&quot;#Overview-of-DRAMs&quot; class=&quot;headerlink&quot; title=&quot;Overview of DRAMs&quot;&gt;&lt;/a&gt;&lt;strong&gt;Overview of DRAMs&lt;/strong&gt;&lt;</summary>
      
    
    
    
    <category term="计算机体系结构" scheme="http://okeyia.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="Computer Architecture" scheme="http://okeyia.github.io/tags/Computer-Architecture/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu下实用工具配置</title>
    <link href="http://okeyia.github.io/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
    <id>http://okeyia.github.io/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</id>
    <published>2022-04-09T13:52:31.000Z</published>
    <updated>2022-11-05T02:22:36.449Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一-shell配置"><a href="#一-shell配置" class="headerlink" title="一 shell配置"></a>一 shell配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装插件的脚本</span></span><br><span class="line">sudo apt install wget curl git zsh vim tldr -y</span><br><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line">sed -i &#x27;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting z)/&#x27; ~/.zshrc</span><br><span class="line"></span><br><span class="line">git clone https://github.com/okeyia/honukai-iterm-zsh.git ~/.oh-my-zsh/custom/themes</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/robbyrussell/honukai&#x27; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>好用的shell有很多, 如fish、zsh、Oh-my-zsh ，本教程以Oh-my-zsh为例，配置教程如下：</p><h3 id="1-安装zsh"><a href="#1-安装zsh" class="headerlink" title="1 安装zsh"></a>1 安装zsh</h3><p>以ubuntu为例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><h3 id="2-下载oh-my-zsh-源码"><a href="#2-下载oh-my-zsh-源码" class="headerlink" title="2 下载oh-my-zsh 源码"></a>2 下载oh-my-zsh 源码</h3><h4 id="2-1-脚本安装方式"><a href="#2-1-脚本安装方式" class="headerlink" title="2.1 脚本安装方式"></a>2.1 脚本安装方式</h4><p>使用curl或者wget</p><table><thead><tr><th>Method</th><th>Command</th></tr></thead><tbody><tr><td>curl</td><td><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td>wget</td><td><code>sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr></tbody></table><h4 id="2-2-手动安装"><a href="#2-2-手动安装" class="headerlink" title="2.2 手动安装"></a>2.2 手动安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.sh</span><br><span class="line">sudo sh install.sh</span><br></pre></td></tr></table></figure><h3 id="3-安装-oh-my-zsh插件及主题"><a href="#3-安装-oh-my-zsh插件及主题" class="headerlink" title="3 安装 oh-my-zsh插件及主题"></a>3 安装 oh-my-zsh插件及主题</h3><h4 id="3-1-插件—代码高亮"><a href="#3-1-插件—代码高亮" class="headerlink" title="3.1 插件—代码高亮"></a>3.1 插件—代码高亮</h4><ol><li>克隆源码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件 <code>~/.zshrc</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( [plugins...] zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><ol start="3"><li>是配置文件生效</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="3-2-插件—自动补全"><a href="#3-2-插件—自动补全" class="headerlink" title="3.2 插件—自动补全"></a>3.2 插件—自动补全</h4><ol><li><p>克隆源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( # other plugins... zsh-autosuggestions)</span><br></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-3-主题—honukai"><a href="#3-3-主题—honukai" class="headerlink" title="3.3 主题—honukai"></a>3.3 主题—honukai</h4><ol><li><p>主题配置文件一般存放于  <code>~/.oh-my-zsh/custom/themes</code> 文件夹, 进入到该文件夹, 执行该命令, 将下面的内容(复制内容如下)复制进去.  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim honukai.zsh-theme </span><br></pre></td></tr></table></figure><p><strong>复制内容如下:</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Based on the great ys theme (http://ysmood.org/wp/2013/03/my-ys-terminal-theme/)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Machine name.</span></span><br><span class="line"><span class="keyword">function</span> box_name &#123;</span><br><span class="line">    [ -f ~/.box-name ] &amp;&amp; cat ~/.box-name || <span class="built_in">echo</span> <span class="variable">$HOST</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory info.</span></span><br><span class="line"><span class="built_in">local</span> current_dir=<span class="string">&#x27;$&#123;PWD/#$HOME/~&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VCS</span></span><br><span class="line">YS_VCS_PROMPT_PREFIX1=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[white]%&#125;on%&#123;<span class="variable">$reset_color</span>%&#125; &quot;</span></span><br><span class="line">YS_VCS_PROMPT_PREFIX2=<span class="string">&quot;:%&#123;<span class="variable">$fg</span>[cyan]%&#125;&quot;</span></span><br><span class="line">YS_VCS_PROMPT_SUFFIX=<span class="string">&quot;%&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line">YS_VCS_PROMPT_DIRTY=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[red]%&#125;✖︎&quot;</span></span><br><span class="line">YS_VCS_PROMPT_CLEAN=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[green]%&#125;●&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Git info.</span></span><br><span class="line"><span class="built_in">local</span> git_info=<span class="string">&#x27;$(git_prompt_info)&#x27;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_PREFIX=<span class="string">&quot;<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX1&#125;</span>git<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX2&#125;</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_SUFFIX</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_DIRTY=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_DIRTY</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_CLEAN=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_CLEAN</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HG info</span></span><br><span class="line"><span class="built_in">local</span> hg_info=<span class="string">&#x27;$(ys_hg_prompt_info)&#x27;</span></span><br><span class="line"><span class="function"><span class="title">ys_hg_prompt_info</span></span>() &#123;</span><br><span class="line"><span class="comment"># make sure this is a hg dir</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&#x27;.hg&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX1&#125;</span>hg<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -n $(hg branch 2&gt;/dev/null)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="subst">$(hg status 2&gt;/dev/null)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_DIRTY</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_CLEAN</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_SUFFIX</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompt format: \n # USER at MACHINE in DIRECTORY on git:BRANCH STATE [TIME] \n $</span></span><br><span class="line">PROMPT=<span class="string">&quot;</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[blue]%&#125;#%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[cyan]%&#125;%n \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;at \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[green]%&#125;<span class="subst">$(box_name)</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;in \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;<span class="variable">$&#123;current_dir&#125;</span>%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;git_info&#125;</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;[%*]</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125;→ %&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$USER</span>&quot;</span> == <span class="string">&quot;root&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">PROMPT=<span class="string">&quot;</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[blue]%&#125;#%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$bg</span>[yellow]%&#125;%&#123;<span class="variable">$fg</span>[cyan]%&#125;%n%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;at \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[green]%&#125;<span class="subst">$(box_name)</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;in \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;<span class="variable">$&#123;current_dir&#125;</span>%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;git_info&#125;</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;[%*]</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125;→ %&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;honukai&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-用户默认使用zsh"><a href="#4-用户默认使用zsh" class="headerlink" title="4 用户默认使用zsh"></a>4 用户默认使用zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which zsh                #查看zsh的路径</span><br><span class="line">sudo vi /etc/passwd      #以用户sen为例, 将/bin/bash 改为/usr/bin/zsh</span><br></pre></td></tr></table></figure><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220924155931302.png" class="" title="image-20220924155931302"><h2 id="二-sudo-免密码"><a href="#二-sudo-免密码" class="headerlink" title="二 sudo 免密码"></a>二 sudo 免密码</h2><p>个别情况下，sudo 免密设置的特别麻烦，这里可对某个管理员用户设置sudo 免输入免密。本教程以<code>ubuntu 18.04</code> 为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br><span class="line"><span class="meta">#</span><span class="bash">在%sudo ALL=(ALL:ALL) ALL下面添加如下一行</span></span><br><span class="line">username  ALL=(ALL) NOPASSWD: ALL, 这里的username就是你自己的用户名</span><br><span class="line"><span class="meta">#</span><span class="bash">添加完成 如下图所示, 之后按Ctrl+O，接着按回车确定保存文件。最后Ctrl+X退出编辑</span></span><br></pre></td></tr></table></figure><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409220215145.png" class="" title="image-20220409220215145"><h2 id="三-vmware-配置git代理"><a href="#三-vmware-配置git代理" class="headerlink" title="三 vmware 配置git代理"></a>三 vmware 配置git代理</h2><h3 id="1-主机ip及虚拟机ip设置"><a href="#1-主机ip及虚拟机ip设置" class="headerlink" title="1 主机ip及虚拟机ip设置"></a>1 主机ip及虚拟机ip设置</h3><h4 id="1-1-VMware网络编辑器配置"><a href="#1-1-VMware网络编辑器配置" class="headerlink" title="1.1 VMware网络编辑器配置"></a>1.1 VMware网络编辑器配置</h4><p>如图所示: </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221141249.png" class="" title="网络编辑器配置"><h4 id="1-2-本机VMnet8-设置"><a href="#1-2-本机VMnet8-设置" class="headerlink" title="1.2 本机VMnet8 设置"></a>1.2 本机VMnet8 设置</h4><p>请确保本机VMnet8的本机ip地址和虚拟机IP地址处于同一网段, 如图中所示, 配置为: 192.168.1.1</p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221513434.png" class="" title="image-20220409221513434"><h4 id="1-3-测试与主机连接"><a href="#1-3-测试与主机连接" class="headerlink" title="1.3 测试与主机连接"></a>1.3 测试与主机连接</h4><p>在虚拟机中<code>ping</code>主机, 如果能<code>ping</code>通, 就代表连接无问题. </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221853038.png" class="" title="image-20220409221853038"><h3 id="2-gitconfig设置"><a href="#2-gitconfig设置" class="headerlink" title="2 .gitconfig设置"></a>2 .gitconfig设置</h3><h4 id="2-1-本机中运行代理软件"><a href="#2-1-本机中运行代理软件" class="headerlink" title="2.1 本机中运行代理软件"></a>2.1 本机中运行代理软件</h4><p>本次以v2rayN为例, 代理开启pac模式, 设置中打开允许局域网连接,</p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409222218684.png" class="" title="image-20220409222218684"><h4 id="2-2-查看所用协议"><a href="#2-2-查看所用协议" class="headerlink" title="2.2 查看所用协议"></a>2.2 查看所用协议</h4><p>在代理页面查看配置的协议及端口号。v2rayN中一般都是http协议和socks5协议, 记下配置的端口号. </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409222519626.png" class="" title="image-20220409222519626"><h4 id="2-3-编辑-gitconfig文件"><a href="#2-3-编辑-gitconfig文件" class="headerlink" title="2.3 编辑 .gitconfig文件"></a>2.3 编辑 <code>.gitconfig</code>文件</h4><p>使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global socks5://userName:userPwd@127.0.0.1:10809</span><br><span class="line">git config --global socks5://userName:userPwd@127.0.0.1:10809</span><br></pre></td></tr></table></figure><p><strong>或者</strong> 在用户目录下，编辑.gitconfig文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加以下内容, 这里的ip的值就是1.2节中配置的主机ip, 端口号就是2.2中的端口号, 注意端口号和协议保持一致, 可以配置socks5协议, 也可以配置http协议, 这里配置的是http协议。</span></span><br><span class="line">[http]</span><br><span class="line">    sslVerify = false</span><br><span class="line">    proxy = http://192.168.10.1:10809</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">注意：如果使用socks5协议的话，可能需要用户名和密码（默认是不需要的），socks5配置格式如下：</span></span><br><span class="line">[http]                                                                               </span><br><span class="line">    proxy = socks5://userName:userPwd@127.0.0.1:10809</span><br></pre></td></tr></table></figure><h2 id="四-github-clone-加速"><a href="#四-github-clone-加速" class="headerlink" title="四 github clone 加速"></a>四 github clone 加速</h2><p>如果自己本机没有配置代理,   可使用国内的某些代理网站.   <a href="https://gitclone.com/docs/howto/howto_github">github clone 加速</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;一-shell配置&quot;&gt;&lt;a href=&quot;#一-shell配置&quot; class=&quot;headerlink&quot; title=&quot;一 shell配置&quot;&gt;&lt;/a&gt;一 shell配置&lt;/h2&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;t</summary>
      
    
    
    
    <category term="工欲善其事, 必先利其器" scheme="http://okeyia.github.io/categories/%E5%B7%A5%E6%AC%B2%E5%96%84%E5%85%B6%E4%BA%8B-%E5%BF%85%E5%85%88%E5%88%A9%E5%85%B6%E5%99%A8/"/>
    
    
    <category term="Tools" scheme="http://okeyia.github.io/tags/Tools/"/>
    
  </entry>
  
  <entry>
    <title>复现师兄论文实验</title>
    <link href="http://okeyia.github.io/2022/03/13/%E5%A4%8D%E7%8E%B0%E5%B8%88%E5%85%84%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
    <id>http://okeyia.github.io/2022/03/13/%E5%A4%8D%E7%8E%B0%E5%B8%88%E5%85%84%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/</id>
    <published>2022-03-13T07:05:41.000Z</published>
    <updated>2022-11-06T00:38:57.178Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b963e430fdcd63331ecf8da00e85b68c2ddcda7788cf3885fe52308ad479ae60">e8ddf16f6a907c53c402f597f0c2281f2d7aac72253b3449ac2f4958d425e4708939b0421678b058df7b574f2a20007e61d25057c51aa67913fabc023c3d73494eccaa335c69a5dde71800ac33dc951944d77760c7bf01b6c31af0a16f1c0952bdd51f36a4ccf7ea2417f35a9c1293b6f23ab88fb618b8f94f8262a7cffe802fa67bebb1363a3f78c305ee32db600db354663cf276924d653f0b0185099545d14218dfb81d4f984a974436e28157f892e2847dacac013ccb245d3f7c5eee159f2808230a0710b6ee3eadf884d48fd15d10a8ad70d968ad152e9bdc70be171c2ed49e643bf6e132330221de45d9f8f6dc2a23c9e5f7d19a1453bbc601184be48db3800769b6d0edacd0b2f3ecf4fbb0644ef825c1ba340ce05712b613cf75ca29b20f09c0eeb3013ac874b676f5a8fcb0e39edc4dfbcae1551afbe43d2181f3b115b90a4673c9144cd00bbe622bbb0e855c9473e8d09fa741bea29ed840cb993a30f3806313c4363664025393c92721161cdd95c970d9f786a5ef4a6287e20b90ee1035a209791a559be4f33b3ff26c4ca5aa4d261efd40e67829cb12242c6a40b6c64fa00a4395ae8d1887e08653d8e7a799dadd259b4cd81a66cd6b6c82985b73340c9dcda35b49e9bacaf52fd7adae534d3e46388c77168c2a7f581ab2f063e1c4b646d27fc0800878f289925db5a0fff67bf96219d5d62d525f2f885e41addb2a27944d78e22124ed657904f7956ce13234bdb72e59d4f7dded6d696be7c769138df8f190ca4fc496f3407cf0951ddcefe87f239e149a3848f26c55570d3218658669174c41f3d81e47227662d98d3e85965ee29072fd8d8362020456ca8cf5899c39911cc509f65f26347f8de36a9d82d9202c091ed3ece57c25c62e09316ed91ce0f547ba992a39e6dd0ee76f8d3c3fa89e83df5fed2a541b266c5c2733deb6dad5ece37498413fdb77d650b00ac70a532e8a1ad443c1c24e836714bfe56d30ab659bf737c3a3b6d9896386a84777d61d0db1cfb70f6b28736e832dc216fca658eda012a1cf29122170254aaa1da2b34a218a9c00f7b0463504707b0990a11534435524ab044ecae0ffdb373944ddcefe9b70d3a73b980e34688c3d5a237b066036d94a776fc340f04330cb5fd76f04da8a4d1e64eb87343b5932880c1e088df72dbe1635189a38ddb9fd12060dfeae4d4109e8bbf44b252976308b9e12d22843b8566295385fa90bdf0f5cc0833506877332b16a5d6eb9b7c799969ebd8f8752095f99db1110890ddfd9fef0b356c6cd5e1e0671415e25317286497ecfde35c2e87658008e62a5b2cc6b1c7567d6793af600d5f90800832311d0fb26e86322f3fde999461f771845b797e11c2831929d7b8a2886ca6208b2712a7c95b550a4469cbe05050f430e32ceb62161645b34cf2fbd79927e9979af17531b42e81cbf4666a660defbe68b977326b67779982355ab640a061823aa7e09bee1694bb3760d7782ecc88cb0492078e7c1c603afa883ae8bf3fe9e040c9d6d5ab1bd1976e7eb24e75bb29ac0abdf3e741232c27e3a2ee54513927e0cb848951a77226280bc197961e9c8bb66acbed8870e00d7f517138f3c5d6c3169f880b664dda71cc6d1a5c314ed41d88dd9a96af24770b5847a09ba23355d5616da7a10660382cfa7b74b20f060e000bee9a5bcebbc378857c0022795cdcaffb18093d200201bbb25096db5d62b6e55b219651f59922ed3906de41c23496f73bb20f6a8050ef31a29989649cbe598d42ee91ebbddb6fdcdfa8eb42f2ed78aa1384904e7c859bd6712c5f8f4e04e5eb32ef11a897c4cf78b4a6826d8b8d295d4e808831c72dbe8c55c69c9f893a266a83d63f9356e19594c6f1ef44d9894e9e1f3ed46e439c152b3d777936fa8c43686d2cd8565aff7178632eac82f3fea5faf4e523c0dd093393855f631bf0c075e5ac4cb5f26b3350c73ed361cdd7cfd6f4c4e8a53116dcfc7b61647edc8656b81b42d2dec7529aec6751360c528f21e517db6cb39d7b0f3eeec183df1acef9d30587e56bd0c4ea3187de7d28b2e02cadbeb825d54619749823b1e5c907506cb709865a78bacf3e451ca8d0cbfb76e8e00c0dbd12793b85b3a2e2521795f3073329dcbb1b81000eed2c0be72d0af6176cb581cd3ac418af70f7ca507fe3781684639e5e0a2411d2c6985aa63e8721bd90df5e1db19914f0b4a7dfe3b3edf17e51ed8fff28e78771350241270d39a231427c8b9945c015fbf2a8e673eea0b7cd78f210b8f776be3825acc73de19e22b6bd24b1754b05eb24d92855bfdaebc63918e5452132d68f77b9cfd70dd6d839f34f1d4e1a2eecc11e489dd4e07e178ec8fcd25e6f942137f82b9e5e4a056958b146d0d0e4aa42bef70c0140eabcc4bdbbc0eba37acf0d0a85c9062b1000a9745b66c1c81ade6432566a4081ad2ea1ade22f70fca34423cca8638891a3368a9aab512c54e1f29eec118823c37a6aae6298ba52641225ade348efb28323fe7daa2a5ef9b2fba669f1354bc5ab3d3feb4b2932845c9b13f990a53e88b71ac812d68c553ec7d914553b11355aaa6ecfdb3228b6a0802426c59644a75052383e924682ac2d5cf380b448a5ca4ab8d8e98e35302ffc6498cd2aca17f1852fba7eda150612d2bcc9ab73f3d1fd081a053a77bf885ae62b1a77557799818a08d1636ecf761c162fc6b327d762785c0b0740f6044a8dc5a7a792f41e236e665058bc32096ce9e9398cdbe1318da5ba22aa9757b6565d8662e022d3ec1a7d5a278444c648c5fa3d699d6db073899b15ef4b29dc3c009207066a157a850868ac033ad32896df2b12d05c53441a8849aefd92f1c9adebc5b909c2788dd87e841e8c959724161d4a31ab0b9936ded7d48bf13ae03e8b8569ccf30c484249ffe8ebd99586927594cacdbf20defc80dbbb4586a5853768e4af7ff5176c095b6e6ff29b0a27fc94a789ace86ed99b7cac984d8a9fda276f458772294022cee5c9254ebbc74c53359ec73bc37233901d06865e9679e69c625f93738e8d25fbc5b37774b40cfdd2f2a7fcf317f3ae79b5d094e12166bd3b25958efce69a97dfad930218c61a60490e80c54bbf17f6b6dab11fdc8fecbfe20e02acd62959b394adfffaaa975c011eb2292252e829026ab7d86c361eea9971346f789c6ab86496aa0e25d585c1fdd2866a6cf19ed62abb7a981882e14b7afd894dff7bd6d42b9919973ac7385a81241172903237e779b48a9c24360376599bd86dc42dc99eb0613f0ec3e2f1c099dd5fcbfa362bd2bba64b058dc462fefb0305315d7479d566c67b144fed1835a0493473dfdbdcc043dbb102825f1fbc88c9f5a4d811eee89679a758b1fbe726d1ea56ad4df740e49e1a4e72c2623b9b5a52fffec46bd1658afd665a40aa55ba8aefc066c159c0fa124cc83fa7e8626eb9162f3bc3871bcf3364bacb7cf45a0a17b8fd1e48511f0b89173e33e781e8117afb42f6e1e800265f7bb9acf4c60fadadbe0a3711908df423f8ca2c9ccb787018a09a0c881ba2e702580510adc3727cb6d9da265a25a92ab617a110e6b09f02a7d2048a6d093f6a7a9736bf82b02481224c114a4cdc99b8171b9c2cafd678475ac30530f02da05defee7744869512e357224e1bfdeb0f007dd5ce8780b6fcea45342023278fa7f12c2676d1799a5f3e792a7a3c621db20b69f198b6301f4f403a52f29de3d1546e529d071414a01f0edf0114914319100a3f35af32020ad29c446ac1b79165d9162eb616da885569da001792bec512fa5e59656a64ad6041eac88694433e3dd15ae48d8a18dd0c1ce10086e9eecbcb37108313d0e99d01bf723f6c7d6d1902bbf373fb34ec8fefc8941a5b74721116c7f2a68fd14241e977adeaac8d3b284cbf4a3b3d7d20f66f6ade81d706c0d892f7b8a67665f8cfa86c6719cecadbf1e6de65a31d5384aa87d79cafd58c70483ac83d190645f7edcb68b1ebb7d1782d8640e071ed17f1911f033eba7ac9ad8e6629b4c701b44495816c00cb078e0a9280e38654dec734ffe02300562bb49aa9168347c6d7a67510452d6e50187254623f0491d7f7c760904b8cbbe597b8d5158de4e5582acca1402115c5fdf6a6cc14a34c962832b5b78d0ad0b5232561c7c320e9a5eb3b665683121c6978190f702f1c28424c00907d401ba74d915a4ecbe7cf2c87841176c1d1ba9fec92850c4ccc5ee776db056eb33dbaaf4ddde72b0bc84cd8c36af9792ef0f452974c83bfa8ab440817e72214de36b6738a192421b151b2119d47078325a6708e612c347caa151d7e9da9e269bf646ad0ae76d55cf885880f3a5c8ebb18279cd9afaf2f2315a7812735f181b5bbf9ff194e9909bebe266118f67e5f5765afac06b818714c2682120aecaabaf7eac24ec141d7a3f5960edb1d7e1fe31558bb9877485f74bddf57df08fae690f8f6fb26eacae95411e598402ff5bb98dbf973233fac8c740d697f0856dcf00ffc16570f9b025061da423891c7b0cfdeb746e1f20bd2d8f9098e038631f13d63ad493fcba41e6a558efa454e72ac11c9e1dde166ce82f7783ee6749a29497f884ee4579059d063fea384e37327396dfb3cf73b921e3a43b3094c82877071ccbb4719d36e6c9970e874abccf8f33d1e5e07243b5b759de325341a45d33fd861bbe6a77f7bd73506912f6a8362e6b564f18f1e0457a60ab0a922df3831b66cd68e80f93510d67e3014e9f23123a68b7a6d2e60920355f34abbf6dc7ec25c62cf16f55b99ee59ba1a9a75239b49ec34b08e2de21726199ba60a4e3225c675274825caae79e97676ae6e3b21ae445e55f737576c733903ec58a10c1c6c731c375031795023d2434167cdcaedad6305c72e9772604edb0ab2d5dfb2da48d7794f2281cce52426fc9c597a92ad029ab27e62e0a938582ac325b1b28049c62fe11441bf7d12c85be35138dc40b3cce5b74311513aefc4c6f3344e438270fe26aec0c265531b9d710671e35b131241ffb92eee1a60d173c8cfed75bdbf54ac695939e4a1453ab573a2bca8eb0ce77ff6b43e0918ae97634966d9264fe5eb0eab9ccf6c07a1a7b10a145d4d89000198d40fd91ccc2a3b340d76969e88a6cfcf8e3fd8b40ba9936c8c37eb0a7cac5d1b57f91d179dbe63e9423ab2dcfb777f415c873dbcfe7b1e95218b7711c244e178a3b9064123f3035fbee0b185023dbe844168c96736d91b81d08ac9e229a90508b0e5a4cb83b4f68e6a33f1862947971c5b232cd66ba3300142bc8114ee7319aa5d66784a1ed6b34e744d4dbfebeebe81feb040ce644077f815cda40eb737cca4ea419966b1341901ee00a886993f93a12aed56e272b4dccc77ce2f83999f55976cecc7aed6ae6cc711a50ed8e66d75e27498f1ee94ad0a9aac6a0dd5ccd64973d0aef2d40e10b22c4cad5ab5423963372f516cf29bb3001b65cd46c2e8b4d1b85f05cbc6477163eef4128b01ab228d04cd65a292cffb772b252c30dceb6cc508971398ca720bcb36e5225e477c7e055dc1d342985961a224b89bb29500b5c22c8212e85cceb0ad8758418f8f5d8e9183100d9a9fe0598eedf8e9132122dca3cfe722988372b625b3b7766185899d1a73ea6347c15dd98721c51ae513be2e2992014cc30968f9ef66727dec2af91d42e27720a4367f77ff282cdd62dcc4d2a8f34b2a1adc27705c52cce8bbbcf8464e82ce03336ac02ab9286743f9a9596ce12bf669c4e9049c9646bb8e41c13e7b9425f8b1af275b64aa5dd5722b200d13050a35e1e2a263144fafba5360cbf3bfe751f77757f708a2f2427546b99c08df11f4d6968ae243475c182b785fdc0c9232ba854eed6bad070ee98c104dae5e66300cfe1ffeb96be2d3c9d08b50105313ff6c5c79470e0f6edb5a48327ac6fd78ea9400fff52427dbd892d589dcd26869c3c02a58399e08b6a0c2c77ce0b9bf2247914a150bfe0639593cdd7ba6dfa3986546ad229526471aff3f3073f799d72ce54408bbd18d2493afe11b34dab8f3c92262e1f104bc4d52aa8a6af98e5b221b5785f3e83cc9789e10fec61f0003c596186d54fa7c696c593ee3204cf16e577878ab8929b32feb428746c37caa68a01630019a41ac3d51f1d5696801cca303953ac0ff12b30d29a474a80aa3f75ddb3b791d6dd8b5264c71696d1fbe7cceebc961670d1c63f038f9a999a4bd913d7792b1c5fd60a079dcf278e69fbd5ee627b12ac75ce5e86db52b4a284d110638f9123afc96c881217970bbb60c60410c174dc01f472fa61c26169d67d007565ae6bd5c22791cbcf9a7e6c0d95d88772c5262361c416ee30c9abb74f86a39abebb3b7c792e01caf8bb94b6f54245c154c1052f0a04c3fd52ef148bab70d2b4a46ea7f175f339132660db70ac2ae1efe5ec8b252a1df803c929b23d00c8c1a7a7e6be6b99e28af39b58c288d7970b995e603cb2846ee6944b55dbf0f9761b694682473918443dc908ef61e80e44d865f9e5fd19b072e1efd5718e73c0546099ae50203d6563a86cb6690804fe4950dc88e3834119bee24f4de4c280afa512f941c6c7704fc4f3b805d12c3c870094a950144c511710b2a723c7efe4779f146a372b5354004934eb4615b83825106aede8f9de958f424566c72853d9ca426680d881d94bc75284c1fec4fc0d536c829ed0b5e8568419efb0dbae0544b22dd7e0ec593620fb10c39a44a72f496c5ae82f6999b500cbf691a69b86fb428d3e693164f38da8f4bd34e16722dd822c678edfcf6509d14b1b6d6f41b7b0ab12194a6df27563d4eece9560e18e1ac4352ab8193f7c06bb247cb6670afea8ff0190a8f91c07c281a7166d187048ca2639c769089669bef3525b3001704694b40e8d2a225f841b35738bf2dcd600f7fcc4af9f775815808b3d6b3be7a9b2b6235dce59ca4a55691cce032bc9fba4ae7d68e76cef9e11c5d963d8ff992a0a61b128b485ca448c733af21a10f673b0bca67facbad4e9b19080f00801cf67bfe0aff5e3a4bbe20d285c99f1a28158ab27827d7e04bbbf27d1da613e091c0c568954f524cee89d190245a6426e091072ec6ff82dbb1d39d6b5409b6e77e81f54ffc705f173c6a5ec31ab47173356a506feff22f7c41a9bc62df0c27520608c46ac18c72ef5c0392289ad0d0a8fc689d7a0c372b8699407135524754a5169b6e3eb7f313bcf2cf93017a0acb054e86c38c28375470770cfe412083a7bf5aeb253faf0c7902fb8a25a2ab11079fe66ae0f868f7aa06c7186cd8941610bb3e903ce1f8e0222edf0045fad8a854af8e2a401e9e55e37050ef1387f2875b6737cde972a202b41aa23aa00217dfddc9929d9ef5099808acc20c07e3089847aa65aa07cfd9d685bf43bd2d077f3b2cf463d9782ceb28eefa6419260cedda1c023766174d0e62af52b41f0275d93a1595d9b44015b11c5908f1f51aa8190d203c47cd6c6bf85035d03707e9c864d3b9ce9fa4d147bf7008048e975a4cb232613e660019362e3bb674c318ef14c613a74d4aa37e83a135047e3fef5d4d136511d56b7e11b1de16563c8c074db22c1a0d4e583880638a844021182233258023e21739f98369710803de95d586ff9b96761349e44309851f0a7ea77afacd4bed5798f408324aa7988e37daec989570334ec04b7b8447f22b9cabbbfdf18c3340109dcaef1e6b49a238b0901527c7e57edd39d042a93799cd10d11fa47943ccfdb38270278121408a020552daceec2e07d4899520e1f64444d109393e399d399b7c3bcd51c222f4b27048d8dbf4a1811564efe3b95d8dc96bd9e79b300c47944e93488605fdedc72e2b6d2be74e679cefccb7283c42cdf4740a1d74d693fd8d94b11e360e1d6cfa5d29b904e2364aba5705a656e4ac9d961dfa881cc44612d5ec5aeb804e3c6ca56a6d6ef1db24f04fc70ed558baa652d7544a4e3b840ad51dfc6ebbbf6150d20fc1e36e1d25f32e853c144eb42a80dffbf0d80c74908ad759d78bb4557ae10578d799a1b5ee1387c05dd55af6d0cd56f3cf4f2cc1b909e2d1a542677b263c686fbec48c481f40e651ad9c0703906632f69bd12fc6e8d1a4e8586acde0c118bed687c898ef132076167cedd660a71b3a3ce270ac67a05e4e1b7fd7f6fc13433f60c1253cec338edfe4e44c85dc6c1c2edd9b735e63a23b2be93af9f0f9e95ae0b078008cf050dcf3883bda4f9fd8920d44a59b927b7c4bb7d414cd955120b45bcd38926fa8270e3b65f5327854dd973af9b165c022d03a288ae5610f5d12286cc73a4d2a96b32a1d1dc11a57316e6ad8356a493381b2cdf6342573fa66e05cf0c385d853f8eaee73bb031641932c129f36b0415109c0f74af288ef3c5af26cf50376b005addfc8da6148ee8890168e711f593640a24b099d627bb3e2ddb634d53a37834d847a50b63e701a418214a186089119cb1deacc30c696e209bc325f37f57623773d6159c6f235535c6b8e1157812e7d244c57e2754c7c6c9d961b0ef97ab403172d580cb61baf8a1b9372c105ab4fc379b147e5d1723c2e126edc4ef624c20ed56384853b683bc6c67b71ba25dcd2f18976d0c046d9da453ab425679c0a84a33f71e0987f470b97a48829b2cd3772c6d0c606676bf884b6aea916ac863c007a66cf2f6a363bba04d3d78b4387611bd49d7fd1ebc4d8c775b0f695fd7d35a30f39b886f6ce61a0de33c7d122fe84efe24bd91e69e4a335a32723c6f679858ad659207b2ce3a889d76dc7054a1f49de1f3422dc70224ec11ed8ffcf5f6cc8e0e55987d742c7258ddb6e44ac00ebaad6e306c2b2690e64b95e2b2fc106379b48b71201b7e86fd70b31c59abad73f7828a75b945279dafee8d84367e05ad9e65b99ec1a80eafb260550db8f4edb4c119a24a65f3a794339a26ef9e186a2aa872b65f620cb1ea4d9e76022788fb33baf8d9aaed892d6dba4b62f9b2bfaa65cf653feef49e8a136b6f8f7ab8babdc6573ba8b69d2dda1a1a8bafcac3800067ef74d1e2cdbeb591f2ef2acb09d1d2c6565984e5b1d993a680c0e0d177de37c07c4882db952859cb9c849d45d799b01e02fcf26045a5783bd188c1d102adb8e4a2adcb90853f65caf88ea884c1014c6977097aec037d54511e62069bb18a4a87d903bb24bec77a9243a34ea52567ca8c820f56df000bd704b52b31e6d46f64019f88dc5cbd133bbfdc90017ba5118462d0b9eb4f56ccbbf52414b2fba370249e879062118cdc92faeee778aff75144e2f5cf1ca7e90c0a85c17a2198ac770fa54d4c7d056fecbacf916687d939e38d311355c233fd74420406d7b8adca5b01352928a549c386b31f360d5a01c22724b9fafd1ec76bee19db36fbc3dddae49c8736a70c0d400eeeeb3bd0b82f07f2834773c10bd314f406fda98142260c1900ea85f7450c34dbdd3db84b12b7290ceb50eda5b200ca0b080a422302b93e2a7ed63b8c9ecf924ca61ea19a853777c593fb7d1eab71663c84e8ac4b21943c2d76ab9513b9768d14014e9a18fc7693838133e82f320951e7807d875953898c21174ff867cbe7dddeb03fd4c5cc14119eb6db9118448cc42463978db177a7973ae165d8df0e581c63f3fd726ff245be148adda5794b88e66ea289dd1222a2a812a1fe8d96273b01b4208daea5cdf8d623e7c20f185456356fa75f77ef8f2973143b532b91e3ff030503c3cda18a9eb70031b7174fa18fd3244571da5e2840b03c02266136cd8c0a3004eea812fb1b0014078efaa37bae1fea6804a85d51af01d7532f778057af89b3f14342e6a328ed9cd439bf9e93e5749b550d22c38fbe24b87ebfde0d842da8bd2811dd9c431d3b6fdf4305d6b54f9ec96d8b0bee18ff44e6abbd11f42255a070f8eb5aaa66a11a81b133d30f84a01802210878eecc4ac2b357e64fe6cb6d9965a49490a081717221297b5b86e70171a9b6c88c1330a90de192581206a4d997cae724e813898fcbe60d98dcb2de04061cad75b315f4048cdbc2c87949da7fae6a6950b98f2d91760e341e290f3870af97ca0a829987333386795a0c9f9c8a4de77c57544ca311447c203e71a7a97201fe34d586e346eea35b3502e79c2e36e8c16eee776268422e5656840ccd8976b034d20c4259a7f7c2abdb293ef99298e9b064d336de85703eb53fe45c7397a3bf108cbaa80dd360e96a6197540bb521ec3b60b0170a4f9f231bfefd416a6adc9cc7ccc1f7004aa9a800fa92697c5a03d5211d05323f3fe54055d23017ee711ba2717db6ef87a83940b0125865350d665c8fd8154e73791084adc29dd34ef455b9a22bec607bd7d283a95ead44709915e2c0e47eb1164a8b74ae37b010627e51aa52799460bad8d24c43c5ddc821faf9a7f2b75cea34b7f8b7fe11a208c7acf1ccdf7c874582ffc89e36450c7a505e13af1078eb23b32ded0e67fd682da643b61fca7bbd831a09f82510f2137b17bf55517cfebdb3aefa16875fa871bb9ea85d1cdef61f03923f9825b4e60f782c73fb956fa09f8d2f15455ab05f07cb7cdcc3d61b395a79887b09cad9faaf197d35c176bbddcd4888c8eb5730bd7d489ece7ed631c09de238a07d5561c5ff002d3fc5599b7de20dad4f6e90cde32663b86d85953b3b5bfb2d76e7d1aeb83a9bab07b10d38728871d4a974da902b83a834595ba8c8c16ac178cc5e8c03527d7647607c458d79d48fe27f0d973042a0b16da5d3b2b50615a18bc1cac9c167b891c2cf34cbd3418df4e4dc5f0f30babfa8e48003d3f9aab0ac84e8dafebcd223913947f4d7ffaf35a5b6c91d2937c47871b2cbb2e73042ff4a5e709e70ab1b4bf32fa27aedca63ef2837c1717bb2064bd181ac9f58797734493566965d53367c09f25d192a9d6b20e85867d805cdd57a2b4884ed081749b967bbb4c26313938f261f89a9b20f0269889156a0d9de7fd5d517c5b177a6ddc30d78c7705804816eb0bc7c96d236d2a324a5415577f56061506269200d922c466d05c295189f496d60e820acdcd118fbd8839c4d03b47d92204d62f031d9dbe222120f224093359ab9161675cbe1ec8bcd30ae817f753b6a9c4b18c3c2962468946f1e78e83c7d7bf7da6a32080bbf360459e39030400682b788409e22fa87ae881650c7fcfd9baed461ae543e1ce5585aab51e4aab16a09c23da9535233a06349ad4fc383da1e1e11d659fbcf6cbfd43b2ee8428951679997ebb065892b11b1719283d8fa781eff2aed60a39d1d06d6ecf8a0dafe68e402286ec2b753a2a84465598718774a6f4f80a3cbbff3229c85882628ee1e5b95c417ea352823f6cf4d4361ff521b0a55073783e8f224641794f2035be7f6ad90889c24a94b04681dceec43916ad64ba1516c09b1a6f3ddd183bfc44eeeed118264699a627b1ae7cadd58ea9fb524c666b6f56051791a629823faca55f184f36ede83b738febc9422cf4ba06a24881e6907e3ccc1987e805ed1c1229308f809e070da6893e44a990d1e27ae71edf2cf33bcf55ec85c19ef112beae9314640c3b560c2940e8d26777f636103087b4e63b7b79786f4fbd2187d29db16dfef2f0e1a6ee5d3b3054a67c45042695c57ce475df28fc3211336d73a3242779041cfa2e8392c5abbc6189c36573a1e346c8295ec63c4fffbff9093864de014fb12f363d5b94aaa0213dcef025017063e78cc8065083c931d303d13c9463ba3be2073b6c795cf319e82f26181694de78aff6a4a77eb017d3906bf41f195f5234ec6d80145b4a29d76c6d719e80fea12f09d1f26e1fcbbadc461cefd61cb04e2059184b5dd00f02be2c8a649df0e6d0958d5fd4eacdd648ea7ca04ec0e8ba142ebd94aee03d72c733ac4fa24e20fa6b6f89b9b4bb4fbadb6bc61e06c52b74fb2ab9a2ea9115827997bc5b29ba4537b4a32398a55aba7ec2df3cff1c619bfbf5672ea3bcb98cede3cd3f88bd9b3fe689258d1c2f322c628db6a5b106d40fb8122596c0e203a3bebaebdd48d859c5797e6b15744de429c6b32d56677101f3f6597a2dc461c37473904023a58011d600c65a5b2caca41bb4e8448371a761ac59d99bc16c74d10d4ec7d1cdbd4ad7818a15f0288dc09519aa0cdf986cb2af2224feac0c7203f83678b39edceccb9d1b859a1571c53099ffc262967732f1cb255c42e7a630499ddc26c60a6c962db51f797cf7f4710b4c837b12f34439187247b356c3a010e1ce9ad04e76df8ff9732b8c106a49d17fd51d2a82a98bbb6fb6d2613b6659b57802f53d6f57bed7f3f7615c915785942da9a318c8e46001116665bd6741be2ed5ebca0262c4da22f2b6eef968b87afd9de7ee5a23034fc5d69b40d63a8229ca1a9926f1a9e883d60f89919f619411b81039b9310865db034f926bc0efe3827ac5931127167aa861b68ddc6d3562d6bcb01280a7839b453d290f9d91852ec420287fd93c516577e9d872c8233d64f3fcc43c9f80b3ce2b149db382da69bb9a68747c7486408b7da61f0e3130495b3f19149933b3f88c9ac09140b53c703def7991ec3e5f53b6bd0ec42ac174d3c3a674117c0131600ede7cf26d1fb78da78e0e1383459a8f35227d3561077fb1e5cb4e3bdda1fb3e2893c02437a53883d930e0a90c55638c49e39d3369b03f047792cdbc94a1629f272447560afd62516a912e93f5b53bf5f70fb937db74f56eadc8de655ab3903304e47a764dcb584a3e1df2fa57b5acaa3a322e2dfbb88750a47ce7523d3dd1bb512953b375d0b8cc9af565f02d031bf544ae9f74fe2c18af1785dd3e13161a60168117066000f95ad45028e64313a897bf71fea3c0cb068f052a3d1544df5bdc26074b8d28bfe550f67e1ae149fadd32a98b4640e455df4927e5b92f57afc38ddf0e8bf6aa2102ba8d47c16656c44e79abb1cb6bed0cbd2fadf8de4cb0c00cfcedde3e7847f692ae1e7028e6490b8063cdd7bf699d0558d7d3f75d6d993a97bdc00f832e0b36a3e7e73d50ed5386cd56ff37fde108d333f658448933e5816ab8359c7faa8ffb0a6880daf0239766a1f0af783fbe60204dfdc0cb6fa34845b6ec2a846b3c8ea93b572c4384a4bd07ed47d584cee93d5baf697ba051f0d0dcebae81508a6a3939bd7fa152c21829648c848b6e56d60f5c9c18784939062cc35714f4e0f8cb6e2f8fe0d88894dc846dfd7ce21c6ac2626925b38d20d913c901bf89e59a78f6663c172ae418af94e335111b0d14ccd22f6be82bd31891a9d5bd7183ddfb80810116232b5175a5151fba645748a1f13b3a883f10a4b70f0b5f2949b10b5cfea1113eaf71f0e0bd39fa7f8d141ad8bdeceaaa2aa48c05c4518cdded5b4c5e75b2b8a2c0a3487fb6d3ce2edd751413eabb597649669a9461dd844e3b5e4fe5927e03b6bd1386d3ed42b5d7450c37c90ffc7ba3013c1831e279ef96d04544437ecd8e82ec5e7cdc81cf41ace4f28fe936eee1dd45f84255259975323d0e20d455fe0a220c9cfa86a26b95b42c1ec3895d5bf7247c9a1cd4bac4f5fa225907d2303e8a73f9ee78884735bf85e0048335bd75a9d3f90c5315b95b9711c29101f7057265ef12d883056e9acf21e2bdf92d41b25d2fe49d05a9f47c4400d1567a2c28eb14e482c8c06c85090ba3633aa017c775f47c4eec6f62807de86ee63db672d9f08fb8cc8d2b1c5b4546b51c263e4736ef9c2661d5c22d601bc96cbb0d728952e761f03829eef002eec9b43f409569cc88a9a14c513fc8d7fa9834ef0ff2cd1baefc5f0622946b75427d50f3c9dae07adb160647ac167827732ec730d83882879f85409aa113b93bc091660ce9e553e54971fa21c5b3226b6fe0ef269a4233ea8bf109f6f5f14912002fae323ff340306498c9b3ab9c683fcb048af620ece334237be795bed86ee246685f6426ceb66196d3ec6065e59dea8c900a71f387b1b73ff55bcb549cbe9e504129b37f9667db2a9616c31c1c76c84c96b3d5b048dcdaa4a1f5cc9e4883b37bfac34e5bf67e3d081d259a95e418d0f0654767a6aeaf2407564a69ca7ec6fae527af334706affbb163bed349bc0bbdcb2f4d9a732e5089db5745b37a2ff5689afc634a4db06ea09fc51b51ecf8d4fd0a65e0ea0a61fec2e6f7c886d1da912ca31b317fede8167cd5b0271cc5dad3856a67621806e6ea52b6efddbc3221fdc24692bbe40d48405601fa430f76bad80cfbb08c2f3d98d7444438801a20170826363aea1588f947e12cfc4c5185f5c3abc8dac288f59673c201563dfde3240d279eef24677b614cc2c45bab6d5237d383d6a96140ef1e659277ad0fe7be32ab6925f56c76e01d739d3b4a9e01aafdae17cf87f0ee900ebeafaf0a2eb8670bbf56fe5ea63a9cf419e53fb3a371c2890f39b229f21a1d26849df4841281c0d293a5c62d4179f2605c92cd6c211a936f2d0519fbd646259f6e5ff0465b1764b9d0ade9ed76b039574cc49b691c5099646c067dc02859e4e3c96e4f751f65e71a119e7e6f2ca7f268239aa705e8e0b6d3660c7724bf3884a035de60f3540d71c407c2261afa5fe3c877082ea21456000afb1ca022dd4a16b7d9b5f3ac97dcf2796b70c36e88b5a5fb4b74b771f06ff7db636e31fef3389e6cfd755a55e74f5800ff4a06d2506f4ca9d5db52c0f9eb91514ec189528304b2e88f2c573181f73a498b2250046626814021ead25741810fbb7077e3652b920365186649b992626aa3df47948efcb30b08c4c7f6fc412db6ec7f67fa01d115cd4be5e62bf8007974e0410c8127e07a112787dac6a5d8c8a5b81648978521ee8213152c5339606328291422d43cc4f61636d9cd1a7850352378f7fb749c8b5083faea30b4de31fe7bebee87ecff23d7597ee7bf92587458058d59fad8b7e514d9841952ab35e60ea16423914d2a8d8fadcd536f0db36d642ac6dd36cfa98ef661c84bea2560280c06f875208de1b8c6d717b28845ecbf7f2b9c7b5a44fda4eb86485642eb4a64be04d8a378b8a13b977d4f3d95527f3cb4cc621d4cbe96f994b547ccf5e6b385ce7d46b3090ce7c8f62e548ec1aeb0ed1eb0dd5574d68132c722cff8b2200836a8d76136c35f36e08d97e251c4160ddb7acef91f1daab5b1b8f5490d9e04e7fdbabb7bc3c3cb08b3bb444259dd3ad47e7235629adb7c7127662346f5064662dd20003bd84c9a2daa363d260fe0bc54bb34d83ff74d93a28a795e73f0cc534b57c2288487a409355ef91d5fa5958ce90183c25a3fa71c49f466cd3c9679443ac419f1f22d6fd8bb759cb96d25c9c586e9ec887fc26c5476a903d327df09d0ea51a9eb49a95ebaac17c7263dccdfe57fac26fe4617e40a73ac93f2d4f458c95f50681dc9c429ed6be06a2b36d2f850140878e842bac899ff79ac22d662ffd75276f7678190e7081373f56c8e360da32093c31b6e93a55c52f01370c6155285a4db14a73fd296bbd722dde011eaf4c7bab0bcdc7615f75e1a83f002e5a3434ff113866fc8967f249a982904144532149e647a0618d0d7a0169680fd2776d82c188ec9dbfab8e3539bfbafd0a116c587dea77fc0592ef98755c0df201ec6a9280ca9e48fd880e1b45cc892f1a335b6b7589fabf38bcb923c7b06fe5a995c4964d1bb3565320e6cfd1e97e96df4bc396b6ae0d2efb55e2ef365dc5770be9f7d94dde3e60b118931493d23764a99d83f7269408fe2dcc8e40bbe8ef3e8de35e7df587fea165c3cb306f9663b0e3de4f5e982b73949ccf88127b90a9f60439bac6ee1d90d754afc8a3fd2105b4f1f1455638dc9b92ed312b1e3d3fa890e83b7508b0d45dae004606648c09b57aa8ec5d4736820835ba17a1c4278fc6ea5f26c66eb79904115e830ee3e4b5d726aaee41d61c23d02371a1283a7c553d3dec1c7e7b4a94e01fe24e4ab7023afbe7bebef49fe4188c6ea1dcdd0575b75dc07ee584a8d7124108bcbfdbdb40b67d6a149495f0aebffd60f3e28f6ae68975cfbbe643a45578f37cbc855dc22d24a5c6496c9f982378d555e2ed404c10ebe9a57a3fdd08eaccc9665a36956452ee2554f51848a6afeec5d91927e0560a563fb3c6f1ddbb39da61b15ac26d51f179f74148c15ec7ed31907e61c0204dd6e8d219e1e2e04b8be4cb38afacf447eb76c0bc623222aea1c6e870c48b9dfc5f19fe4c404eb1decd9f2fa952446395ecffd5492b2b1ae7ffbb01a1bbcdb5814c132c02876bb5a1543c42c1b7acf4c499bd225ada2e7be1905d7f6b1ab12e59140f2cab2c2a02455ff51fc49426dc7f148372360b43d1e6c427bde5a08e32c1096310af77bb6e3a36595ba70f2a5308bb7b5f6f194cee038870048d2be5a69497065d0d6ef0be8519b6ae6d9710aed46839c9303e99fcd43779411da79fa7031e418cdb4e3b38375ada5cf8aee23a642f54c0777d88061aa1142498a3b106d02d4f7cff48d64c998de0111283fad5cce482dc80180bad71d290792237c3c46a55dd839358a63a86c206719daecca746fc123ee35531e6f00bdce168a1046afc21b3d989418162a7061d2387e774ecb8d53e53fdb2b3665914239cf24e4d4e8ecdccc5f3c20ba6c23351a2c0cb67750c7c31e0d2fcebc7227caf30bd2baf7eede864bebe806b1681bcd51ce87a2ffd69f282e5e90d316f70aa1ed9f1635ba06ebcb8e90ad56d21419382e684fbf9f4589d879507f244fd156e98f2af3e045219c2df5201432f9f91172280f87af1d63e0e98e2f58218db52e8e373109114059cfc242a8807340f03f5e479e2836ea5a6be8131ab7ae8aaac0ceb92f128f9f9832a8c314469a14cc65252d012302d9fd41746f94258981f800404ec333503f83cb3dd748b555b9892f300533134f1775faf1c70ada8811b9771587c23bb00d084964edad6c95bffb1c38774a746f5305fc8002b229d5cf6c4d23005dd66c55fa95d6b17a4660f7580add4a3896c116edfe97ad58b250ac3d993606a8a901405cf92802cffd06e1977cd73d549dba786eba3c93696a5ccbb04e27599c4925ec8624a950b250a247dadea4784aabf86422c68cec93531609a2a6d03e6de69032f62885a8c8ccf9c50c7a5dcdfd1e4724bd51eabf030afc201fb33b5191d2ac716ba52d52169da0fde6f95861c5e2d1a965bfb27740ab28dba1e56924e5d16a3c14ece0bbd38f4537a337f2bb91d94090c72b69b414f71ee1efd8e4bf0b772af999b479d802d185e328bf999eb2c5d884bc9a0d4a22ee3db36c706790dd21814fd1619eb1c17ed788c2140957c61283f7fb7b212df086095249c5caaabc37f3bfd68edf91ca9718a332f976db0e1e300a33a36d8220da285fd389c762c40647a77d535c585fd52f665cee1148b5e2dc2385b54d3c238cb25bbc9572e85888580a21b70efba7e94e30919e9fd013028421f2bafea114dd35258e0448bf28c11b2b9de3ad041b1616654ef0fc7b3081216b6bb8512faf90b8ce20fc41d541b2bb8e5361128be241a9786f29b03eaf58aa747588b62f4bb15f9566199a8e6bdbd786df74923f66162c663e1a4c5825dd4d1158e928a48f0968293ef6d2f137759a847b5b0c4d22339d594c49fd78ec24f85f8ff9192fa806fc0848b6c79d12ee2bbdf4d018341af0244004251a9e138e2a536681279d3a4e71022e7be8c0ce73ecd9a729c8727cb4dedcc69bc7ee03449fa6c165cb17aa4b1e352b72a0971664f6734b0c6fdbce38fc8b58d23e437be22e1d826d7650db4ec24422934b5ae3a6bdc76645a2cb7a7c4ecfde014a36b99df897eef95c25bebe1b6bd46dd2daf03229b7eadf38bd79ddc1ee424b4050662d0665443dea924dfd43ca54762dd857da2e8376c40b2fbc06e334fb4021a321731017af247bb56476508dfb6292b15e575c7ad0b5ff6d61fbf31b01ce21ca0e21520176be75c4a8f496c07a96b8215c44aa3c7bc75abbbb3be4eecd721a81eb261ef40e3bcd867f638d6b85fc72085f3e9143c98391b579ea6cebac2cb65415f73be2a4106cab880597cabff2f39b073f7c014b530f12e1ea844fae689b2202038e18fc4e3e0c866cc26870780a8a41faeb64ed56654c0082a927b07db60b72ddf6dfd7d04bda395b1d79fbbdfd860df18fea38db10902bee9cdc31bb6f66b7f49bcbac442444318d38377720086b91957f9eb9a1807fc5d5c20cf352382653571fcecb322186e66399802b69d012875ceb470de2830f780d3d1c221d155a19a75ccb6f96b1bbe9133c0c334e99b56b57c4bc8ae915b0f7d660b932a50b79e68925c4309b2966bfd0908896023ec483741e2bffca95015ff4aaa6cb464be0b28a15656c5d66f01cb84e79d6d171b69d0b9f79fba33c52ca82f8d1fc6ab9b7935f35b0839efed9ea17c1bea77e750a6a67f655b6ece7ac56fee877a707568d82f9ccb6460d514abe72e4768d93caf9306417724e5318809092bf59a289ce015d90159e762a9457e66a0a6a37356171e049342466553ac30cf5e541ae1abfad54cb2b3b188140f8281f64d2a32ba34d8e1bad2b452aa701fa2aedde8059ae4b097c34156d4a66a60ad712302a0b06053ed558d5894d59346f72f15caef092ba3e1b350d463cd7ed35da8e808c2d7da54e9e7251a8011ea96f33d52652d2cbfb5856bb168c006ae9a5a53f67ab90dfc4b8085b4731ceddf9c7ac1aa956bedaf6aea070f2493d67cfab0858a9f7d8bae89b272aae0abf5f4cb739554f676be6b7c330ed40ababf1325241e47390ac56042ada7ac01868b355dc94f09759bcc3a97bd3b026a5490f51f8b73ff9a2400a6184c96fe9c204333ea5c2bf1df77f9c9e4928286e6f75398fdf7f9794148bf839e7c378a161e75c462de2f011573f99c990e22e04add92f96497158f9fdab63aa7e8bbd84c284f1aca53cf9fa3a7c946327b3390ad1218ede796b4ed0695da0f1cf008ebb424711553c8101f16e7374845f12404c034e110301ae5c735a8b2ce7a5a189b296004e27af602a1cd83319a3de6eb05f133e7bbb1f649f467abf69c769207e73de2eea9f3f304345326e6a6d6f0df0961e9075ea3cc06df4ef6250e06cddf0f557da3c549465f5ecc62213e407aa7a541f66a9cb161257e96950cce447401271e62a7fa5d7f958b324cabda6c78ee9de0feeb5c9cefa95d05a516f97e83948ddcff45d0389b6d421f5858d465965fb60c782fad56dd1f8a335d2cde24733d2ffc57fdfe5438b734955618af1f44c72d7a5a77a3f24e54614042e1d4968ab4397f39dfa9b8a62e647a250f8d1b0e6a6c87bcaa2aa3df9dfd5ff33c88291e2163842189c4c57d49a5af0f37868ae9855323968272b0201d25b5a6899299deee2c10c12066f5070fb710e7a36380d2df1aff1bd9233a648f51ec86c0874cb1dbb1265d941fbf3a2656c8462bf6b98c4a2e8198d8660331230e53073875f10b1d8a375f0547ef010b505af9a513741a42e171d1be557d01ce875d075e84c534d6d1f607a5f01251f7453ece5938b3f739c6fe181021b491387900058abfb9258faae3614e827cb1da364522a0f14fbc7fcafe5fa1796a4cf7eb9bca7877ffe4381dc6411ee8eaceda41106cc27a1a23943b11d3d6385b39cc1a724696e5a2d06ea5e189df675bffe6d1caff7dfd2ebf3351a05f5e5d59aefe0192df058ce1239e52fd44cc71285c3d3d3fcdccffb7148e9f2b9631cec6a2289b92ac9481ec89d4fb2a9fd1e05fd658fe9cee4ef0a51eda1f83290e0b5078d74674f12b5d3fe80bda83ed48dd4f6d44083be349526605b18a1d8160030d12af64146ea63781b3436abcd1b58f5527c6fd6325f4e24156b69077f64de3924e7613870d8256d048358cadec836ed85713870d64b37c7f69f6a3ba8e5ec6c8d74c53aed3ee28a3c4f081800411cbbb7195d52a46960d6df968d53f0c0db5581a048790e37d79e080e795ef488119e2a13debb833d690747cc89d302bcd281b19887452cef23742f9729b687211d2fd5885887704fbecc241232a35e6b4f9d8f69c67dd5b312a6d3eb67cd5036ac96709f52c0664b17a6cb88076360b5c8ab47d4449e0990fec584d73d8f6b676e540ef593a38165ef0b283f9b5557a37387689e03c0af0ebcb4878087a89d26e0ad89e74dc325643e3c87e832bfe38e63780a65cdd776c1ef5f87287305bd1ba74941b2a080006ec1954a16358823cc7030b52200871df533cd038129057450bcb0a2a6abbcce522315aabeb54256e4e23df638ab77ab815884494e90f587cf4bf81b0266edf51c24adb1576a23617696e495510e74e04eb7ba23256ff896477d62fb2e99c90051bedfb52248e050a1627d39933389c7c2327d97ff8a0d13ca12d7ce0c3bc14e4185cbf8ed3d55826de6ba470f8cf5b61a1b5bd531f098f9d5cd6b4a2b1b499cee879e12c20c5e6e24cf0e975f62be4a7b40efdf8c422a282b6719022b4ec7cd15b73a3ee78c112b1e16b818125eb191b1033e0cb163f3ab163c70e197c7a6a7460f49b34746da2495f913da96a59908eb1720569aee4d4ee307c6a95cf0f93a27b108d066f308fca9615d5e45380a7bc305c3937d05084f741ff9996e1f504f5b25572d6636fe226444b3a8ce812e76565e153a0275c3f5846510003e3efee24390df6157843cec8ccb381c89c2360bfa687b4306d1c4d43f0cc99a4881328ade97f94a4d858c254bb1c335b4f7ba11239d209dddcc379dda07d3a7972636cb7ed5a0f87bb29a0aca08749ff4e51471b224e7fb26abd8a426bdaa8623aced4583f4bda7e642a6a83405c86923e6688a2518f89bcfe108a8876a2c2fea7b8c192d19dd66ef5f59a11451751b182c67c6092c09b0b19766fd52cf1b7de02eb50754485b00bacb798280f7cf6181adb771da4e39211dff54b032f9fb9cef6049a5485a4a00a79059a3f44bb307727f57ad794d4731f306b274af2675fdb0a2a583cc50ddf28153f249517f6362315b3177a67b96b8b786ca1719d79ad1868fc06e796acdf807e2330999416597207cde3440cb3227fe923f1678c264bb5927cc6b1cd203e986514ac02c8baddcb86e07009372e88db6eb217cafcdba8cb6f6ac3944ad41f8f90001f72704c243e3a0965dcaa8d28915d0b54c014fdf9a155e803086c5b3e36410e9153d5dd3aa9aa828e16ba9338ad5785929af04e0e8aa3104cce7cf4f7289063c29228b9530a95143b57aa1656e06a1ab3d24b7203d0f346022189980d9dca89c16664751cc7408047cc1364d9c05f9b2fa4ba51687ea4dffc4f9b60afdde1d5500986a24190b6c82928b47933de08687828a2481d8b3846ba5c9f235bd2b1310b4d3366538d13917a40a3ef76b85b49781df3055390be52f3abad46bcef1df9abe38ae8fc0563586428cb4653aa1511415a7e27feb9c04ff45bd272cbef13747e1e8ff7a28b8c735ed75a076ca28431c8069061b9c286ccea6290ee950c604108f881e9b6eda1a72b14a4582ce8ca0ffe5e5bfa0ecb30a0a0302edfbd911fa21e57a1ec0a8bc8913abe6f06526a214186ff51f8d44ba2572fb78cb21824673bb9184bf8616ce5de703182ce5958fa1dd0239c6f8df8cf59b0599ef04300c9b264f0bef9b7185bf636b05a65225b367958ea50ae5e749951d7a66e375d01e7bc45fab0ccdba8b8b1a5ece3f08d7c0a261988e1c05a980061fa8a3512d9b8511e0489812f86b39569e250fbf12ac572e8f8074a324efec134a8f529f4a461e1bcf8121caea700386d893f4096348a2c1ee292ea2d5d79e9a560851ec601224ea2c26d655a8617999fe59c1179d70948120388f25639d85acc60cbd8d513e0a94a83621c8d8a3603bfde40236e4c375983da1a8ceda36e60cfad839fa26ac84e91683c86e33d6c02863eb4cb92e37983c54688d5497e7344e4cbfdb202c7bea23a011c7608503396086d16ea2a9e0860912caa16e0730e59e636bcc9d2cbd70d1a10ced3cdde21eb0523555737efddbfb43c5d43df62b1d3945ba77fc76a532e4fb84f1f8e4a5efc8a6ad4c842d50e8d2f999837f9e12cd815ecda9150151abfe638ead53d813ba6b275e302af21bf689e9a863a10578c4fa82370a5782fc1bafe1e99bab9e10202e045b23400f321295948d14d5ce0fec1324683194e0a37166c95ba25fe9eda9c8f513f257c3eb2d786cf69adc4c33f5ec595e47ff2f8ceb2101935f3159dff604013295e884642c38bf625390deb154656b6545354f35906aaa34c78d984a9df41e13058108ebcc12d509894f55ab5af998008e3845b9e8a156f4cee77992963c0a981bd226f7ef6f7b5e2c3cf2dd9222a54672b0c80fc857fa564c3b0b5634037e3d59bcf48221ac0fedfd1abf5204dbfbb073c7d11c955734ef09eddabf89066f12aaf1dd1fb5482b9ea16d889a84664d52bf40b15f60ef212c3f133e2e6018f0d1cf185471ce6ad372b8ef4abcfc946ab9ea424b649ee18c20e897b90a3a24a32a6111d314b0ecf8d5453b3a600c5b2c6d70cf72695b435353ccd3a1db05d1d04a4b927fbc1c2870875da7fdbf8651ee3b508c4557d8510a261a47995236dd15506705f33d035f2196c1412559e2f9a456721bfa7eedd2134a81273cba6bbff7a5fe0c130e772f0a50427f6ae65f4da92a2d25bdbc6b151babaa0689c4c5af8266d140750a89077cd3660ec54a2509ed9ae5b44b5d8b58b2eb8075b8cd362905916d2a3dd4411701c7b23f74bf40f47873e2631953d8631aeed1675b7df380f32704479877ffb64006de454c15453a03eaa481cc93f7b2d6ee19361bbb24b7e3c452278bb0d0a4ffeecda936274cba800e132937b0397a521303ef98c482347a4139120e65c8a3ccd9d0d1ec97e62be684e5a8882b922a405c0b790950958070ed5db47adf8795b40b5f55a146eaa0fd136f545f414ea6c07fb020308d01a760e40fe3cdb6b0fc060af1edaf42e19bbac18e4c9be39842c63229c2de3df2b7fa3178d223947141c98cbff5b5d2c2e7c376c96721d70d2e61f9691065d3774a6d4ddf2184844ef33342cb8c207c24b5db768bb780e7ef064a499091b84f9f0144fbe4bf559eb973ed0aee7597eb08d7b1d7bf5cfa9adf36e0321955834473548c251b55cef93469aa086be08eecb39af61a8f05750ef6b3c0d2902175600f5c32da49328883d573d18ce6b54ad2f8e331ae1f9ed1f382ab1b673a1e81db1bcc0ec8e332f1aef8a18b577dc22de0899027df1d87cc3bf310cb7a4fd01b4d377860bc193bea84e6126b33d9abfd3b5e8b351b147626d36be853c6c52763a5a922b23ce7770277477f1ab43ed2911b307b57454df935bc15349163c95669ae1142df312344b1f9fe9d7489db19afb18ff28e595d010e6410cf99e7cdd18b65c6d703a0d49c57d3170469e9c001d9444d0a76ea3f8dfde58736e6b00be15f4a20487818a1acbcae9d2242173a432fed119768b66bc8c4e9bf4b45edb53a474cf7da6f496e1406c547b521fb56a1d7d4af26aeee07c93ad0ba9a4f3bc208a5eee002fa090163cc4e832981beff52a2295a994db9d9c349295a98a2783429491d389eb6dc83907b88f0d4284a8049dcdaa9ef5f564ee3abc7dcc37301290b9b4be33c2260b932f7c0a6d41e49fafad291ca3a3f75959c0ce0aca1990b1464bbbe859d19f031fe01e4745161fd08a4ef9b7d2aac3bf1462e7da521ecc969e21eac441d21d5f2b37d6c5aa1bfe7b168328297544c6dfd46bc2236f0df06beb725c3b1939ced10d4e589da032b3819c1a65f26570e250c2915d0783425b0f8b29c25a2d9405963a4054d6c0f44d59a56bb5a072c1f42f05d9bb2e7e9bc91aeffc0475434eca4adbb902273d0843785d087a3494e67a98758a3ffc5f05d0b515dad2c94de44879d3bee8bc4b76e5f089775f0b6ddf1e3653bc4669094d9f57c1436b85676f4a238327b1380ef2e9fc93478944ce58d4c89b1b3b35f1194d2cb1b2e0c3f02c76fc320773c8bd0315d6f7783ca2862d88a73c3cd8bd3a4093806b23648f0c69331e1c52a1ec6ea50c44840bff1b27e4385438ecd309510c21cd251ac89e2e0c97423149bbbbf80ea77f0019c25459d6aa851e3e18ef6bd180de8461887cae68126fef91d0991c128812be9f0fa8ca0e8106bcbfa0a23812855cd2f9b13819dc7a6caff354ba8dea0c99ecd427a47fdc8bfb18583ceca319aad03b1ce09b9076ed98ee5504031b483a50d0b521184b676f6bf8fe71628ef9b77b6d2c56379695799c5017c4102e0e2326ffce27c9f8264c829126e9a021b6a24e386b00289742d1a310666399456b451b861161b37c12faace3db833f33d6d794bcfb1bffe27d1253b239bf34fac4549bd3aa75bfd72ddd29b7768f81a56c31532e8d85f2ddb87c6cda3c03a018e1ba2211401afee076ca415501c51fcc85109ecbf3989cb500f5132e456197cd229b106d31f547a823d70946843d5f76214b6bef5c8a91c92c35dc140511b2a135980e3060657e025792bb00a58ce66c2e4efad7183d55b86f503d3300c0d4d93c7860074aa385cacac33411cd07f069d4909b82ef17e9ad7dba0be85287dfd5b864028559eb603835c114d621bff5154e469b30f742da0957a25d72e12e2e05e013b44d59fb83c42ed285b109d46d11d01119621d516d011de809714d3473affee32abb04b56f3ac5f9de38faa84b80302ccb84004044128a5629e2210a56ff730bd8f75c11e0dac6443db69be6efd076874479cf07a09d5e9a2d6e974d9b5adf2a38777fa1ab5b38ea323d31e6d3eabd4314f2c0f9be07e5af0a230b88be47d4da105e067545810a72b98a46b3585a59f6998f8a2cdf34a0d66adbf90719788e3d8323f4b74a39a03d37929ca625a8aa8d12345fb95e9bc956f4f84ac4b622bdd79ab80f2dade542c155ae8629981902ab8732617704eb2172d23f1bc1df5cb25b359766fc7bb2edf179bb04016cab12330958ab42da9eedf3bf4e2bcdaa1daa9c1ba54bb0f10fd032a97ee874c46c731916df52e1f1e6ee96546d82c575514f0d3defb6f5516b6636163eb078bf8ebcd6d9fe5d7c2665001f7bd5663d7ffa88b8f2020e2f4fdbcbf0c2162613e638769660fd64da98d165ab061c4dd681f3eca0734663bc856d13e334c6d733bcabfec3b62728688473de89ad3aa6e5d51371d00d732ada0c14b3445c9c76c58a912440373bfcbbfc7bee0c17123a8a2daf8369fee31e31c85f23e3456cee14e84e64a86f185e5198c9469e55344a8bda3de4863e38e9f6ad00a5d18cbafde6edc831f0c6dd2db61c9792956917d1e340237c91a8d37fded2412e329b8522449e63bdb9dfb4bdfba65acd926ff5947891d99a43465a5d5aacb3cb73f579312dba1050fb35e06f68d4d8e457d65289deb17eaf32205c4e7170e05bac38f054c426f8c6d56dbc0525dddb839c2cf68eac257b0a103c094b65689412774fd02fda71d8de98843862c243cf8fa3d2c226b6766907355b2bfb090540870f220b6af9b5c6ae0833eb255c626d0f21cf330fda55bf8fa03e545a5d7f61c773a6c54bf9cc1ad9556d7c028e2de2a4ebc7cea829090cbdf5340a2c8978a68705305136c9831ae42c59ec55ef118be6f19f06c52bd547808dbbe7cb36ad3fb730aa6a461d7a212430b4fe4eed9faa91eb4aea9c47e728f31d4bcbc8747bc53d21d0d0f965ae9b969db8acdaeb0334b6f859ed1348617c592feac4b0b8dba95faa179d7ec017446f974d6bdf828260ad0f8b496d78773b2a401a2a933bf8f2599b66a71bc0f150ee2dd34642fd8f1b5c87b83d99ef307541f24c6ac6c7e64925ef5400889c2876639850a4fb9ab1b75df64614f0611ecb171681b563b45429e5828d4f7b504a2b16f8e3e48513bc8e8b05fa4407d75becb6e5cdc2b81394e9f819a1aae7ddd0e2357a6da281b31da692dab4e84f8bdb7363cbd6998a1478deec57ad70f183316597c8c0fa76d7e92fe539f125e6b7102322ac2856bb9b9bfb71476c5cc507c66ea1a4cd82c13c9637bb6e5682ebc22f921847d0c28c6aba3d1565742668a76eb38de5071ebb074785e9672b1e731562dbef224092bd67ac2777f1824f73dc0b21769c964c2ff1c86f458a55d9813ae8aca91daf5e05f7c146e4a0599a76b4e3c62d90dd47c9572cd2297a11c3c89623736f5972a714ae9c33e2dbd383c2ef706389dd20f2a05f5b39c395112057b7f825a80612556ebde8972d0b754fb547f4027a7ebdeff44a932230bc8b4a739b7412a7dec89f7a3c4e6fc202ffa5de2e5c066a77d56b87ffd35349f1f6e07a38dd1b5f012ed61725fa56f173610a0e1fae612c1cbc6b70005ce0d6e7f639a5bcf7f13a406f5bd20e3028da89f526a1b96805576f6cb18e44ce2ef68c35356c1eb901062b930f7de311879cf8434468d21429dab01ec46a6367635e0571a61c5f606e5792e00def0206427e7cfce6b88cb35ce9d08098b4729af2294408cbaefa9e19aee587aaf2f161246d0197fbdeba64eb5598e14920128c2ef3c7efdc0b375c16af2e7a795d04a3e158f2850e0537ec2c0db59773e664735e000012413ea4d024ac97c77ae966c70090dc1667500da784cd14357a7067135be34673dd70c9cf51848ec4df1a1d04d14e3719f857a05ccf62afb51b6bc3d6a480191770e24833fc2199f61b69d8ca4d6190e1f0f7e9c7d1dc64e4134cc5befd8e7c1afd5313308b3db951ee871bba48660a933bd7da0b4e47b56ea541007df11f266f69475916f7469e6608a1714c854ad7f611c8f774a4a2f5decde2df977ee6dc2feda89cb7806d45d610187d0b3bfe7702af29985f17963ddab08394504869b0d07a78d9c4073150ca4822ab65dc2668b2c6ac5fc239ea13371aff8aea54967afbeb50a6434d42670013e38c3c69755545ae3197954d140faf815c5c801f1d5d131464fb95e83fe45f3487fbd0fc249f425a1f73934beffbd0095d46a416286300c30b5cce8b8c6fe96e737294fd799573f1efc7b71c67afa61fdd7f4a4d1e8aa5d271da6a3d8882f2bec9cf50d6f58226168be98d099ca158b5691cd24e6714565c52c2f248950598d1c3113f881c92f5c15382373e6c32b18705a52ff5cb39c886e93f6625a3fd35e2cac0c083af6d3445b12de0366a42cee915b178214198c14b5eaed94fa356686506f0fee36ea86d4c3b58c7681c8b0cf0ca2e08057a39ecc48413b45926fd5ad7c405c4ed4dbdcadb32882ece8ee69c9af4e123fc3026ee30ea0c7d1a637c95b7a34a484f33539af4d8f8e19e7e39f8c54d59f4864748570a8d7379f7ab870342c2032998a31d2d5eb6e42e06578db6478a74638f5c9a700d06d5fd3bfa2d70654b8b2ee2f8919278cc81500c013be9c04d18450a4efec50ab8627e975ccbd7d43dddee81d3c89d1f9d838d894c7fcb57885d617966533cecc1a0c4bffd80380e7e736abfd6f67b470cbd46936027462e61688d877de341b98e191af7d09f0445b0393fab2f8ad00efa13fff127e4eb5e718eb76b87dbe0405dbd162a776b7249ff233fc4dfeab6fbe29eecce9739d43236152f83b542385b815c47cce7c82b3c6fca26a504b33afea9cfb6fc5a8df86638ff95b4d134f2983c04ca86cfac3975be70e443428f569f95f0253191db3608ea03d669e3b1f5d298b5fd35f33c73e590919528faf405ca93cf937ca53c5616929c8a72d157c7d33a7179384b8642c34b97f6ea2e5e3b234c9734e50fa88d13d052b9b30821c46c174fc9d2b8ce4d123b58dec26b34a0f3832c998b2b700deed8d524f52852bebf9beeb283c4a0d6e07f2d3a9372ccdfa5203c24af90ecb16eef91d739ed5bd8e53f9876873403a83150fcc6d5c0e61df2be3b9f2a78bd8be030ad63947b62acff05d2c19c066bbe5b111036619a35eb4b75bcbbfd6b44c7223ec26b86846120bdce8d73245a730f2f356e9b1ff5523212eb02d00d4308b24236d48f50304b5cc2d7b8269cf2263c48edd5b7671482f056ba6d2223c0a99593c55a81ef88c465c62906f28f956e837ae2509000e0215db6adaad66d5f5bab82834b09ae274111b814c10032734e3ffd2d1a4979f01ea7d232545fc738004abe944c8047bbd7d9b882ebe3983795a281b587d9dfdf485d776019cb0842659469152bdfee0e1adb01042d379683c5309c757a65a64db989bd4b087374aafc6139ea680d88d06776f7dd6e0e01328ff603fcf7c81a588fb316e580ce746011c3b83c69deff1e5b4a9cbd22c4cc50ecc1c25d7658392ab1aab243b3b4e20171d73aea98d13444088ce21bd47dc77461ad9804bb3cc1181818032a8a0bc1f71456bea772b33213164b9b864f8d45107d82dfb0b71b1ddc80b0a418868833581e92b4a74c2ce68084cced24e1ba873d459e506801128150980e0853fa747e29190b6c3e197d7cfa0328648c1cf3ddd010b5ea5569581bf763eeb20784b7c7324b95c8a9d44f6d3c9b55ac252c5c67ebc7b8c59f55dc92fabae39573c1653d154c7c54be27a94d193b31bb4d4269419cefed68c7c835bdfddb6bb2348ab3491b48e8fa97317c87aebbfc9555fad4eafc090da1524e90e566b6eb502398e60d9b4fd74e7fdc32e1de8effa67f071daa94caf70fe09e79d31d1c390a02e3f3fd80db72db97f40949a648ca983421b57ba816b07ba46f7695c4746ae4af9f60d22a9b1712cb37f29b2e8892550e0e5517cdb5095330e1e01f29150691239a524d921ea74ccd8f7fb660005cfd5f94604a82610f81fc1262ab059911f75e59e4d4270b96f8e1ba8efc366ca9b04b307ad9cd140dc4fd9dbb41ad6e12ea9cc03b31f7cead860dbbf2dd2b2a8d6dc6e5247c79d5bec5f5bff494b6d65c92764b08fab1ab93fc29b109c364e6dcea8dc74bdbc0dc756710d9910093c5cb804e693ba659c32f314cfcb43b071a0eda53f05872982493ea3dd43af19f556ea31df47ca3623e13b4488daa4246ec6e8691394f1f24da6ab7a10a0a3b37f498ed64b5df1913244c573cb7be297bc4055b40119e573a18c5fe3f0701037da1ee15eb4ff65b1606583debf186b4dddf3b645e3d957b028b3ea805b9333413df45ceaa2222ffb3b7d9a20035734dc846129c945799147de181e5ba707fe070bd6f5a3166ebf2933ebfd294e8dc3b9726c939e228b783023938e176e7b83c2c2a9fa68f6eb7d00a5453970a955294284ff7c494d470966b7b5b3c9f46aafa3b1458ef6055bb62fc2bb58a04ea3061bc1f870cd50afab63377aaf50d57536d8bab10f29bc9eb60098276e8fbf47de44528b721a3baf243678d56ddfef67330118146836917333f6db9b6f6e9572edfa10fbca002d112544846018f65380053c4dabd3d69f3956d6bc0863b7f816b34fbd284a0eee07f991d7f8f08bc3ed61116e09a3f08e44b5ac02a7fa951ec9e389315cb43bc78295069e4adc6707a62fedd692fbce8d52226cc03d8708278b7fca25a91c9e354daa98997f9e09f7283571cb089bbd4429eb92f342e95ed95dabdf47d575c27e6fdb8d750d13c4584ab786ff86e031e9202f61be1bd714232e9fac0e0ab8e1b886007e94a3bc40c1e64caeb32c744cf00bc4a1b045dc93ded6217ba0cbb0c74f45f748604f14acb79b01dcd938a4adb65bfae0afc81941e2f02e5604a7150692cf70e496b3a645a5b707dff27182a489dabb2995622e9725760c1aa34054e397480ace3714d39e3c9b1864e6b769ae8104d62e1e601bd15a6427fe7310e08801932438f1a101f54d07f596b1a9ebf44659d37dfc3e870528bab1df2ca251c07c4400ea1b445fc7879a00e52fa675a9264314a9153c862971c3f956e2b5b03b4a92b451eb241f01e0ed24bfd2dec274a7420ac87105f66072e380f489b7ebe83a05076db0d0a2db589f60225e2273034c3f0f2731222c146ab406cc4bce83f338f93f39269586f6b6a52a96eed1918927cb4ed5cc70b15f95d70d56fe2b58927c385755877d98debc448625f4b8931b334b4c396cdd48bbdf0f71a4e10e116be07e6c97d0ed49f858cda1e36b84407df08ccbe117e7ffd969d890a746ce060ef9b45e3c797a96a2ff666044649ee718142649e3997fec104faf4cc722d0e3792601ecdb79b7b59596ed2bf6d8d2571e81e56384b9fb0f94964c7ab9cfb45abcf6ce0d23df0ef5d72617906594ae28a53a3ba4af8dedd5d253a203e632973dc72d542f446b7bef31efa65b3657c4ef0a49cdc47118a6653c884e23e333dfe728b73cdabc2b97d01422637554dd954d1a7c08bf343f636289365c773e0be0956a0cd2e438bae199eea8620545a46f01a191a20159abaaf0464d645333b2d65dec651281564936a78eda88ab8cfc28762cd47e0876cd886d6e53a951ff455ee46deb80eaa3783d915500ae539d5ed1765f166f953722ebc633ae64879859ce6a94709c8984766a71491e3eec6df0991b3b00aeda023c8ecd23b66b1371c0a8684d5a1962558eb0f5eb4c68874319a91ad14eef8f0cb6281d12f6e17fa11c17ebc2f648844fc297f10176c5af84caab679edd100ce31bbfac5b6b806e2b2293da94b8e78bd5ca90a0edf43d2f913852d28709aa1fd7240cfcf97727831c73e07a2b9bcab16f57edafcc57d0fd543ac5489ea39e3f06efcc18fb42bbdf281754be275e4d37a6ce5ccecff7fd62ba2ef671f826b1db296aac8634f7cf0e0c55eb76e5d9f5c8dcb8b6393cee032b4298b7407cdb8191554dac3588ee646a501eef32e97ff78746e311a47117bfdffa8c056c55a2c2e82db67f8439ef758e9126474e7942f13603dc02bf8cd2112d2410f4771449796307aa6aa1fb3ce7317901d17c69b9e31d772dbabed21bd8dac4879f5503818d7974398a1a03ef4c2724f9e658ab8463a9a92bf5082df50f52672d29a8291e15fb3e5ea91b3d68c56eaf9a6ac4f3efb9412fb8a5e0e266991ebaa1962835bf2d4e483dbdd38672d85cf0d3b25533a3541c570b86a884a4c70dc726d1489d188efa090bff228643ac7e095bb7462544e434a9841f8c528d8891482edee1805e4e43764002d56c874e372a7d9ff013dd02b438f15af7cfe3d78ecdfbec1cfbb9101f3a0419470230e9cf51e3ecdb9d020c267e40e53cc6dd4e4404920f9c0633ff2a2b278314221eb69c33fc3ee5a5aacd0c30146a023ae666b69d898d535eeb71956408387e2fe037880fae9ddccd2ebd120cef5c4702ee837da1636f263196ac5fe09b8aab6e0ede4c5d4be2f8d3e4c76db45c07d4312572ec301ca662edbaa164ed54d8da0e276b7b96cf616302186c4fc35171097975e373df3cb4271b4b7eddb0218a5c6e4efdbf7a29f0b7d67326f2707c141ac730854669c13cc07e3918fd65cf45543dd4f5411dd99d9d98451e49302b980813bd00376c5807b4c596b4b92ecfbfdf583efd8a1aec451a666e86ce0ba0b206c7c5b4504ec80373b1f2d34c7883e86d473813b641bbae8ff71f99cb2d800ff9f7319514544b57507019c19d00223f8f8b215acbedf17816c13a244a6bb4c0e916bfdc699e01c8ffa7473f828802c097a3cf62defc2c6ed829ecd2d6023acc247468ead5874bb737fb1913f606e8733ede62b73e1c303b6261eb0282bd5fe047b114ece279fff5538f585e598bc3a8b80a3370d5507c6daaa196b50269bb7cebc35429ad65675144f9819788ad0df732858230ba080ec64810c47b797c66d9f9a02974b5e1d5de3d9ed656106d872736e7e9c0edde89c2cc5015782eaa39b925ac43d7d412b77ae076da1f8e5913df826eefbbd20a50c8ee8c86aef16ba0d41b227acadce5fe497a3079f4f0a848cf975a7e81c8846ef1a91fd5b6f154e83c90ca667e5d6768ffca7c2569cbfb9f10257bba9da1dec74009007f9771b6174fd390a37e632d0ab9c4613ad10029fb6a65e90893974d4875cde21948b36fedeb818090bd77cb4a1b2d96f6b76886a8f03bd1b76bd43b35b7db296a3cd91900b318db97be61d8d53d01c1847acdaec7678f89ccd33c2ae4814c574100164b5ce30041ef84d146182636270184acbc36b9176f080819a56a2c47635179652f7c6fafa13755b2a8091af20514363c7588e8fe9e21b3cab96768b2bda73c5006cb0c1b1e0d9a35199e197afc66077e99402e2ff37dee2939c9f207933113c0eea5b22b25ac06a0323c3cb8d928277dffbb80c943c1a092c55d59ebe456b1448f285be3b7f9ad96f18c1f94f73f8629b8bb1f234c6e33e46e9e783afba20547ba2443ae0832845de20517c4e098d5a08e17b4a8e95387d507e7dbc29fdab9187068145932871cd2a05e021e60142dbbe567930ae2ca9d45c2d34637ab9479dbfafef0f30b371ed888d4672ae47aa9000e0cefe5b51241e7857e12d2bc6187c35a4baa9fa887d1b13373fea22a0c0680577bcaeed783e19bee19bda35099f231ed6c9511016a3558d9464f447d8d89b1b67358d654a193d3c5de04de18ae6acf710dd2bf044f97969e809f02e6548fcf3ac8a79f0ca3615610a3d7d1f8ad905b37571cdd40e5d0cce386820bdcdf71f70460a83217bc910afd7cb917325b98c9018b311ef34f5993625869b1fcf238a4932a91b72a03ead136e9b8e32996a1a4c5795d2a60c55da4bdbc78625dbe829ad2a52f518f02b9a50483c0bb34ac96adb80fb91296f56cc750d8e7f77e41c2c7f9fe5cbe2cd8dabb7f8235f825d4795284dce4862e1152e2e4cad1ed5511de8f4e924c292e8824a78fdabb3500c022a8e7991232acc235bf28a47b8bca88c1a0a743b70be042266622d35d07166719f99da77348039d8d67c3d58f8fa32ff73ff90d5f422f6c787f8cc2fde3328b37cc314daf9642472569dea7288309ddba9c5554e3092d4d002e3b7ce77273b4636cfdd44acd206e780ef62739227814295e6a256c69ea85326fba210bdc7687e595dd36045f7914afd3bb85c12c2f7730c55473d5ff470a266963a100816bc80a93f1f2ddca141fc2edb8c29011a06300e33919aa5a4f723f7a36af51624aa28b15349177f7bb4c40ff8c82d8eb4fe8b28c02696678b8127151d301fb543eda0a6eddd6ffcc740a2c9066f119ff1c77a3f7af4ce007a89cce1a48cca1c925d63776c0b4ae3036ab08abdeed27c4bd90abdd527db98f4f48401c4e3478847f781215a150dfe14645c0406a64995595aba96597f4b09f0310c116c96c554c779308017723b16b9a33552c60599c66ab31e6504ef285dc79d5294e55c85e28420cfd189e472b485d91329de2fd5b8dc1c808359182980c381fc91dcbfa003f7e442d68da27b7d9e2f85a457c069e6f79265893fb7276e9433bd9952f72718e7f4b5f108c5bed7b771fbb2ef77becfb9f9510d449734379e803302a1f0bfdca1c134a4aef5b2bc711c279a11751d9bc381f9f06581f2e9bb20b2ffca55c1ad000005baa9224e6f7e0a83e1ede8f581104c19b028b1cd7907bb755a701e196dbfcdc7a8f1d6c9a638d54cc821561c41ea3669293401e9dc81a6e59f2c50822f3751168be933379cf3fecc1258c216165dee29dd4b1853c4dd4744d2afcd9b45522fd86b2e2600628334b5ba61383bb4eb59568b0cfd1e7676fbe2fbf803117027383f65625294515d64be1b8878a435497e4d3a0b179bc1c66dbba1d159312ed899ccdd3e7bdb04eb03a659bd10132c773a168bb87d90803ebbfe34886d518456bcfe6edd6d03ba728cb2d272bed5e0984fe1ce0f06303e3797603b8352728e0c6e6a1d932747c5d5eb537fb3108b74f6b6ee2e0007474f032280e23563308c6a43cf09ca05305759ba629486ba108ef85120cb9f0f7d2428382279788785619f9fc730a1c50249dd68ebdc899bda233f48d1f1fe989f7e60a88595ffe7ff9d6472eee02d3fd771123b69c968d25ab28deb82696249ec06ce74670e046b47c8ae089a01301a1014507a3c8fc786be79f8e1a989296a969fc87e9091646d4eabd32d24a9433c939cf8cc0a235c94f95b3b0ed198195d0cb5501745ced1a6424d2ca3c0f9dd272e77501d95e9e8bc1433705e50ace5f7aea735c944f027e6b094e86852b657e4864e41724f4fc0692c0e3e7bd6353d107eb5a44afa511937d1c3186c6e103a093f1826549352187dbc5af73746d607a0b5bca5c253bdc2a6a03220924002424755ca8dc5bf5e8b92e0a4fd52a6829b6d5ad2e4ca99ea57183d5041c6af8e35d03690611f9aa423869ab8d2041ab4bbba3e4999cc0dee89834033334183c425365eb81e949ce9dafde3f106665882529da0365e772ad0386145a18f896d0ebd6cf8b025db35860695729d2dd31ba45ec9dbe6865cc14097d4a1f618ecf6e8d1f98a56fc837b40c541031495ae865327e16fcf6e2bdeeefce53415336387d77410f35d7ff74e5ae86133acf9b54da33dcb942fc5cf87611334ba8e6a2e779f52eb2cefa73e16e610f848cf32cff42c048d9d293900665b8651f121b7e731eb49d91dcd8ba63fdfbfde775c5d907ed2ec4de747ec0e09a72bedc04a911d158be1aee32167f6f12be164569d3efbaaf45f30e3379543778b95a621eed9a016b2a6d50f992442133db18d7da859525ecfde554ae5b0bab5aa76b2bc7c69d1e7c93b9e044eecbd0c7f8b403d9f9f23d59a5db6a007b9beca44e5534d4a7f8a8af70dda2c9dae9cb031ceef399179b1e878646b6b0651b5858e1735aa3e4877360cb0b451d9a5cc27fb1136cf905cd2063008cd10adfe3957a91cce1c6df284a1ca5c262cc884c8dad03cde6c4e568008fbc1c4e6570dc49a3c3e5cb4f4da7a89d540b51d81dfd22c6b54c50ab469a9f5fd9f19ed4ca77652c7ee7b75185af0134b88950d5cfd02f05f52989d20f326b9aa866b5052ed3fba17fef2b1fad957304ebf213887b561f1cd7d0cacb9d55d01eda6a434b1f55f1e73a5be225c6b17a4de68a5792a8e4ce3d5110124b7a68253fd09f38e738e7233c40ef7c93e6dbab18b9f35d52135da899310bd621b917b22d245ef5ed0066c1be10707a9c9e6644d07e65fe52e603da3f2da55a92ed318a9d611d1454f361518e6ad7e98201cb2dd4c832dd45a2c3e75e423c881a0cabc91a2006c46208b4bf0a619dfb39c049c400471b2663c1a8daaafa6438f26dcaf4d969571b4415b17a0ac3cba786710b7c77ef22a77defd1d195f095adaeafd6ae43db0d96dcff86c9b5d9c6a82b70ead0a4552d1f300b06fc498bf85434042fb99d499beb5e1d2a78bac3f6ff62f392acfbf3912f56784d41e372a345f1df6840988743bc94448c7bb33c747f522bc3985df3edc2ac57b5f7efa2d5f05cfcd18efb34765ca1f099b38c294d1a2c686ac6b9fec116cf0344e6b1949fa98f0389d1c36978962877ef84d305b1f334c9bf490c96cd82169f4245d54f5535f22ed74e3f9e3c0625ce3c0e48e88a73389a73978f8d8643bdf27bf0af397857f16bdfc6eaa02954a1b9ebdf66a4cb35b906e8d551241b2ec58ee4b3d94b0b8880fe008311f6ecad2eeced7ca34a38ff3304635cf35dd68e7009f1749c978ace261c84f1a7c461ed492261a3415cb30c92290caf51e46c59cfe4ab2974dcb42fc641a168251cd6d2dc2d2a9d90451dc767a955e7ae83c8b239a14a69f740d992a85a1c8aeda3dc916127a854e9898438d47829fc3498c2e321ed7b17e15551a8639005b61cc0c8a92e33bd9e265d1fccf0d814b8d33fcef4d69bb018656dd3d5522a222d729dba8e5f14979b0a0547b73defdf1c392c51b814ac68465697031ada5fe6d19f932cd6f487fd117e14e7aff4a6d0341eba7fc09208187a6dd31bebd49202b1ec24dae93dfb79f945b1bf693ccfffb3b595f8aa506694ad4f17846a105f250606473e1bffa356b24887289d9a50dec167169f126cd7f8836a48789eebc6a71a31148177c2f70d5343b3ce2794a35f6500e632d815cc0c5b414a9f1c245a575a8423429acd0b2206b05c8ba391e3aab30b58332d455c49bcb80e34d1b16a09d71751e77aac82b1922e7a3e0212f5ebe87a27ff168901a65c4a93880c5d91559d21a1119bfcec6895224612cfe972caf462264d59317862194d32664e35093c9c140ef3d189df56a263fb673d1e303392816eb73f89b3f01b1221e982a3fc31529ae3cee0a4d6a91699b987d1cc3cab769c716ed395d0ad0562b725ac6e0d5fa9a305ede1ce5e2b21992d3c71f56bad1ec1b89fca244dbd739aee8985758ca3e8216de887a5ba210ba567738ba905667b83b2e6af7278cb8d628680af80590cac728e3e007ef2ba07e331f4f9c5ae345da328e9559b317340bf3bb6b0538947326df88a8f6adff2e8da390cfa493634b1db95f004655e038a164d14fa17a7b2b095ae19b37546ca2a6ce3d0a77377451c85dc87477e008f9a05cd20ba79edbe64a8bc1ff8c9460c5b87bb2e5df681a10218c7662263c5e35176fd23e65a34a24aae235ff6d387797906538151440385f1c180155d9e3d139e8ca248fa815202036c6a2c4c65dad9d1b896f7bc475fcf7f2cc0038be68bd18a29da6f9f1ea7e8fa2ccf2e43b188da936f236630ec3c6fd08fb890d44eafce8e5c5c6d2b4bee7c24fe73e1c88b6ba3706d3cafbfb97b57e6b61175da49616b7625109e5a034999f595e3b26959baa2b1eee52d7570d98ad8369a7d1b999720122ac287e05289ac02da4ad480168b6f1146fda532bf94d2588e37d72506c88eb0f613f50e0a9e1e93c31ea00a6e615775750e8f9793817e17e9fe3aa7501822d69f758f705c0b4556c115e8654f5d86e6f0da43eb0a5eff0c6b18ba9dd10b9785265fc703511279dae7c2d9d23e02c452cf862a5d2293521266926ea79864cc5f7ba5c35f7131eaf69b186c0f640f32bfb96c48b20ffd6ac6fe451f1b0d92aa32ef59dfc51bd9455897c9f3feb1ca3bf7ecc35516501934e300fc5972aa663eb4498d55990cb8a2e34d3055f833f6cd5bd3e7eb68cb85d3d1a3989c813922205bcc39de46a7af0e7e156748ebb6c70c0e7cfb4c6b74496e609a4241a347659ac14c4bf972d70b38bc70b4d74b15232c50a4e48f4d389f757fd718f3d86ef45b9938af6320b3be870685f289da056b760f8a629911ecc2d5a05d13da3625dbf88686af8cc4334acd4ec2f37ea0b848076c5b3aa7e8da0c283da713d4f222d8d0a87d18096bde6efbc036e5274dd975ad63352a1a5eab7846c3b732874a581f074da3d01dfbee4e9a3a6242470e81c8af2f249aecef0df286bc46c874f6c3be4976ddbca071137c578948a3c8234a5dc4f7214486fefa85e0be919a37f360fd4247c77f7b276a5fa8ec4d90cc6e9c30f5ffb73c291dd4511024b44efa4b9919e80404730cfce5838d31b2ad675ce77b79800443cac522829d3377909aa195543c815f562c147b030a0aad19122e0ef10e219433ef44fd4820d39d9793aea26f58813e058f2d80dd3cbd95754e720bcf814b87b71f8e9c28144d4354f5316db9067130f414acbf98cbd8d4a0b07519a4336fb118f1c823e5af1fec19faed94868e0c1de028c59306744ab7a1c941e218f47f830d94ec5f9dce18f9f560110381ea5a5e24000df24ce4c2df7b149153373790d11eead11443c0a882a95d94e0f62d083a7b283e96c5700ff758dbdcfd874f92269bf04dcb7bf55eefd01993f7735450d6549174f0a9b267a6278e364430fd24d02c40187b718a834f305cee065b708a34a2609ab0eb90e856a8092301e0ad5aecb7b9f7ac71f119b83a15e0d6a576225e1b6984ab50ba36f3eafb16853f821249a6d5ac6a990670eab6f0bfc902dc216ac6c7b8fb791cefc9259ee62eb93244a00e794fa749dd85c834b206bc9a84db8492202aa29d3d1d5cc2484b058a955d3c69a074687bfbf52b41ecbc2eaf2ae727a6947c8a258d1088b69bacad3693051456262529fb8f5ecacb3f997770d3ebdf5439f289a347bd24ff48d02fbf72a8fb9f994eddcfc68cb6af26a092fb4cbe4f8c7ea1ef13bd5e6ab037737834a089759561373c89bf8874553526f4f42369c387bebf64804d062827cdd1e6220ce54b3f8384d42940659b293bef3a2b6067c8bedeafc9fc8ba00579c335fe63f450530292d086d3fae2521a93decd3ad51b269d0da0adf6816fb713601f555caadea50c05c8a15384153daa153ea21d096cde0b8143ec2897ed2bd6f274597489d1d159fd1c33cdee690f3d6f0c52ffc42c2f0181a08ff258fc8313914654f3da9136608e57032499c871d9043fc7e776e96c5ec12bbf890fa8692f3cadcc1ed58e339a91f53c3f477b78d849dc8c3a04bb37dd23f6a8d7ca5d665c6d79129a85c8784bb3fae89268800b8ebdea31deefd16e6a311a0f34f862aec38ef7f1043b61eb6ec490e848968bd6721d7373013197d6bb6e50b760727a7a561e2f0b8693db513991c94ffdaae61eaa15c44293b81e1f8470f4e5bead9659ce497e1a972f4bb3bd08ae91af02edd4c83714308d6ce0a92cb8b2ce6d798f4485238550547c5bb4d36563d988f0174052607264b07fa27f507450292da2bea59f2b174e7b1d8b53915c7ff8bc6429ccc6f3db0253026c9a86e7a4b1b45fa72c1b1448ff16c4bfa2563800a6f7baec3de5a8b0c4b8c69612ad99b97b3770cbfa52f7927b4efd251ed7d52d2ddd339627b82dc8718dace6519346812df46934da81e5c65af4a9e49e21f328085125d75bf0fad9844e3e2f5d4893ce50d9fcb6bbefc42e7a5e46839c94f41788535a90a5ecb57bd4bab0a78fc5e5ce0e2fcfc75d6cbcb2d2ccd52bed5777779c68277bdd4d099fdc0dd45cd838ad331378b62d271ba90db8239c9aa7dc1702ac19a7d821e80c8aa08afdf4beee1c45d5e2629eedde5760edcf8f7e43419ab1642a67c586f0e72ba92335cc730e47e61e1126ff13097afd8594ffa66004e73384f5adc59784a22a9deaf2cfaae7511c2d8dd55b5e8e621c491c0a3310986b7c780dc6f2fe53175418840d34ccaf7dddb6a14741ba5c0302f43a3cc86ac9979cac9b634c725a8776eb2d0601be20c9fbd71fff0f9847c01a8d624db80e050212b4a92274af2cbdedacdd6d3cf59494cacc9e99841791a9321f9a3977d9885da97b95c102df895c9f42a047e5e3e0c6bc1ebc201b28a1544535077b554733509841cc796337ce78cbcddb56e11204c1d2cb3a89109c68b6ecdd560168d6c8c6509ea589347c4cc6093c87c872f02cdbd3f4c0bd99ed83d28c7c1b742c34707f26fd233cbe75a12428c5c602eff844083de040674f9faf69d6f8fee1a08b5b92b59ff781d8cedf2e7fe7f18308289d24ff079992078e691a0f1a24a1b88f10c5818d7431f2b6e4380654f3e5241044f87347ca2b09f08b0b9536d451b0edb3b2ebfcddb948b610cf689eceee2279322d72320a6d432b44e0efe5b52a8c05b9b11a220fd94bdf8c7ce19bfc0194e837a4a2c02d4013c76855e4b9ca2ea604dd6ff3444aec67025e524967de5d5c5565225b3e85099e3cf4fe38a6093e3a5e8c1eb9563fc6e1e43f5c92df7522a61291d414cffba20ff1e69e211d8596c432e6ffa3084d66fba5e62ffedf295071501f04bdec772282e69f473c58ed1a2d6aae6d8a5212f026ae25443e63c4511527d03fc5c9adaf8918ca2c51481539f7b28350bd1cc5a0587dee172bc98b839696fea1b9ff63c3de28b07821352474086c19dee820265df38cc8c4467734bc063e62a198279646487388a27684e33877bad7f99c1ce2a22a8724a932b8add7bd35477f08c5df6d43f53f99b5427165d9422b9e362063ba7b029489771a14f94243b7bfc511999c893d401c3350343cc14e7ba2e3b0c074e53cddb40b853c4bf307a207ebb76e2bd33851088834632d68c0127fb2d2be3f8f4cc303251cf3a5717a7785d1499ada3ba6c9f9c646c4f36e9476e1648204a5c5fcea262aa88465d0663996ce5f6ed85d6cff9af8f46049750651f3add0d6aff2c10df9ff63f5bfa2db0647798c62518fab72a51e2903a9b2b127ee4243c8fb4bf16349e0f51c5c0e1021dc4c2d67cfc0ddcfd40e065259806f11685df62f49c4527d0ad636785614476649e14d52231a243fd266032a0293d961d97eee77efa7e96f7495777d3adb4963cdd96acd094f348e1f3157459f37167de96c080f51e62bc7242f153cb9e87ffc0e92ccab5c024836fb80c42333b32e6275e38bb87b0cc795b0068119af064e83d815f03ace28dac99d57efc67d2dee19d2368b67b39b7e683f5ea67679ae4f147e8234e57f13d115c78a4401dc681ed11b309bd9c6c509e6ee23af7906348a0e4443d1a1d69536b0d1c237bde8a3001f1d62f6e927a02a086b2079046d22066d8041ac0ed9e0f54a75cb4549a7263a91c146f7e860852c56fb5bc209f5d6a80ae6c9e24fa9aaccfa5fb3714c38a56e804f53fb83ecb1106521897a37d8ad6e692e8c038453c319af5dfad40db918e97a39676780e0c3435c838d9e7ecef28a87dd262589791cfafb13c56b00d4ca1c318c275105a944ad89a3d05293cda85ec54845b8fc4f4ee9eff7f5ce45249d1f28144215e6b2583032bfebe61a8d477c9e91b12b06724f603aab1de402cec2dfa8ab3d5e44507936ad10f9efe461fa3ea008eecf7ca881e09597e58816b4c67a538c32fb51182eb601e96481c4428de54b89ebe7b8266d7fd65fd2623853bf70e6e6b6cdc41645a7aad21c5f857846dcfa1821214af60b8267ad58564ed10ac741515a318954e4a3576bc25a8b842cc0a1f2a798fba104c5c71a705ac0390ae5b31c164581730293eb321a9a7f08bc83ff503a13b51e810910e26ac2b73741c19d3169d01bf783539eb75ff31f1ffc1aede28973883d2058545bcc62a9872e3a3e6a7b543095926535d6ca50deecca6b96c04bd7c2180c803c997090354e05535c7ff9a9805180c72d5d5822ff37978052e50dd3041017ae2ab9ae64cdfd521e7e2b03f0feca081f62623032563208a6b25dec1bbe5e78d10ed41620cf88d8d36616e7ce7fd4dcaba87e8dc08f1582065b5cad77bea19bae3f558de1f6a12a9662dd1448abe15d72ba6bf0c4af8fcfef9698967777ddf055644092cbe26f7b2daf949b534c47cb6617b77be8f43c1b7f954594d383104effbca57c9f1764339b8fe4dbb17a007bd334c004c2902c39eea7a6ddebcd27b9ca0f728c7eb0d18540545425564f2ffad4c9d0ac46a8a8f9d0792e8054dd7eaa3f84c5641e976f8785f1e3f38b3f9c7a1b8a9246721ea7a0acfe5617fc14f7b32c6013621eb33f42dffa64f932b0219493b07f2486fad1c3ea62703d9c3775e72c6886374f53fbd2c634773d7bec669ad7d15a02a19917d053c971f4e135db879a1668ffd96a8adfb352a3d2d1edae633100a30cdcf1cec281cb00012441f61b4ed2ce6cb171a0433f01d9b39491eceaa35bd40e6de85a9d4af09ad074ba1e3f7d54d658aa85fafef0a0a4def6a0592cfb24f6c1b27c665833ff458bc53436fc9bd1e13516f9008af511f078dc854a98a1e868be5e0cfd48957cc7b5374716c994990ba9c895cd7a0feaa05ccdf44a83f2de7a5e61104632c524bccafbcfd3431040797576ebbaa966acc2f767f5d33e69458a4df5fc0a849538a142e22ce7a0b3da33238a6a9ee2506b82fea12df8e982776d72f6a98a52cc577ec1fd94e1a67ef4ed60af74be693081abf22705ae4504b7342b1d863c6dd242494723da69ef00908745f472832f0ff81e2baa8d524cc2efad0cc33f7cafb1f5c4d15155b353465497f6ccc1ef976dab084712bdd12b62d2638be08805476ac7d10b9f1c1a01da7a6f99fc01b77c5db9a75f26a600f09c1d69fd2fcdfd74db5342b2afa6a0edd3191ce08a9d6d92791247cf9ad63858fc080658ddc3a38366aecb59621d26c033055441867027df7733e50354787547164f6b3d1d48227251f943e4ec6bed1ff2d0e529f9425ce3dd413daaab28607ef55a48b14860af9c01a149dcf7b1108aef091aefe7de2654b7c02759f75730c867afc87e91d301f0884b888b429500cf44402338af78edfa918fabc5a06d88820a0de830560184947b2c7ad5c92f7764aa2d999d3f83aea7bfc4a59693e087eca15d8811606dd6e66b86afbdd312f34a36a9a272addc701be5ce98d1bebfd7934ccdf3defd7a1c98f031730ca4d064e752bd521a2451b9c00c35ea31274f11b745f589cd877f7e3d1f81cd554d0d281dc5ccfe692bc965e7805cce5b32b06877726fa5f2d119ab94b88098a8a3c9adb24cf91c6b49782ac5e9d781bde593d581a67612862983e4fffbf151f15b3119c647ab7293f6e663b9f3ea317e1cd2f9f30528d5beb0d7697bb7692f3d013620a868d359fe9ee71873e8d1cfe9ee2427dc4ebcc8a03ec85efa3a4c16bbbf0512e715c9ef034b8d61a6786a360de533acceed88feb02a595bed989ac121703bfaa8dd7942d0e927bb977136df77fd32797e07e470c013741e2c0f4d5c5d2fb6d93fc317a2a6ec0195d7d8ae92b88667bb6ab6e0818079a592ad4662a2b8b14b169c08e119510e8bd950b26daf0443deaded0083415240935fe6ab6786c73e3671a30c2239513599cdf4d3bf2786b1f3b2f809d473ef1a6e83380a8cd93f2ed740dd1893bb7e03c40363287ad91203f72a5f370d9901e73e49bf17c6a8ae3c2fc0a60c96eaf56243702ac696323adbf7ee19fb26f6383ab81aa63ca85214a7cc64543a8bc6b11634e2041298cd604f845e35e6698a1771da459d238d02fcb993fea79680b5d7e96665f7093b2bcfbd8387d92f2e4b827036b829674a8a599be817ccb322ac13f10cce231821fa502e085d4a2a7ee570a76c7773ccf6c64cc44f457bb400914113ead1ef0e2c7ad8864d4224ce84eeb6bb18d44cf1640c652e59b52aa6ddc0f03d47ecefd6fd5316d535a55cbe470644a019c88d7a5c6ea9ae5a655a3ddffa969207f35548fd1091934f8e58077be36e1a122c56f444bfcfdfc6fd3fbbc09a7075df0aa71bc7c1e7a5db7515ea875e162f309c4e1f587ecf1cd53a1fbd09b422d273ea4b3abe3bf13983317e20fcd4a1a50aea0d2b256faf55b11f9e62e31ec6423c716676ad20fee608f0827a09e08eac7c9f9f65e7e798930b5a27cf1d291868c017ef3847427354720ec30573a2f4b5ea296f205afbfce9688f3484e2f677ce27d7637e88fe4d73ad55ab1df04420809f8c760bc1a940c23a772c20b4e18e8421741a87d30e1947fe7b51c4de8acdd1744f679e0cac6a19a9c14188cde4eee9737fb683570a80087052c72195420ec505019be0f3efe9dd95650e0ef1a94aa52de84aa9747daf09bdac5df7e776d7e8513c48f650f863c8eecdefa65f968ef4405fd0c3bc2c16eb6bd29ee29bcc42a115f130a9fb33eb46f8e54815a50539201dc9ecc02f53577aabf6ce479faad759ada3dc971502450a9772ad327d519efe2a1e0896a7b58d4d5893d27cc316f2e91a932217bfa3e2a0c7b108385cfe230cd620ac73f748a9dbe215814c1a46b4739e72a72b1665514cc8d134c944e429704501b700feff91bf342347ca46693691a5eed69c8e21a1f90d7e061e6b2b37267a15d96dd8d1f89998bea45619962e6b040aa234b8eaf0726ebed92c0c733ec06369af67d69a44629bde3ce5909a94a20f8408ce609c193283fe7e0f8b60666cd3fccf5ff65a5f5f3a8799e529e9b30a4b2125496c85c67cf95b7cb0e63c9086fe0d89cf9d1c6105a9fcfcc28f45c1ed2b582e1850c5e0a5609b8db22cec58708d45a330aa2bb975bd5e3a0995c6669b5b05ec16c0fb200ee774223d56bf3b73de65525d5088334fd1a34ce9fd866134a1619bc4e4a2d6d59ec28d88e03386cd968ef72d3278801ee8c2a11cd4cc7d3bda63256d9753956513007d4133abe9e1a3f2e96fa5d086670ba283a20f39e204da6ef9b89f4aa65640e78e7faff055948d4e22e7f045a6ea02d2be5a5e7eacbf1f9f692e971a506bae06894574c4a52c64cb72aac46aad20fcc4b3e91bdb35fb2e8d9b0abab28c5cc06512bb515433533e46b09ed194f0f91824c1ef4b7bed65d6b4a9deccaa9491ef58f97f1d0e86668dcd6d722cf25f3134e9f893f8ab4e8bd6fd6c2c840e789553b0f43e7fb5b0e8aa76c13945d044dbff02c46d675a36a8dd61d27ef3b4b418cff7faf42e04995bbd4036025010f0acd3f5cf735e143ea5e0ff19f5116be0783a401dc5c1151f5da28b677dc4caf53873c684f0e2d24a6654d6522dd286e5d6d5b93d87af88c5d2fd421c9b45b340e2922b9807cd3f2a3e560eacfe3fe398a100167acac051bf621532f9db8b1535d49b2a9b00f9f9f7b15fd2ffb162413972f8bc601d82ba3cc507f7a46c50be23721975818ce0381b44e4d8e00c6770183cae4c6207825f0bdd852baf12df952ba6983b4a67bb7b63e54194f4d108781d2251129103c2d60734edc862326bbb4b23bd7ad0c814fdcb67639cfcc5566e09e0496bbbe07c3c7960e0c56b7b9a60646549ac88ac60704d971f80ae8bd2d7918ed34827540f7252e29e976d38f3296bcf6c3234a8964b05ab4af8787d335dc03806a36921f1506a87c754ee9582bc0f88718ec91ddc75f1cd29a8b7210e0a8e7efacc214fbd6d740b0de7ae91b11ce02f9f136fc75de32ce0d89eddb4cdbaa20af5ec43569de5c913d6689459f65361c23b3e2fa9f68cf44c8c8605d5961a92d9a9e5b625bef48e24d47508f1bc161050ba5c99c031f827d13f191f1bd1183f3771ee21c3ecb99d8e0502d195019b78a44488f446046788f4a372be163f478e76cd4bd66f77d0bd7a4155465dc205fc213664c30c863c89df25cd0be4fb308c8cb40a78e6ce7237240786f124d85c18adfdd4fd283c51de1ec43abeb742a5c67a034ae3c0143ee3a87db6e27ef8fe4b7146535256dc7d7b83ee30bd80b66870dda17390637756ff1b15fbe9e3a180e6c6369cfba4764e8c553d3e230aa33f4f3dc63bceb767b93be7bbe3dca1adf23444a9812d0b11f98b0ece3349e68cac14986b685a919c57c9522937e088434d7f194b3984f632ed26feae287b069c95f884bc9197a717cbd10624c459cb1c46ccea5c28f5d659f4969c9ed75a0da16add08258d49d40549412cac48d830c8edb024af274dc18d04dd179d277fc962429d89709ef111bf4bfed67e66fda3e114a009b5d6f77467323bdb79ec0b5ec5a7edd0916c614a9bacbb5e52303228308f75af1afa54bbb4777af171d41b658dc8db98ed053af2e3f14fbda0c1ca4ab2ec563e451f754b985005ff212501b7d6d4ebf6311661618cd4e492ba5a3f0707c3c875f8afbf844d9db0c506201cfb70f4ae6b087cc7fdbc88d65608017749eb794e99f306cf6caba9b81ac70c5e5b924dd8fc2b73eb66037287d7a95640c5943bcc51c701c1ca74ea4675cbad3a715cdbba5a7786a30a878baeeecb9319c12da8c5da47c2fe3f5f4f2d12f816b7efdb6bf0324cb9952cadadb027eafac1ca26d62fedacc4058c1cf12d4043e35949ed483e18684033da29bdf8708a9d12c6d1a04fc4a9a676fe0c87cea8939d53af450b69d7f2348c9ca7cf115e68cc2dc12b2f911c29e37c803299ec87cce7adfcb92016cbf276d0bd0374762738d330e94ef25e41a8b138949b84fd7897873e494d7e13fd053d929b6ae27a966ec33ffde079f69fe44dc1d32a22f5d686707d90a8c8f5237d83cdab7bcc514a6418a4b923b7d65e1d1b1dd915ca746aa0b53eec8f7f8ee528451f84e105947b9bd08253a939b98656eb80be082adcdd0f4a8dea3fcb63fab2e12bd8a468eb72a5b0942003d0bc179a37c06ceb242f5a379ddac2a54a9f1c0a9fe0b9f7616207962ce45b7c631adf05c8ebf7622ee7f70950e9a1990a43387f5c36525ac5f7e96b0381a1e84c6e199154e0637a9d89da44320b011b7fa0a443a2598c38408bf31513a828abed167d66f92a3e96129630400f44a2bc204dfe62a6cc28a71d7835f118593fa4c31ddce12f915e5d52aea095e49f62c7adb878f1de18e71104268c01a8d889a1e4a50a1c0a837d1c8bc62161d5a8e09fa3142edb83a292c79d2778b8068a175d00eb869ff08b6b39c13695a87b3dd29c73907f67ac2486242561b12a7630418ece9dff54dcb6069eb11bf5c99d4b6cf59ab7082f0cf56a0d84ea591c1308fc57ea47063c49efc46d5f8b6d58e6789904b2cadc0219bcb8a19df77a72a3059c26dc243bccd0bc4d63fe8ff0bc5577809c3341a74fcabc52551913676d94a3e25d3c52d04f5dc4cad08737c6a1d802bfb47e01da561ad7556d1b32bc4505e23f96a6d6f8b57dacca14852a8f9ba9cbb233d1675b8dbfccef9a431bc0a0797967ae4e79554b11f83e9ea9c51ced1f6c0d4110501893b8ef9a259c3d569f69aca58f9646b0129901ae3709200ba5de29a2e3449727a72b4fe61a6946ac5b514a5ca896fe0d586e6cde3f3380052823722129feca1abd2aa5f78436358c6284c7139aca784c10f53c0acf57cc107d9f311480343c0f0205f0e2cb0f67cc8ab5ccdb960abf0ca1adac31b58e4c818a83049a27a0824a1f79786b36b355fdc2dad376a1cbfa4aca3388d669af20e6babaa895b6a551f4d9605edba418d59e665772e6bc869e5df67c3674ecbf06d7b793f96201d1a497c25ba891982c51f27e01f5fd11e9bf4e5a370f08baa522080604ed71b7047de3e6c6494e07d557399f2201db79c8c4f3df77889891b4f7e3b618a9efc6f5105d048ddc32057f5329156d7a597f7c9c6ef3064dc0f0435e2bb6ca7de5efaac9c6f94871d76d994da12b7aa973017510b0b25405d0aecdc7996ab8fd7968f7219937da2edebc64b20431d4f1fd84d0c75b7e064222af604a497bd3ec550e1233b2978cc5b50aae87aebd35998120b1b7caca6485d13871e401ff44f9a8da40d2faa84422a21f6623698ae9034d355db6965de65a789985e2bc8b540b44d68f0bed90bf0324f40e577f90ea0af065aa2d3bca83b04b8c3883df5fc74c3a3c4bf3be96218cb0216e37d0365300d557496cfad016f207b883b3243fd2d239b133c92ec91a5b18fb206925083c703b7daa11a4cca2cd5d6597088c178332d9786f28aa753a9804088b451e35e77232d444eadce5a43acab4e907bdc07f511d0a26894917702b37974da5e0fbce16177ea985347b58fb9a56071d1a8282bd4a80c3cbbae64c74fcf9b49cdb3150f206a9aded8b91bd6b26c86271d366af358c344b06b160cbf21187bea9f59cc51a2b1734399b0d91ea0418624078b51ec188673b611f3350dc5a663575b707a5a726ee92eabfdfd992eb1cc68988647f95d35a66a6d93cd33240f572bc89a2f2c3ab88ea422bed8f6d4eeeb7eb7779c7dfff8e33266e18f40004ea1f8cbff26b43f29c5cc565ede7a9f25a918a1124adcab84380f8f786a06aef14c87c1a7df13049b6322c721691866ddda128e70e6dfe51cd66420e567202e8939a11670c9b63e2d96222f4f1883f96a92f36831670c808e5f01f2c124b519eb0ea78c49ba6dd50f4fe3768fb5720008bbbcb9d82c1fef09501d64837e46666819203c99f79edbaa8d6bb20b9ab12c506f6b6bcba3ce26915f16d0a70803598d43c84d4864ad8435feaaf88cadcb0aa71d43f2644ad5dc445f6184fd4aff7dafbaf173532e49cda7c7474a8631a5c6b10e5480da264cde33e3f54c62455acc1cc990d71f949d1003e96dbf520af00fb36bdb46093213ace05a4a164715cca4987e4328e5af78aafb2222937b2b1344f938acfcc46aca2d9876a9dd920bc2601c964146ab18524659e1957f3a5fd406fb01533367e237b015a68051e80c0b254766889273b0828d77a309712faaaa5e8e2279a2a2b1a47035b10d199e194e6f53cf0cd4534be5fa0724cb1d14693695869244a284c35b7c5be47a2334541f1f27d4b68175579781277f335b988a7539694d4391cd3d59f68ae9de186f00b5d58de9527109758d63d603abd1b95a5d703f4472e1741bee88cb08865bc0a735e36e48147f18811838aaa3ba4b088b8c45f99be7d30e398bbe830fd584c2e69c33ceddab19e105ea15c8fea7b4c43a2b3b31184125fb5bfb30fb2fb60cf0a68453ebcd525639c03233d1294e6254822d2e184832380e0c80ad6add705cede2a2d9ad03fe8ac85f863111524d1f7b9d719baca83605c911b713776f9d077359270719f7befd9bd6a8a3bb976387fc8db2af48ce94f61c00fc06a0993702936075634bc4d6290d2d877cca4b9ce03f09b8d8464dddfe4dd92f449bfd9e3bb1f5bd1a05756a684e0082cab506ef3c3c1c16a8ed12ea76465e968c7281af18043848cd7c31964b683328dd9ddb8370eff718644daede24cd14822b1fd1e2bb7917f23b16ee529f531a43c02e62a8fa18ff46a02435b439d2165a2e2078cd3c826d550183cfc3cdaa54f5e60e7c8a849997d0943f2781faf8a4760a016cfca6fb18eff9ea5d085dc82ffe2f2238d13be9c9729bcaf569a695d0ca302507faca614c10241a0d409d267002d1a1d351c696d584ce11bd613a7b5fde35e2096e7680de20605c69bd18d79ce891a45f0fa88cf856f8e5959f47da27f407501e135d7c0075716a12609de4a63dc3398ce4b241304424a92b7df276371ce81ffaf6c0058d1d82a69d29537a45aab9d97f74d1825691afa642e28f0c50d49e50de3e9e4aa3d8155fae111680fac44e4ad991fe8c43b3c933752af6b8ba3358aef61f66e229303e9ba0feea663fc099b41f9cb0418b286814025dc824c245580a67daf73ad9c0d973c1228f32d94631b08c6ea787f64b4f5afbd23b8a64a778ba234d0fbe0a334ab38e5488d044ba751a518857e4948d07792a3af82c354327615caeb7199a22784ab8b0889ded54fe35a2ad011b44525e9a8f6acdc422ab5027f60b10d69e8a830d80809bc577988a68c5f02f4267e3aea1e1b713efd4a9c7bfa92729f62f2bdb20e726a5433a687eb3aa219b7b9a0016cbd95ce653a9a83a91a227067ee911a7a7780dfd5bea42314df193e63eed4f2c0224aa8abf0f3e3d989dc8069e9d969230b72076aae150e808c7376b411edb0d8e29a61b13dc844c93a0499a861430ac6adc31f26174a8a48c97029c7f974417c1ab0f7e9718c8510f14fb3cc2982831cdb0acba84fe5b24a4faa3888656473d9810be38ee74ccf638f43fdd922d2e770bf742a9948c20734339ad691e252d6ff7f59fd7b54a7cba75948553a70b15b5e08511025a3e71b2857fc20166fce586164818012f9dbc3960b2ede9906d63615955b698c3a5b195cb0572488a2960245a35032fd245af19958f6e8d9d2fedba32456e52e82ca58d81df8062b3578bc6b56bfd891d0e3cc8cc9a2956406cc8cc0da6b9d2be5072e4a4283dcd9afad0b0c0c76a0b6af704a16f291b572f7e5d1dbac4b4e3f8331b6887cc5c0c73a04f9872707de990ee4b8b2fd11d358144cb94f8f7b2ddf22a1f11f76ae0fa6c13499a5be0cf2836e6d806b23c5b4c9377a328a1d43f34f1554adf49526c90ba2afa1136d7073df811b26b1e04f35e7fd5dcd55a0c8841ac82134cf08497f8800fcff99e8f9ac33c1b6d0b902fd41059c66471ab9257e6e77e0ba0d8f501f986361798b039a6bfd84e899cb838a11f62489d0cf4792acbba6582345319074e0e94d1d93350236fd687041b373e7130f60a24e42ae16b1e5728361e85ca53747f74a0b5c04dc3f54ae6ab378c98452149ce8ed436b8a2abb161c4aebbce71887527f01647b60cb30170139e68d563b3ab7db07ee4b7d18e1356829745072179405126ea6f1081d6b00bedeb4daa47dff244ca7d25357d33278f74e5031187d9d15c8ddac9f49b55e22f23ca3c5f6b4f0b83faa925d89a20ad6ebb791345a5f16129362b75f09908baeabf5f1e5b7e4ac9bf460872af7da15bd9ef331d994c56816c05f7b2aba83c3608adfead3f85a2c24bb0aea148d4e719950d494f3c53ca9ebad7faa7b52ca0facc8b8c7dbf60c458737f56f75539a41cdf130e00d80fd05af157007bb1d77c76eca73584966fa703dac55b090b4bfedffec533027df1df4e11082b66da6d7aa18c2963c9765c49963b7d26a49d0295e4bf38cd0a9e256d470eced0a88bffed056bc72776b61d1c9243d6a94c2b1f80fac0035b4d20b2b4cf37d7606b822967e02510c04c851ff597a3eac747849c55bfe8120fb0f70e031fa520985aac0ba700a30335cc174ad68ecd18fdb4943460bda57b97b4d065548cde02bbff13256a081f20589e8c95efada3362a778c341595d062930fdfb41665f761d33d4beaba4a4fff0f2a1c15c9dd961eb7183b2c0b61bd5647daa30d0e4a9a18e0ef3672d4ff8fa0fc5c4a24b95d3e2a0177c709e50e6da08b10d2c3c60b18c0d46d3e300e78afd73913bddac7082ce3c2ba0a586a9831d03718d12a8c57cc698295da7782defe8f8a664305748c9bd268954e5848b132c62ae31423f3fcad9a5e77435e1d2dc35cfcbf45d4c81609317f1fab028ae5135dfd2e46f3ecf4c46e1cee0877d1bfc92f2f429ed6f26e565d227325982fa18d825ac7658781c04f77c786f9bb7fba7e5b275ba6f840e87f8051fc5b25f1d5c4d9834d32de094c8cd4c7492a7caa2e60611a7bd1704ac4e4ec45c34df12a4ef4338c8e49c1407041140cbacb10ccd61db264830fc83930acdd19a07a6713d0bc5225b7ad7ebc704858c617325e451a40ad2aa8f114a685c52948102a2c5c221fbc2b68531d5dd9263f28fb3119200ccfd300e252561055e2d68cb1b77ca970eef39fb1bb92a55e3d4f692cb40be9de1ada5a6564577e3f842bb2f5a9035d07d80bf3bd65510298acb55778418397af61dbe5819933c594d3bd4135ff9236501aff59a06cbd5022e071f7caee1998084cbb9ea66a026b0fae1b6bc8146f8f368e0f99f917d54807b404b14c5a43cd0981297858ea7aa64c46f5218de1b08ae031b92c8800260d33b63ebf1cd16663eebecd80f4067776ea7cead40fce183a748587a9e1cdf1be40b842a7fdbe6de3390ee0e78e6c132477d80efa342790e5fbcca0add75c2124b682038b00f5bcb91415d344f697d958036959c47b665ab9a89e16f30683581e4609125695d8af1e27bf96a3b7e5d5f9213f6c0eeb2d37fcc641a27aef038dd34167cad606e53417744b32ebc0babf5f356ed194f7aca00e4d9a0a37c541221fac6207ec2e0d0f388120b805235650eb51f0ff2fd22554b08de84d2e1cd8edafd8c8bdab89ee0b140f5e657ddae0188be41defbc0c360bc9a187a5eed558283433d79731f927b8b406a405918cffff7d821943121f3ba312c0d2d3ee965dc8219de6ba4bd02c6f389a09da47a7381ca0014395b450cc5e08f2ef3edc0c032ae34819242be0ab58c97271ef949ae1bf5bd1f9ab201c1295a888c26b8b483d661d9ac98a56a1590e16c7edfd8a268ddac0d22d77163be7aeb7289fb553ceb71b3baba31adc11138ed37a382db0e4fe181c7797c2395754b0802b12675e41af8453bcd82732e6f31562d5e60a5cc91432da334d87b321867bffc7f069e02f79f2b51f77b8030dcf8d24b521330647d391b836ffed88144a3df5e4af2d903d3f2d47288e0283c88c382d7a1b546ee582ed8c4b6d8688b8a2423a7faaebb556648f3a1cf7aa43ccc8937094a953c69143220f748b7fef7bff9749045b2ebc51c22e3808ac83b61df31caf8810264acbda91a784f2b1d81ba0a00e0b3df942c8c72eb8570990d62c22075615bfdfb38e8c4fa81af3631735a07b98b74784b151acc466ecb3d4b64a4f3a26df5b95d39f67d3a81635fdf8dcf6722bb9d5ebd348d9cf292c3f1fba512f854903bad9fa070f6f1dc6a99afb244949a172a476afeef4730b554b8cd6c1f51b70954526cad5962da06ca917435fdd84ef42eda92e06b066e1f17807a8f533ac96fd4d63ad958d4e3ae8b4dbf63a87ff4130c851eb98ae52ca5f2d25d49c9b608706412422382554d8daeb18ed6d21d213edc68c31681ba9de892bd0f07954f1ccddb469b01f30779e1bc1217cd03670882dc22b246157a34f450d90cab72c4a075bebafc9b569b06765c45476afc770b1da8473e433316dfc5c3fb684a25a2b49ed71fea9408576d012208bc13408ac5b08561bcc926b73cdaffc0ee99b61601cf6a6201252f25addc596bc5115a40e14f9da7807f82cf865a37e37e36efe50b4053bd3045b6caebb14b350e941f72223754f0cc083b8da675f5acdb1735e56f7bec8acf5f5e3db71bdf520a8e14c3c0199b98be94b161a9e6504d5e944c862158632ead31a3921bff5628a0502cad90d9ebf17da7a64813cbe9ebc915760ce36c22f40358ffb44946bdc7317e393c19ef54055a51905fafe817ac6e933ee5b804ac764e4fefaec9d34c972785dc3915350d2ddb2675b76b36d277f7adc73f6728596ce69a9d16f2fbb42d876671c24690d833caeef47f44077962fecfb91410072cbf9e1ec3ee62f02304eff0109c2751257c38734178ab938003b557d866bd77552f38231fe755ba5abc57fa756d336d3f3ecd615c21a6a95045fa54bee552a3d2561977e9f69c8e4c4e3a5d2c7a32fdd6d2e2015363e319ed2123578dd85db62e20ef5a2250be2342cfce65cf747c3e0bfbbb15750a13468204c060e6c5a84aabe7377420b49213e4bb79a13154d3b8fcb16c1852908694bd7b6feb12b4f64491d62199a8a414a31bacd4be3773264ef5d2b3b9184d222b1e3723ec518441d148f9ed20d5e38ddbd50859d4a1ec03f4482cacd67f4b6d0c5f95a6207b39711ecc3be9193d1dda413b38bbcbf6d05b0fae2790958f178ddf36e7c04136b05d302a32db6d15b485095c07a7b7f61794a404ad7b9fb3eb3469118ce159eb4d3a321a6ca4c966a256df0b3f7d4e2e79389cd79cbf83b16cbb92cccb31b713c87f0d72418937664831fb31d636e6fcf1e495818bea9395f171eff3d6a629301a7c2e5475d29bd3baec778e9a1890e0707cc8571b64ba1b0a6a868a4a4e98057ca3f43e14760301c392e2c12ba65214fcb8fc2c588ffeacbd41e62428c2cef40ac24ae6f144395eca282e11265db1459c1166b04317ee1b1f528c65d68d6d1b1968c9dee9abb7d2f80061143b69bdfb5352284028f4b02e991a480068356406bc9ab1744f79a0f766053f93581db7896ef974674f5a0047c63cd8437b903c844602ca9c12207bd2d39a68efe64ba24c95d976a4e971a46ee1fa7a3a00e79ecfb39a46aa811c51faaed2e34f96aba29fc037d7ab59bd9d562e5d90cb90dcf9a0f82b69ea7a1e8ca88c5d33978bee23f125fd518822fb2a99061f55e60d1635e228ebc791f25cd2ec95ea8e1c6a34c4de267c9fe06d1a0b55479c40f65869cdf687bb36bd17983bae2d958648cd8967ab2d625dce5399ce59f3870e1bafc23db9e8017371018e0df58449092c7efa57332292b006c4efc685f4a4fb5dd95900ba25817931d98d677937de80b2a9c40fb2a7cae3bb434c0625c6991e915cee10ff4d29a74c1051b74f66ea51fde240302af246c5d87d90969f94c57456a52dff8e1cfb5a1aaf26dd7ef986fe1a6e8e51d0a60d8ec8e1012c3a2b83e023b5b8f8d331ccecb9e728e343e98d14727784055cfe7e6be2d69dc4e9d9694ddf6ce9ff2323d671a2c0b3ec6ff12fd547845ee4589b47c8b46f7108ebd0b40b27aecccc85ec914df0a09a029d0b13c3c10038f25ac1345887009c4e57b8749a12c16368af26e0f0815efb22fb5678cb4fdf49c36a862fab995e42a61e9ff5ce5b2a3c019cd264f2175f4358d2c8feb6e3da951410e57c9783fdb06726dcdccb4465e377080504b52c18d478a0861524b6d8c54c23817565ee97c0e6e0ad8aa7dd3769533ef01b6717ebb24276f31914eff6ccf239bfbe0b75987f00446fa985e235fe87d5b91c7e864a4ecd11ca81627858c21a5c8b1c9cb27a4c26aea35db3ad528712529683720e1633609685a75bb68ab6d6b2ad6dca18bb0d5c29d76bc0e99ad17fbb7dd2fdb62621b498066140b7f5c5e840012efbd7c9a9a22926172c218796b0060ef7bcdda77de2ae6061a673283740301f756c1b48ea94cd0e9d962c8f4d8af95172ca0b48f123df44bf6bf794962c3f7dc10d46e893453774d96a9123aa4d3fd0945bd210d6619deea7799f3ba96cb1372c4a68ebc17aad527c70230650d28688df7a9ee695a7f6c4b7943d7c32dced9a1d054faa4b2072ef509c92c1dd5220cf40374efa60b556724efaad3d3ed06cb99fe46cc495921bb2208ca0d9be1a68332c850fcedb7f798abbf5288715c59658de341895832dc0aec810be74fa9498f64450fe1447d619d8cf919f90f0184cf244136c869935c022afcf3639d6c6dc8531a80250cb3fe5db69387ce0f1924736f2558ad8c2b95e0d05f759a60797cb9dc7a96b7cbf1542a8e9d546707ab85376ff936d7b39c281137183deb461f2951b4a891cc9a82fcea94afae3af35b5835b52b4c05da3901ac6a0ddff990a6f9a9701ae555a2b20572e085d9f19a9ed33dd3059fdbb9d88b08db0fd5cd7b7b7424039ec5bb71ed244c922a3f1c1fa345fd969cf07bbbdabb2fef2e3446f3829c56a6d4506075cec584a2eeebf1020e0d03cfd376841277aba2c6202984989be24b8cd148ced99858ef868148a0a0c607aaf05ffcbb66a1e395f1a0ee5987c29e912be0cfe70ad240032b98703688a93c8465d084edb48479bfb2e555e232e6061d477628c1c1cff0de704f2f4f08f1b7b90dec3a63c98cc56bc4ff5c1da982de2dc37ffd08e93e226ba73a0eee13cdfd42ec537b9d512400a99039b39c23dc489f9ee6c9a4ddcd6fb993f3ac7a6aaeeeee5dc0a069b7023cb4df6c46b4eba357304422ee0acee2d38f13203eaa5bd6f2c09c178db844610fde5d928b1f53ae11d91c2065131d4f65a96215ef6cf9da9244ffb3842197e61b236cc9ea8cb79f2b7e09b085c56cacdb9b3e401056d0a26e536f59ecdef8a292f15b06618f5a3ef569d86825c1d0e416401ba869f8e5a6b9660d64fa37ce9c6853e50c3f9f8f59ea7d550a47a3299ed937e5a1386d95b6588fa95b4633539749fd42680183b3754209ed6def8e45b9e0c7230bfabb373f3c9ebefc4a7aabb4369d5fce6d387c34e764857fe4d7540efacb03664fea07de324659dec4aed911437785cd398f8de8b20429ada71b430a1b34e7283a24ae23afd34a9da91a47999e71bbb5944a99b55b40f6de1733dea218e17698868fca75a5fe79337d33d67eab8eff80cde6f9ffbf4db88c933d45f6f8401b74bccd18674a76fb49ce62fec96ede7a10e8e713898fab58d9bb2a8867d7489e982a492baff75be3e86e0a58e94d47cd5b61cbc21f9f28b0a7affd71ac99a861ed824e108f3619c07427f25455394663d92c37140ec0db34d55d7d108f4bca9e05006dd436ad0b4c552dcf782b388705b9430d63bbea0416da784139f5c65aac3557a065208199a6152fbae27525b135b4b685fb1d452d5c4ee67e05c4538261975171e0d6a318ab61791602d28491faee3f0cf4eec34aa84aae5cbe282f20c6829e5bcad6da78fc9f56b2b877c60b3e97a03323adf1e38b0cc63dbba59fb6d34558c72d65d4f156770696ab495e2cfccd410e20ba08ad1f2a6d128853ef9190a0b0bf3ea2b986abcc544c9043873f16952e9553d83e9f22f4a1845a8663e18f74a2c95f6f2807b66122ae7daaf15831dc0c3b5a11dcfa7883f7d4627b8a015c5ec4263f9ec24860f8509066f4151791c12cdf4be3f3321e146be30d0c02b057eee46fb00d7db5cb45c747a3b76401c30d2f408a9a497f2a931174e2acb188257168e2170a30f8f55afb988d44a570b40ab75b85b9f90887eccba4074fb27e0bf4e151a3f2afad68ffca0f2d8e1a5c30f8a6ca80635acf9c55473f98214128c85966e1a705784c308912494e13fe7ba1c8047631037b65cdc6313f2df1efc9dd847139a200f80a4190873353ecceb4983fefaa57105357de1c37ccb42f9d5ae485eaf2d70fb462c752cce25c152ba14e7007271e078a995dd04adf68b3a01cf8e428357cc10aa1b8e9014435507aa030c081e5725c5e463be13d5426b5d13dd07252983aa9aefc6d50cb98093369c52646caa54b577d03f38d38addf0c0e61821260788cce5bf0dc3719b6c2bb7a104156b8b1a8230d61497b26ccb5d01a3ff46a28cf32adabc00ed7c8547572cb05248a0760e25da81e7c902a2e52bbc37ae33605d72632c358383ef685a7811b16336b7e1cd476683a5f6ddeb9c5b549f16ec29ec422db0e4b5e554569d9ff11191783dc5e6971999e19f252dd77716a4520c1fd298474711cf69aefbf5496c889256eabbc3d9e846e51d32b51bbd92d89b5eae5b8557cc4775d80164acdbe40b7cdae2e29bf36e513c9cebe9a6a38ba37757a7a847203fef77e85055c9a63bc67315f2ca8833e4f7eaa71d94d0148a0dcc7710811b15383d9417fbf4ec603b20c0ad91ddd459e2be0852ef3cbc0e5234796dfa2ee46049ca4facf440e8d27ebe446707636ac5af3bf5ba6179547ca85a612b6b204579e15543db92911668fc1d9dbf1a3b93af67ab8fb38dce2180195ed987ab40f7872a64183d86caf2767bd5270decb80d415719055e1556b557161abffa2e28304f0d7667f18628a1371938435b62f9c03408bc8421d71266e7f366fc780331b958cbe3bc0fc3947a3eb7973c1af6cef8147079d25077c8758641e12dfa3975115c6c0d66f7002faedb5c368a0c76fc35bd49f9d55aabde6d8a03b645e89c6bafd167096acc34098bc1ad617dc9e1a1966b94ffa19e52306ea5e8b5e125a162293a017474ac11cb6eedf457e952883dbe820d17c465ab5b882177bb70ab3cfbd578fd8baa2d001d4b4d3e619336ead3d800c133af9670e50bf3b6219e6ba144bad8b22447f8a0d188869b099f2bdc46af430028795948102e9425f7b642508fd4472c6b18c347c65d10d775b52d150feb68d00829b1d546692f9b2c618ccac9ccfa26bb72d4de6089be4ca3f55573a61ecd0065dd5906b487991a149fed9a1469c6df7439907c2965c22896adf5cb79d60eb476afdd1f091a6b2eda3f333102cbc78b50796e085db7871ab40bc35c858c879a0cf3ffbbccfe337719a04a4fd23436a8b9e8214edf5e2b23719322f69fd24143e0ba0060a828b63b9578a8ff1628b384b7da051446a9e80e210b2466a42d9d0928a94321edd245db202b1c17aeea102b466a1ab6f1b645090b763a36c9e7e1de99def8ae21e4bac066bb5e8293b7dac38e677c611c834d8442c7d0bd3adde4b907804a960b96c43f90141168dde93532eb93938d36c6c11c50776fbd4f0d4c1e2bde85101e31226e9fdf01747e18bcd51f609230f1d64f18e4f75981ba28e68d85b5620308090e74167e8a40373f18be6b9b478500497b4501b453a17f6c686c522bc4f85f077c55acd2fb6d0f47b5d827956436e6297060590e3a07bdf675cb247db1086303e992562928b383d21aaec83fe14b899edbbdc80411897a1b78aaf097b96379f798e2c6dab4db9caf13807984bfef10ee0c31819ad99c6f15e4af2f6df56577fa37b88be03230ba27e249abb237a38c40ebe74ff7a4622bd05cecb52e14d3198c299959c36365bce59fff920ea43b39451df69648eaeb79173add78eb4b8275bc4f3b544e0f5c4b7e51e212496e4e42eefec9bcae93fcfd1478bccc6accc3bf9f913b57f11aa3fe09f58b8e8407d8cb2b00d46794129e31ad4b1c10ebfe2685a60d194e863a134ec166577c0e1f533646015f0c0cc65d4abca5d99f977e5bd94c1161980852e647570a05432ee82cb0cf8cef9090a1848f1e838e6aaabaf57402039a0ba2712738254d178ad47001717a101086b915eae8ec06d90653fa1bb07397627d9ee7fb1af8ce71c2f6f3edd6e44e834b0cdb1c7b6fcc049021f5fbae554c69f268bdcb21499fe9a44c53aaaa18fa4c5af0c191bef7ee459f4958e6e98f5f9bcf573e18feffa2cf2130d6d6db3837fdaed4fe264b9f7cf0384bb193ebe8d824143a36b5b4481af7404c333287133dba57a7f338dda3478de7ee7ad25714670a3671a4e3a83853ca1b219b4f73dd59da4e31c71e018611169f0b8e92891b5c98867ed4df38099528d295e53e78a87882efcdc72950ec9d44f26943ee8b7a44cf93ac7599729c96e565ef922adf28d60c112c2fa5e8824904443f3a09f743d7aec1136acb667eeb23975ca7e1c29de87928fab806581ec1432346aad9e10fdd6b41ec77cdfa0bbde1981ebdede5c1a00368e45e1ee8f8264015e93ee0293189befc53665e855855996eda0530a805fc27084be39875ae942854bba6cd896a7af5ad811f23aa5a81f0167d50cdce5c73f223c6ced242b93794ea4bbce87f32ea438a9de0410fe88aca4f12fb7f425147f971dee6481546c1c0be670fd94b9170df9b5336d9693d983ad93807ec1cf538173d28c2931eede3603174308915128167a44daf0128b01bfda3e3be3010b13ea233dcf2896c383c5cb29aef837244344f3ec7f8fe16d566858b617b0e864e079d0d102d6941e5f549abee753d33517e5daf5778bc6932c289d2ac4d3a6c7bc92efbd9cbfecba62eee1c6fa74bfa3c4367b84b0473e9b95d651a7b6c4895c48b347607140e714430b4e7d729750525714bf81c10f81f328aad4345b568b24592f5a39177acf8f662a66341c7017f58c15379b45eed4c9e1910ce68d28d3f68da881ceb03d8df0f5661f74b861264929dfffcadf477efe5419e8058b358dc2a924a98ddeacf62176327e059d4c56be539094bb9ad8eea1f50dcf4a7ad18124310ba2232e134cf67290ddc0cea754c2034704f383cda76504db6c5f3635a24532e1cd22b55efc9c48cc62131671954de5c1e672eb6d294461e77add858c5b7377c6d194665c4c29e9ada393dffd7343dedad73fa5b130f77f9eb592ccac095b584b7b9c01ad105abc50c6aafe0a849520316d00d96c5b6bd46c8fa15a58c1e96f30d46ba30b21392b57a554ea623d589b8ab9999fec056cbb15e89963987facd3a2634506c2edf2209a03a62026adffcce9605f8c84d3ecc98b6c868145993dc4c8a8116928fc6b9a1ffa027ef2f44b021d9057bf91adddfed0927657aadf0709bc43f4af1ea34a01d6a2ed86321c5097a5f49eea7dfcde510debd7867a4c33f68184a0baee41f3cf0d5374aee5909285e01a1a20e7a010805ac225f4cc2d4ab010a350828472291ec300a21bf5b92d25e2e4688beda552b9853d84710846197f3990c8a73ec6739eaa108eedf49cc2404012ec70bbc2ee79ee73bdbd44c5d4162d54127b8916c3760b78ec5a6343a0e807b78f22115ab130c211eb8ded3540c14bfa69f0ecec510d23a61036cb24000c9018a1af9f7e6c9dffd8b33c667d47dc848639f6615e3c8537b7793f75c2546d2aaf30e950df5577ec93ed7ec5e38a74d9b725eadcc4e75eb11631cd8d87d0c60670a9f8edfbb07b1e8992d7221aef5fc2fea1b5695d106c84e553be22f0a7514043427ec2f01d055cd60625e6678bdb548b8a93c397695e7e0330c2f79f94f41733cc57bd4b17a2e6376c4b1c1509bcf87d211e4f9d2a414b55c22cce75c8504854659c0f78b1513d6b6e84c3fb4dc5e7d00c837fd1a2fbdd3e28587cfc0b1fccdcb05ad1c9d9cfe062c24d465aaf4435c97c0075fe39d4e7e32ffbb4f0e781433680b61f0ad5ef987494c3d8ee903c42ba2a2af82dfbf2e34d27125fb98900c148d2a2833eb2fa73e580f24be0660d50a8e411577b3707218181d1be315d59922e91b825c790b439ae2c8bcf8ba9bd3910fc7140fb993f49d9d404bb0d61bce30f9933e9cfc429152f4919d697b8664c9e40457bf1679498b4631d641a1ceba56787d51ab50b1a173c6fd55d718c63bbccaf6f67b804b85ffad9a66e57012eb4b75175187a8a1498dd955c2966a07991b1607b4614a2501383203aae4997ce839db90fa4693dc1da520b622b70e84eeca153e3e91017d046d5d8332069243dc4c116851f26a3515a5618aa4d46e3b7e9e433b52427b6e827404a152424914f197423e5e28488193d65d1920c24caf077af9a40975251c31b4c5c374960bfe372155aac1b3f2fd74c9af3845133c63ec5a8aa7144c720204f2a581c8e912191e69ee0ded18c46de0b07253e09c682b290efe620be17f883982b9e30da1540c79981d7d5a7b9db6c35b74da7133ddd3a52169d501186e0fe51cd81c7c86c94e78742f68394060710d0914beb427b64cb0b22245b33bf80b0a3d4604ea13de704217b7f01c1e751e0a266e5870b114e44d08b10a465dc0a05e36e92058d4fb3440ff29ab8b6473d90f512285ccc80753def96d3a586161b9ff495a89ab8bd8191e329590234f24c45d1871090b36cae25af60a9d93635d16fe0f7a7904e0026283187aa36790aa24bea06811ac57e7c34509c2439037033866360938ee88be4a337da1a301af98b93b27138a2119f2c6547ffe7ac9f7ffb7c927d8a2c4d44de13be41d69e173060a713b3f067598b580a89edbf79a02efcd68f89d25179b3cec2730f3bd8de5ac51441d919178c08f9fd8ffb6c248a9f0653a861f6886b58b2bc3ac75d4a84f854696fc03421ed4b10b136bcce5dccb5d0a5de4ef4843024ead08edd33bc568011c81cb858202a4ef5f99008b7801a7b0b3df29e228c9d9f59fc7b8be14b904b85237b68527eebe08542e35a810972088cbcbd24b9c081e4e7b0b4ae7fa5da0e9e977dbd37da7af464ae9fb44c0662ca75d13001aa3dbc4eb30597292326c82742b8632ec2575ac43df31d048dded4cd94c7e3a99ac2ba359b2d163a5402522e451b391e1f9f19857cb50f6ae9fb80e919158d908ee47bda8ce64df2d238ec089f87273f6efee372a3bee9fba608e262f0e6dc20a881083bf3c2a266320f6a79a918100d73902479494dcce1ed90b3941e0c94bf7486b9071abde8d1ba5b504c483b68fad6cfa8c6234c680345a00ff4906cf13dd3b3d8e5c2a6f1054e8ec8200a04c52e9ec1447c25938e39904ebfc1c2c3e621672eb802e2d0d564adb20c555cc32557d8fb104f68eaafe6dc632cb2a444e1770de6d0c0f74fcccfb7b8b9b2168edc7d229296d9981279c364fd54d7afd9f83a2d38f26e06f4ae770a77f4a407b9fbe68e8d8c76a4b265a382c97af4a83bff06c8a06cab1fca8f922f939fd4cd161f39aa3ecbb516a646e57fba8532af2a0a784edc5dbff1ed31e0826455075d44763245c3deb6e666d4bb5f50052150d0bdcd4de57ba80f496e70e6e5d33ac62124aaa3c21d43fa7a1369f6ea5d0e29a5afd12fd9f4853dd1185b15b4505cb4d4a21749ded5891bc031535512d515fea15e4784b92e1a8f6550bbb095c5bac9dbfa675aed9bd7a9a6c9f5045e40072a80359e527e98342db8d3c753df7022cf63c805d765d0ff345071368f134952d3f415a8af73f92ae82ce39fd2b2b3e066bd6020257e7a93ed091094541136792fbdcc6c1a8c9a6eaa7760afbd85de6f4ba67be576d95ad6cf0cb5f2e4fe0540b3c8e58eca40fb036682df53b83542947b553f26ad1db8f3543c3ccd4fb6a2f30b96e99b53e116ea128eb01c1bbda8e7c57896e0eb3e23a6f02a1048342e87ca0ec6fc7ba2497f825d6241835e1ed3c43dd9a1b7abc547200da9b340bc715bbb914d3fcd2a76d3e078476ddd9e1b4f4fb67bcadaf62668220abf425998bbbf1b3293edbf917d2a012f8895add43b477457954b2d0511935e6a35f562cbb14e25c56589cec25bf557d850effbda77b1187aff6cba2fc81cd623903adfe020f9e34bf27186c1af13215e88614f5f62b3214b25dd829a1e34d88337953a04219f9ea2b4361774adb4ea41dbb1fadaeb2cf973dad5fa130c850487ffe18b07aaa0dd338697f10cf68486f2b124a32396fcd97e95b5b3a632a032abe9a3ba4014d9187edf77275d23c3b54113d79fa6067b7831953a97074e5d8115d39f6e7cef2ea32283d46b8c85c1ac559f3c2fbbfaa427d79f12e9372de4de3edccd822f953a3644daf0a3a71f87a1601d5d61b1acba37e0b166160e5363d9138fa9a75aa21432099ddaa3bc919a3a303775d603adbc6e0cbefedad5602b93c7334df60af6873377085cba5863e2cc2e5d1f23060d2d5efc62fa280efa332887c4a088e339a7a06bad7dec8c3c3fbd20f50b69fc6d7ddd3ef0c45cd9abd839751fe5d81fcb95bfa7958b7ca7c70a8c95de40bde2776622a98f509e48b10ffdb65f4bd43f668e89629f28e3e8f4a4b630a9f88ae9781028eeb70f5d9c169516b0b86d2ac3baf5d87a6a6f3b5b08032bb31bf9a9a83e1ef6c83caaf779b907e079ac0646a795f042a25d814e0c86eeb68282c9aa1d07e0bec4749ee0a3ff7cd5fd584e9aa99c99dfed8299aed0459b331ff031c945495e27381684ce3a4927b2af906d89f5737cb48d55ceef240f21e30ca38bda2ba3c460203829df013a3f3fde9d875ac27195c32234d49633e3058d8694ae8e52634a8e7a0f3bf7df51b755d0b57b9bc1110af29ceff79098a146d6fb184320b1bc3b6efb7bef2c1bda621947102989d5ed0a12a5e810a798faba56cac46d5aba4e2a21c37a34f995527caad633b5bf1307eef1e2c14482cd87129a0c2dabff91a1b3cfe272562651ddbcdb829a6b7ba671115463a3903e20ba470355f9a914b57594b62280e469bf18dbfd735b1f55ab6045b1c87736530eb232f3544c0a3ca5efd3bd0997a4aa8daa15148afd954d62d05a6ad31f1182b48c135e6e737dd8e2035a35647bf688e735ab64d5a2d4c36fbf5ecb3ce0437cb90db59de3c2c29120c1ef319c9e8a581613c6758f8ae44902065c9ed74e2b34283135410078dc578eb82cf027c795dcdff13900addf85d84325f699d92bb474afa070f558b8abad1850a01355e5d67c169929d97c484edcbe98da59e1671ae757a1b333ff8e5b068222a0a85f60ade7647c121e7f8a997e2b8c10a451931ffaafbcad0e0fd75afb7336dcc63bcb5190d496a95c329d129f3f932ea76c0c210431a13a9e5198c21ced0eaf8fa1f1ce0152d03638ee93b515538a5f383b071eb6b7870018f62165ac189245bb187d30566781e055e4a6ed6e683eedf9461b72f0fa97e93ad5e63b43e1cf793ad89dcca3702daad071d5fbd90b232321d84b1521dff7aa490c0cb9f2e8702cb445d8797888e5d7274aec678873a5f8dfe5f4987a2a26ab528936ab4383f6e729f8609e01d2e40da570b5a831f8b04874d1a957f5ac46998a207f7ba4ea725487b79709a25d635b953e3fe14a76b3a85dda1743eab7b4613f7f7f3406cd0e4c9fa554247d9ddd3f5c80b2218d0e4b624017c97b08f4668791163c88de4306e2e56094de673d7ae60bb6f599598afd1d30e0dc1b41ec195a58fbe2537642eafc507e78444c2ce76cf9beedbd0bc3e71ec19db8985eac79f99006f1ceee86caf6293bbc3d5b5e2409d47aaddf9a5e6e93f59d2d2ba9adc73804826ef4ad6495ae52a2cc1f40f2ed9140b144018004d45eeafcd56fc7e2c88893d0447ac9d71d2ec3850952cc1b2f895f449c00276aa4eaccd19f03f2224f1f3de4c32af9c1ee8f9ccd3a29bf9ba6956019c20abba9dc35678ea215ed476d438ab33c119fc4c64c4d392a079afb9dbd9f687a48296bb75c938280fdc007999a79f8efb70d9ffa98b58d55d89e30f5bcce7f3b827af39a67e9bbad0e927ceed5ff60d36b30d8dc997d7b3de92b184978cf3a9eb0b79eefbeb0afe06a888cd051d28d7563c85f4e981492cac6dc7bfc47ba1d25d86cf7b349902fd703313cc477bf0c48fee2419118ccd1a2c58ca764d4a624efdf93c4398c9ab35825340ea1771910b5f3e2f56c737885a7268c03d063a9d50531b06fab9f65f3156c0d0b3855d6cf543908b385f53a4b3b51e8efa5f381c2e925748e1c35e002c1a6ae2d3152da0c6baa24fbb20cff995c48999129eaba00b59c2e1201fb9774c9ee0157363214dddeb790cecc4f9c032121639617ce51cabab17e0caa57896e390ead4133d70a28e9c5e80224ff555e5030fa40b952569c1eb64a6efbe215b4044ef09cdd8bf8ee7309a0a01154c27326f016db34b70d2d783af7497a9fd583ce09632401dba3c06ed12ea448252086080ea8fc6728c13d25bbdefabb19c31a628ee7010d568785a7883ae2612be86698ffdb03980c90e03101b282dbb42d4507b328ad461ab4eec22c41443c7798bd8f161bfb660ee06ad743daa0b1b747546eb601ccd19b3439fde38186783f2c0a54bc1aa4bb9c645c47cdd139178b3413ff393d99cd8481f011e6b47d38bd702e4d13cc5e4c3c82c74c437d486900c7a581307264270e5c2b24e6840009b5d9ead87b8c19af2fdb7436d1c36cdfde58297e08e13b2fadcf99fd9d9c05bd1b8b7bcf7d794eb3b5479732abedcac1efed1ead6fc93cf2a6ec5a6ddcf8ee43d8aa1f415eaf361bb8a716fd77049608ea0c465f14574688d4c988ade8a647c59c046f4a34a0d6f22abe785b532e4558c6eebec9507eef403a81c5b8d9099203989fd142f9f47da82902fff041bb3369b2976fd3df48b30978ec8ef9ed325471ed515b50326f9152c5a02994363436265dd350dc1052b60d2ada0591228eda97fac86019edb78443bffb96af0aa3ad9100497f5fad76edf583b43d89252b813959f1d0ca6bef2662b8993bdd7d3ee4ff390406613df43f48916f4c33ecf3b34607a1f6d27d75dc6bf81cac517f79bd8887f216c2eaba6143f3cf38a4a3bca5474caef8defab1a5815dd3c59a1990553f1b52399364305eb024d093832de9e3b25671980184b5a1cf0d32da16008de718018536e6c0929effb3b742e0d125d98040629de6b85eb741e8d520f3f098f7f067f507aa94d46e58dfcae005b755198ca60f090617918dad3c59736cb01cbd6a39e504b9ca0a6dc0a22687cc20de7c199ecc887106146e2749f3c84c63889077c96913c63bc6e79ad6f4ac370e3438470612ffd1566f69d6633690461e98453c553d63d2e75627ecce55d9070bbb87d3fdcf102849d606b9170e03d3bf601221a016b642502f525ab3066a6fabf3b5bea7a8874dfaf3ab3ef1464985dbd3c7faa3a73f5295bbb0e59aea0a7a79d9fc0974db1d86a9804859e0407eb88a011d6afa521e5711351a8ee51fd7b0010bbcf0def539e1b5ad2c470784faeb1f415865c26394a18146739737e4355129f404b4ae49def46cff6fb099e439452173b13bf978593f6fc006b4601dbda7a13df57a7a582965e4e2acfff3f068e7c74d985b5b7de42a8df8e0eed1ca974820a5321612375b1efeb792accc954fa627746b0052803f2061256c9f3f32c33347b8b2235e66494e85377c1841a5d56126a354e9a663401528725e485f2aa68277e8214a8144dc9bf913a290c67f51fd0c66e89d459633038e9dbe44047c407b9f85eb42d5189ab29650fb84b375e905ecb6cb01312fd94ab29f6bdcf45a892ab34de8dd21cac2ef8c563a3325e1ebca8b8c1d80f0e558e92ac78d1fd9d4bb00d7c498990c4d6a769608d20b94f24de6e0bc25a867a40aa8e73da0a026c2a58186e6b7a7e8c3ce9f53bfb92ee47d38e5de59cb73bf2e7feb20b68a2baafac114c74c320c86c9a109f52f754989798177ad4b58aa339f64d77e9c91b1ed5ecfa7c184735082b246feaa305f9cd69e2e710f98e28750e0181fdb49f59737070bd50e116343c79365a9458ebd98b9fa3114aeb1a43477fc14350aaafe2ba57ba514c5b2ee36085caec48b3d4add7d86e5bb040f0cae885a00297b30781a8ea78217d0cea21e0eb1d6663eaa6357674d6662b1bcfba5dfc2d3a433a924319178465c2df52d4da4d3a162b2ddbfea6488982a71d62e8220582a06739d3db7638fb161de7c5e944d8db3609957a37a18988e1532e0faa7d1fa89f93bbe8159d51e2b274259879df334dba68b7d071a37847180924c657a5ba56f16c16b1ad974ea1b746184d3c1b2192f1ecbb82068dbc38e048a1b1759aac6d8897c5501194fd3ea7526cc43eac521053cdbcd02be4aba0ab886aa4dfe847e5c44e20995f682a344c05e1cf70072667d52e455b07ac953a1360fa5ba00d2d11a37c484b57c9fe35c7b41d0fb17a025a1094a76f0a28d1825cec00d8e42e013d36ab979acd7b656c0bf027a9c2be0405a8eb15443aa8cddc013ae8e41a0ce4ed630149936705440d1a61f14765e04a9ddcbcb13c08fa8b1c81e491b5e7cb59e5fe5ba5aedb45872c7a5f88333efaa91487e9141348a574068dcf8347e4888ebd9be00ed6c6c17b85c08941d633a5e9777c77ca0fea3be391d21ea015bcd9a827e96e5c58451d510ad57bb53df97ee53b5604ad672d9525aa1b8b43d6bd14b08e796aa16f91550f784ee45eebafe87c405288c4a3dd0ceceac358ef31e16a7ffde48c3ca20a65ed86c1c1a03032cc242960d5daab36d26048d370e90038377d893882191b4230cf14f57e3bfc29fca1a506d50287bd9aecd52a91f44be32bd3b89015036edf3c8ce44a7bd963d00ac84758eb0d6ae1456f6075407b9177dee208128fa364170f759f76937c1f903003f3eecd7b2cc22f4b8a7fdc294a431fba267977fd9d2483ffc83ec65a36816a7b13fec2fd1f998d2f2cbe10e826e30572e9681df6c9829b1253d8c4f77aa33720e8b4f081c23694424f3bffae1576d9d4a1244704296ca0204db14d1cc9e9859ece91f567030114ae342c4aa509b8140e711dc1406f17adeb42a76b741802034b868747a9ffc2bd4a4114b7fbbabd2a80294d8adf300d77ca154af5413041592967ef8e572e488e70d4433697e91e79f460b29d5fc7015b5c81502f66ee5ffdcdab094395a41b11ada72c2a4e3696fec45ef260492d01760ffa47f721b8e3dd2756ac4146469110fee7f44cbe22480da299d560e42966e4f0a626f9afec0a7a8bd65d7cc260d766f62560630396112ef2f71a707175329be0296d5d3c77ec21aaa138e5cf9640fc3f112d4cd7ebdb15191e4e8d70aa268c397f6df083c9983f027486583f6ae2f03c4ea9906dfbe2e825adc742f4fbf56558e46d0ff5901cc7cd0d0b753f9adf0c703ebf73a8f449ad06f0d100a4bbea3a9a6b0b4e244fb21e4679b5c5f3c5a4db3dca4fff3b7a4dff7fc0db1c48340887a8af38186d226739c12dcfc920644a46f3f120c9be70035b034f3f11e310fb7d254cd7a3c0235737b627909b9829cae07f639bc285705fd489046963011aa4a0715ab6eaba8481711e059f1d40d27dc864cf7841a9ba434b5b0c4fb49665f3f0be6f33af3fe4365deac9d5de525dbcb3d42946b263591ae6ccb24d41e035ba9dae3bf71c65d5610c5be6cdb3c2bf3cbdfac24e37f121c9a846fdc16472a93c334dd4a685c3b6ece223e5f889f1ca5438b94a6091ec91cc2ac924292b55f1a39e5fe5c1722c0a1dedd3e6c59ccb499bce2c065358c5b55e8e6727652911696b0ec36ad7e16f8127041a739a2d364d4d11bd57d0e7568728e4e9b50694782e9cc7925788124d41aaf8a756a8f9160b299bfdc9a66b2111ac621d8bb9ab00a9ff9994f9bfa8d9d92aade7071a39738089803d85427e3810df3407d50f528d29c849e10033b22e488e2cfed00d0a3506a68e6e902874c46876df3b7d53bd37134f048ef73bf9ba54dea3366c9d6892bbb9e1aff62eb84b0c78619499cfed693e7d61009d0120397da74456eaf816d6d64f005ff180099ca3506d95085f2ea24025a718089ae555c3a8d42c7c9b75621fafcce057b89603b5d74181f413f6b7e47f100103ca30fb1c55d092827022c1fef9afced7329c17085f90a90c45c425d11ad802b247329924c669fdbb92fcde5809afd2f93629340e5cc331d9a95a236d0814fb74b0338f819bbe18e5f0c134427e8637cd445177373b569c84ce8a36e27d890779cfdff3075b4d28323db887c6979731e53fd811247c870b3d6b65237cbb25fec1e203173420723b7db6878b8dcae0f0559046bcb4fd12d70fb1dbadbccf68c10d8058160031011955d02f92b50110eedbd87c4577fb6b28399a6d2d52913d172648876c852711b76c36d3edd2231ea413fd3694ef6cd530a48a341df957e1e206dedf9ff6783d38e6f4449352d91ac5402243dd9744c6e31a143450668aea8dc51101ce734fd32903c4c85104c8c0f5f79565c463e5221240f26e3e6c1d4bfc85d52e64f3af7dc632531aee93577c66cfbbcef29b413478644264e58c6b42d9ad23acd2347a138b62b563351d911e3aa4a2954b0db9d9925598e9582f32e7730ae35973f1d842f4af9bb20cea2d333779351e4b65aaeab99b01ffd6b6b4883097ebd0138fc3d6dd67e603fdddf34640db226fc38b7959033ee0daf4731b08cc3cd2880855e793e054299c7ae295bd0bd5b1eb328def90a358815e5c6d0176f917f1467d6053bb9551ccc7d4a3cd1cc6b15fe005ee031cfc130976efa95def6f1db65aaca7e83b3756f18beb63bdae97c7636da8ab4ae0009bd59c1b8527e775fc3adf9e5eb3ab107452141d25c62b5e501e8667987af49be774a6de8896a18ab652fe60a7766b26657210aad6770a93e2cf4d3ae1760b643e83ba97c29d379df2bf14f01cde0b72a83fbe5bd4ff1eb3e04e21b99ba400e948d6431a62554497660246ab94201591e61bc7cf16a1cbc17180df4ecf364db4c7ab5384ae6d563bae291f56891457393c218a39e7bf4034d50bd8a4df59f5dbc718ec348029d3fea104dc86add8909d7367dca4a2f0e806bc05fe15897be7618abd96ebd993c11e202d9ef2aaa7111d1d3f9a890ba648673bf7f8d12aefd2988dd4dd89c700fcb25222b261e3f95830980d627bfce000861230606eea260b4adaaf2c351cbab984c2a94149cf3f8071e6e21cfc4305d3a5b17397a7e039344316c65daebec92e8145a3dc8f1d44d5effa5e6d3ce03b5e15cf27ba083cf673757c7b6b4ca76cba3a7636f8a811d34ff1ad62dc0e3a680c0b4aa8a94f48a631d7ed48cf5b95238ba7459d9e862e329cdd7f8152f26349038460eb4ac3daae39ba7e92b0209b25818d3c7f59800de1c5b7897adc8370f40655d2e8685f6ac29449664a1e960ea8f75d6e3ea367863fc37285d628baa122dbb067637cc3b9007aaf79142f28a1895b2dab4eaf1935ab7ab291e6bdf8c7c96806a745cb569c32177abdb00637cc89530a719ef9c034190087e6ebe92e102b6a1f49f5e80e61524fd5c67aea73682e89bc032431dca05d55146120e71d0d96cdf09f7df318fdc7f5ad5460b3902926b1680374423dfe66fafb6e762014b2e1b9e0633e289e4e28a56c62b615fc3028bc5f4b29643a878ab979c225a2d974b916b6034ddc9c958c32ac515ece022320e551b02232aac69a922f5be43f9094839e294c8a551d5a69a5b2296f19519eb86363dfab0b23d9a6e25c523ba5870fb5ed11e3c3a8c885b9cfe208e5018cda2d29d29dc967e459eb7255374cf14497f5caca9f068eb7a0556b711d52849629a52b8c209d92e827802130510fde48f7bc1cc46b20ac012ebce7840f503a38ffea59b17d87decaa6ee40849c30e4e4ba26afd1c88c48603c8123455eabbcf75bc0de26151856fbe87913c9d5a44965c5122b77e476ce6171f476c9c633d8f4b29fd690e26331eb12b23199e1823d9b5de3332db1bb6d65205b46edff809578359a4c1769e810fcac6b8f51fc627784a6c685f628b02f475f78b5fb017bef0d2de4e64af5fc3185ba9bd3b561b97df90c21a823016ba67b50a13c58ad3609a0ff94676dda18ce44fc3dc8afb292d407584e069283400e0e233794ef9f4316cf76f11cab365f0f6bf1b06dee3e4b438ff78570e59d5a344d321b6db9e40c7d609a0fab945e5856cb822c6d35f4b94385c9ffc7bc88b5452b1244043901337578aa137d337917982352cb70e684bf963edfe31cd198858441280630ee7bd334a31d32da7e402513e849cb3f924156b34115e3ac06cd8e97875dfcd5116bf0db47327cbaf210746258c09bef34560031be8d7c414cc65b377e53a99ade93e5fe3a039b7bdb797e03d740174b49d33f7d6eafcf605397db32190b4e503c89f92e2e31a9bcae87b1dc524202db8a2b4dbceddb78b75dfb2208cf6d06064ef33f2ec6a8f5666acfaaf78b2f4c25b27b42ef125ec9e2a3e28ac11130694d6208a169e14fdbc310f74ea6b0ab7981944b912b1eabd6c0f0bb4ae4145ef22b4d8931b2c285e87f70f3137b83398ff2c16b9e776c2d5545256878844cf333722376e724c1494686977bef5db7ecc981632e9d4a4deb3941cb691cbf5eb87e8b5fe3f33f64a46c586e9bc59ab3e9ec20ccb9057879230d4af8d2001b257259dc30ae38710a279ab1bd81b2d9452bc6bfad424b82dcdb8942d09fe4e55cca8fb2d63750504a00de042f1c70e6c91fd54991bd0a2afa9e833ab4a536b759472e907aadda15a269584c6d856084e9b958c47c09fedbf6d7b019251e554713e3cd552b99a549d676cc4e4b693c834195cfbc473214c1b0db677e8e51dd20043e5ac5a0741ed5fbe15b244fe92a3b1e93eefc4b33536883fdfd4dc6e437d468bae6d1111b484161cb108e658c9fa28f07fb020714cc3ede4bd5609e0356268de1731b21fa1b1bf055b6d127fdce46296d17dc2c5f250df8893e280c18844a32a4f2a1c29260dbaa0b555b5c8cfdae98a8eabf6ee0da73183bb48060b559a7e9b810bf26892b482a4c091b659a8e9d5d263dea50d69b12f52a4893277dd90112aefafa2fc964965bab1e93febc2a65aeb29381652f878dd24bb1fffa94183b417ef410b960fb503906ebc84004937df0570f617a32b837cd4a5f59e98c2f24ae5962a54697d6c2b1b30e8b1612e247369cca7a41b74c66221d7a8607195bffa1a85e69ef57e1c4356daf4dcbd845683faab57d2f023e570861d721899590e9d64cf0032cf3107bde3ac3fdbf3a59ac096d4e76e273b26607cc422c7a898af814d8ba3823a0ec897273beafab349321b1824a7c41e1c401cac8d193bb38fc65a8a0f953df0c8a12a0af87913538308f7cd66f4d6f3f6cd338c6c72c37cea54ed61c6b214b34b0427066e5090ed539ef39a859ed8dc7edc599f3dcbaa40235e8bf589ff30b11d0348f7a4b6d3f30ccee39ad72103d8bf18ed52a756d9f54f6b6382c3a077c66fe9894f79fae70fff28dae372f03ecd2856f0d95b0f10ed0c787655b6f1716e70a4dc880f1594a780f50610df4987ad834915241f8fc956a510f4b155392e8cea4f735eabf6800d38eba3d50c2104049e448f287087a463df2cca0266b208490af268e08f722177c703aa19973745aa689a8fe28778f637b352677aa1c95e0514133d60305dd965d3016692970b3f208b50776771568a3a61ed14196653bf9ecb141468efa077d0a9b910a49d9b9b988044d6316add3bdd3b6a45b3615f0e45b77d496e9ab7140d432e2b92e540e4fb3a119c1c05e827a70e263539d39e9e55b0493bf404aa9c590a04b9aef014f968af52086e98fba2a20109ca32b5c2e51d0bf7d79323e784f54d762ca4ea08bcf31c2bc4df3c178ad9732845bb3e507435eb4a0452f31211f6fc92f7b772ed64b6170f9fcd3ec04e7f0c46b5fdbe82054436943752f0b3feead8b3dfc815692cbb25683135172ccbf3cb6e049a2c30a6b281e81e4d31862fd91fbacd9d9e430404ad796aa3c608986acdebea4c295e635aacbb59a646924cfc2f22649e912a64518f41e31575f052efd4473a67fb99693c67e451f87196aba7ed30069aee21e951e13106a0f0f1c053f749df575a8afdc7ae563a42affb41dca844aef8430997233912f663bc11dc5cf6ae2ac1f81d76522775ec9c0ed0c251ed8254032de1cdf9855a5000df6541d457a9b08d5b631df3ddabc04f472e8bbcf0c01f2ea9f717e74696500884853637052e35003e055c879beff84e865848f80164e89be068e7d42225693b8d9649050c17318249d130c713d7dc51c2be39458c7619938d781a064f20ca84651be2a1d93b68b44aa6f7e16f30a9064c3a366b622eee14dfd763aaf3a545fc467cf8d7bd40ff102d09378a34cb92bbea18df843e3bba2beb81942f1fb4c2dd2e5584b3123fb12fbb8c5ae4830c3e4b4d4e74c1863b38a4182d5e97c6f595f46b80239967649f265854f7e78343d9206e7b25d752b8058247ff170ddbf43d26849c7bb06cb5ac73b79bc700def14203ddf88b2e4fc67a9d810103647c0668296b5d71cf7fd1ee338f1e3bd34c00feef723edaf45d841f2827ac41972001ab59bd18b69cce7002c40bfe38c4fc870d820ef5aac56a4be2be769a4ee599aef513589315b0ab0b0abf3f4117d101422805e977fdabf795b652bc7303b2015baf354f00f7e863ffb0874a4dcbfdbc2fe83c459f5df6692dae852737375f4a725e21918b2d6ca8592ec84d9ad44e20732c742ab15d47f3d212227e8f40dc15eeb6465640cfd9beca0d785afd1909d629456433d4d17507b84d598d7ecdee1076df7d0f914e40ad4c0242ed3ed95d9797ecc3f42fc6472b1f7051d0cf6364da9090164894c6d8cf56219e85e34cd048b2d0e2ec99e38ef7ffcdfdd69119e17ccd6e99fe5a91e8cb9f40a652682ccada3427f6636336b4cadbcbda6b6056e7b39f5ee92b1e09689e396b5516b0fba9a26c0f13d5b41785f940f90bb34f08e6fc0b22bdcb624c0322728786a8a3c0a0913845b40e87c1d7d56ad501eceb2dfcd7142d5b89b9642604b7271ef42caf1be9535b21e7389de76fe5d691d4c6d38d6886bb86cf31ff71f2b764e9650c73ac3ded7059a9f34ad2b2dc3d46bf0c55f5c7d9f9b82459833051bbef66a84cac991c6f1fd9a303f5fb18226077e3b7f1a5e952b4eb2e9d8d86b6368013d174c4286edcc10f0391356dbe374993bc0d226a5c14a3f4a4b8bee34acfd01c26a9d47ec440539c8c176b96b5c747731fac033b554a1c3a9e35594bb4905163b6707cd9723ed281eb9fdedb265710208c16a4aa8b68c66712c32e18c31f087187adeeec60848d7c6d59fe19653af3d762468b2204f40170b1401eff34777e98fdc4aa452128796fdd91681e1632e7fcb14030c3152b9c01ac88127b891dab756ff42525655cf7e4aa8b8bc27911ca2902720ff2e1951b3d962170f47bde6129db7b30fb326506ca10287813605f9434393d622c189d7389ab5af9df3caff64484ec8f8cd06286ced52a4f60a16619dc48edee3c64cb7f10f5673900736e9bbc2f3cf075bf504729cf1c3166e87c4c43a6a50fe7e55cf4c463f65927c8f15e2406282258d8031670f97198182a9e17bc740c335d3eda61102c29314f1ac6822ed75e31f5ae23de5f07ba3570947ca0407415f5fc6368545fc2e2be577a39539e7da52e56e0bb8e4f2dc4a398ec1e04a588bf493365167a98bd16c2cc87a2f0b009826e6c9df173e15743d500518c979fd5c850869803e8252e9f36283314114ea8e60d906e6d1c93b1cecb06db13d04b19bebce52e804170a2b48dfba5cb4e096a8f2c1255516b92e8ddf32434a4a3b1e30e79aebd7e2dba6c026aa0b776b428fddff3b5eb6f622cd7907c2ce3cfb7c0b6de075513d811748694dce71ba2d434459d3104a22431519c8089ed15a3d7fbe88b4122b3662d66b198f12e88d1f3cb0d3eeff194c9a6f9267bcecf17bd45c1b5b57b4be6553a990451d82b62500f5246e4dd5dbff0c7ab795258b4cde0f389994d75045251e3d37fd4f8051c33d2887ead9caea4c044202b0063e86f1006fb1729536d78b42c3c367a084f827f9e9ad72297044e5afd3e1b99d766cb02796bd41b1d1fd2d3cfb0a200cef10a9344fdcb7ee78cc2c1103a8673512f79243f4c660dbff27363060149a9720adbc2cd2331998487168bced1bcc8560928ab03768c2ee231eab6965a18f6c3beb4ed4b6c44d5f34771770fb429c4148400d588e298ceb60ff8059f61b92e3a12a2769dc7b6d6ba1967c5a00803ffca5ff20f4c91b503a212d68d60417ee57140797de16d41c3d253ce42a1a08fa2c12251fcdebbc0a5367736aa4eb32ecfc70ca297defc856f31d858e21b82c2510fc2f4d880616cafeaf5a67e492e59a373c4cf252f76dda180acd7eebb8019d39a9928e976db25c077cd5569faa7e6f4d3de7571f45f80a04a8d90a308ac2513b26327e7cfd7795ed27efe3d905748fbf2875a0e5ea18c9d286d7972c129c83f5a2b5cff4714f5f58935ef47ec615e7b2312241ffca3e4a3434d7af7d88d4c0e76282cb9daeb1b6c24d4e48d44b93d976c6d70d550727e99b1484624a6473d3f0fcfedf22f65f9b081dc2fc9ec631e2ed64a56936fe5ee19c4b988fb5e0f4b0954d215e28a4743cbc812b1b3fcb681686fba3cfded6680211e1d82429f6941bc2f61bd5dd1a9bdf2f61ed3a26ce622763c24e7e231d7d20ec8b2b88269ade9985dfba412f51d873e2554cacd50a88d5f1ef686ba706e44dc550eaf766450e4e162b1a1d1b66ff17abe4efda5f78e7966869d61a5ecd8e5a436f907a2978cecde186c338e85bfe84156f12851d9fcf4a8c360fd5ed85facb0d8beb13201b388ed9f15cfe8b18da0113fbe45b9c1c0c8b4b2019c504f89cd95f591f579c927f9209a3a5235ba363b3985a1de8b06165e51791fde41ddd103e0bb1bd9567733054acd6cce99afaf991b84203bebdc5f40aafdfdb75ae41e38c3b024566b9888a91d805283c782bf06cba1912ea71b0c1f3146196b3321b2f32c89b5937d3ffc2bd981e76170a79dafd3d8a208ced4310a239487e7c3a4f093a911ff3cefe267d1b4c216dc763de3d09de82983347602b31d211f8701dfcdab3626459ba2ac6d65115ee6e38ed5a44d3ed126c57b9312fc74d7fbc27136686a84b3ad9ec45261c8842b66bc549b994df2cf643ac5ff4f46c3c7db55d9e7419f25fdd22b27e528fdcf21d94ce9f70234471149733152f26c6307f8a6539903b4e5cb7300e047e855736ad71e7b9351ae606ea70aec4ee7c1efabcb6b663681b8c2f128935fe578bb6330108ebb5ea2d63fd735360b975a7fb8048e8fa598c6fd5cf2a091b7d2b88ee0d408fb79f6fead493c8c491cb8e7cc310f3121302cb623f895cde0fca0358d1e4082411e2e130085d8b63d0cafaf26d9bcf6a71a9b9208a0d797a56a1e0441dab06d57fa40ab0282ccd6832f14e801caa2cb722ead51405a4f1933e1517e922707e7bd2d29c00e9558b62f3f2ef5bbd2925129aaacc97f907590845711a8c758d67feebafd6fcbbfb9f40d654b96bc66091b02d0b845f90397369d661a6668a5dc6ce93a9a4a19b9c5402b83f1e2ddd8f4892973b40c2a77a3ce603e37c18ea3de900c6a37c90ebe4ba88bf9af1cf5f07c3d74454ed98e2d68f25f2fd922b43530889ff0566a74fd7f57540cefb7c8bce3be7d6faa0e20438aacb50fee44b5357b78f0b9b7b5886fb791ac4c6dcee4ccf926a1a650f1b217416ec279a1227b158cd48d9eccfb3405fc65007106b1bac753d18ecdbdf147bf39e5156e69eb3d6e8eb4bc093ba70c828d05bd75647aac03e4c411ef6a5a4095e7d0e08189e06c2f708de7794e27b342854c54ce014c48f28a774338d96821f34ee324c7cd64cfe207720f5849c6ae39bb4effc336fa138cecd10f6db9015537d1d059d16a973a0d3cb008504c5a60896e93652842507357637d238f738f47bdb22245726abf53081ac029f6e0e6dd88e226d5f4f0b7f0efbf95a8a38279e4e2837446510eeb1481f1192105377f0b0fec689790b3f292a03922502fe88c68fbe9a46566d46a7ad8cdd1c3985124f95f817580d2fad434b493058663c94397b80a708c2dde0efc1e81f9f656ac98d9d4dcc3274b51b42261a8d8d6eb09adf26300d7f3b51172ecf14b04691560a5493761c46037ada750b337f96ec7524cc05b9a239944439833e5b2b405e309883864b2dd94e128659525128dd05f214e28b192c6ec1bf458f169a142f4d08d51aeb6d227</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">gem5复现论文实验</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">有东西被加密了, 请输入密码查看.</summary>
    
    
    
    <category term="学术论文" scheme="http://okeyia.github.io/categories/%E5%AD%A6%E6%9C%AF%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Gem5" scheme="http://okeyia.github.io/tags/Gem5/"/>
    
    <category term="非易失性内存" scheme="http://okeyia.github.io/tags/%E9%9D%9E%E6%98%93%E5%A4%B1%E6%80%A7%E5%86%85%E5%AD%98/"/>
    
  </entry>
  
  <entry>
    <title>杂记</title>
    <link href="http://okeyia.github.io/2022/03/01/%E6%9D%82%E8%AE%B0/"/>
    <id>http://okeyia.github.io/2022/03/01/%E6%9D%82%E8%AE%B0/</id>
    <published>2022-03-01T06:12:56.000Z</published>
    <updated>2022-08-10T07:21:42.177Z</updated>
    
    <content type="html"><![CDATA[<h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><p>本篇博客记录一些容易忘记的技巧, 或是一些解决常见问题的方法</p><h3 id="一-终端命令行参数"><a href="#一-终端命令行参数" class="headerlink" title="一 终端命令行参数"></a>一 终端命令行参数</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/argc_argv.png" class="" title="argc_argv"><h3 id="二-cmake-添加-h链接库"><a href="#二-cmake-添加-h链接库" class="headerlink" title="二 cmake 添加.h链接库"></a>二 cmake 添加.h链接库</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/target.png" class="" title="target"><h3 id="三-git代理"><a href="#三-git代理" class="headerlink" title="三 git代理"></a>三 git代理</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/git%E4%BB%A3%E7%90%86.png" class="" title="git 设置"><h3 id="四-cmake配置MPI和”-lm”参数"><a href="#四-cmake配置MPI和”-lm”参数" class="headerlink" title="四 cmake配置MPI和”-lm”参数"></a>四 cmake配置MPI和”-lm”参数</h3><p><img src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202203241229563.png" alt="Clion带参数配置"></p><h3 id="五-md插入pdf文件"><a href="#五-md插入pdf文件" class="headerlink" title="五 md插入pdf文件"></a>五 md插入pdf文件</h3><p><object data="1.pdf" type="application/pdf" width="100%" height="877px"> </object></p><h3 id="六-双屏变单屏解决办法"><a href="#六-双屏变单屏解决办法" class="headerlink" title="六 双屏变单屏解决办法"></a>六 双屏变单屏解决办法</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/image-20220421153609068.png" class="" title="image-20220421153609068"><h3 id="七-学习git网站"><a href="#七-学习git网站" class="headerlink" title="七 学习git网站"></a>七 学习git网站</h3><p><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解Git</a></p><p><a href="http://onlywei.github.io/explain-git-with-d3/">Explain Git with D3 (onlywei.github.io)</a></p><h3 id="八-图工具"><a href="#八-图工具" class="headerlink" title="八 图工具"></a>八 图工具</h3><p>Gremlify is a free tool that provides an interface for querying a Graph database using the <a href="http://tinkerpop.apache.org/gremlin.html">Gremlin</a> query language.</p><p><a href="https://gremlify.com/">gremlifyy</a></p><h3 id="九-ubuntu下zsh设置永久环境变量"><a href="#九-ubuntu下zsh设置永久环境变量" class="headerlink" title="九 ubuntu下zsh设置永久环境变量"></a>九 ubuntu下zsh设置永久环境变量</h3><p>以git的仓库目录为例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat .bash_profile</span><br><span class="line">export DBG_ROOT=/home/server2/grasp</span><br><span class="line">export PATH=/bin:/usr/bin:/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure><h3 id="十-Lambda-表示用法"><a href="#十-Lambda-表示用法" class="headerlink" title="十 Lambda 表示用法"></a>十 Lambda 表示用法</h3><p>lambda表达式可以理解为一个匿名的内联函数, 语法：[capture list] (parameter list) -&gt; return type {function body} </p><p>capture list：表示捕获列表，是一个lambda所在函数中定义的局部变量列表<br>parameter list：表示参数列表<br>return type：返回类型<br>function body：函数体</p><p>我们<strong>可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</strong>，</p><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/Clip_20220810_143813.png" class="" title="Clip_20220810_143813"><p>lambda 表达式本质: <strong>我们编写了一个lambda之后，编译器将该表达式翻译成一个未命名类的未命名对象</strong>。<strong>该类含有一个重载的函数调用运算符</strong>。</p><p>参考:  <a href="https://blog.csdn.net/sgh666666/article/details/89000215">C++ lambda表达式及其原理</a></p><h3 id="十一-c-类注释"><a href="#十一-c-类注释" class="headerlink" title="十一 c++类注释"></a>十一 c++类注释</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/image-20220804155226015.png" class="" title="image-20220804155226015"><h3 id="十二-C-优化等级"><a href="#十二-C-优化等级" class="headerlink" title="十二 C++ 优化等级"></a>十二 C++ 优化等级</h3><p>-O<br>接下来是-O变量。这个选项控制所有的优化等级。使用优化选项会使编译过程耗费更多的时间，并且占用更多的内存，尤其是在提高优化等级的时候。<br>-O设置一共有五种：-O0、-O1、-O2、-O3和-Os。你只能在/etc/make.conf里面设置其中的一种。<br>除了-O0以外，每一个-O设置都会多启用几个选项，请查阅gcc手册的优化选项章节，以便了解每个-O等级启用了哪些选项及它们有何作用。<br>让我们来逐一考察各个优化等级：<br>-O0<br>这个等级（字母“O”后面跟个零）关闭所有优化选项，也是CFLAGS或CXXFLAGS中没有设置-O等级时的默认等级。这样就不会优化代码，这通常不是我们想要的。<br>-O1<br>这是最基本的优化等级。编译器会在不花费太多编译时间的同时试图生成更快更小的代码。这些优化是非常基础的，但一般这些任务肯定能顺利完成。<br>-O2<br>-O1的进阶。这是推荐的优化等级，除非你有特殊的需求。-O2会比-O1启用多一些标记。设置了-O2后，编译器会试图提高代码性能而不会增大体积和大量占用的编译时间。<br>-O3<br>这是最高最危险的优化等级。用这个选项会延长编译代码的时间，并且在使用gcc4.x的系统里不应全局启用。自从3.x版本以来gcc的行为已经有了极大地改变。在3.x，-O3生成的代码也只是比-O2快一点点而已，而gcc4.x中还未必更快。用-O3来编译所有的软件包将产生更大体积更耗内存的二进制文件，大大增加编译失败的机会或不可预知的程序行为（包括错误）。这样做将得不偿失，记住过犹不及。在gcc 4.x.中使用-O3是不推荐的。<br>-Os<br>这个等级用来优化代码尺寸。其中启用了-O2中不会增加磁盘空间占用的代码生成选项。这对于磁盘空间极其紧张或者CPU缓存较小的机器非常有用。但也可能产生些许问题，因此软件树中的大部分ebuild都过滤掉这个等级的优化。使用-Os是不推荐的。<br>正如前面所提到的，-O2是推荐的优化等级。如果编译软件出现错误，请先检查是否启用了-O3。再试试把CFLAGS和CXXFLAGS倒回到较低的等级，如-O1甚或-O0 -g2 -ggdb（用来报告错误和检查可能存在的问题），再重新编译。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;杂记&quot;&gt;&lt;a href=&quot;#杂记&quot; class=&quot;headerlink&quot; title=&quot;杂记&quot;&gt;&lt;/a&gt;杂记&lt;/h3&gt;&lt;p&gt;本篇博客记录一些容易忘记的技巧, 或是一些解决常见问题的方法&lt;/p&gt;
&lt;h3 id=&quot;一-终端命令行参数&quot;&gt;&lt;a href=&quot;#一-终端命令</summary>
      
    
    
    
    
    <category term="cmake" scheme="http://okeyia.github.io/tags/cmake/"/>
    
    <category term="git代理" scheme="http://okeyia.github.io/tags/git%E4%BB%A3%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>机房预约系统</title>
    <link href="http://okeyia.github.io/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/"/>
    <id>http://okeyia.github.io/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-29T15:16:08.000Z</published>
    <updated>2022-04-17T08:52:21.490Z</updated>
    
    <content type="html"><![CDATA[<h1 id="机房预约系统"><a href="#机房预约系统" class="headerlink" title="./机房预约系统"></a>./机房预约系统</h1><h2 id="1、-机房预约系统需求"><a href="#1、-机房预约系统需求" class="headerlink" title="1、./机房预约系统需求"></a>1、./机房预约系统需求</h2><h3 id="1-1-系统简介"><a href="#1-1-系统简介" class="headerlink" title="1.1 系统简介"></a>1.1 系统简介</h3><ul><li>学校现有几个规格不同的机房，由于使用时经常出现”撞车”现象,现开发一套./机房预约系统，解决这一问题。</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682783885.png" class="" width="1548682783885"><h3 id="1-2-身份简介"><a href="#1-2-身份简介" class="headerlink" title="1.2 身份简介"></a>1.2 身份简介</h3><p>分别有三种身份使用该程序</p><ul><li><strong>学生代表</strong>：申请使用机房</li><li><strong>教师</strong>：审核学生的预约申请</li><li><strong>管理员</strong>：给学生、教师创建账号</li></ul><h3 id="1-3-机房简介"><a href="#1-3-机房简介" class="headerlink" title="1.3 机房简介"></a>1.3 机房简介</h3><p>机房总共有3间</p><ul><li>1号机房   — 最大容量20人</li><li>2号机房   — 最多容量50人</li><li>3号机房   — 最多容量100人</li></ul><h3 id="1-4-申请简介"><a href="#1-4-申请简介" class="headerlink" title="1.4 申请简介"></a>1.4 申请简介</h3><ul><li>申请的订单每周由管理员负责清空。</li><li>学生可以预约未来一周内的机房使用，预约的日期为周一至周五，预约时需要选择预约时段（上午、下午）</li><li>教师来审核预约，依据实际情况审核预约通过或者不通过</li></ul><h3 id="1-5-系统具体需求"><a href="#1-5-系统具体需求" class="headerlink" title="1.5 系统具体需求"></a>1.5 系统具体需求</h3><ul><li>首先进入登录界面，可选登录身份有：<ul><li>学生代表</li><li>老师</li><li>管理员</li><li>退出</li></ul></li><li>每个身份都需要进行验证后，进入子菜单<ul><li>学生需要输入 ：学号、姓名、登录密码</li><li>老师需要输入：职工号、姓名、登录密码</li><li>管理员需要输入：管理员姓名、登录密码</li></ul></li><li>学生具体功能<ul><li>申请预约    —   预约机房</li><li>查看自身的预约    —  查看自己的预约状态</li><li>查看所有预约   —   查看全部预约信息以及预约状态</li><li>取消预约    —   取消自身的预约，预约成功或审核中的预约均可取消</li><li>注销登录    —   退出登录</li></ul></li><li>教师具体功能<ul><li>查看所有预约   —   查看全部预约信息以及预约状态</li><li>审核预约    —   对学生的预约进行审核</li><li>注销登录    —   退出登录</li></ul></li><li>管理员具体功能<ul><li>添加账号    —   添加学生或教师的账号，需要检测学生编号或教师职工号是否重复</li><li>查看账号    —   可以选择查看学生或教师的全部信息</li><li>查看机房    —   查看所有机房的信息</li><li>清空预约    —   清空所有预约记录</li><li>注销登录    —   退出登录</li></ul></li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682206670.png" class="" width="1548682206670"><h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p><ul><li>创建新项目</li><li>添加文件</li></ul><h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><ul><li>打开vs2017后，点击创建新项目，创建新的C++项目</li></ul><p>如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682413343.png" class="" width="1548682413343"><ul><li>填写项目名称以及选取项目路径，点击确定生成项目</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682522544.png" class="" width="1548682522544"><h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><ul><li>右键源文件，进行添加文件操作</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682597721.png" class="" width="1548682597721"><ul><li>填写文件名称，点击添加</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682679989.png" class="" width="1548682679989"><ul><li>生成文件成功，效果如下图</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682733912.png" class="" width="1548682733912"><h2 id="3、创建主菜单"><a href="#3、创建主菜单" class="headerlink" title="3、创建主菜单"></a>3、创建主菜单</h2><p><strong>功能描述：</strong></p><ul><li>设计主菜单，与用户进行交互</li></ul><h3 id="3-1-菜单实现"><a href="#3-1-菜单实现" class="headerlink" title="3.1 菜单实现"></a>3.1 菜单实现</h3><ul><li>在主函数main中添加菜单提示，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客./机房预约系统  =====================&quot;</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548557945611.png" class="" width="1548557945611"><h3 id="3-2-搭建接口"><a href="#3-2-搭建接口" class="headerlink" title="3.2 搭建接口"></a>3.2 搭建接口</h3><ul><li>接受用户的选择，搭建接口</li><li>在main中添加代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客./机房预约系统  =====================&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select; <span class="comment">//接受用户选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (select)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//学生身份</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//老师身份</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//管理员身份</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出系统</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新选择！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，输入0、1、2、3会重新回到界面，输入其他提示输入有误，清屏后重新选择</p><p>效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548558694230.png" class="" width="1548558694230"><p>至此，界面搭建完毕</p><h2 id="4、-退出功能实现"><a href="#4、-退出功能实现" class="headerlink" title="4、 退出功能实现"></a>4、 退出功能实现</h2><h3 id="4-1-退出功能实现"><a href="#4-1-退出功能实现" class="headerlink" title="4.1 退出功能实现"></a>4.1 退出功能实现</h3><p>在main函数分支 0 选项中，添加退出程序的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎下一次使用&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548558992754.png" class="" width="1548558992754"><h3 id="4-2-测试退出功能"><a href="#4-2-测试退出功能" class="headerlink" title="4.2 测试退出功能"></a>4.2 测试退出功能</h3><p>运行程序，效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548559026436.png" class="" width="1548559026436"><p>至此，退出程序功能实现</p><h2 id="5、-创建身份类"><a href="#5、-创建身份类" class="headerlink" title="5、 创建身份类"></a>5、 创建身份类</h2><h3 id="5-1-身份的基类"><a href="#5-1-身份的基类" class="headerlink" title="5.1 身份的基类"></a>5.1 身份的基类</h3><ul><li>在整个系统中，有三种身份，分别为：学生代表、老师以及管理员</li><li>三种身份有其共性也有其特性，因此我们可以将三种身份抽象出一个身份基类<strong>identity</strong></li><li>在头文件下创建Identity.h文件</li></ul><p>Identity.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//身份抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Identity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作菜单</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name; <span class="comment">//用户名</span></span><br><span class="line"><span class="built_in">string</span> m_Pwd;  <span class="comment">//密码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548573329273.png" class="" width="1548573329273"><h3 id="5-2-学生类"><a href="#5-2-学生类" class="headerlink" title="5.2 学生类"></a>5.2 学生类</h3><h4 id="5-2-1-功能分析"><a href="#5-2-1-功能分析" class="headerlink" title="5.2.1 功能分析"></a>5.2.1 功能分析</h4><ul><li><p>学生类主要功能是可以通过类中成员函数，实现预约实验室操作</p></li><li><p>学生类中主要功能有：</p><ul><li>显示学生操作的菜单界面</li><li>申请预约</li><li>查看自身预约</li><li>查看所有预约</li><li>取消预约</li></ul></li></ul><h4 id="5-2-2-类的创建"><a href="#5-2-2-类的创建" class="headerlink" title="5.2.2 类的创建"></a>5.2.2 类的创建</h4><ul><li>在头文件以及源文件下创建 student.h 和 student.cpp文件</li></ul><p>student.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生学号</span></span><br><span class="line"><span class="keyword">int</span> m_Id;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>student.cpp中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student::Student()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-老师类"><a href="#5-3-老师类" class="headerlink" title="5.3 老师类"></a>5.3 老师类</h3><h4 id="5-3-1-功能分析"><a href="#5-3-1-功能分析" class="headerlink" title="5.3.1 功能分析"></a>5.3.1 功能分析</h4><ul><li><p>教师类主要功能是查看学生的预约，并进行审核</p></li><li><p>教师类中主要功能有：</p><ul><li><p>显示教师操作的菜单界面</p></li><li><p>查看所有预约</p></li><li><p>审核预约</p></li></ul></li></ul><h4 id="5-3-2-类的创建"><a href="#5-3-2-类的创建" class="headerlink" title="5.3.2 类的创建"></a>5.3.2 类的创建</h4><ul><li>在头文件以及源文件下创建 teacher.h 和 teacher.cpp文件</li></ul><p>teacher.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_EmpId; <span class="comment">//教师编号</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>teacher.cpp中添加如下代码:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;teacher.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher::Teacher()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-管理员类"><a href="#5-4-管理员类" class="headerlink" title="5.4 管理员类"></a>5.4 管理员类</h3><h4 id="5-4-1-功能分析"><a href="#5-4-1-功能分析" class="headerlink" title="5.4.1 功能分析"></a>5.4.1 功能分析</h4><ul><li><p>管理员类主要功能是对学生和老师账户进行管理，查看机房信息以及清空预约记录</p></li><li><p>管理员类中主要功能有：</p><ul><li><p>显示管理员操作的菜单界面</p></li><li><p>添加账号</p></li><li><p>查看账号</p></li><li><p>查看机房信息</p></li><li><p>清空预约记录</p></li></ul></li></ul><h4 id="5-4-2-类的创建"><a href="#5-4-2-类的创建" class="headerlink" title="5.4.2 类的创建"></a>5.4.2 类的创建</h4><ul><li>在头文件以及源文件下创建 manager.h 和 manager.cpp文件</li></ul><p>manager.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造  管理员姓名，密码</span></span><br><span class="line">Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showComputer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>manager.cpp中添加如下代码:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager::Manager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，所有身份类创建完毕，效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548574390768.png" class="" width="1548574390768"><h2 id="6、-登录模块"><a href="#6、-登录模块" class="headerlink" title="6、  登录模块"></a>6、  登录模块</h2><h3 id="6-1-全局文件添加"><a href="#6-1-全局文件添加" class="headerlink" title="6.1 全局文件添加"></a>6.1 全局文件添加</h3><p>功能描述：</p><ul><li>不同的身份可能会用到不同的文件操作，我们可以将所有的文件名定义到一个全局的文件中</li><li>在头文件中添加 <strong>globalFile.h</strong> 文件</li><li>并添加如下代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理员文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADMIN_FILE     <span class="meta-string">&quot;admin.txt&quot;</span></span></span><br><span class="line"><span class="comment">//学生文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENT_FILE   <span class="meta-string">&quot;student.txt&quot;</span></span></span><br><span class="line"><span class="comment">//教师文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEACHER_FILE   <span class="meta-string">&quot;teacher.txt&quot;</span></span></span><br><span class="line"><span class="comment">//机房信息文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPUTER_FILE  <span class="meta-string">&quot;computerRoom.txt&quot;</span></span></span><br><span class="line"><span class="comment">//订单文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORDER_FILE     <span class="meta-string">&quot;order.txt&quot;</span></span></span><br></pre></td></tr></table></figure><p>并且在同级目录下，创建这几个文件</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548575650130.png" class="" width="1548575650130"><h3 id="6-2-登录函数封装"><a href="#6-2-登录函数封装" class="headerlink" title="6.2  登录函数封装"></a>6.2  登录函数封装</h3><p>功能描述：</p><ul><li>根据用户的选择，进入不同的身份登录</li></ul><p>在预约系统的.cpp文件中添加全局函数 <code>void LoginIn(string fileName, int type)</code></p><p>参数：</p><ul><li>fileName  — 操作的文件名</li><li>type      —  登录的身份  （1代表学生、2代表老师、3代表管理员）</li></ul><p>LoginIn中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//登录功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoginIn</span><span class="params">(<span class="built_in">string</span> fileName, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Identity * person = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(fileName, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件不存在情况</span></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)<span class="comment">//学生登录</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你的学号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="comment">//教师登录</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你的职工号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入用户名：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//学生登录验证</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//教师登录验证</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//管理员登录验证</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;验证登录失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在main函数的不同分支中，填入不同的登录接口</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548575945985.png" class="" width="1548575945985"><h3 id="6-3-学生登录实现"><a href="#6-3-学生登录实现" class="headerlink" title="6.3 学生登录实现"></a>6.3 学生登录实现</h3><p>在student.txt文件中添加两条学生信息，用于测试</p><p>添加信息:   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 张三 <span class="number">123</span></span><br><span class="line"><span class="number">2</span> 李四 <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>第一列  代表  <strong>学号</strong></li><li>第二列  代表  <strong>学生姓名</strong></li><li>第三列  代表  <strong>密码</strong></li></ul><p>效果图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583693555.png" class="" width="1548583693555"><p>在Login函数的学生分支中加入如下代码，验证学生身份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生登录验证</span></span><br><span class="line"><span class="keyword">int</span> fId;</span><br><span class="line"><span class="built_in">string</span> fName;</span><br><span class="line"><span class="built_in">string</span> fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;学生验证登录成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">person = <span class="keyword">new</span> Student(id, name, pwd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加代码效果图</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583915819.png" class="" width="1548583915819"><p>测试：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583950828.png" class="" width="1548583950828"><h3 id="6-4-教师登录实现"><a href="#6-4-教师登录实现" class="headerlink" title="6.4 教师登录实现"></a>6.4 教师登录实现</h3><p>在teacher.txt文件中添加一条老师信息，用于测试</p><p>添加信息:   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 老王 <span class="number">123</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>第一列  代表  <strong>教师职工编号</strong></li><li>第二列  代表  <strong>教师姓名</strong></li><li>第三列  代表  <strong>密码</strong></li></ul><p>效果图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584030522.png" class="" width="1548584030522"><p>在Login函数的教师分支中加入如下代码，验证教师身份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//教师登录验证</span></span><br><span class="line"><span class="keyword">int</span> fId;</span><br><span class="line"><span class="built_in">string</span> fName;</span><br><span class="line"><span class="built_in">string</span> fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;教师验证登录成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">person = <span class="keyword">new</span> Teacher(id, name, pwd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加代码效果图</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584158339.png" class="" width="1548584158339"><p>测试：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584177003.png" class="" width="1548584177003"><h3 id="6-5-管理员登录实现"><a href="#6-5-管理员登录实现" class="headerlink" title="6.5 管理员登录实现"></a>6.5 管理员登录实现</h3><p>在admin.txt文件中添加一条管理员信息，由于我们只有一条管理员，因此本案例中没有添加管理员的功能</p><p>添加信息:   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin <span class="number">123</span></span><br></pre></td></tr></table></figure><p>其中：<code>admin</code>代表管理员用户名，<code>123</code>代表管理员密码</p><p>效果图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548577855190.png" class="" width="1548577855190"><p>在Login函数的管理员分支中加入如下代码，验证管理员身份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理员登录验证</span></span><br><span class="line"><span class="built_in">string</span> fName;</span><br><span class="line"><span class="built_in">string</span> fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;验证登录成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//登录成功后，按任意键进入管理员界面</span></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="comment">//创建管理员对象</span></span><br><span class="line">person = <span class="keyword">new</span> Manager(name,pwd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548588322712.png" class="" width="1548588322712"><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583245072.png" class="" width="1548583245072"><p>至此，所有身份的登录功能全部实现！</p><h2 id="7、-管理员模块"><a href="#7、-管理员模块" class="headerlink" title="7、 管理员模块"></a>7、 管理员模块</h2><h3 id="7-1-管理员登录和注销"><a href="#7-1-管理员登录和注销" class="headerlink" title="7.1  管理员登录和注销"></a>7.1  管理员登录和注销</h3><h4 id="7-1-1-构造函数"><a href="#7-1-1-构造函数" class="headerlink" title="7.1.1 构造函数"></a>7.1.1 构造函数</h4><ul><li>在Manager类的构造函数中，初始化管理员信息，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-2-管理员子菜单"><a href="#7-1-2-管理员子菜单" class="headerlink" title="7.1.2  管理员子菜单"></a>7.1.2  管理员子菜单</h4><ul><li>在./机房预约系统.cpp中，当用户登录的是管理员，添加管理员菜单接口</li><li>将不同的分支提供出来<ul><li>添加账号</li><li>查看账号</li><li>查看机房</li><li>清空预约</li><li>注销登录</li></ul></li><li>实现注销功能</li></ul><p>添加全局函数 <code>void managerMenu(Identity * &amp;manager)</code>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理员菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">managerMenu</span><span class="params">(Identity * &amp;manager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//管理员菜单</span></span><br><span class="line">manager-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Manager* man = (Manager*)manager;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)  <span class="comment">//添加账号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;添加账号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;addPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看账号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查看账号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;showPerson(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看机房</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查看机房&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;showComputer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//清空预约</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;清空预约&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;cleanFile();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> manager;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-3-菜单功能实现"><a href="#7-1-3-菜单功能实现" class="headerlink" title="7.1.3 菜单功能实现"></a>7.1.3 菜单功能实现</h4><ul><li>在实现成员函数<code>void Manager::operMenu()</code> 代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎管理员：&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.添加账号            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.查看账号            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.查看机房            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          4.清空预约            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-4-接口对接"><a href="#7-1-4-接口对接" class="headerlink" title="7.1.4 接口对接"></a>7.1.4 接口对接</h4><ul><li>管理员成功登录后，调用管理员子菜单界面</li><li>在管理员登录验证分支中，添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入管理员子菜单</span></span><br><span class="line">managerMenu(person);</span><br></pre></td></tr></table></figure><p>添加效果如：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589297779.png" class="" width="1548589297779"><p>测试对接，效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589344206.png" class="" width="1548589344206"><p>登录成功</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589328710.png" class="" width="1548589328710"><p>注销登录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589416576.png" class="" width="1548589416576"><p>至此，管理员身份可以成功登录以及注销</p><h3 id="7-2-添加账号"><a href="#7-2-添加账号" class="headerlink" title="7.2 添加账号"></a>7.2 添加账号</h3><p>功能描述：</p><ul><li>给学生或教师添加新的账号</li></ul><p>功能要求：</p><ul><li>添加时学生学号不能重复、教师职工号不能重复</li></ul><h4 id="7-2-1-添加功能实现"><a href="#7-2-1-添加功能实现" class="headerlink" title="7.2.1 添加功能实现"></a>7.2.1 添加功能实现</h4><p>在Manager的<strong>addPerson</strong>成员函数中，实现添加新账号功能，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入添加账号的类型&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、添加学生&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、添加老师&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fileName;</span><br><span class="line"><span class="built_in">string</span> tip;</span><br><span class="line">ofstream ofs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fileName = STUDENT_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fileName = TEACHER_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofs.open(fileName, ios::out | ios::app);</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;tip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入姓名： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pwd &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;添加成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试添加学生：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641024216.png" class="" width="1548641024216"><p>成功在学生文件中添加了一条信息</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641141027.png" class="" width="1548641141027"><p>测试添加教师：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641195834.png" class="" width="1548641195834"><p>成功在教师文件中添加了一条信息</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641237513.png" class="" width="1548641237513"><h4 id="7-2-2-去重操作"><a href="#7-2-2-去重操作" class="headerlink" title="7.2.2 去重操作"></a>7.2.2 去重操作</h4><p>功能描述：添加新账号时，如果是重复的学生编号，或是重复的教师职工编号，提示有误</p><h5 id="7-2-2-1-读取信息"><a href="#7-2-2-1-读取信息" class="headerlink" title="7.2.2.1 读取信息"></a>7.2.2.1 读取信息</h5><ul><li>要去除重复的账号，首先要先将学生和教师的账号信息获取到程序中，方可检测</li><li>在manager.h中，添加两个容器，用于存放学生和教师的信息</li><li>添加一个新的成员函数  <code>void initVector()</code> 初始化容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initVector</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; vStu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Teacher&gt; vTea;</span><br></pre></td></tr></table></figure><p>添加位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644354561.png" class="" width="1548644354561"><p>在Manager的有参构造函数中，获取目前的学生和教师信息</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::initVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取学生文件中信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(STUDENT_FILE, ios::in);</span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件读取失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">vStu.clear();</span><br><span class="line">     vTea.clear();</span><br><span class="line">    </span><br><span class="line">Student s;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; s.m_Id &amp;&amp; ifs &gt;&gt; s.m_Name &amp;&amp;  ifs &gt;&gt; s.m_Pwd)</span><br><span class="line">&#123;</span><br><span class="line">vStu.push_back(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前学生数量为： &quot;</span> &lt;&lt; vStu.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ifs.close(); <span class="comment">//学生初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取老师文件信息</span></span><br><span class="line">ifs.open(TEACHER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">Teacher t;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; t.m_EmpId &amp;&amp; ifs &gt;&gt; t.m_Name &amp;&amp;  ifs &gt;&gt; t.m_Pwd)</span><br><span class="line">&#123;</span><br><span class="line">vTea.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前教师数量为： &quot;</span> &lt;&lt; vTea.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有参构造函数中，调用初始化容器函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initVector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，运行代码可以看到测试代码获取当前学生和教师数量</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548642488049.png" class="" width="1548642488049"><h5 id="7-2-2-2-去重函数封装"><a href="#7-2-2-2-去重函数封装" class="headerlink" title="7.2.2.2 去重函数封装"></a>7.2.2.2 去重函数封装</h5><p>在manager.h文件中添加成员函数<code> bool checkRepeat(int id, int type);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测重复 参数:(传入id，传入类型) 返回值：(true 代表有重复，false代表没有重复)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkRepeat</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><p>在manager.cpp文件中实现成员函数  <code> bool checkRepeat(int id, int type);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Manager::checkRepeat</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = vStu.begin(); it != vStu.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == it-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Teacher&gt;::iterator it = vTea.begin(); it != vTea.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == it-&gt;m_EmpId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-2-3-添加去重操作"><a href="#7-2-2-3-添加去重操作" class="headerlink" title="7.2.2.3 添加去重操作"></a>7.2.2.3 添加去重操作</h5><p>在添加学生编号或者教师职工号时，检测是否有重复，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> errorTip; <span class="comment">//重复错误提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fileName = STUDENT_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">errorTip = <span class="string">&quot;学号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fileName = TEACHER_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">errorTip = <span class="string">&quot;职工号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">ofs.open(fileName, ios::out | ios::app);</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;tip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ret = <span class="keyword">this</span>-&gt;checkRepeat(id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret) <span class="comment">//有重复</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; errorTip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548643909979.png" class="" width="1548643909979"><p>检测效果：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644151974.png" class="" width="1548644151974"><h5 id="7-2-2-4-bug解决"><a href="#7-2-2-4-bug解决" class="headerlink" title="7.2.2.4 bug解决"></a>7.2.2.4 bug解决</h5><p>bug描述：</p><ul><li>虽然可以检测重复的账号，但是刚添加的账号由于没有更新到容器中，因此不会做检测</li><li>导致刚加入的账号的学生号或者职工编号，再次添加时依然可以重复</li></ul><p>解决方案：</p><ul><li>在每次添加新账号时，重新初始化容器</li></ul><p>在添加完毕后，加入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initVector();</span><br></pre></td></tr></table></figure><p>位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644779578.png" class="" width="1548644779578"><p>再次测试，刚加入的账号不会重复添加了！</p><h3 id="7-3-显示账号"><a href="#7-3-显示账号" class="headerlink" title="7.3  显示账号"></a>7.3  显示账号</h3><p>功能描述：显示学生信息或教师信息</p><h4 id="7-3-1-显示功能实现"><a href="#7-3-1-显示功能实现" class="headerlink" title="7.3.1 显示功能实现"></a>7.3.1 显示功能实现</h4><p>在Manager的<strong>showPerson</strong>成员函数中，实现显示账号功能，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;学号： &quot;</span> &lt;&lt; s.m_Id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; s.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; s.m_Pwd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTeacher</span><span class="params">(Teacher &amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;职工号： &quot;</span> &lt;&lt; t.m_EmpId &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; t.m_Pwd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择查看内容：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、查看所有学生&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、查看所有老师&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;所有学生信息如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(vStu.begin(), vStu.end(), printStudent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;所有老师信息如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(vTea.begin(), vTea.end(), printTeacher);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-2-测试"><a href="#7-3-2-测试" class="headerlink" title="7.3.2 测试"></a>7.3.2 测试</h4><p>测试查看学生效果</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548646791248.png" class="" width="1548646791248"><p>测试查看教师效果</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548646833665.png" class="" width="1548646833665"><p>至此，显示账号功能实现完毕</p><h3 id="7-4-查看机房"><a href="#7-4-查看机房" class="headerlink" title="7.4 查看机房"></a>7.4 查看机房</h3><h4 id="7-4-1-添加机房信息"><a href="#7-4-1-添加机房信息" class="headerlink" title="7.4.1 添加机房信息"></a>7.4.1 添加机房信息</h4><p>案例需求中，机房一共有三个，其中1号机房容量20台机器，2号50台，3号100台</p><p>我们可以将信息录入到computerRoom.txt中</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548647538570.png" class="" width="1548647538570"><h4 id="7-4-2-机房类创建"><a href="#7-4-2-机房类创建" class="headerlink" title="7.4.2 机房类创建"></a>7.4.2 机房类创建</h4><p>在头文件下，创建新的文件 computerRoom.h</p><p>并添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//机房类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputerRoom</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_ComId; <span class="comment">//机房id号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_MaxNum; <span class="comment">//机房最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-4-3-初始化机房信息"><a href="#7-4-3-初始化机房信息" class="headerlink" title="7.4.3 初始化机房信息"></a>7.4.3 初始化机房信息</h4><p>在Manager管理员类下，添加机房的容器,用于保存机房信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure><p>在Manager有参构造函数中，追加如下代码，初始化机房信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line"></span><br><span class="line">ifs.open(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">vCom.push_back(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前机房数量为： &quot;</span> &lt;&lt; vCom.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure><p>位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548647976462.png" class="" width="1548647976462"><p>因为机房信息目前版本不会有所改动，如果后期有修改功能，最好封装到一个函数中，方便维护</p><h4 id="7-4-4-显示机房信息"><a href="#7-4-4-显示机房信息" class="headerlink" title="7.4.4 显示机房信息"></a>7.4.4 显示机房信息</h4><p>在Manager类的showComputer成员函数中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;机房信息如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;ComputerRoom&gt;::iterator it = vCom.begin(); it != vCom.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;机房编号： &quot;</span> &lt;&lt; it-&gt;m_ComId &lt;&lt; <span class="string">&quot; 机房最大容量： &quot;</span> &lt;&lt; it-&gt;m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试显示机房信息功能：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548648276929.png" class="" width="1548648276929"><h3 id="7-5-清空预约"><a href="#7-5-清空预约" class="headerlink" title="7.5 清空预约"></a>7.5 清空预约</h3><p>功能描述：</p><p>清空生成的<code>order.txt</code>预约文件</p><h4 id="7-5-1-清空功能实现"><a href="#7-5-1-清空功能实现" class="headerlink" title="7.5.1 清空功能实现"></a>7.5.1 清空功能实现</h4><p>在Manager的cleanFile成员函数中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::trunc)</span></span>;</span><br><span class="line">ofs.close();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试清空，可以随意写入一些信息在order.txt中，然后调用cleanFile清空文件接口，查看是否清空干净</p><h2 id="8、-学生模块"><a href="#8、-学生模块" class="headerlink" title="8、 学生模块"></a>8、 学生模块</h2><h3 id="8-1-学生登录和注销"><a href="#8-1-学生登录和注销" class="headerlink" title="8.1 学生登录和注销"></a>8.1 学生登录和注销</h3><h4 id="8-1-1-构造函数"><a href="#8-1-1-构造函数" class="headerlink" title="8.1.1 构造函数"></a>8.1.1 构造函数</h4><ul><li>在Student类的构造函数中，初始化学生信息，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-2-管理员子菜单"><a href="#8-1-2-管理员子菜单" class="headerlink" title="8.1.2  管理员子菜单"></a>8.1.2  管理员子菜单</h4><ul><li>在./机房预约系统.cpp中，当用户登录的是学生，添加学生菜单接口</li><li>将不同的分支提供出来<ul><li>申请预约</li><li>查看我的预约</li><li>查看所有预约</li><li>取消预约</li><li>注销登录</li></ul></li><li>实现注销功能</li></ul><p>添加全局函数 <code>void studentMenu(Identity * &amp;manager)</code> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">studentMenu</span><span class="params">(Identity * &amp;student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//学生菜单</span></span><br><span class="line">student-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Student* stu = (Student*)student;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//申请预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;applyOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看自身预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;showMyOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看所有预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;showAllOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//取消预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;cancelOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> student;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-3-菜单功能实现"><a href="#8-1-3-菜单功能实现" class="headerlink" title="8.1.3 菜单功能实现"></a>8.1.3 菜单功能实现</h4><ul><li>在实现成员函数<code>void Student::operMenu()</code> 代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎学生代表：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.申请预约              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.查看我的预约          |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.查看所有预约          |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          4.取消预约              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-4-接口对接"><a href="#8-1-4-接口对接" class="headerlink" title="8.1.4 接口对接"></a>8.1.4 接口对接</h4><ul><li>学生成功登录后，调用学生的子菜单界面</li><li>在学生登录分支中，添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入学生子菜单</span></span><br><span class="line">studentMenu(person);</span><br></pre></td></tr></table></figure><p>添加效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659552298.png" class="" width="1548659552298"><p>测试对接，效果如图：</p><p>登录验证通过：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659590221.png" class="" width="1548659590221"><p>学生子菜单：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659670651.png" class="" width="1548659670651"><p>注销登录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659682402.png" class="" width="1548659682402"><h3 id="8-2-申请预约"><a href="#8-2-申请预约" class="headerlink" title="8.2 申请预约"></a>8.2 申请预约</h3><h4 id="8-2-1-获取机房信息"><a href="#8-2-1-获取机房信息" class="headerlink" title="8.2.1 获取机房信息"></a>8.2.1 获取机房信息</h4><ul><li>在申请预约时，学生可以看到机房的信息，因此我们需要让学生获取到机房的信息</li></ul><p>在student.h中添加新的成员函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure><p>在学生的有参构造函数中追加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">vCom.push_back(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure><p>追加位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548661562158.png" class="" width="1548661562158"><p>至此，vCom容器中保存了所有机房的信息</p><h4 id="8-2-2-预约功能实现"><a href="#8-2-2-预约功能实现" class="headerlink" title="8.2.2 预约功能实现"></a>8.2.2 预约功能实现</h4><p>在student.cpp中实现成员函数 <code>void Student::applyOrder()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;机房开放时间为周一至周五！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入申请预约的时间：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、周一&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、周二&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3、周三&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4、周四&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5、周五&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> date = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> interval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> room = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line"><span class="keyword">if</span> (date &gt;= <span class="number">1</span> &amp;&amp; date &lt;= <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入申请预约的时间段：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、上午&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、下午&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; interval;</span><br><span class="line"><span class="keyword">if</span> (interval &gt;= <span class="number">1</span> &amp;&amp; interval &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择机房：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">0</span>].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">1</span>].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">2</span>].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; room;</span><br><span class="line"><span class="keyword">if</span> (room &gt;= <span class="number">1</span> &amp;&amp; room &lt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约成功！审核中&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::app)</span></span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; date &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; interval &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; room &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ofs.close();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，测试代码:</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548728936052.png" class="" width="1548728936052"><p>在order.txt文件中生成如下内容：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548662281801.png" class="" width="1548662281801"><h3 id="8-3-显示预约"><a href="#8-3-显示预约" class="headerlink" title="8.3 显示预约"></a>8.3 显示预约</h3><h4 id="8-3-1-创建预约类"><a href="#8-3-1-创建预约类" class="headerlink" title="8.3.1 创建预约类"></a>8.3.1 创建预约类</h4><p>功能描述：显示预约记录时，需要从文件中获取到所有记录，用来显示，创建预约的类来管理记录以及更新</p><p>在头文件以及源文件下分别创建<strong>orderFile.h</strong> 和 <strong>orderFile.cpp</strong>文件</p><p>orderFile.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">OrderFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录的容器  key --- 记录的条数  value --- 具体记录的键值对信息</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; m_orderData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预约记录条数</span></span><br><span class="line"><span class="keyword">int</span> m_Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong>中获取所有信息，并存放在容器中，添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">OrderFile::OrderFile()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(ORDER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> date;      <span class="comment">//日期</span></span><br><span class="line"><span class="built_in">string</span> interval;  <span class="comment">//时间段</span></span><br><span class="line"><span class="built_in">string</span> stuId;     <span class="comment">//学生编号</span></span><br><span class="line"><span class="built_in">string</span> stuName;   <span class="comment">//学生姓名</span></span><br><span class="line"><span class="built_in">string</span> roomId;    <span class="comment">//机房编号</span></span><br><span class="line"><span class="built_in">string</span> status;    <span class="comment">//预约状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>; <span class="comment">//预约记录个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; date &amp;&amp; ifs &gt;&gt; interval &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; roomId &amp;&amp;  ifs &gt;&gt; status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cout &lt;&lt; date &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; interval &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; stuId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; stuName &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; roomId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; status &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> key;</span><br><span class="line"><span class="built_in">string</span> value;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = date.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = date.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = date.substr(pos + <span class="number">1</span>, date.size() - pos <span class="number">-1</span>);</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = interval.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = interval.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = interval.substr(pos + <span class="number">1</span>, interval.size() - pos <span class="number">-1</span> );</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = stuId.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = stuId.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = stuId.substr(pos + <span class="number">1</span>, stuId.size() - pos <span class="number">-1</span> );</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = stuName.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = stuName.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = stuName.substr(pos + <span class="number">1</span>, stuName.size() - pos <span class="number">-1</span>);</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = roomId.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = roomId.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = roomId.substr(pos + <span class="number">1</span>, roomId.size() - pos <span class="number">-1</span> );</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = status.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = status.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = status.substr(pos + <span class="number">1</span>, status.size() - pos <span class="number">-1</span>);</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_orderData.insert(<span class="built_in">make_pair</span>(<span class="keyword">this</span>-&gt;m_Size, m));</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//for (map&lt;int, map&lt;string, string&gt;&gt;::iterator it = m_orderData.begin(); it != m_orderData.end();it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for (map&lt;string, string&gt;::iterator mit = it-&gt;second.begin(); mit != it-&gt;second.end(); mit++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; mit-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; mit-&gt;second &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更新预约记录的成员函数updateOrder代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OrderFile::updateOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::out | ios::trunc)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_Size;i++)</span><br><span class="line">&#123;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;date&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;interval&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuName&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;roomId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;status&quot;</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-2-显示自身预约"><a href="#8-3-2-显示自身预约" class="headerlink" title="8.3.2 显示自身预约"></a>8.3.2 显示自身预约</h4><p>首先我们先添加几条预约记录，可以用程序添加或者直接修改order.txt文件</p><p>order.txt文件内容如下： 比如我们有三名同学分别产生了3条预约记录</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667534747.png" class="" width="1548667534747"><p>在Student类的<code>void Student::showMyOrder()</code>成员函数中，添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (atoi(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].c_str()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667252474.png" class="" width="1548667252474"><h4 id="8-3-3-显示所有预约"><a href="#8-3-3-显示所有预约" class="headerlink" title="8.3.3 显示所有预约"></a>8.3.3 显示所有预约</h4><p>在Student类的<code>void Student::showAllOrder()</code>成员函数中，添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667591734.png" class="" width="1548667591734"><h3 id="8-4-取消预约"><a href="#8-4-取消预约" class="headerlink" title="8.4 取消预约"></a>8.4 取消预约</h3><p>在Student类的<code>void Student::cancelOrder()</code>成员函数中，添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;审核中或预约成功的记录可以取消，请输入取消的记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (atoi(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].c_str()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span> || of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  index ++  &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入取消的记录,0代表返回&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"><span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;记录所在位置： &quot; &lt;&lt; v[select - 1] &lt;&lt; endl;</span></span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">of.updateOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;已取消预约&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试取消预约：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669551036.png" class="" width="1548669551036"><p>再次查看个人预约记录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669728023.png" class="" width="1548669728023"><p>查看所有预约</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669753496.png" class="" width="1548669753496"><p>查看order.txt预约文件</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669798037.png" class="" width="1548669798037"><p>至此，学生模块功能全部实现</p><h2 id="9、-教师模块"><a href="#9、-教师模块" class="headerlink" title="9、 教师模块"></a>9、 教师模块</h2><h3 id="9-1-教师登录和注销"><a href="#9-1-教师登录和注销" class="headerlink" title="9.1 教师登录和注销"></a>9.1 教师登录和注销</h3><h4 id="9-1-1-构造函数"><a href="#9-1-1-构造函数" class="headerlink" title="9.1.1 构造函数"></a>9.1.1 构造函数</h4><ul><li>在Teacher类的构造函数中，初始化教师信息，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpId = empId;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-2-教师子菜单"><a href="#9-1-2-教师子菜单" class="headerlink" title="9.1.2  教师子菜单"></a>9.1.2  教师子菜单</h4><ul><li>在./机房预约系统.cpp中，当用户登录的是教师，添加教师菜单接口</li><li>将不同的分支提供出来<ul><li>查看所有预约</li><li>审核预约</li><li>注销登录</li></ul></li><li>实现注销功能</li></ul><p>添加全局函数 <code>void TeacherMenu(Person * &amp;manager)</code> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//教师菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TeacherMenu</span><span class="params">(Identity * &amp;teacher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//教师菜单</span></span><br><span class="line">teacher-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Teacher* tea = (Teacher*)teacher;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line">tea-&gt;showAllOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line">tea-&gt;validOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> teacher;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-3-菜单功能实现"><a href="#9-1-3-菜单功能实现" class="headerlink" title="9.1.3 菜单功能实现"></a>9.1.3 菜单功能实现</h4><ul><li>在实现成员函数<code>void Teacher::operMenu()</code> 代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//教师菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎教师：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.查看所有预约          |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.审核预约              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-4-接口对接"><a href="#9-1-4-接口对接" class="headerlink" title="9.1.4 接口对接"></a>9.1.4 接口对接</h4><ul><li>教师成功登录后，调用教师的子菜单界面</li><li>在教师登录分支中，添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入教师子菜单</span></span><br><span class="line">TeacherMenu(person);</span><br></pre></td></tr></table></figure><p>添加效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670866708.png" class="" width="1548670866708"><p>测试对接，效果如图：</p><p>登录验证通过：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670949885.png" class="" width="1548670949885"><p>教师子菜单：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670958602.png" class="" width="1548670958602"><p>注销登录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670966988.png" class="" width="1548670966988"><h3 id="9-2-查看所有预约"><a href="#9-2-查看所有预约" class="headerlink" title="9.2 查看所有预约"></a>9.2 查看所有预约</h3><h4 id="9-2-1-所有预约功能实现"><a href="#9-2-1-所有预约功能实现" class="headerlink" title="9.2.1 所有预约功能实现"></a>9.2.1 所有预约功能实现</h4><p>该功能与学生身份的查看所有预约功能相似，用于显示所有预约记录</p><p>在Teacher.cpp中实现成员函数 <code>void Teacher::showAllOrder()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-2-测试功能"><a href="#9-2-2-测试功能" class="headerlink" title="9.2.2 测试功能"></a>9.2.2 测试功能</h4><p>运行测试教师身份的查看所有预约功能</p><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548676922678.png" class="" width="1548676922678"><h3 id="9-3-审核预约"><a href="#9-3-审核预约" class="headerlink" title="9.3 审核预约"></a>9.3 审核预约</h3><h4 id="9-3-1-审核功能实现"><a href="#9-3-1-审核功能实现" class="headerlink" title="9.3.1 审核功能实现"></a>9.3.1 审核功能实现</h4><p>功能描述：教师审核学生的预约，依据实际情况审核预约</p><p>在Teacher.cpp中实现成员函数 <code>void Teacher::validOrder()</code></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;待审核的预约记录如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ++index &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入审核的预约记录,0代表返回&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"><span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入审核结果&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、通过&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、不通过&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">of.updateOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;审核完毕！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-2-测试审核预约"><a href="#9-3-2-测试审核预约" class="headerlink" title="9.3.2 测试审核预约"></a>9.3.2 测试审核预约</h4><p>测试 - 审核通过</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677286679.png" class="" width="1548677286679"><p>审核通过情况</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677383681.png" class="" width="1548677383681"><p>测试-审核未通过</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677402705.png" class="" width="1548677402705"><p>审核未通过情况：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677632792.png" class="" width="1548677632792"><p>学生身份下查看记录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677798815.png" class="" width="1548677798815"><p>审核预约成功！</p><p>至此本案例制作完毕！  <code>^_^</code></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;机房预约系统&quot;&gt;&lt;a href=&quot;#机房预约系统&quot; class=&quot;headerlink&quot; title=&quot;./机房预约系统&quot;&gt;&lt;/a&gt;./机房预约系统&lt;/h1&gt;&lt;h2 id=&quot;1、-机房预约系统需求&quot;&gt;&lt;a href=&quot;#1、-机房预约系统需求&quot; class=&quot;he</summary>
      
    
    
    
    
    <category term="C++" scheme="http://okeyia.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>二 高性能服务器框架</title>
    <link href="http://okeyia.github.io/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
    <id>http://okeyia.github.io/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/</id>
    <published>2022-01-29T03:05:24.000Z</published>
    <updated>2023-03-09T06:17:21.665Z</updated>
    
    <content type="html"><![CDATA[<h2 id="第二篇-高性能服务器框架"><a href="#第二篇-高性能服务器框架" class="headerlink" title="第二篇 高性能服务器框架"></a>第二篇 高性能服务器框架</h2><h3 id="第5章-Linux网络编程基础API"><a href="#第5章-Linux网络编程基础API" class="headerlink" title="第5章 Linux网络编程基础API"></a>第5章 Linux网络编程基础API</h3><p>我们将从如 下3个方面讨论Linux网络API：</p><ul><li>socket地址API。socket最开始的含义是一个IP地址和端口对 （ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket 地址。</li><li>socket基础API。socket的主要API都定义在sys/socket.h头文件 中，包括创建socket、命名socket、监听socket、接受连接、发起连接、 读写数据、获取地址信息、检测带外标记，以及读取和设置socket选 项。</li><li>网络信息API。Linux提供了一套网络信息API，以实现主机名和 IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定 义在netdb.h头文件中，我们将讨论其中几个主要的函数。</li></ul><h4 id="5-1-socket地址API"><a href="#5-1-socket地址API" class="headerlink" title="5.1 socket地址API"></a>5.1 socket地址API</h4><h5 id="5-1-1-主机字节序和网络字节序"><a href="#5-1-1-主机字节序和网络字节序" class="headerlink" title="5.1.1 主机字节序和网络字节序"></a>5.1.1 主机字节序和网络字节序</h5><p>现代CPU的累加器一次都能装载（至少）4字节（这里考虑32位 机，下同），即一个整数。那么这4字节在内存中排列的顺序将影响它 被累加器装载成的整数的值。这就是字节序问题。</p><p>字节序分为大端字 节序（big endian）和小端字节序（little endian）。</p><ul><li>大端字节序是指一 个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0 ～7 bit）存储在内存的高地址处。</li><li>小端字节序则是指整数的高位字节存 储在内存的高地址处，而低位字节则存储在内存的低地址处。</li></ul><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224104317174-1678341964415.png" class="" title="image-20230224104317174"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断机器字节序</span></span><br><span class="line"><span class="comment">// union 参考https://www.cnblogs.com/linyx/p/3998893.html</span></span><br><span class="line"><span class="comment">// 在一个union类型结构中,所有的成员公用同样的存储空间,其占用的大小为其成员中需要空间最大者；</span></span><br><span class="line"><span class="comment">// union本身只保留一块地址空间，因为只有一个成员真正存储于该地址， 但这块地址也要满足内存对齐原则。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">byteorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">short</span> value;</span><br><span class="line"><span class="keyword">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">&#125; test;</span><br><span class="line"></span><br><span class="line">test.value = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;little endian\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unknown...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送端总是把要发送的数据转化成大端字节序数据后 再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所 以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转 换（小端机转换，大端机不转换）。</p><p>因此大端字节序也称为网络字节 序，它给所有接收数据的主机提供了一个正确解释收到的格式化数据 的保证。</p><p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的 转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="comment">// 如htonl表示“host to network long”，即将长整型（32 bit）的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="5-1-2-通用socket地址"><a href="#5-1-2-通用socket地址" class="headerlink" title="5.1.2 通用socket地址"></a>5.1.2 通用socket地址</h5><p>socket网络编程接口中表示socket地址的是结构体sockaddr，其定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sa_family成员是地址族类型（sa_family_t）的变量。地址族类型通 常与协议族类型对应。常见的协议族（protocol family，也称domain， 见后文）和对应的地址族如表5-1所示。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224120412533-1678341964416.png" class="" title="image-20230224120412533"><p>宏PF_<em>和AF_</em>都定义在bits/socket.h头文件中，且后者与前者有完 全相同的值，所以二者通常混用。</p><p>sa_data成员用于存放socket地址值。但是，不同的协议族的地址值 具有不同的含义和长度，如表5-2所示。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224133658704-1678341964416.png" class="" title="image-20230224133658704"><p>由表5-2可见，<strong>14字节的sa_data根本无法完全容纳多数协议族的地 址值。</strong>因此，Linux定义了下面这个新的通用socket地址结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> int__ss_align;</span><br><span class="line"><span class="keyword">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-3-专用socket地址"><a href="#5-1-3-专用socket地址" class="headerlink" title="5.1.3 专用socket地址"></a>5.1.3 专用socket地址</h5><p>上面这两个通用socket地址结构体显然很不好用，比如设置与获取 IP地址和端口号就需要执行烦琐的位操作。</p><p>所以Linux为各个协议族提 供了专门的socket地址结构体。UNix忽略.</p><p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构 体，它们分别用于IPv4和IPv6：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipV4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_INET*/</span></span><br><span class="line"><span class="keyword">u_int16_t</span> sin_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/*IPv4地址结构体，见下面*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">u_int32_t</span> s_addr;  <span class="comment">/*IPv4地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipV6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin6_family;<span class="comment">/*地址族：AF_INET6*/</span></span><br><span class="line"><span class="keyword">u_int16_t</span> sin6_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line"><span class="keyword">u_int32_t</span> sin6_flowinfo;<span class="comment">/*流信息，应设置为0*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/*IPv6地址结构体，见下面*/</span></span><br><span class="line"><span class="keyword">u_int32_t</span> sin6_scope_id;<span class="comment">/*scope ID，尚处于实验阶段*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];<span class="comment">/*IPv6地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使 用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因 为所有socket编程接口使用的地址参数的类型都是sockaddr。</strong></p><h5 id="5-1-4-IP地址转换函数"><a href="#5-1-4-IP地址转换函数" class="headerlink" title="5.1.4 IP地址转换函数"></a>5.1.4 IP地址转换函数</h5><p>下 面3个函数可用于用<strong>点分十进制字符串表示的IPv4地址</strong>和用<strong>网络字节序 整数表示的IPv4地址</strong>之间的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络 字节序整数表示的IPv4地址。它失败时返回INADDR_NONE。</p></li><li><p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于 参数inp指向的地址结构中。它成功时返回1，失败则返回0。</p></li><li><p>inet_ntoa函数将用网络字节序整数表示的IPv4地址转化为用点分十 进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，<strong>函数的返回值指向该静态内存</strong>，因此inet_ntoa是 不可重入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* szValue1=inet_ntoa(“<span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>”);</span><br><span class="line"><span class="keyword">char</span>* szValue2=inet_ntoa(“<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span>”);</span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">1</span>:%s\n”,szValue1);</span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">2</span>:%s\n”,szValue2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">address1:<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br><span class="line">address2:<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br></pre></td></tr></table></figure></li></ul><p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且它 们同时适用于IPv4地址和IPv6地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">char</span>* dst,<span class="keyword">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>inet_pton函数将用字符串表示的IP地址src（用点分十进制字符串表 示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节 序整数表示的IP地址，并把<strong>转换结果存储于dst指向的内存中</strong>。其中，af 参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返 回1，失败则返回0并设置errno[1]。</li><li>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参 数相同，最后一个参数cnt指定目标存储单元的大小。</li></ul><h4 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h4><p>UNIX/Linux的一个哲学是：所有东西都是文件。socket也不例 外，它就是可读、可写、可控制、可关闭的文件描述符。</p><p>下面的 socket系统调用可创建一个socket：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>domain参数告诉系统使用哪个底层协议族。对TCP/IP协议族而 言，该参数应该设置为PF_INET（Protocol Family of Internet，用于 IPv4）或PF_INET6（用于IPv6）；对于UNIX本地域协议族而言，该 参数应该设置为PF_UNIX。</li><li>type参数指定服务类型。服务类型主要有SOCK_STREAM服务 （流服务）和SOCK_UGRAM（数据报）服务。<strong>对TCP/IP协议族而 言，其值取SOCK_STREAM表示传输层使用TCP协议，取 SOCK_DGRAM表示传输层使用UDP协议。</strong></li><li>protocol参数是在前两个参数构成的协议集合下，再选择一个具体 的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它 的值）。几乎在所有情况下，我们都应该把它设置为0，表示使用默认 协议。</li></ul><p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1 并设置errno。</p><h4 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h4><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地 址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给 socket命名。</p><p>只有命名 后客户端才能知道该如何连接它。客户端则通常不需要命名socket， 而是采用匿名方式，即使用操作系统自动分配的socket地址。命名 socket的系统调用是bind，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>bind将my_addr所指的socket地址分配给未命名的sockfd文件描述 符，addrlen参数指出该socket地址的长度。</p><p>bind成功时返回0，失败则返回-1并设置errno。其中两种常见的 errno是EACCES和EADDRINUSE，它们的含义分别是：</p><ul><li>EACCES，被绑定的地址是受保护的地址，仅超级用户能够访 问。比如普通用户将socket绑定到知名服务端口（端口号为0～1023） 上时，bind将返回EACCES错误。</li><li>EADDRINUSE，被绑定的地址正在使用中。比如将socket绑定 到一个处于TIME_WAIT状态的socket地址。</li></ul><h4 id="5-4-监听socket"><a href="#5-4-监听socket" class="headerlink" title="5.4 监听socket"></a>5.4 监听socket</h4><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如 下系统调用来创建一个监听队列以存放待处理的客户连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客 户连接，客户端也将收到ECONNREFUSED错误信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/2/24.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_term</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">signal(SIGTERM, handle_term);</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number backlog\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> backlog = atoi(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sock&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建一个IPv4 socket地址*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inet_pton函数将用字符串表示的IP地址 src 转换成用网络字节 序整数表示的IP地址，</span></span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> ret = bind(sock,(struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = listen(sock, backlog);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*循环等待连接，直到有SIGTERM信号将它中断*/</span></span><br><span class="line"><span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*关闭socket，见后文*/</span></span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224203335190-1678341964416.png" class="" title="image-20230224203335190"><p>可见，在监听队列中，处于ESTABLISHED状态的连接只有6个 （backlog值加1），其他的连接都处于SYN_RCVD状态。</p><h4 id="5-5-接受连接"><a href="#5-5-接受连接" class="headerlink" title="5.5 接受连接"></a>5.5 接受连接</h4><p>下面的系统调用从listen监听队列中接受一个连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd参数是执行过listen系统调用的监听socket[1]。</li><li>addr参数用来获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数 指出。</li></ul><p>accept成功时返回一个新的连接socket，该socket唯一地标识了 被接受的这个连接，服务器可通过读写该socket来与被接受连接对应 的客户端通信。accept失败时返回-1并设置errno。</p><p>如果监听队列中处于ESTABLISHED状态的 连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么 服务器对这个连接执行的accept调用是否成功？</p><p>做实验说明,   <strong>accept只是从监听队列中取出连接，而不论连接处于 何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更 不关心任何网络状况的变化。</strong></p><h4 id="5-6-发起连接"><a href="#5-6-发起连接" class="headerlink" title="5.6 发起连接"></a>5.6 发起连接</h4><p>客户端主动建立连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数由socket系统调用返回一个socket。serv_addr参数是服 务器监听的socket地址，addrlen参数则指定这个地址的长度。</p><p>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了 这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失 败则返回-1并设置errno。</p><p>其中两种常见的errno是ECONNREFUSED和 ETIMEDOUT，它们的含义如下： </p><ul><li><p>ECONNREFUSED，目标端口不存在，连接被拒绝。我们在 3.5.1小节讨论过这种情况。 </p></li><li><p>ETIMEDOUT，连接超时。我们在3.3.3小节讨论过这种情况。</p></li></ul><h4 id="5-7-关闭连接"><a href="#5-7-关闭连接" class="headerlink" title="5.7 关闭连接"></a>5.7 关闭连接</h4><p>关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下<strong>关闭普通文件描述符的系统调用</strong>来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>fd参数是待关闭的socket。不过，close系统调用并非总是立即关闭 一个连接，而是将fd的引用计数减1。<strong>只有当fd的引用计数为0时，才真正关闭连接。</strong>多进程程序中，一次fork系统调用默认将使父进程中打开 的socket的引用计数加1，因此我们必须在父进程和子进程中都对该 socket执行close调用才能将连接关闭。</p><p>如果想强制关闭的话, 可以使用如下的shutdown系统调用（相对于close来说，它是专门 为网络编程设计的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数是待关闭的socket。howto参数决定了shutdown的行为， 它可取表5-3中的某个值。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224204515803-1678341964416.png" class="" title="image-20230224204515803"><p>由此可见，shutdown能够分别关闭socket上的读或写，或者都关 闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p><h4 id="5-8-数据读写"><a href="#5-8-数据读写" class="headerlink" title="5.8 数据读写"></a>5.8 数据读写</h4><h5 id="5-8-1-TCP数据读写"><a href="#5-8-1-TCP数据读写" class="headerlink" title="5.8.1 TCP数据读写"></a>5.8.1 TCP数据读写</h5><p><strong>对文件的读写操作read和write同样适用于socket。</strong>但是socket编程接 口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据 读写的控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">void</span>*buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">const</span> <span class="keyword">void</span>*buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置 和大小，flags参数的含义见后文，通常设置为0即可。</strong></p><p>recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们 可能要多次调用recv，才能读取到完整的数据。recv可能返回0，这意 味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。</p><p>send往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置 和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置 errno。</p><p>flags参数为数据收发提供了额外的控制，它可以取表5-4所示选项 中的一个或几个的逻辑或。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224205138815-1678341964416.png" class="" title="image-20230224205138815"><p>实验结果: </p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224211104916-1678341964416.png" class="" title="image-20230224211104916"><p>客户端发送给服务器的3字节的带外数据“abc”中，仅有 最后一个字符“c”被服务器当成真正的带外数据接收（正如3.8节讨论的 那样）。并且，服务器对正常数据的接收将被带外数据截断，即前一 部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全 部读出的。</p><h5 id="5-8-2-UDP数据读写"><a href="#5-8-2-UDP数据读写" class="headerlink" title="5.8.2 UDP数据读写"></a>5.8.2 UDP数据读写</h5><p>socket编程接口中用于UDP数据报读写的系统调用是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags,struct sockaddr* src_addr,<span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags,<span class="keyword">const</span> struct sockaddr* dest_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位 置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都 需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。</li><li>sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置 和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该 地址的长度。 </li><li>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调 用的flags参数及返回值相同。</li></ul><h5 id="5-8-3-通用数据读写函数"><a href="#5-8-3-通用数据读写函数" class="headerlink" title="5.8.3 通用数据读写函数"></a>5.8.3 通用数据读写函数</h5><p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅 能用于TCP流数据，也能用于UDP数据报, 在第13.9章节进程间传递文件描述符 用到了。</p><h4 id="5-9-带外标记"><a href="#5-9-带外标记" class="headerlink" title="5.9 带外标记"></a>5.9 带外标记</h4><p>在实际应用中， 我们通常无法预期带外数据何时到来。好在<strong>Linux内核检测到TCP紧急 标志</strong>时，将通知应用程序有带外数据需要接收。内核通知应用程序带 外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信 号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure><p>sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数 据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用 带MSG_OOB标志的recv调用来接收带外数据。如果不是，则 sockatmark返回0。</p><h4 id="5-10-地址信息函数"><a href="#5-10-地址信息函数" class="headerlink" title="5.10 地址信息函数"></a>5.10 地址信息函数</h4><p>在某些情况下，我们想知道一个连接socket的本端socket地址，以 及远端的socket地址。下面这两个函数正是用于解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure><p>getsockname获取sockfd对应的本端socket地址，并将其存储于 address参数指定的内存中，该socket地址的长度则存储于address_len参 数指向的变量中。</p><p>getpeername获取sockfd对应的远端socket地址，其参数及返回值的 含义与getsockname的参数及返回值相同。</p><h4 id="5-11-socket-选项"><a href="#5-11-socket-选项" class="headerlink" title="5.11 socket 选项"></a>5.11 socket 选项</h4><p>如果说<strong>fcntl系统调用（文件描述符控制）</strong>是控制文件描述符属性的通用POSIX（可移植操作系统接口）方法，那 么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> level,<span class="keyword">int</span> option_name,<span class="keyword">void</span>* option_value,<span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> level,<span class="keyword">int</span> option_name,<span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd参数指定被操作的目标socket。level参数指定要操作哪个协 议的选项（即属性），比如IPv4、IPv6、TCP等。option_name参数则指 定选项的名字。我们在表5-5中列举了socket通信中几个比较常用的 socket选项。option_value和option_len参数分别是被操作选项的值和长 度。</li><li>![image-20230304223735943](二 高性能服务器框架/image-20230304223735943.png)</li></ul><p>暂时用不到， 略过一部分。</p><h4 id="5-12-网络信息API"><a href="#5-12-网络信息API" class="headerlink" title="5.12 网络信息API"></a>5.12 网络信息API</h4><p>socket地址的两个要素，即IP地址和端口号，都是用数值表示的。 这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。因此在前面 的章节中，我们用主机名来访问一台机器，而避免直接使用其IP地 址。同样，我们用服务名称来代替端口号。</p><h5 id="5-12-1-gethostbyname和gethostbyaddr"><a href="#5-12-1-gethostbyname和gethostbyaddr" class="headerlink" title="5.12.1 gethostbyname和gethostbyaddr"></a>5.12.1 gethostbyname和gethostbyaddr</h5><p>gethostbyname函数<strong>根据主机名称获取主机的完整信息</strong>， gethostbyaddr函数<strong>根据IP地址获取主机的完整信息。</strong></p><ul><li>gethostbyname函数 通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访 问DNS服务器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function">struct hostent*<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*name)</span></span>;</span><br><span class="line"><span class="function">struct hostent*<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>name参数指定目标主机的主机名，</li><li>addr参数指定目标主机的IP地 址，</li><li>len参数指定addr所指IP地址的长度，</li><li>type参数指定addr所指IP地址 的类型，其合法取值包括AF_INET（用于IPv4地址）和AF_INET6（用 于IPv6地址）。</li></ul><p>这两个函数返回的都是hostent结构体类型的指针，hostent结构体的 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>*h_name;<span class="comment">/*主机名*/</span></span><br><span class="line"><span class="keyword">char</span>**h_aliases;<span class="comment">/*主机别名列表，可能有多个*/</span></span><br><span class="line"><span class="keyword">int</span> h_addrtype;<span class="comment">/*地址类型（地址族）*/</span></span><br><span class="line"><span class="keyword">int</span> h_length;<span class="comment">/*地址长度*/</span></span><br><span class="line"><span class="keyword">char</span>**h_addr_list;<span class="comment">/*按网络字节序列出的主机IP地址列表*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-12-2-getservbyname和getservbyport"><a href="#5-12-2-getservbyname和getservbyport" class="headerlink" title="5.12.2 getservbyname和getservbyport"></a>5.12.2 getservbyname和getservbyport</h5><p>getservbyname函数根据名称获取某个服务的完整信息， getservbyport函数根据端口号获取某个服务的完整信息。</p><p>它们实际上都 是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name,<span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port,<span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>name参数指定目标服务的名字，</li><li>port参数指定目标服务对应的端口 号。</li><li>proto参数指定服务类型，给它传递“tcp”表示获取流服务，给它传 递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的 服务。</li></ul><p>这两个函数返回的都是servent结构体类型的指针，结构体servent的 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>*s_name;<span class="comment">/*服务名称*/</span></span><br><span class="line"><span class="keyword">char</span>**s_aliases;<span class="comment">/*服务的别名列表，可能有多个*/</span></span><br><span class="line"><span class="keyword">int</span> s_port;<span class="comment">/*端口号*/</span></span><br><span class="line"><span class="keyword">char</span>*s_proto;<span class="comment">/*服务类型,通常是tcp或者udp*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-12-3-getaddrinfo"><a href="#5-12-3-getaddrinfo" class="headerlink" title="5.12.3 getaddrinfo"></a>5.12.3 getaddrinfo</h5><p>getaddrinfo函数既能通过主机名获得IP地址（内部使用的是 gethostbyname函数），也能通过服务名获得端口号（内部使用的是 getservbyname函数）。它是否可重入取决于其内部调用的 gethostbyname和getservbyname函数是否是它们的可重入版本。</p><p>该函数 的定义如下： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname,<span class="keyword">const</span> <span class="keyword">char</span>* service,<span class="keyword">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span>;</span><br></pre></td></tr></table></figure><p>hostname参数可以接收主机名，也可以接收字符串表示的IP地址 （IPv4采用点分十进制字符串，IPv6则采用十六进制字符串）。同样， service参数可以接收服务名，也可以接收字符串表示的十进制端口号。 hints参数是应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出 进行更精确的控制。hints参数可以被设置为NULL，表示允许 getaddrinfo反馈任何可用的结果。<strong>result参数指向一个链表，该链表用于 存储getaddrinfo反馈的结果。</strong></p><p>剩下内容 忽略.</p><h3 id="第6章-高级I-O函数"><a href="#第6章-高级I-O函数" class="headerlink" title="第6章 高级I/O函数"></a>第6章 高级I/O函数</h3><p>Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数 （比如open和read）那么常用（编写内核模块时一般要实现这些I/O函 数），但在<strong>特定的条件下却表现出优秀的性能</strong>。</p><p><strong>本章将讨论其中和网络编程相关的几个，这些函数大致分为三类：</strong></p><ul><li>用于创建文件描述符的函数，包括pipe、dup/dup2函数。</li><li>用于读写数据的函数，包括readv/writev、sendfile、 mmap/munmap、splice和tee函数。</li><li>用于控制I/O行为和属性的函数，包括fcntl函数。</li></ul><h4 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h4><p>pipe函数可用于创建一个管道，以实现进程间通信。13.4节会讲解如何使用管道实现进程间通信.</p><p>pipe函数定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>pipe函数的参数是一个包含两个int型整数的数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组。如 果失败，则返回-1并设置errno。</p><p><strong>通过pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端，往fd[1]写入的数据可以从fd[0]读出。并且，fd[0]只能用于从管道读出数据，fd[1]则只能用于往管道写入数据，而不能反过来使用。</strong>如果要实现双向的数据传输，就应该使用两个管道。</p><p>默认情况 下，这一对文件描述符都是阻塞的。此时如果我们用read系统调用来 读取一个空的管道，则read将被阻塞，直到管道内有数据可读；如果 我们用write系统调用来往一个满的管道（见后文）中写入数据，则 write亦将被阻塞，直到管道有足够多的空闲空间可用。</p><p>管道内部传输的数据是字节流, 自Linux 2.6.11 内核起，管道容量的大小默认是65536字节。我们可以使用fcntl函数来 修改管道容量（见后文）。</p><p>此外，socket的基础API中有一个socketpair函数。它能够方便地创建双向管道。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol,<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>socketpair前三个参数的含义与socket系统调用的三个参数完全相 同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能 在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一 样，只不过socketpair创建的这对文件描述符都是既可读又可写的。 socketpair成功时返回0，失败时返回-1并设置errno。</p><h4 id="6-2-dup-函数和dup2函数"><a href="#6-2-dup-函数和dup2函数" class="headerlink" title="6.2 dup 函数和dup2函数"></a>6.2 dup 函数和dup2函数</h4><p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重 定向到一个网络连接（比如CGI编程）。这可以通过下面的用于复制 文件描述符的dup或dup2函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> file_descriptor_one,<span class="keyword">int</span> file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure><p>dup函数创建一个新的文件描述符，该新文件描述符和原有文件描 述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回 的文件描述符总是取系统当前可用的最小整数值。</p><p>dup2和dup类似，不 过它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统 调用失败时返回-1并设置errno。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> connfd, sock;</span><br><span class="line">&#123;</span><br><span class="line">sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret = bind(sock, (struct sockaddr *) &amp; address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">connfd = accept(sock, (struct sockaddr *) &amp;client, &amp;client_addrlength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">dup(connfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abcd\n&quot;</span>);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们先关闭标准输出文件描述符 STDOUT_FILENO（其值是1）</li><li>然后复制socket文件描述符connfd。 因为dup总是返回系统中最小的可用文件描述符，所以它的返回值实际 上是1，即之前关闭的标准输出文件描述符的值。</li><li>这样一来，服务器输 出到标准输出的内容（这里是“abcd”）就会直接发送到与客户连接对 应的socket上，因此printf调用的输出将被客户端获得（而不是显示在 服务器程序的终端上）。<strong>这就是CGI服务器的基本工作原理。</strong></li></ul><h4 id="6-3-readv函数和writev函数"><a href="#6-3-readv函数和writev函数" class="headerlink" title="6.3 readv函数和writev函数"></a>6.3 readv函数和writev函数</h4><p><strong>readv函数将数据从文件描述符读到分散的内存块中，即分散读； writev函数则将多块分散的内存数据一并写入文件描述符中，即集中 写。</strong>它们的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/uio.h＞</span></span><br><span class="line">ssize_t readv(int fd,const struct iovec* vector, int count)；</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>fd参数是被操作的目标文件描述符。vector参数的类型是iovec结构 数组。我们在第5章讨论过结构体iovec，该结构体描述一块内存区。 count参数是vector数组的长度，即有多少块内存数据需要从fd读出或 写到fd。</p><p>readv和writev在成功时返回读出/写入fd的字节数，失败则返 回-1并设置errno。</p><p>清单6.2 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-4-sendfile函数"><a href="#6-4-sendfile函数" class="headerlink" title="6.4 sendfile函数"></a>6.4 sendfile函数</h4><p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中 操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率 很高，这被称为零拷贝。</p><p>sendfile函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sendfile.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd,<span class="keyword">int</span> in_fd,<span class="keyword">off_t</span>*offset,<span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>in_fd参数是待读出内容的文件描述符，out_fd参数是待写入内容的文件描述符。</strong> offset参数指定从读入文件流的哪个位置开始读，如果 为空，则使用读入文件流默认的起始位置。count参数指定在文件描述 符in_fd和out_fd之间传输的字节数。</p><p><strong>in_fd 必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。由此可见， sendfile几乎是专门为在网络上传输文件而设计的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键部分</span></span><br><span class="line"><span class="comment">// connfd 是socket, filefd是打开的文件描述符, </span></span><br><span class="line"><span class="keyword">int</span> filefd=open(file_name,O_RDONLY);</span><br><span class="line">assert(filefd＞<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">fstat(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line">sendfile(connfd,filefd,<span class="literal">NULL</span>,stat_buf.st_size);</span><br></pre></td></tr></table></figure><p>我们将目标文件作为第3个参数传递给服务器程 序，客户telnet到该服务器上即可获得该文件。代码清单6-3没有为目标文件分配任何用户空间的缓存，也没有执行读取 文件的操作，但同样实现了文件的发送，其效率显然要高得多。</p><h4 id="6-5-mmap函数和nummap函数"><a href="#6-5-mmap函数和nummap函数" class="headerlink" title="6.5 mmap函数和nummap函数"></a>6.5 mmap函数和nummap函数</h4><p><strong>mmap函数用于申请一段内存空间。我们可以将这段内存作为进程间通信的共享内存，也可以==将文件直接映射到其中==。</strong>munmap函数则释 放由mmap创建的这段内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/mman.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>*start,<span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>start参数允许用户使用某个特定的地址作为这段内存的起始地址。 如果它被设置成NULL，则系统自动分配一个地址。</p></li><li><p>length参数指定内 存段的长度。</p></li><li><p>prot参数用来设置内存段的访问权限。它可以取以下几个 值的按位或：</p><ul><li>PROT_READ，内存段可读。 </li><li>PROT_WRITE，内存段可写。 </li><li>PROT_EXEC，内存段可执行。 </li><li>PROT_NONE，内存段不能被访问。</li></ul></li><li><p>flags参数控制内存段内容被修改后程序的行为。它可以被设置为 表6-1中的某些值（这里仅列出了常用的值）的按位或（其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226134942673-1678341964416.png" class="" title="image-20230226134942673"></li><li><p>fd参数是被映射文件对应的文件描述符。它一般通过open系统调用获得。</p></li><li><p>offset参数设置从文件的何处开始映射（对于不需要读入整个文 件的情况）。</p></li></ul><p><strong>mmap函数成功时返回指向目标内存区域的指针</strong>，失败则返回 MAP_FAILED（(void*)-1）并设置errno。munmap函数成功时返回0， 失败则返回-1并设置errno。</p><h4 id="6-6-splice函数"><a href="#6-6-splice函数" class="headerlink" title="6.6 splice函数"></a>6.6 splice函数</h4><p>splice函数用于在两个文件描述符之间移动数据，也是零拷贝操 作。splice函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in,<span class="keyword">loff_t</span>* off_in,<span class="keyword">int</span> fd_out,<span class="keyword">loff_t</span>* off_out,<span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>fd_in参数是<strong>待输入数据</strong>的文件描述符。</p><p>如果fd_in是一个管道文件 描述符，那么off_in参数必须被设置为NULL。如果fd_in不是一个管道 文件描述符（比如socket），那么off_in表示从输入数据流的何处开始 读取数据。此时，若off_in被设置为NULL，则表示从输入数据流的当 前偏移位置读入；若off_in不为NULL，则它将指出具体的偏移位置。 </p><p>fd_out/off_out参数的含义与fd_in/off_in相同，不过用于输出数据流。len 参数指定移动数据的长度；flags参数则控制数据如何移动，它可以被 设置为表6-2中的某些值的按位或。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226135725302-1678341964416.png" class="" title="image-20230226135725302"><p><strong>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。</strong></p><h4 id="6-7-tee函数"><a href="#6-7-tee函数" class="headerlink" title="6.7 tee函数"></a>6.7 tee函数</h4><p><strong>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。</strong> 它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操 作。tee函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="keyword">int</span> fd_in,<span class="keyword">int</span> fd_out,<span class="keyword">size_t</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的参数的含义与splice相同（但fd_in和fd_out必须都是管道 文件描述符）。tee函数成功时返回在两个文件描述符之间复制的数据 数量（字节数）。返回0表示没有复制任何数据。tee失败时返回-1并设 置errno。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-8-fcntl函数"><a href="#6-8-fcntl函数" class="headerlink" title="6.8 fcntl函数"></a>6.8 fcntl函数</h4><p>fcntl函数，正如其名字（file control）描述的那样，提供了对文件 描述符的各种控制操作。另外一个常见的控制文件描述符属性和行为 的系统调用是ioctl，而且ioctl比fcntl能够执行更多的控制。但是，对于控制文件描述符常用的属性和行为，<strong>fcntl函数是由POSIX规范指定的首 选方法。所以本书仅讨论fcntl函数</strong>。fcntl函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,…)</span></span>;</span><br></pre></td></tr></table></figure><p>fd参数是被操作的文件描述符，cmd参数指定执行何种类型的操 作。根据操作类型的不同，该函数可能还需要第三个可选参数arg。 </p><p>fcntl函数支持的常用操作及其参数如表6-4所示。</p><p>![image-20230226141140857](二 高性能服务器框架/image-20230226141140857.png)</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226141206370-1678341964416.png" class="" title="image-20230226141206370"><p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的，如代码清单6-6所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option=fcntl(fd,F_GETFL);<span class="comment">/*获取文件描述符旧的状态标志*/</span></span><br><span class="line"><span class="keyword">int</span> new_option=old_option|O_NONBLOCK;<span class="comment">/*设置非阻塞标志*/</span></span><br><span class="line">fcntl(fd,F_SETFL,new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;<span class="comment">/*返回文件描述符旧的状态标志，以便*/</span></span><br><span class="line"><span class="comment">/*日后恢复该状态标志*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h3><p>除了网络通信外，服务器程序通常还必须考虑许多其他细节问 题。这些细节问题涉及面广且零碎，而且基本上是模板式的，所以我 们称之为服务器程序规范。比如：</p><ul><li>Linux服务器程序一般以后台进程形式运行。后台进程又称<strong>守护进程（daemon）</strong>。它没有控制终端，因而也不会意外接收到用户输 入。守护进程的父进程通常是init进程（PID为1的进程）。</li><li>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台 进程都在/var/log目录下拥有自己的日志目录。</li><li>Linux服务器程序一般以某个专门的非root身份运行。比如 mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、 apache和syslog。</li><li>Linux服务器程序通常是可配置的。服务器程序通常能处理很多 命令行选项，<strong>如果一次运行的选项太多，则可以用配置文件来管理。</strong> 绝大多数服务器程序都有配置文件，并存放在/etc目录下。比如第4章 讨论的squid服务器的配置文件是/etc/squid3/squid.conf。</li><li>Linux服务器进程通常会在启动的时候生成一个PID文件并存 入/var/run目录中，以记录该后台进程的PID。比如syslogd的PID文件 是/var/run/syslogd.pid。</li><li>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能 承受多大负荷，比如进程可用文件描述符总数和内存总量等。</li></ul><h4 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h4><h5 id="7-1-1-Linux系统日志"><a href="#7-1-1-Linux系统日志" class="headerlink" title="7.1.1 Linux系统日志"></a>7.1.1 Linux系统日志</h5><p>服务器的调试和维护都需要一个专业 的日志系统。Linux提供一个守护进程来处理系统日志——syslogd，不 过现在的Linux系统上使用的都是它的升级版——rsyslogd。</p><p>rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日 志。<strong>用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件/dev/log中， rsyslogd则监听该文件以获取用户进程的输出。</strong></p><p><strong>内核日志在老的系统上</strong>是通过另外一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等函数打印至内核的环状缓存 （ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。 rsyslogd则通过读取该文件获得内核日志。</p><p>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。<strong>默认情况下，调试信息会保存 至/var/log/debug文件，普通信息保存至/var/log/messages文件，内核消息则保存至/var/log/kern.log文件。</strong></p><p>rsyslogd的主配置文件 是/etc/rsyslog.conf，其中主要可以设置的项包括：</p><ul><li>内核日志输入路径</li><li>是否接收UDP日志及其监听端口（默认是514，见/etc/services文件）</li><li>是否接收TCP日志及其监听端口</li><li>日志文件的权限</li><li>包含哪些子配置文 件（比如/etc/rsyslog.d/*.conf）</li></ul><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092105214-1678341964416.png" class="" title="image-20230228092105214"><h5 id="7-1-2-syslog-函数"><a href="#7-1-2-syslog-函数" class="headerlink" title="7.1.2 syslog 函数"></a>7.1.2 syslog 函数</h5><p><strong>应用程序使用syslog函数与rsyslogd守护进程通信。</strong> syslog函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span>*message,...)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数采用可变参数（第二个参数message和第三个参数…）来结 构化输出。</p><ul><li><p>priority参数是所谓的<strong>设施值与日志级别的按位或</strong>。设施值的默认值是LOG_USER，我们下面的讨论也只限于这一种设施值。日 志级别有如下几个：</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092428475-1678341964416.png" class="" title="image-20230228092428475"></li></ul><p>下面这个函数可以改变syslog的默认输出方式，进一步结构化日志 内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ident,<span class="keyword">int</span> logopt,<span class="keyword">int</span> facility)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>ident参数指定的字符串将被添加到日志消息的日期和时间之后， 它通常被设置为程序的名字</p></li><li><p>logopt参数对后续syslog调用的行为进行配置，它可取<strong>下列值的按位或</strong>：</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092709404-1678341964416.png" class="" title="image-20230228092709404"></li><li><p>facility参数可用来修改syslog函数中的默认设施值。</p></li></ul><p>此外，日志的过滤也很重要。程序在开发阶段可能需要输出很多 调试信息，而发布之后我们又需要将这些调试信息关闭。简单地设置日志掩码，使<strong>日志级别大于日志掩码的日志信息被系统忽略。</strong>下面这个函数用于设置syslog的日志掩码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>maskpri参数指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值。</li></ul><p>最后，不要忘了使用如下函数关闭日志功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h4><h5 id="7-2-1-UID、EUID和EGID"><a href="#7-2-1-UID、EUID和EGID" class="headerlink" title="7.2.1 UID、EUID和EGID"></a>7.2.1 UID、EUID和EGID</h5><p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分 服务器就必须以root身份启动，但不能以root身份运行。</p><p>下面这一组函 数可以获取和设置当前进程的<strong>真实用户ID（UID）</strong>、<strong>有效用户 ID（EUID）</strong>、真实组ID（GID）和<strong>有效组ID（EGID）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;<span class="comment">/*获取真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;<span class="comment">/*获取有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;<span class="comment">/*获取真实组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;<span class="comment">/*获取有效组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置真实组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置有效组ID*/</span></span><br></pre></td></tr></table></figure><p>需要指出的是，一个进程拥有两个用户ID：UID和EUID。<strong>EUID 存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。</strong> </p><blockquote><p>比如su程序，任何用户都可以使用它来修改自己的账 户信息，但修改账户时su程序不得不访问/etc/passwd文件，而访问该 文件是需要root权限的。那么以普通用户身份启动的su程序如何能访 问/etc/passwd文件呢？窍门就在EUID。用ls命令可以查看到，su程序的所有者是root，<strong>并且它被设置了set-user-id标志。</strong></p><p>这个标志表示，任 何普通用户运行su程序时，其有效用户就是该程序的所有者root。那 么，根据有效用户的含义，任何运行su程序的普通用户都能够访 问/etc/passwd文件。有效用户为root的进程称为特权进程（privileged processes）。</p></blockquote><p>EGID的含义与EUID类似：<strong>给运行目标程序的组用户提 供有效组的权限</strong>。</p><p>代码: 编译该文件，将生成的可执行文件（名为test_uid）的所有者设置 为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID 和EUID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo chown root:root test_uid<span class="comment">#修改目标文件的所有者为root</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo chmod+s test_uid<span class="comment">#设置目标文件的set-user-id标志</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./test_uid<span class="comment">#运行程序</span></span></span><br><span class="line">userid is 1000,effective userid is:0</span><br></pre></td></tr></table></figure><p>从测试程序的输出来看，进程的UID是启动程序的用户的ID，而 EUID则是root账户（文件所有者）的ID。</p><h5 id="7-2-2-切换用户"><a href="#7-2-2-切换用户" class="headerlink" title="7.2.2 切换用户"></a>7.2.2 切换用户</h5><p>下面的代码清单7-2展示了如何将以root身份启动的进程切换为以 一个普通用户身份运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">switch_to_user</span><span class="params">(<span class="keyword">uid_t</span> user_id, <span class="keyword">gid_t</span> gp_id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*先确保目标用户不是root*/</span></span><br><span class="line"><span class="keyword">if</span> ((user_id == <span class="number">0</span>) &amp;&amp; (gp_id == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*确保当前用户是合法用户：root或者目标用户*/</span></span><br><span class="line"><span class="keyword">gid_t</span> gid = getgid();</span><br><span class="line"><span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line"><span class="keyword">if</span> (((gid != <span class="number">0</span>) || (uid != <span class="number">0</span>)) &amp;&amp; ((gid != gp_id) || (uid != user_id))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果不是root，则已经是目标用户*/</span></span><br><span class="line"><span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切换到目标用户*/</span></span><br><span class="line"><span class="keyword">if</span> ((setgid(gp_id) &lt; <span class="number">0</span>) || (setuid(user_id) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h4><h5 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h5><p>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息 外，还有进程组ID（PGID）。我们可以用如下函数来获取指定进程的 PGID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>该函数成功时返回进程pid所属进程组的PGID，失败则返回-1并设 置errno。</li></ul><p><strong>每个进程组都有一个首领进程，其PGID和PID相同</strong>。进程组将一 直存在，直到其中所有进程都退出，或者加入到其他进程组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数将PID为pid的进程的PGID设置为pgid。</p><ul><li>如果pid和pgid相 同，则由pid指定的进程将被设置为进程组首领；</li><li>如果pid为0，则表示 设置当前进程的PGID为pgid；</li><li>如果pgid为0，则使用pid作为目标 PGID。</li></ul><p>一个进程只能设置自己或者其子进程的PGID。并且，当子进程调 用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p><h5 id="7-3-2-会话（session）"><a href="#7-3-2-会话（session）" class="headerlink" title="7.3.2 会话（session）"></a>7.3.2 会话（session）</h5><p>一些有关联的进程组将形成一个会话（session）。下面的函数用于创建一个会话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>该函数不能由进程组的首领进程调用，否则将产生一个错误。</strong></p><p>对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：</p><ul><li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li><li>新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领。</li><li>调用进程将甩开终端（如果有的话）。</li></ul><p>Linux进程并未提供所谓会话ID（SID）的概念，但Linux系统认为 它等于会话首领所在的进程组的PGID，并提供了如下函数来读取 SID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="7-3-3-用ps命令查看进程关系"><a href="#7-3-3-用ps命令查看进程关系" class="headerlink" title="7.3.3 用ps命令查看进程关系"></a>7.3.3 用ps命令查看进程关系</h5><p>执行ps命令可查看进程、进程组和会话之间的关系：</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228100733965-1678341964416.png" class="" title="image-20230228100733965"><ul><li>我们是在bash shell下执行ps和less命令的，所以ps和less命令的父进程是bash命令，这可以从PPID（父进程PID）一列看出。</li><li>这3条命令创 建了1个会话（SID是1943）和2个进程组（PGID分别是1943和 2298）。</li><li>bash命令的PID、PGID和SID都相同，很明显它既是会话的首 领，也是组1943的首领。</li><li>ps命令则是组2298的首领，因为其PID也是 2298。</li></ul><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228100847532-1678341964416.png" class="" title="image-20230228100847532"><h4 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h4><p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制 （CPU数量、内存数量等）、系统策略限制（CPU时间等），以及具 体实现的限制（比如文件名的最大长度）。</p><p>Linux系统资源限制可以通 过如下一对函数来读取和设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/resource.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource,struct rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource,<span class="keyword">const</span> struct rlimit* rlim)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>resource参数指定资源限制类型。</p><p>![image-20230228101329120](二 高性能服务器框架/image-20230228101329120.png)</p></li><li><p>setrlimit和getrlimit成功时返回0，失败则返回-1并设置errno。</p></li></ul><p>rlim参数是rlimit结构体类型的指针，rlimit结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line"><span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>rlim_t是一个整数类型，它描述资源级别。</p></li><li><p>rlim_cur成员指定资源 的软限制，rlim_max成员指定资源的硬限制。</p><blockquote><p>软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。例如，当进程CPU时间超过其软限制时，系统将向进 程发送SIGXCPU信号；当文件尺寸超过其软限制时，系统将向进程发 送SIGXFSZ信号（见第10章）。</p><p>硬限制一般是软限制的上限。普通程 序可以减小硬限制，而只有以root身份运行的程序才能增加硬限制。</p></blockquote></li><li><p>我们可以使用ulimit命令修改当前shell环境下的资源限制（软限制 或/和硬限制），这种修改将对该shell启动的所有后续程序有效。</p></li></ul><h4 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h4><p>有些服务器程序还需要改变工作目录和根目录，<strong>获取进程当前工作目录和改变进程工作目录的函数分别是：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>buf参数指向的内存用于存储进程当前工作目录的绝对路径名，其 大小由size参数指定。</li><li>如果当前工作目录的绝对路径的长度（再加上 一个空结束字符“\0”）超过了size，则getcwd将返回NULL，并设置 errno为ERANGE。</li><li>如果buf为NULL并且size非0，则getcwd可能在内部 使用malloc动态分配内存，并将进程的当前工作目录存储在其中。如 果是这种情况，则我们必须自己来释放getcwd在内部创建的这块内 存。</li><li>getcwd函数成功时返回一个指向目标存储区（buf指向的缓存区或 是getcwd在内部动态创建的缓存区）的指针，失败则返回NULL并设 置errno。</li></ul><p><strong>改变进程根目录</strong>的函数是chroot，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>只有特权进程才能改变根目录。</li><li>path参数指定要切换到的目标根目录。它成功时返回0，失败时返 回-1并设置errno。</li><li><strong>chroot并不改变进程的当前工作目录，所以调用 chroot之后，我们仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。</strong></li><li>在调用chroot之后，进程原先打开的文件描述符依然生效，所以我们 可以利用这些早先打开的文件描述符来访问调用chroot之后不能直接 访问的文件（和目录），尤其是一些日志文件。</li></ul><h4 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h4><p>最后，我们讨论如何在代码中让一个进程以守护进程的方式运 行。守护进程的编写遵循一定的步骤[2]，下面我们通过一个具体实现 来探讨，如代码清单7-3所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">daemonize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*创建子进程，关闭父进程，这样可以使程序在后台运行*/</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，</span></span><br><span class="line"><span class="comment"> * 文件的权限将是mode &amp;0777*/</span></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建新的会话，设置本进程为进程组的首领*/</span></span><br><span class="line"><span class="keyword">pid_t</span> sid = setsid();</span><br><span class="line"><span class="keyword">if</span> (sid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切换工作目录*/</span></span><br><span class="line"><span class="keyword">if</span> ((chdir(<span class="string">&quot;/&quot;</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br><span class="line"><span class="comment">/*关闭其他已经打开的文件描述符，代码省略*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/</span></span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Linux提供了完成同样功能的库函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir,<span class="keyword">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>其中，nochdir参数用于指定是否改变工作目录，如果给它传递 0，则工作目录将被设置为“/”（根目录），否则继续使用当前工作目 录。</li><li>noclose参数为0时，标准输入、标准输出和标准错误输出都被重 定向到/dev/null文件，否则依然使用原来的设备。</li><li>该函数成功时返回 0，失败则返回-1并设置errno。</li></ul><h3 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h3><p>在这一章中，我们 按照服务器程序的一般原理，将服务器解构为如下三个主要模块：</p><ul><li>I/O处理单元。本章将介绍I/O处理单元的四种I/O模型和两种高效事件处理模式。</li><li>逻辑单元。本章将介绍逻辑单元的两种高效并发模式，以及高效的逻辑处理方式——有限状态机。</li><li>存储单元。本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关。</li></ul><h4 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h4><h5 id="8-1-1-C-S-模型"><a href="#8-1-1-C-S-模型" class="headerlink" title="8.1.1 C/S 模型"></a>8.1.1 C/S 模型</h5><p>所有客户端都通过访问 服务器来获取所需的资源。</p><img src="学习笔记/Linux高性能服务器编程/image-20230228201337000.png" alt="image-20230228201337000" style="zoom: 33%;" /><p>C/S模型的逻辑很简单。服务器启动后，首先创建一个（或多个） 监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后 调用listen函数等待客户连接。</p><p>服务器稳定运行之后，<strong>客户端就可以调 用connect函数向服务器发起连接了</strong>。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。</p><img src="学习笔记/Linux高性能服务器编程/image-20230228201534348.png" alt="image-20230228201534348" style="zoom:67%;" /><p>I/O模型有多种，图8-2中，<strong>服务器使用的是I/O复用技术之一的select系统调用。</strong>当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。<strong>逻辑单元可以是新创建的子进程、子线程或者 其他。</strong> 图8-2中，服务器给客户端分配的逻辑单元是由fork系统调用创 建的子进程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端接收到服务器反馈的结果之后，可以继续向服 务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连 接，则服务器执行被动关闭连接。至此，双方的通信结束。</p><h5 id="8-1-2-P2P模型"><a href="#8-1-2-P2P模型" class="headerlink" title="8.1.2 P2P模型"></a>8.1.2 P2P模型</h5><p>P2P（Peer to Peer，点对点）模型比C/S模型更符合网络通信的实 际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回 归对等的地位。P2P模型如图8-3a所示。</p><p>但P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络 的负载将加重。</p><p>图8-3a所示的P2P模型存在一个显著的问题，即主机之间很难互相 发现。所以实际使用的P2P模型通常带有一个专门的发现服务器，如图 8-3b所示。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228201859415-1678341964416.png" class="" title="image-20230228201859415"><h4 id="8-2-服务器编程框架"><a href="#8-2-服务器编程框架" class="headerlink" title="8.2 服务器编程框架"></a>8.2 服务器编程框架</h4><p>为了让读者能从设计的角度把握服务器编程，本章先讨论 基本框架，如图8-4所示。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228201956583-1678341964416.png" class="" title="image-20230228201956583"><p>该图既能用来描述一台服务器，也能用来描述一个服务器机群。 各个部件的含义和功能如下表所示:</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228202116872-1678341964417.png" class="" title="image-20230228202116872"><ul><li>I/O处理单元是服务器管理客户连接的模块。它通常要完成以下工 作：<strong>等待并接受新的客户连接，接收客户数据，将服务器响应数据返 回给客户端。</strong>但是，数据的收发不一定在I/O处理单元中执行，也可能 在逻辑单元中执行，具体在何处执行取决于事件处理模式（见后 文）。</li><li>一个逻辑单元通常是一个进程或线程。它分析并处理客户数据， 然后将结果传递给I/O处理单元或者直接发送给客户端（具体使用哪种 方式取决于事件处理模式）。</li><li>网络存储单元可以是数据库、缓存和文件，甚至是一台独立的服 务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单 元。</li><li>请求队列是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样， 多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调 处理竞态条件。<strong>请求队列通常被实现为池的一部分，我们将在后面讨 论池的概念</strong>。</li></ul><h4 id="8-3-I-O模型"><a href="#8-3-I-O模型" class="headerlink" title="8.3 I/O模型"></a>8.3 I/O模型</h4><p>第5章讲到，socket在创建的时候默认是阻塞的。我们可以给socket 系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的。</p><p>阻塞和非阻塞的概念能应用于所有文件描述符，而不仅仅是socket。<strong>我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。</strong></p><blockquote><p><strong>针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。</strong>比如，客户端通过connect向服务器 发起连接时，connect将首先发送同步报文段给服务器，然后等待服务 器返回确认报文段。如果服务器的确认报文段没有立即到达客户端， 则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调 用。socket的基础API中，可能被阻塞的系统调用包括accept、send、 recv和connect。</p><p><strong>针对非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。</strong>此时我们必须根据errno来区分这两种情况。对accept、send 和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一 次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言， errno则被设置成EINPROGRESS（意为“在处理中”）。</p></blockquote><p>很显然，<strong>我们只有在事件已经发生的情况下操作非阻塞I/O（读、 写等），才能提高程序的效率。</strong>因此，<strong>非阻塞I/O通常要和其他I/O通知机制一起使用</strong>，比如I/O复用和SIGIO信号。</p><p><strong>I/O复用是最常使用的I/O通知机制。它指的是，应用程序通过I/O 复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。</strong> Linux上常用的I/O复用函数是select、poll和 epoll_wait，我们将在第9章详细讨论它们。  需要指出的是，<strong>I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。</strong></p><p><strong>SIGIO信号也可以用来报告I/O事件。6.8节的最后一段提到，我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。</strong> 这样，当目标文件描述符上有事件发生时，SIGIO 信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了。关于信号的使用，我们将在第 10章讨论。</p><p>从理论上说，<strong>阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型。</strong> 因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后， 由应用程序来完成的。</p><p>而POSIX规范所定义的异步I/O模型则不同。<strong>对异步I/O而言，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已经由内核接管。</strong></p><blockquote><p>也就是说，<strong>同步I/O模型要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据 从用户缓冲区写入内核缓冲区），而异步I/O机制则由内核来执行I/O操 作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完 成的）。</strong>你可以这样认为，<strong>同步I/O向应用程序通知的是I/O就绪事件， 而异步I/O向应用程序通知的是I/O完成事件。</strong></p></blockquote><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228203724545-1678341964417.png" class="" title="image-20230228203724545"><h4 id="8-4-两种高效的事件处理模式"><a href="#8-4-两种高效的事件处理模式" class="headerlink" title="8.4 两种高效的事件处理模式"></a>8.4 两种高效的事件处理模式</h4><p>这一节先从整体上介绍一下两种高效的事件处理模式：Reactor和Proactor。同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现 Proactor模式。</p><h5 id="8-4-1-Reactor模式"><a href="#8-4-1-Reactor模式" class="headerlink" title="8.4.1 Reactor模式"></a>8.4.1 Reactor模式</h5><p>Reactor是这样一种模式，它要求<strong>主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程</strong>（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。<strong>读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</strong></p><p>工作流程如下:</p><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将 socket可读事件放入请求队列。 </li><li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，<strong>然后往epoll内核事件表中注册该socket上的写就绪事件。</strong></li><li>主线程调用epoll_wait等待socket可写。 </li><li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 </li><li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入 服务器处理客户请求的结果。</li></ol><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228204723763-1678341964417.png" class="" title="image-20230228204723763"><h5 id="8-4-2-Proactor模式"><a href="#8-4-2-Proactor模式" class="headerlink" title="8.4.2 Proactor模式"></a>8.4.2 Proactor模式</h5><p>与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p><p>使用异步I/O模型（以aio_read和aio_write为例）实现的Proactor模 式的工作流程是：</p><ol><li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序 （这里以信号为例，详情请参考sigevent的man手册）。</li><li>主线程继续处理其他逻辑。</li><li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操 作完成时如何通知应用程序（仍然以信号为例）。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善 后处理，比如决定是否关闭socket。</li></ol><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228205315653-1678341964417.png" class="" title="image-20230228205315653"><p>在图8-6中，连接socket上的读写事件是通过aio_read/aio_write向内 核注册的，<strong>因此内核将通过信号来向应用程序报告连接socket上的读写 事件。</strong> 所以，主线程中的epoll_wait调用仅能用来检测监听socket上的连 接请求事件，而不能用来检测连接socket上的读写事件。</p><h5 id="8-4-3-模拟Proactor模式"><a href="#8-4-3-模拟Proactor模式" class="headerlink" title="8.4.3 模拟Proactor模式"></a>8.4.3 模拟Proactor模式</h5><p>使用同步I/O方式模拟出Proactor模式的一种方 法。其原理是：<strong>主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</strong></p><p>使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式 的工作流程如下：</p><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程从 socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封 装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并 处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</li><li>主线程调用epoll_wait等待socket可写。</li><li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入 服务器处理客户请求的结果。</li></ol><img src="学习笔记/Linux高性能服务器编程/image-20230228210636117.png" alt="image-20230228210636117" style="zoom:67%;" /><h4 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h4><p>并发编程的目的是让程序“同时”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。 但如果程序是I/O密集型的，比如经常读写文件，访问数据库等，则情况就不同了。由于I/O操作的速度远没有CPU的计算速度快，所以让程 序阻塞于I/O操作将浪费大量的CPU时间。如果程序有多个执行线程， 则当前被I/O操作所阻塞的执行线程可主动放弃CPU（或由操作系统来 调度），并将执行权转移到其他线程。</p><p>从实现上来说，并发编程主要有多进程和多线程两种方式，我们 将在后续章节详细讨论它们，这一节先讨论并发模式。 <strong>并发模式是指I/O处理单元和多个逻辑单元之间协调完成任务的方法。 服务器主要有两种并发编程模式：半同步/半异步（half-sync/half-async）模式和领导者/追随者（Leader/Followers）模式。</strong></p><h5 id="8-5-1-半同步-半异步模式"><a href="#8-5-1-半同步-半异步模式" class="headerlink" title="8.5.1 半同步/半异步模式"></a>8.5.1 半同步/半异步模式</h5><p>首先，半同步/半异步模式中的“同步”和“异步”与前面讨论的I/O模 型中的“同步”和“异步”是完全不同的概念。</p><blockquote><p>在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。</p></blockquote><p>在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“<strong>异步”指 的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、 信号等。</strong>比如，图8-8a描述了同步的读操作，而图8-8b则描述了异步的 读操作。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228211515292-1678341964417.png" class="" title="image-20230228211515292"><p>对于像服务器 这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程 序，我们就应该同时使用同步线程和异步线程来实现，即采用半同步/ 半异步模式来实现。</p><p><strong>半同步/半异步模式中，同步线程用于处理客户逻辑，相当于图8-4 中的逻辑单元；异步线程用于处理I/O事件，相当于图8-4中的I/O处理单元。</strong> 异步线程监听到客户请求后，就将其封装成请求对象并插入请 求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并 处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则 取决于请求队列的设计。</p><p>在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模 型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆（half-sync/half-reactive）模式，如图8-10所示。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228212216219-1678341964417.png" class="" title="image-20230228212216219"><p>异步线程只有一个，由主线程来充当。它负责监听所有 socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生， 即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接 socket插入请求队列中。</p><p>所有工作线程都睡眠在请求队列上，当有任务 到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这 种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。</p><blockquote><p>主线程插入请求队列中的任务是就绪的连接socket。这 说明该图所示的半同步/半反应堆模式采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中“half-reactive”的含义。</p></blockquote><p>存在的缺点:</p><ul><li>主线程和工作线程共享请求队列。主线程往请求队列中添加任 务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保 护，从而白白耗费CPU时间。</li><li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题， 则工作线程的切换也将耗费大量CPU时间。</li></ul><p>下图描述了一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228212643003-1678341964417.png" class="" title="image-20230228212643003"><p>图8-11中，主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。</p><p>主线程向工作线程派发socket的最 简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测 到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。 如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表 中。</p><p>可见，图8-11中，每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同 步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义 上的半同步/半异步模式。</p><h5 id="8-5-2-领导者-追随者模式"><a href="#8-5-2-领导者-追随者模式" class="headerlink" title="8.5.2 领导者/追随者模式"></a>8.5.2 领导者/追随者模式</h5><h4 id="8-6-有限状态机"><a href="#8-6-有限状态机" class="headerlink" title="8.6 有限状态机"></a>8.6 有限状态机</h4><h4 id="8-7-提高服务器的其他建议"><a href="#8-7-提高服务器的其他建议" class="headerlink" title="8.7 提高服务器的其他建议"></a>8.7 提高服务器的其他建议</h4><p>前面我们介绍了几种高效的事件处理模式和并发模式，以及高效 的逻辑处理方式——有限状态机，它们都有助于提高服务器的整体性 能。</p><h5 id="8-7-1-池"><a href="#8-7-1-池" class="headerlink" title="8.7.1 池"></a>8.7.1 池</h5><p>既然服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其 运行效率。这就是池（pool）的概念。</p><p>池是一组资源的集合，这组资 源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。 <strong>当服务器进入正式运行阶段，即开始处理客户请求的时候，如果 它需要相关的资源，就可以直接从池中获取，无须动态分配。 ** **当服务器处理完一个客户连 接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。</strong></p><p>根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。它们的含义都很明确。</p><ul><li>内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字 节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的 大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。</li><li>进程池和线程池都是并发编程常用的“伎俩”。当我们需要一个工 作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程 池或线程池中取得一个执行实体，而无须动态地调用fork或 pthread_create等函数来创建进程和线程。</li><li>连接池通常用于服务器或服务器机群的内部永久连接。图8-4中， 每个逻辑单元可能都需要频繁地访问本地的某个数据库。连接池是服务器预先和数据库程序建立的一组 连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接 池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑 单元再将该连接返还给连接池。</li></ul><h5 id="8-7-2-数据复制"><a href="#8-7-2-数据复制" class="headerlink" title="8.7.2 数据复制"></a>8.7.2 数据复制</h5><p>高性能服务器应该<strong>避免不必要的数据复制</strong>，尤其是当数据复制发 生在用户代码和内核之间的时候。如果内核可以直接处理从socket或 者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复 制到应用程序缓冲区中。这里说的“直接处理”指的是应用程序不关心 这些数据的内容，不需要对它们做任何分析。</p><blockquote><p>比如ftp服务器，当客户 请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是 否有读取它的权限，而绝对不会关心文件的具体内容。这样的话，ftp 服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调 用send函数来发送，而是可以使用“零拷贝”函数sendfile来直接将其发 送给客户端。</p></blockquote><p>此外，用户代码内部（不访问内核）的数据复制也是应该避免 的。当两个工作进程之间要传递大量的数据时，我们就应 该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管 道或者消息队列来传递。</p><h5 id="8-7-3-上下文切换和锁"><a href="#8-7-3-上下文切换和锁" class="headerlink" title="8.7.3 上下文切换和锁"></a>8.7.3 上下文切换和锁</h5><p>并发程序必须考虑上下文切换（context switch）的问题，即进程 切换或线程切换导致的的系统开销。</p><p>即使是I/O密集型的服务器，也不 应该使用过多的工作线程（或工作进程，下同），否则线程间的切换 将占用大量的CPU时间，服务器真正用于处理业务逻辑的CPU时间的 比重就显得不足了。</p><p>因此，为每个客户连接都创建一个工作线程的服 务器模型是不可取的。图8-11所描述的半同步/半异步模式是一种比较 合理的解决方案，它允许一个线程同时处理多个客户连接</p><p>并发程序需要考虑的另外一个问题是<strong>共享资源的加锁保护</strong>。锁通 常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不 仅不处理任何业务逻辑，而且需要访问内核资源。</p><p>如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写锁。</p><h3 id="第9章-I-O复用"><a href="#第9章-I-O复用" class="headerlink" title="第9章 I/O复用"></a>第9章 I/O复用</h3><p><strong>I/O复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。</strong>通常，网络程序在下列情况下需要使用I/O复用技术：</p><ul><li>客户端程序要同时处理多个socket。比如本章将要讨论的非阻塞 connect技术。</li><li>客户端程序要同时处理用户输入和网络连接。比如本章将要讨论的聊天室程序。</li><li>TCP服务器要同时处理监听socket和连接socket。这是I/O复用使 用最多的场合。</li><li>服务器要同时处理TCP请求和UDP请求。比如本章将要讨论的 回射服务器。</li><li>服务器要同时监听多个端口，或者处理多种服务。比如本章将 要讨论的xinetd服务器。</li></ul><h4 id="9-1-select系统调用"><a href="#9-1-select系统调用" class="headerlink" title="9.1 select系统调用"></a>9.1 select系统调用</h4><p><strong>select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</strong></p><h5 id="9-1-1-select-API"><a href="#9-1-1-select-API" class="headerlink" title="9.1.1 select API"></a>9.1.1 select API</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>nfds参数指定被监听的文件描述符的总数。它通常被设置为 select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开 始计数的。</p></li><li><p><strong>readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。</strong>应用程序调用select函数时，通过这3 个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。</p></li><li><p>fd_set结构体仅包含一个整型数组，该数组的每 个元素的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述 符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述 符的总量。由于位操作过于烦琐，我们应该使用下面的一系列宏来访问fd_set 结构体中的位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞</span></span><br><span class="line">FD_ZERO(fd_set* fdset);<span class="comment">/*清除fdset的所有位*/</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set* fdset);<span class="comment">/*设置fdset的位fd*/</span></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set* fdset);<span class="comment">/*清除fdset的位fd*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;<span class="comment">/*测试fdset的位fd是否被设置*/</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>timeout参数用来设置select函数的超时时间。它是一个timeval 结构类型的指针，采用指针参数是因为内核将修改它以告诉应用程序 select等待了多久。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> tv_sec;<span class="comment">/*秒数*/</span></span><br><span class="line"><span class="keyword">long</span> tv_usec;<span class="comment">/*微秒数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>select成功时返回就绪（可读、可写和异常）文件描述符的总数。 如果在超时时间内没有任何文件描述符就绪，select将返回0。select失 败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则 select立即返回-1，并设置errno为EINTR。</p><h5 id="9-1-2-文件描述符就绪条件"><a href="#9-1-2-文件描述符就绪条件" class="headerlink" title="9.1.2 文件描述符就绪条件"></a>9.1.2 文件描述符就绪条件</h5><p>哪些情况下文件描述符可以被认为是可读、可写或者出现异常， 对于select的使用非常关键。</p><p>在网络编程中，下列情况下socket可读：</p><ul><li>socket内核接收缓存区中的字节数大于或等于其低水位标记 SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返 回的字节数大于0。</li><li>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</li><li>监听socket上有新的连接请求。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取 和清除该错误。</li></ul><p>下列情况下socket可写：</p><ul><li>socket内核发送缓存区中的可用字节数大于或等于其低水位标记 SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返 回的字节数大于0。</li><li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将 触发一个SIGPIPE信号。</li><li>socket使用非阻塞connect连接成功或者失败（超时）之后。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取 和清除该错误。</li></ul><p>网络程序中，select能处理的异常情况只有一种：socket上接收到 带外数据。下面我们详细讨论之。</p><h5 id="9-1-3-处理带外数据"><a href="#9-1-3-处理带外数据" class="headerlink" title="9.1.3 处理带外数据"></a>9.1.3 处理带外数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// select是如何同时接收普通数据和带外数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">close(listenfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">fd_set read_fds;</span><br><span class="line">fd_set exception_fds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除fdset的所有位</span></span><br><span class="line">FD_ZERO(&amp;read_fds);</span><br><span class="line">FD_ZERO(&amp;exception_fds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="comment">/*每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，</span></span><br><span class="line"><span class="comment"> * 因为事件发生之后，文件描述符集合将被内核修改</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">FD_SET(connfd, &amp;read_fds);</span><br><span class="line">FD_SET(connfd, &amp;exception_fds);</span><br><span class="line">ret = select(connfd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, &amp;exception_fds, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;selection failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于可读事件，采用普通的recv函数读取数据*/</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(connfd, &amp;read_fds)) &#123;</span><br><span class="line">ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of normal data:%s\n&quot;</span>, ret, buf);</span><br><span class="line"><span class="comment">/*对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据*/</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(connfd, &amp;exception_fds)) &#123;</span><br><span class="line">ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, MSG_OOB);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of oob data:%s\n&quot;</span>, ret, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(connfd);</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-poll系统调用"><a href="#9-2-poll系统调用" class="headerlink" title="9.2 poll系统调用"></a>9.2 poll系统调用</h4><p>poll系统调用和select类似，也是在指定时间内轮询一定数量的文件 描述符，以测试其中是否有就绪者。poll的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜poll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>fds参数是一个pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。pollfd结构体的定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;<span class="comment">/*文件描述符*/</span></span><br><span class="line"><span class="keyword">short</span> events;<span class="comment">/*注册的事件*/</span></span><br><span class="line"><span class="keyword">short</span> revents;<span class="comment">/*实际发生的事件，由内核填充*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，fd成员指定文件描述符；</span></span><br><span class="line"><span class="comment">// events成员告诉poll监听fd上的哪些事件，它是一系列事件的按位或；</span></span><br><span class="line"><span class="comment">// revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件。</span></span><br></pre></td></tr></table></figure><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230301214431734-1678341964417.png" class="" title="image-20230301214431734"></li><li><p>nfds参数指定被监听事件集合fds的大小。其类型nfds_t的定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">nfds_t</span>;</span><br></pre></td></tr></table></figure></li><li><p>timeout参数指定poll的超时值，单位是毫秒。当timeout为-1 时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。</p></li></ul><p>poll系统调用的返回值的含义与select相同。</p><h4 id="9-3-epoll系列系统调用"><a href="#9-3-epoll系列系统调用" class="headerlink" title="9.3 epoll系列系统调用"></a>9.3 epoll系列系统调用</h4><h5 id="9-3-1-内核事件表"><a href="#9-3-1-内核事件表" class="headerlink" title="9.3.1 内核事件表"></a>9.3.1 内核事件表</h5><p>epoll是Linux特有的I/O复用函数。它在实现和使用上与select、 poll有很大差异。</p><p>首先，epoll使用一组函数来完成任务，而不是单个 函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一 个事件表中，从而无须像select和poll那样每次调用都要重复传入文件 描述符集或事件集。<strong>但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。</strong></p><p>这个文件描述符使用如下epoll_create函数 来创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure><ul><li>size参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。</li><li><strong>该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。</strong></li></ul><p>下面的函数用来操作epoll的内核事件表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>fd参数是要操作的文件描述符，</p></li><li><p>op参数则指定操作类型。</p><ul><li>EPOLL_CTL_ADD，往事件表中注册fd上的事件。</li><li>EPOLL_CTL_MOD，修改fd上的注册事件。</li><li>EPOLL_CTL_DEL，删除fd上的注册事件。</li></ul></li><li><p>event参数指定事件，它是epoll_event结构指针类型。epoll_event的 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">__uint32_t</span> events;<span class="comment">/*epoll事件*/</span></span><br><span class="line"><span class="keyword">epoll_data_t</span> data;<span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span>*ptr;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>epoll_data_t是一个联合体，其4个成员中使用最多的是fd，它指定 事件所从属的目标文件描述符。ptr成员可用来指定与fd相关的用户数 据。</p></li><li><p>其中events成员描述事件类型。epoll支持的事件类型和poll基本相 同。表示epoll事件类型的宏是在poll对应的宏前加上“E”，比如epoll的 数据可读事件是EPOLLIN。</p></li><li><p>但epoll有两个额外的事件类型—— EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键， 我们将在后面讨论它们。</p></li></ul><p>epoll_ctl成功时返回0，失败则返回-1并设置errno。</p><h5 id="9-3-2-epoll-wait函数"><a href="#9-3-2-epoll-wait函数" class="headerlink" title="9.3.2 epoll_wait函数"></a>9.3.2 epoll_wait函数</h5><p>epoll系列系统调用的主要接口是epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数成功时返回就绪的文件描述符的个数，失败时返回-1并设 置errno。</p><ul><li>timeout参数的含义与 poll接口的timeout参数相同。</li><li>maxevents参数指定最多监听多少个事 件，它必须大于0。</li><li>epoll_wait函数如果检测到事件，就 <strong>将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。</strong> <strong>这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和poll 的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到 的就绪事件</strong>。这就极大地提高了应用程序索引就绪文件描述符的效率。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  如何索引poll返回的就绪文件描述符</span></span><br><span class="line"><span class="comment">// 当timeout为-1 时，poll调用将永远阻塞，直到某个事件发生</span></span><br><span class="line"><span class="keyword">int</span> ret = poll(fds, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (fds[i].revents &amp; POLLIN)<span class="comment">/*判断第i个文件描述符是否就绪*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = fds[i].fd;</span><br><span class="line"><span class="comment">/*处理sockfd*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如何索引epoll返回的就绪文件描述符</span></span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*仅遍历就绪的ret个文件描述符*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">/*sockfd肯定就绪，直接处理*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="9-3-3-LT和ET模式"><a href="#9-3-3-LT和ET模式" class="headerlink" title="9.3.3 LT和ET模式"></a>9.3.3 LT和ET模式</h5><p>epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平 触发）模式和ET（Edge Trigger，边沿触发）模式。</p><p><strong>LT模式是默认的 工作模式，这种模式下epoll相当于一个效率较高的poll。</strong> 对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事 件。这样，<strong>当应用程序下一次调用epoll_wait时，epoll_wait还会再次向 应用程序通告此事件，直到该事件被处理。</strong></p><p><strong>当往epoll内 核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET 模式来操作该文件描述符。ET模式是epoll的高效工作模式。</strong>而对于采用ET工作模式的 文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，<strong>应用程序必须立即处理该事件，因为后续的epoll_wait调用将 不再向应用程序通知这一事件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件描述符设置成非阻塞的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);  <span class="comment">// 获取状态标志</span></span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，</span></span><br><span class="line"><span class="comment"> * 参数enable_et指定是否对fd启用ET模式</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line"><span class="keyword">if</span> (enable_et) &#123;</span><br><span class="line">event.events |= EPOLLET;</span><br><span class="line"><span class="comment">// 等价于 event.events = event.events | EPOLLET</span></span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*LT模式的工作流程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address,</span><br><span class="line">&amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd, <span class="literal">false</span>); <span class="comment">/*对connfd禁用ET模式*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123; <span class="comment">/*只要socket读缓存中还有未读出的数据，这段代码就被触发*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of content:%s\n&quot;</span>, ret, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*ET模式的工作流程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;</span><br><span class="line">client_addrlength);</span><br><span class="line">addfd(epollfd, connfd, <span class="literal">true</span>); <span class="comment">/*对connfd开启ET模式*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="comment">/*这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。</span></span><br><span class="line"><span class="comment"> * 此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of content:%s\n&quot;</span>, ret, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret, listenfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">addfd(epollfd, listenfd, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lt(events, ret, epollfd, listenfd); <span class="comment">/*使用LT模式*/</span></span><br><span class="line"><span class="comment">//et(events,ret,epollfd,listenfd);    /*使用ET模式*/</span></span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者不妨运行一下这段代码，然后telnet到这个服务器程序上并一 次传输超过10字节（BUFFER_SIZE的大小）的数据，然后比较LT模式 和ET模式的异同。你会发现，正如我们预期的，ET模式下事件被触发 的次数要比LT模式下少很多。 </p><p>注意每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直 处于阻塞状态（饥渴状态）。</p><h5 id="9-3-4-EPOLLONESHOT事件"><a href="#9-3-4-EPOLLONESHOT事件" class="headerlink" title="9.3.4 EPOLLONESHOT事件"></a>9.3.4 EPOLLONESHOT事件</h5><p>即使我们使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程（或进程， 下同）在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发）， 此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线 程同时操作一个socket的局面。</p><p><strong>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非 我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事 件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fds</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中，参</span></span><br><span class="line"><span class="comment">数oneshot指定是否注册fd上的EPOLLONESHOT事件*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> oneshot)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line"><span class="keyword">if</span> (oneshot) &#123;</span><br><span class="line">event.events |= EPOLLONESHOT;</span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，但是操</span></span><br><span class="line"><span class="comment">作系统仍然会触发fd上的EPOLLIN事件，且只触发一次*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_oneshot</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*工作线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = ((fds *) arg)-&gt;sockfd;</span><br><span class="line"><span class="keyword">int</span> epollfd = ((fds *) arg)-&gt;epollfd;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start new thread to receive data on fd:%d\n&quot;</span>, sockfd);</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"><span class="comment">/*循环读取sockfd上的数据，直到遇到EAGAIN错误*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;foreiner closed the connection\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">reset_oneshot(epollfd, sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get content:%s\n&quot;</span>, buf);</span><br><span class="line"><span class="comment">/*休眠5s，模拟数据处理过程*/</span></span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end thread receiving data on fd:%d\n&quot;</span>, sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (</span><br><span class="line">struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意，监听socket listenfd上是不能注册EPOLLONESHOT事件的，否则应用程序</span></span><br><span class="line"><span class="comment"> * 只能处理一个客户连接！因为后续的客户连接请求将不再触发listenfd上的EPOLLIN事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">addfd(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (</span><br><span class="line">struct sockaddr *) &amp;client_address, &amp;</span><br><span class="line">                    client_addrlength);</span><br><span class="line"><span class="comment">/*对每个非监听文件描述符都注册EPOLLONESHOT事件*/</span></span><br><span class="line">addfd(epollfd, connfd, <span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line">fds fds_for_new_worker&#123;&#125;;</span><br><span class="line">fds_for_new_worker.epollfd = epollfd;</span><br><span class="line">fds_for_new_worker.sockfd = sockfd;</span><br><span class="line"><span class="comment">/*新启动一个工作线程为sockfd服务*/</span></span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, (<span class="keyword">void</span> *) &amp;fds_for_new_worker);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从工作线程函数worker来看，如果一个工作线程处理完某个socket 上的一次请求（我们用休眠5 s来模拟这个过程）之后，又接收到该 socket上新的客户请求，则该线程将继续为这个socket服务。并且因为该socket上注册了EPOLLONESHOT事件，其他线程没有机会接触这个 socket，如果工作线程等待5 s后仍然没收到该socket上的下一批客户数 据，则它将放弃为该socket服务。</p><p>同时，它调用reset_oneshot函数来重 置该socket上的注册事件，这将使epoll有机会再次检测到该socket上的 EPOLLIN事件，进而使得其他线程有机会为该socket服务。</p><h4 id="9-4-三组I-O复用函数的比较"><a href="#9-4-三组I-O复用函数的比较" class="headerlink" title="9.4 三组I/O复用函数的比较"></a>9.4 三组I/O复用函数的比较</h4><p>前面我们讨论了select、poll和epoll三组I/O复用系统调用，这3组系 统调用都能同时监听多个文件描述符。它们将等待由timeout参数指定 的超时时间，直到一个或者多个文件描述符上有事件发生时返回，返 回值是就绪的文件描述符的数量。返回0表示没有事件发生。</p><ul><li>事件集合<ul><li>select的参数类型fd_set没有将文件描述符和事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件。这一方面使得select不能处理更多类型的 事件，另一方面由于内核对fd_set集合的在线修改，应用程序下次调用 select前不得不重置这3个fd_set集合。</li><li>poll的参数类型pollfd则多少“聪 明”一些。它把文件描述符和事件都定义其中，任何事件都被统一处理，从而使得编程接口简洁得多。并且内核每次修改的是pollfd结构体 的revents成员，而events成员保持不变，因此下次调用poll时应用程序 无须重置pollfd类型的事件集参数。由于每次select和poll调用都返回整 个用户注册的事件集合（其中包括就绪的和未就绪的），所以应用程 序索引就绪文件描述符的时间复杂度为O（n）。</li><li>epoll则采用与select和 poll完全不同的方式来管理用户注册的事件。它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除、 修改事件。这样，每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文 件描述符的时间复杂度达到O（1）。</li></ul></li><li>最大文件描述符</li></ul><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302141655751-1678341964417.png" class="" title="image-20230302141655751"><h4 id="9-5-I-O复用的高级应用一：非阻塞connect"><a href="#9-5-I-O复用的高级应用一：非阻塞connect" class="headerlink" title="9.5 I/O复用的高级应用一：非阻塞connect"></a>9.5 I/O复用的高级应用一：非阻塞connect</h4><p>在对非阻塞的socket调用connect，而连接又没有立即建立时。会出现一种errno值：EINPROGRESS。 根据man文档的解释，在这种情况下，我们可以调用select、poll 等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。 如果错误码是0，表示连接成功建立，否则连接失败。</p><p>通过上面描述的非阻塞connect方式，我们就能同时发起多个连接 并一起等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1023</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 超时连接函数，参数分别是服务器IP地址、端口号和超时时间（毫秒）。</span></span><br><span class="line"><span class="comment"> * 函数成功时返回已经处于连接状态的socket，失败则返回-1</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unblock_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fdopt = setnonblocking(sockfd);</span><br><span class="line">ret = connect(sockfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果连接成功，则恢复sockfd的属性，并立即返回之*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect with server immediately\n&quot;</span>);</span><br><span class="line">fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno != EINPROGRESS) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果连接没有立即建立，那么只有当errno是EINPROGRESS时才表示连接还在进行，否则出错返回</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unblock connect not support\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd_set writefds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">FD_ZERO(&amp;writefds);</span><br><span class="line">FD_SET(sockfd, &amp;writefds);</span><br><span class="line">timeout.tv_sec = time;</span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = select(sockfd + <span class="number">1</span>, <span class="literal">nullptr</span>, &amp;writefds, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*select超时或者出错，立即返回*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection time out\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试fdset的位fd是否被设置</span></span><br><span class="line"><span class="keyword">if</span> (!FD_ISSET(sockfd, &amp;writefds)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no events on sockfd found\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(error);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用getsockopt来获取并清除sockfd上的错误, getsockopt和setsockopt这两个函数成功时返回0，</span></span><br><span class="line"><span class="comment">// 失败时返回-1并设置errno。</span></span><br><span class="line"><span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误号不为0表示连接出错</span></span><br><span class="line"><span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection failed after select with the error:%d\n&quot;</span>, error);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection ready after select with the socket:%d\n&quot;</span>, sockfd);</span><br><span class="line">fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> sockfd = unblock_connect(ip, port, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**5.11 章节 socket选项 : **     getsockopt, setsockopt, 两个系统调用则是专门用来读取和设置socket文件描述符属性的 方法。</p><h4 id="9-6-I-O复用的高级应用二：聊天室程序"><a href="#9-6-I-O复用的高级应用二：聊天室程序" class="headerlink" title="9.6 I/O复用的高级应用二：聊天室程序"></a>9.6 I/O复用的高级应用二：聊天室程序</h4><p>本节我们以poll为例实现一个简单的聊天室 程序，以阐述如何使用I/O复用技术来同时处理网络连接和用户输入。 该聊天室程序能让所有用户同时在线群聊，它分为客户端和服务器两个部分。</p><p>其中客户端程序有两个功能：一是从标准输入终端读入用户 数据，并将用户数据发送至服务器；二是往标准输出终端打印服务器 发送给它的数据。</p><p>服务器的功能是接收客户数据，并把客户数据发送 给每一个登录到该服务器上的客户端（数据发送者除外）。</p><h5 id="9-6-1-客户端"><a href="#9-6-1-客户端" class="headerlink" title="9.6.1 客户端"></a>9.6.1 客户端</h5><p>客户端程序使用poll同时监听用户输入和网络连接，并利用splice 函数将用户输入内容直接定向到网络连接上以发送之，从而实现数据 零拷贝，提高了程序执行效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">bzero(&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">server_address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;server_address.sin_addr);</span><br><span class="line">server_address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (connect(sockfd, (struct sockaddr *) &amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pollfd fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册文件描述符0（标准输入）和文件描述符sockfd上的可读事件*/</span></span><br><span class="line">fds[<span class="number">0</span>].fd = <span class="number">0</span>;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">fds[<span class="number">1</span>].fd = sockfd;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLIN | POLLRDHUP;</span><br><span class="line">fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> read_buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ret = poll(fds, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLRDHUP) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server close the connection\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="built_in">memset</span>(read_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">recv(fds[<span class="number">1</span>].fd, read_buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, read_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="comment">/*使用splice将用户输入的数据直接写到sockfd上（零拷贝）*/</span></span><br><span class="line">ret = splice(<span class="number">0</span>, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, sockfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="9-6-2-服务端"><a href="#9-6-2-服务端" class="headerlink" title="9.6.2 服务端"></a>9.6.2 服务端</h5><p>服务器程序使用poll同时管理监听socket和连接socket，并且使用牺牲空间换取时间的策略来提高服务器性能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_LIMIT 5    <span class="comment">/*最大用户数量*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64  <span class="comment">/*读缓冲区的大小*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535  <span class="comment">/*文件描述符数量限制*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户数据：客户端socket地址、待写到客户端的数据的位置、从客户端读入的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">char</span> *write_buf;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建users数组，分配FD_LIMIT个client_data对象。可以预期：</span></span><br><span class="line"><span class="comment"> * 每个可能的socket连接都可以获得一个这样的对象，并且socket的值可以直接用来索引（作为数组的下标）</span></span><br><span class="line"><span class="comment"> * socket连接对应的client_data对象，这是将socket和客户数据关联的简单而高效的方式</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line">client_data *users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管我们分配了足够多的client_data对象，但为了提高poll的性能，仍然有必要限制用户的数量</span></span><br><span class="line">pollfd fds[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> user_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= USER_LIMIT; ++i) &#123;</span><br><span class="line">fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">fds[i].events = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ret = poll(fds, user_counter + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; user_counter + <span class="number">1</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fds[0] 用于建立连接</span></span><br><span class="line"><span class="keyword">if</span> ((fds[i].fd == listenfd) &amp;&amp; (fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果请求太多，则关闭新到的连接*/</span></span><br><span class="line"><span class="keyword">if</span> (user_counter &gt;= USER_LIMIT) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于新的连接，同时修改fds和users数组。前文已经提到，</span></span><br><span class="line"><span class="comment"> * users[connfd]对应于新连接文件描述符connfd的客户数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line">user_counter++;</span><br><span class="line">users[connfd].address = client_address;</span><br><span class="line">setnonblocking(connfd);</span><br><span class="line">fds[user_counter].fd = connfd;</span><br><span class="line">fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR;</span><br><span class="line">fds[user_counter].revents = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;comes a new user,now have%d users\n&quot;</span>, user_counter);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLERR) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get an error from%d\n&quot;</span>, fds[i].fd);</span><br><span class="line"><span class="keyword">char</span> errors[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(errors, <span class="string">&#x27;\0&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(errors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getsockopt(fds[i].fd, SOL_SOCKET, SO_ERROR, &amp;errors,&amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLRDHUP) &#123;</span><br><span class="line"><span class="comment">// 如果客户端关闭连接，则服务器也关闭对应的连接，并将用户总数减1</span></span><br><span class="line">users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">close(fds[i].fd);</span><br><span class="line">fds[i] = fds[user_counter];</span><br><span class="line">i--;</span><br><span class="line">user_counter--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a client left\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line"><span class="built_in">memset</span>(users[connfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">ret = recv(connfd, users[connfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of client data%s from%d\n&quot;</span>, ret, users[connfd].buf, connfd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果读操作出错，则关闭连接*/</span></span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">close(connfd);</span><br><span class="line">users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">fds[i] = fds[user_counter];</span><br><span class="line">i--;</span><br><span class="line">user_counter--;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*如果接收到客户数据，则通知其他socket连接准备写数据*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= user_counter; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (fds[j].fd == connfd) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">fds[j].events |= ~POLLIN;</span><br><span class="line">fds[j].events |= POLLOUT;</span><br><span class="line">users[fds[j].fd].write_buf = users[connfd].buf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLOUT) &#123;</span><br><span class="line"><span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line"><span class="keyword">if</span> (!users[connfd].write_buf) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = send(connfd, users[connfd].write_buf, <span class="built_in">strlen</span>(users[connfd].write_buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">users[connfd].write_buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*写完数据后需要重新注册fds[i]上的可读事件*/</span></span><br><span class="line">fds[i].events |= ~POLLOUT;</span><br><span class="line">fds[i].events |= POLLIN;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]users;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-7-I-O-复用的高级应用三-同时处理TCP和UDP服务"><a href="#9-7-I-O-复用的高级应用三-同时处理TCP和UDP服务" class="headerlink" title="9.7 I/O 复用的高级应用三: 同时处理TCP和UDP服务"></a>9.7 I/O 复用的高级应用三: 同时处理TCP和UDP服务</h4><p>在实际应用 中，有不少服务器程序能同时监听多个端口，比如超级服务inetd和 android的调试服务adbd。</p><p>从bind系统调用的参数来看，一个socket只能与一个socket地址绑 定，即一个socket只能用来监听一个端口。因此，服务器如果要同时 监听多个端口，就必须创建多个socket，并将它们分别绑定到各个端 口上。这样一来，服务器程序就需要同时管理多个监听socket，I/O复 用技术就有了用武之地。</p><p>另外，即使是同一个端口，如果服务器要同 时处理该端口上的TCP和UDP请求，则也需要创建两个不同的socket： 一个是流socket，另一个是数据报socket，并将它们都绑定到该端口 上。比如代码清单9-8所示的回射服务器(比如echo)就能同时处理一个端口上的 TCP和UDP请求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建TCP socket，并将其绑定到端口port上*/</span></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建UDP socket，并将其绑定到端口port上*/</span></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> udpfd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">assert(udpfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(udpfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册TCP socket和UDP socket上的可读事件*/</span></span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line">addfd(epollfd, udpfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockfd == udpfd) &#123;</span><br><span class="line"><span class="keyword">char</span> buf[UDP_BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, UDP_BUFFER_SIZE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="comment">// udp数据读取</span></span><br><span class="line">ret = recvfrom(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>,(struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// udp 数据发送</span></span><br><span class="line">sendto(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>,(struct sockaddr *) &amp;client_address, client_addrlength);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">char</span> buf[TCP_BUFFER_SIZE];</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, TCP_BUFFER_SIZE);</span><br><span class="line">ret = recv(sockfd, buf, TCP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">send(sockfd, buf, ret, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-8-超级服务xinetd"><a href="#9-8-超级服务xinetd" class="headerlink" title="9.8 超级服务xinetd"></a>9.8 超级服务xinetd</h4><p>Linux因特网服务inetd是超级服务。它同时管理着多个子服务，即 监听多个端口。现在Linux系统上使用的inetd服务程序通常是其升级版 本xinetd。</p><h5 id="9-8-1-xinetd-配置文件"><a href="#9-8-1-xinetd-配置文件" class="headerlink" title="9.8.1 xinetd 配置文件"></a>9.8.1 xinetd 配置文件</h5><p>xinetd采用/etc/xinetd.conf主配置文件和/etc/xinetd.d目录下的子配置 文件来管理所有服务。主配置文件包含的是通用选项，这些选项将被 所有子配置文件继承。不过子配置文件可以覆盖这些选项。每一个子 配置文件用于设置一个子服务的参数。</p><p>比如，telnet子服务的配置文 件/etc/xinetd.d/telnet的典型内容如下：</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211328677-1678341964417.png" class="" title="image-20230302211328677"><p>/etc/xinetd. d/telnet文件中的每一项的含义如表9-3所示。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211402685-1678341964417.png" class="" title="image-20230302211402685"><h5 id="9-8-2-xinetd-服务流程"><a href="#9-8-2-xinetd-服务流程" class="headerlink" title="9.8.2 xinetd 服务流程"></a>9.8.2 xinetd 服务流程</h5><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211732296-1678341964417.png" class="" title="image-20230302211732296"><h3 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h3><p><strong>信号是由用户、系统或者进程发送给目标进程的信息</strong>，以通知目 标进程某个状态的改变或系统异常。Linux信号可由如下条件产生：</p><ul><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</li><li>系统异常。比如浮点异常和非法内存段访问。</li><li>系统状态变化。比如alarm定时器到期将引起SIGALRM信号。</li><li>运行kill命令或调用kill函数。</li></ul><h4 id="10-1-Linux信号概述"><a href="#10-1-Linux信号概述" class="headerlink" title="10.1 Linux信号概述"></a>10.1 Linux信号概述</h4><h5 id="10-1-1-发送信号"><a href="#10-1-1-发送信号" class="headerlink" title="10.1.1 发送信号"></a>10.1.1 发送信号</h5><p>Linux下，一个进程给其他进程发送信号的API是kill函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>该函数把信号sig发送给目标进程，Linux定义的信号值都大于0，如果sig取值为0，则kill函数不发送 任何信号。但将sig设置为0可以用来检测目标进程或进程组是否存在， 因为检查工作总是在信号发送之前就执行。</p></li><li><p>目标进程由pid参数指定，其可 能的取值及含义如表10-1所示。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304135652650-1678341964417.png" class="" title="image-20230304135652650"></li></ul><h5 id="10-1-2-信号处理方式"><a href="#10-1-2-信号处理方式" class="headerlink" title="10.1.2 信号处理方式"></a>10.1.2 信号处理方式</h5><p>目标进程在收到信号时，需要定义一个接收函数来处理之。信号 处理函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">__sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>信号处理函数只带有一个整型参数，该参数用来指示信号类型。</p><h5 id="10-1-3-Linux信号"><a href="#10-1-3-Linux信号" class="headerlink" title="10.1.3 Linux信号"></a>10.1.3 Linux信号</h5><p>Linux的可用信号都定义在bits/signum.h头文件中，其中包括标准信 号和POSIX实时信号。本书仅讨论标准信号， 以下列举几种与网络编程关系紧密的几个信号：</p><ol><li>SIGHUP：控制终端挂起</li><li>SIGPIPE：往读端被关闭的管道或者socket连接中写数据</li><li>SIGURG：socket连接上接收到紧急数据</li><li>SIGALRM：由alarm或setitimer设置的实时闹钟超时引起</li><li>SIGCHLD：子进程状态发生变化（退出或者暂停）</li></ol><h5 id="10-1-4-中断系统调用"><a href="#10-1-4-中断系统调用" class="headerlink" title="10.1.4 中断系统调用"></a>10.1.4 中断系统调用</h5><p>如果程序在执行处于阻塞状态的系统调用时接收到信号，并且我 们为该信号设置了信号处理函数，则默认情况下系统调用将被中断， 并且errno被设置为EINTR。</p><p>我们可以使用sigaction函数（见后文）为信 号设置SA_RESTART标志以自动重启被该信号中断的系统调用。</p><h4 id="10-2-信号函数"><a href="#10-2-信号函数" class="headerlink" title="10.2 信号函数"></a>10.2 信号函数</h4><h5 id="10-2-1-signal系统调用"><a href="#10-2-1-signal系统调用" class="headerlink" title="10.2.1 signal系统调用"></a>10.2.1 signal系统调用</h5><p>要为一个<strong>信号设置处理函数</strong>，可以使用下面的signal系统调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">_sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">_sighandler_t</span> _handler)</span></span></span><br></pre></td></tr></table></figure><ul><li>sig参数指出要捕获的信号类型。</li><li>_handler参数是_sighandler_t类型 的函数指针，用于指定信号sig的处理函数。</li></ul><p>signal函数成功时返回一个函数指针，该函数指针的类型也是 _sighandler_t。 <strong>这个返回值是前一次调用signal函数时传入的函数指针， 或者是信号sig对应的默认处理函数指针SIG_DEF（如果是第一次调用 signal的话）。</strong></p><p>signal系统调用出错时返回SIG_ERR，并设置errno。</p><h5 id="10-2-2-sigaction系统调用"><a href="#10-2-2-sigaction系统调用" class="headerlink" title="10.2.2 sigaction系统调用"></a>10.2.2 sigaction系统调用</h5><p>设置<strong>信号处理函数</strong>的更健壮的接口是如下的系统调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction* act,struct sigaction* oact)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sig参数指出要捕获的信号类型</li><li>act参数指定新的信号处理方式</li><li>oact参数则输出信号先前的处理方式（如果不为NULL的话）</li></ul><p>sigaction结构体描述了信号处理 的细节，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure describing the action to be taken when a signal arrives.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* Signal handler.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="comment">/* Used if SA_SIGINFO is not set.  */</span></span><br><span class="line"><span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line"><span class="comment">/* Used if SA_SIGINFO is set.  */</span></span><br><span class="line"><span class="keyword">void</span> (*sa_sigaction) (<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">      &#125;</span><br><span class="line">    __sigaction_handler;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> sa_handler__sigaction_handler.sa_handler</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> sa_sigaction__sigaction_handler.sa_sigaction</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional set of signals to be blocked.  */</span></span><br><span class="line">    <span class="keyword">__sigset_t</span> sa_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Special flags.  */</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore handler.  */</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer) (<span class="keyword">void</span>);</span><br><span class="line">    <span class="comment">// 指向返回值是void, 参数是void类型的 函数指针</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li><p>该结构体中的sa_hander成员指定信号处理函数。</p></li><li><p>sa_mask成员设置进程的信号掩码（确切地说是在进程原有信号掩码的基础上增加信号 掩码），以指定哪些信号不能发送给本进程。<strong>sa_mask是信号集 sigset_t（_sigset_t的同义词）类型，该类型指定一组信号。</strong> 下一节介绍sigset_t</p></li><li><p>sa_flags成员用于设置程序收到信号时的行 为，其可选值如表10-4所示：</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304142154845-1678341964417.png" class="" title="image-20230304142154845"></li></ul><h4 id="10-3-信号集"><a href="#10-3-信号集" class="headerlink" title="10.3 信号集"></a>10.3 信号集</h4><h5 id="10-3-1-信号集函数"><a href="#10-3-1-信号集函数" class="headerlink" title="10.3.1 信号集函数"></a>10.3.1 信号集函数</h5><p>前文提到，Linux使用数据结构sigset_t来表示一组信号。其定义如 下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/sigset.h＞</span></span><br><span class="line">#define_SIGSET_NWORDS(<span class="number">1024</span>/(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>)))</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> int__val[_SIGSET_NWORDS];</span><br><span class="line">&#125;<span class="keyword">__sigset_t</span>;</span><br></pre></td></tr></table></figure><p>sigset_t实际上是一个长整型数组，数组的每个元素的每个位表示一个信号。这种定义方式和文件描述符集fd_set类似。</p><p>Linux提供了如下一组函数来设置、修改、删除和查询信号集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*清空信号集*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*在信号集中设置所有信号*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>*_set,<span class="keyword">int</span> _signo)</span><span class="comment">/*将信号_signo添加至信号集中*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>* _set,<span class="keyword">int</span> _signo)</span><span class="comment">/*将信号_signo从信号集中删除*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(_const <span class="keyword">sigset_t</span>* _set, int_signo)</span><span class="comment">/*测试_signo是否在信号集中*/</span></span></span><br></pre></td></tr></table></figure><h5 id="10-3-2-进程信号掩码"><a href="#10-3-2-进程信号掩码" class="headerlink" title="10.3.2 进程信号掩码"></a>10.3.2 进程信号掩码</h5><p>我们可以利用<strong>sigaction结构体的sa_mask成员来设置进程的信号掩码</strong>。此外，如下函数也可以用于设置或查看进程的信号掩 码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> _how, _const <span class="keyword">sigset_t</span>* _set, <span class="keyword">sigset_t</span>* _oset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>_set</code>参数指定新的信号掩码，</p></li><li><p>_oset参数则输出原来的信号掩码（如 果不为NULL的话）。</p></li><li><p>如果_set参数不为NULL，则_how参数指定设置 进程信号掩码的方式，其可选值如表10-5所示。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304143250709-1678341964417.png" class="" title="image-20230304143250709"></li></ul><p>sigprocmask成功时返回0，失败则返回-1并设置errno。</p><h5 id="10-3-3-被挂起的信号"><a href="#10-3-3-被挂起的信号" class="headerlink" title="10.3.3 被挂起的信号"></a>10.3.3 被挂起的信号</h5><p>设置进程信号掩码后，被屏蔽的信号将不能被进程接收。<strong>如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个被挂起的信号。</strong>如果我们取消对被挂起信号的屏蔽，则它能立即被进 程接收到</p><p>如下函数可以获得进程当前被挂起的信号集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>set参数用于保存被挂起的信号集。显然，进程即使多次接收到同 一个被挂起的信号，sigpending函数也只能反映一次。并且，当我们再 次使用sigprocmask使能该挂起的信号时，该信号的处理函数也只被触 发一次。</p><p>sigpending成功时返回0，失败时返回-1并设置errno。</p><h4 id="10-4-统一事件源"><a href="#10-4-统一事件源" class="headerlink" title="10.4 统一事件源"></a>10.4 统一事件源</h4><p>信号是一种异步事件：信号处理函数和程序的主循环是两条不同 的执行路线。很显然，信号处理函数需要尽可能快地执行完毕，以确 保该信号不被屏蔽（前面提到过，为了避免一些竞态条件，信号在处 理期间，系统不会再次触发它）太久。</p><p>一种典型的解决方案是：<strong>把信号的主要处理逻辑放到程序的主循环中</strong>，当信号处理函数被触发时， 它<strong>只是简单地通知主循环程序接收到信号</strong>，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。</p><p><strong>信号处理函数通常使用管道来将信号“传递”给主循环</strong>：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么 主循环怎么知道管道上何时有数据可读呢  ?</p><p>这很简单，<strong>我们只需要使用 I/O复用系统调用来监听管道的读端文件描述符上的可读事件</strong>。如此一 来，信号事件就能和其他I/O事件一样被处理，即统一事件源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将事件添加到 epoll的内核事件表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*保留原来的errno，在函数最后恢复，以保证函数的可重入性*/</span></span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">/*将信号值写入管道，以通知主循环*/</span></span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置信号的处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = sig_handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SA_RESTART 重新调用被该信号终止的系统调用</span></span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在信号集中设置所有信号*/</span></span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表</span></span><br><span class="line"><span class="comment"> * 文件描述符使用如下epoll_create函数 来创建</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用socketpair创建管道，注册pipefd[0]上的可读事件*/</span></span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line"></span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置一些信号的处理函数*/</span></span><br><span class="line">addsig(SIGHUP);</span><br><span class="line">addsig(SIGCHLD);</span><br><span class="line">addsig(SIGTERM);</span><br><span class="line">addsig(SIGINT);</span><br><span class="line"><span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">/*如果就绪的文件描述符是listenfd，则处理新的连接*/</span></span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果就绪的文件描述符是pipefd[0]，则处理信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*因为每个信号值占1字节，所以按字节来逐个接收信号。我们以SIGTERM为例，</span></span><br><span class="line"><span class="comment"> * 来说明如何安全地终止服务器主循环*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD:</span><br><span class="line"><span class="keyword">case</span> SIGHUP: &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM:</span><br><span class="line"><span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;close fds\n&quot;</span>);</span><br><span class="line">close(listenfd);</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-5-网络编程相关信号"><a href="#10-5-网络编程相关信号" class="headerlink" title="10.5 网络编程相关信号"></a>10.5 网络编程相关信号</h4><p>本节中我们详细探讨三个和网络编程密切相关的信号。</p><h5 id="10-5-1-SIGHUP"><a href="#10-5-1-SIGHUP" class="headerlink" title="10.5.1 SIGHUP"></a>10.5.1 SIGHUP</h5><p><strong>当挂起进程的控制终端时，SIGHUP信号将被触发。</strong>对于没有控 制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务 器重读配置文件。一个典型的例子是xinetd超级服务程序。</p><p>xinetd程序在接收到SIGHUP信号之后将调用hard_reconfig函数 （见xinetd源码），它循环读取/etc/xinetd.d/目录下的每个子配置文 件，并检测其变化。如果某个正在运行的子服务的配置文件被修改以停止服务，则xinetd主进程将给该子服务进程发送SIGTERM信号以结 束它。如果某个子服务的配置文件被修改以开启服务，则xinetd将创建 新的socket并将其绑定到该服务对应的端口上。</p><h5 id="10-5-2-SIGPIPE"><a href="#10-5-2-SIGPIPE" class="headerlink" title="10.5.2 SIGPIPE"></a>10.5.2 SIGPIPE</h5><p>默认情况下，往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号。我们需要在<strong>代码中捕获并处理该信号</strong>，或者至少忽 略它，因为程序接收到SIGPIPE信号的默认行为是结束进程，而我们 绝对不希望因为错误的写操作而导致程序退出。引起SIGPIPE信号的 写操作将设置errno为EPIPE。</p><p>第5章提到，我们可以使用send函数的MSG_NOSIGNAL标志来禁 止写操作触发SIGPIPE信号。在这种情况下，我们应该使用send函数反 馈的errno值来判断管道或者socket连接的读端是否已经关闭。 </p><p>此外，我们也可以利用I/O复用系统调用来检测管道和socket连接 的读端是否已经关闭。以poll为例，当管道的读端关闭时，写端文件 描述符上的POLLHUP事件将被触发；当socket连接被对方关闭时， socket上的POLLRDHUP事件将被触发。</p><h5 id="10-5-3-SIGURG"><a href="#10-5-3-SIGURG" class="headerlink" title="10.5.3 SIGURG"></a>10.5.3 SIGURG</h5><p>在Linux环境下，内核通知应用程序带外数据到达主要有两种方 法：</p><ol><li>一种是第9章介绍的I/O复用技术，select等系统调用在接收到带外 数据时将返回，并向应用程序报告socket上的异常事件, 代码9_1</li><li>另外一种方法就是使用SIGURG信号，如 代码清单10-3所示。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGURG信号的处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_urg</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno=errno;</span><br><span class="line"><span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,MSG_OOB);<span class="comment">/*接收带外数据*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of oob data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">errno=save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig,<span class="keyword">void</span>(*sig_handler)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler=sig_handler;</span><br><span class="line">sa.sa_flags|=SA_RESTART;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig,&amp;sa,<span class="literal">nullptr</span>)!=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,&amp;address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sock&gt;=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret=bind(sock,(struct sockaddr*)&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=listen(sock,<span class="number">5</span>);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client);</span><br><span class="line">connfd=accept(sock,(struct sockaddr*)&amp;client,&amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>,errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">addsig(SIGURG,sig_urg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用SIGURG信号之前，我们必须设置socket的宿主进程或进程组</span></span><br><span class="line"><span class="comment"> * F_SETOWN 设定SIGIO和SIGURG信号的宿主进程的PID或者进程组的组id</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">fcntl(connfd,F_SETOWN, getpid());</span><br><span class="line"><span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">/*循环接收普通数据*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line">ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of normal data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第11章-定时器"><a href="#第11章-定时器" class="headerlink" title="第11章 定时器"></a>第11章 定时器</h3><hr><p>网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态。服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。</p><p>为此，<strong>我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构</strong>， 比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定 时事件的统一管理。本章主要讨论的就是两种高效的管理定时器的容器：时间轮和时间堆。</p><p><strong>注</strong>: 定时器容器是容器类数据结构，比如时间轮；定时器则是容器内容纳的一个个对象，它是对定时事件的封装。</p><p>我们先要介绍定时的方法。 定时是指在一段时间之后触发某段代码的机制，我们可以在这段代码 中依次处理所有到期的定时器。换言之，定时机制是定时器得以被处 理的原动力。Linux提供了三种定时方法，它们是：</p><ul><li>socket选项SO_RCVTIMEO和SO_SNDTIMEO。</li><li>SIGALRM信号。</li><li>I/O复用系统调用的超时参数</li></ul><h4 id="11-1-socket选项SO-RCVTIMEO和-SO-SNDTIMEO"><a href="#11-1-socket选项SO-RCVTIMEO和-SO-SNDTIMEO" class="headerlink" title="11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO"></a>11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO</h4><p>第5章中我们介绍过socket选项SO_RCVTIMEO和 SO_SNDTIMEO，它们分别用来设置socket接收数据超时时间和发送数 据超时时间。</p><p>这两个选项仅对与数据接收和发送相关的socket专用系统调用有效，这些系统调用包括send、sendmsg、recv、recvmsg、 accept和connect。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304222359944-1678341964417.png" class="" title="image-20230304222359944"><p>我们可以<strong>根据系统调用（send、 sendmsg、recv、recvmsg、accept和connect）的返回值以及errno来判断 超时时间是否已到</strong>，进而决定是否开始处理定时任务。</p><h4 id="11-2-SIGALRM-信号"><a href="#11-2-SIGALRM-信号" class="headerlink" title="11.2 SIGALRM 信号"></a>11.2 SIGALRM 信号</h4><p>第10章提到，<strong>由alarm和setitimer函数设置的实时闹钟一旦超时</strong>， 将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来 处理定时任务。</p><p>但是，如果要处理多个定时任务，我们就需要不断地 触发SIGALRM信号，并在其信号处理函数中执行到期的任务。一般而言，<strong>SIGALRM信号按照固定的频率生成，即由alarm或setitimer函数设 置的定时周期T保持不变。</strong>如果某个定时任务的超时时间不是T的整数 倍，那么它实际被执行的时间和预期的时间将略有偏差。因此定时周 期T反映了定时的精度。</p><p>我们需要先给出一种简单的定时器实现 ——基于升序链表的定时器，并把它应用到处理非活动连接这个实例 中。</p><p>这样，我们才能观察到<strong>SIGALRM信号处理函数是如何处理定时器 并执行定时任务的</strong>。此外，我们介绍这种定时器也是为了和后面要讨论的高效定时器——时间轮和时间堆做对比。</p><h5 id="11-2-1-基于升序链表的定时器"><a href="#11-2-1-基于升序链表的定时器" class="headerlink" title="11.2.1 基于升序链表的定时器"></a>11.2.1 基于升序链表的定时器</h5><p>定时器通常至少要包含两个成员：</p><ul><li>一个超时时间（相对时间或者 绝对时间）</li><li>一个任务回调函数</li><li>有的时候还可能包含回调函数被执 行时需要传入的参数，以及是否重启定时器等信息。</li><li>如果使用链表作为容器来串联所有的定时器，则每个定时器还要包含指向下一个定时 器的指针成员。进一步，如果链表是双向的，则每个定时器还需要包 含指向前一个定时器的指针成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LST_TIMER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span>;</span><span class="comment">/*前向声明*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用户数据结构：客户端socket地址、socket文件描述符、读缓存和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">util_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">util_timer() : prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">time_t</span> expire&#123;&#125;;<span class="comment">/*任务的超时时间，这里使用绝对时间*/</span></span><br><span class="line"><span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*任务回调函数*/</span></span><br><span class="line"><span class="comment">/*回调函数处理的客户数据，由定时器的执行者传递给回调函数*/</span></span><br><span class="line"></span><br><span class="line">client_data *user_data&#123;&#125;;</span><br><span class="line">util_timer *prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">util_timer *next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器链表。它是一个升序、双向链表，且带有头结点和尾节点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort_timer_lst</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">sort_timer_lst() : head(<span class="literal">nullptr</span>), tail(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表被销毁时，删除其中所有的定时器*/</span></span><br><span class="line">~sort_timer_lst() &#123;</span><br><span class="line">util_timer *tmp = head;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">head = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将目标定时器timer添加到链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line">head = tail = timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果目标定时器的超时时间小于当前链表中所有定时器的超时时间，</span></span><br><span class="line"><span class="comment"> * 则把该定时器插入链表头部，作为链表新的头节点。否则就需要调用重载函数</span></span><br><span class="line"><span class="comment">add_timer(util_timer*timer,util_timer*lst_head)，把它插入链表中合适的位</span></span><br><span class="line"><span class="comment">置，以保证链表的升序特性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire) &#123;</span><br><span class="line">timer-&gt;next = head;</span><br><span class="line">head-&gt;prev = timer;</span><br><span class="line">head = timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">add_timer(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当某个定时任务发生变化时，调整对应的定时器在链表中的位置。这个函数只考虑被</span></span><br><span class="line"><span class="comment">调整的定时器的超时时间延长的情况，即该定时器需要往链表的尾部移动*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">util_timer *tmp = timer-&gt;next;</span><br><span class="line"><span class="comment">/*如果被调整的目标定时器处在链表尾部，或者该定时器新的超时值仍然小于其下一个</span></span><br><span class="line"><span class="comment">定时器的超时值，则不用调整*/</span></span><br><span class="line"><span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器是链表的头节点，则将该定时器从链表中取出并重新插入链表*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">add_timer(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器不是链表的头节点，则将该定时器从链表中取出，然后插入其原来所</span></span><br><span class="line"><span class="comment">在位置之后的部分链表中*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">add_timer(timer, timer-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将目标定时器timer从链表中删除*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下面这个条件成立表示链表中只有一个定时器，即目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail)) &#123;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">head = <span class="literal">nullptr</span>;</span><br><span class="line">tail = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的头结点，</span></span><br><span class="line"><span class="comment"> * 则将链表的头结点重置为原头节点的下一个节点，然后删除目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的尾结点，</span></span><br><span class="line"><span class="comment"> * 则将链表的尾结点重置为原尾节点的前一个节点，然后删除目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == tail) &#123;</span><br><span class="line">tail = tail-&gt;prev;</span><br><span class="line">tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果目标定时器位于链表的中间，则把它前后的定时器串联起来，然后删除目标定时器*/</span></span><br><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGALRM信号每次被触发就在其信号处理函数（如果使用统一事件源，则是主函数）</span></span><br><span class="line"><span class="comment">中执行一次tick函数，以处理链表上到期的任务*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;timer tick\n&quot;</span>);</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);<span class="comment">/*获得系统当前的时间*/</span></span><br><span class="line"></span><br><span class="line">util_timer *tmp = head;</span><br><span class="line"><span class="comment">/*从头结点开始依次处理每个定时器，直到遇到一个尚未到期的定时器，这就是定时器的核心逻辑*/</span></span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 因为每个定时器都使用绝对时间作为超时值，所以我们可以把定时器的超时值和系统当前时间，</span></span><br><span class="line"><span class="comment"> * 比较以判断定时器是否到期*/</span></span><br><span class="line"><span class="keyword">if</span> (cur &lt; tmp-&gt;expire) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用定时器的回调函数，以执行定时任务*/</span></span><br><span class="line">tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头结点*/</span></span><br><span class="line">head = tmp-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*一个重载的辅助函数，它被公有的add_timer函数和adjust_timer函数调用。</span></span><br><span class="line"><span class="comment"> * 该函数表示将目标定时器timer添加到节点lst_head之后的部分链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span> </span>&#123;</span><br><span class="line">util_timer *prev = lst_head;</span><br><span class="line">util_timer *tmp = prev-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 遍历lst_head节点之后的部分链表，直到找到一个超时时间大于目标定时器的超时时间的节点，</span></span><br><span class="line"><span class="comment"> * 并将目标定时器插入该节点之前*/</span></span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire) &#123;</span><br><span class="line">prev-&gt;next = timer;</span><br><span class="line">timer-&gt;next = tmp;</span><br><span class="line">tmp-&gt;prev = timer;</span><br><span class="line">timer-&gt;prev = prev;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev = tmp;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果遍历完lst_head节点之后的部分链表，仍未找到超时时间大于目标定时器的超</span></span><br><span class="line"><span class="comment">时时间的节点，则将目标定时器插入链表尾部，并把它设置为链表新的尾节点*/</span></span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">prev-&gt;next = timer;</span><br><span class="line">timer-&gt;prev = prev;</span><br><span class="line">timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">tail = timer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">util_timer *head;</span><br><span class="line">util_timer *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>sort_timer_lst是一 个升序链表。其核心函数tick相当于一个心搏函数，它每隔一段固定的 时间就执行一次，以检测并处理到期的任务。判断定时任务到期的依据是定时器的expire值小于当前的系统时间。</p><p><strong>从执行效率来看，添加定时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)（因为是双向链表），执行定时任务的时间复杂度是O(1)。</strong></p><h5 id="11-2-2-处理非活动连接"><a href="#11-2-2-处理非活动连接" class="headerlink" title="11.2.2 处理非活动连接"></a>11.2.2 处理非活动连接</h5><p>现在我们考虑上述升序定时器链表的实际应用——处理非活动连 接。服务器程序通常要定期处理非活动连接：给客户端发一个重连请 求，或者关闭该连接，或者其他。</p><blockquote><p>Linux在内核中提供了对连接是否处 于活动状态的定期检查机制，我们可以通过socket选项KEEPALIVE来 激活它。不过使用这种方式将使得应用程序对连接的管理变得复杂。</p></blockquote><p>比如，代码清单11-3利用alarm函 数周期性地触发SIGALRM信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../11 timer/lst_timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMESLOT 5</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">static</span> sort_timer_lst timer_lst; <span class="comment">/*利用代码清单11-2中的升序链表来管理定时器*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll 添加到内核表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = sig_handler;</span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*定时处理任务，实际上就是调用tick函数*/</span></span><br><span class="line">timer_lst.tick();</span><br><span class="line"><span class="comment">/*因为一次alarm调用只会引起一次SIGALRM信号，所以我们要重新定时，以不断触发SIGALRM信号*/</span></span><br><span class="line">alarm(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器回调函数，它删除非活动连接socket上的注册事件，并关闭之*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span> </span>&#123;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">assert(user_data);</span><br><span class="line">close(user_data-&gt;sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;close fd%d\n&quot;</span>, user_data-&gt;sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置信号处理函数*/</span></span><br><span class="line">addsig(SIGALRM);</span><br><span class="line">addsig(SIGTERM);  <span class="comment">// 主进程发给子进程的结束信号</span></span><br><span class="line"><span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"><span class="keyword">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">alarm(TIMESLOT);<span class="comment">/*定时*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理新到的客户连接*/</span></span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">users[connfd].address = client_address;</span><br><span class="line">users[connfd].sockfd = connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建定时器，设置其回调函数与超时时间，然后绑定定时器与用户数据，最后将定时器添加到链表timer_lst中*/</span></span><br><span class="line"><span class="keyword">auto</span> *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">timer-&gt;user_data = &amp;users[connfd];</span><br><span class="line">timer-&gt;cb_func = cb_func;</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">users[connfd].timer = timer;</span><br><span class="line">timer_lst.add_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// recv成功时返回实际读取到的数据的长度</span></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//handle the error</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ret; ++j) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[j]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGALRM: &#123;</span><br><span class="line"><span class="comment">/* 用timeout变量标记有定时任务需要处理，但不立即处理定时任务。这是因为定时任</span></span><br><span class="line"><span class="comment">务的优先级不是很高，我们优先处理其他更重要的任务*/</span></span><br><span class="line">timeout = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM: &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理客户连接上接收到的数据*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="built_in">memset</span>(users[sockfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">ret = recv(sockfd, users[sockfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of client data%s from%d\n&quot;</span>, ret, users[sockfd].buf, sockfd);</span><br><span class="line">util_timer *timer = users[sockfd].timer;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果发生读错误，则关闭连接，并移除其对应的定时器*/</span></span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">cb_func(&amp;users[sockfd]);</span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line">timer_lst.del_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果对方已经关闭连接，则我们也关闭连接，并移除对应的定时器*/</span></span><br><span class="line">cb_func(&amp;users[sockfd]);</span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line">timer_lst.del_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*如果某个客户连接上有数据可读，则我们要调整该连接对应的定时器，以延迟该连接被关闭的时间*/</span></span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);</span><br><span class="line">timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;adjust timer once\n&quot;</span>);</span><br><span class="line">timer_lst.adjust_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//others</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*最后处理定时事件，因为I/O事件有更高的优先级。当然，这样做将导致定时任务不能精确地按照预期的时间执行*/</span></span><br><span class="line"><span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">timer_handler();</span><br><span class="line">timeout = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">delete</span>[]users;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="11-3-I-O复用系统调用的超时参数"><a href="#11-3-I-O复用系统调用的超时参数" class="headerlink" title="11.3 I/O复用系统调用的超时参数"></a>11.3 I/O复用系统调用的超时参数</h4><p>Linux下的3组I/O复用系统调用都带有超时参数，因此它们不仅能 统一处理信号和I/O事件，也能统一处理定时事件。</p><p>但是由于I/O复用 系统调用可能在超时时间到期之前就返回（有I/O事件发生），所以如 果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT 5000</span></span><br><span class="line"><span class="keyword">int</span> timeout = TIMEOUT;</span><br><span class="line"><span class="keyword">time_t</span> start = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">time_t</span> end = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the timeout is now%d mil-seconds\n&quot;</span>, timeout);</span><br><span class="line">start = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, timeout);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">/*如果epoll_wait成功返回0，则说明超时时间到，此时便可处理定时任务，并重置定时时间*/</span></span><br><span class="line"><span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">timeout = TIMEOUT;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">end = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*如果epoll_wait的返回值大于0，则本次epoll_wait调用持续的时间是(endstart)*1000 ms，</span></span><br><span class="line"><span class="comment"> * 我们需要将定时时间timeout减去这段时间，以获得下次epoll_wait调用的超时参数*/</span></span><br><span class="line">timeout -= (end - start) * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">/*重新计算之后的timeout值有可能等于0，说明本次epoll_wait调用返回时，不仅有文件描述符就绪，</span></span><br><span class="line"><span class="comment"> * 而且其超时时间也刚好到达，此时我们也要处理定时任务，并重置定时时间*/</span></span><br><span class="line"><span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">timeout = TIMEOUT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//handle connections</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-4-高性能计时器"><a href="#11-4-高性能计时器" class="headerlink" title="11.4 高性能计时器"></a>11.4 高性能计时器</h4><h5 id="11-4-1-时间轮"><a href="#11-4-1-时间轮" class="headerlink" title="11.4.1 时间轮"></a>11.4.1 时间轮</h5><p>前文提到，基于排序链表的定时器存在一个问题：添加定时器的 效率偏低。</p><p>下面我们要讨论的时间轮解决了这个问题。一种简单的时 间轮如图11-1所示。</p><img src="学习笔记/Linux高性能服务器编程/image-20230305172536051.png" alt="image-20230305172536051" style="zoom:67%;" /><p>图11-1所示的时间轮内，（实线）指针指向轮子上的一个槽 （slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽 （虚线指针指向的槽），每次转动称为一个滴答（tick）。一个滴答的 时间称为时间轮的槽间隔si（slot interval），它实际上就是心搏时间。该时间轮共有N个槽，因此它运转一周的时间是<code>N*si</code>。每个槽指向一条 定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间 相差<code>N*si</code>的整数倍。</p><p>时间轮正是利用这个关系将定时器散列到不同的 链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时 器，则该定时器将被插入槽ts（timer slot）对应的链表中：</p><p><strong>ts = (cs + (ti / si)) % N</strong></p><p>很显然，对时间轮而言，要提高定时精度，就要使si值足够小；要 提高执行效率，则要求N值足够大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIME_WHEEL_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_WHEEL_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">tw_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">tw_timer(<span class="keyword">int</span> rot, <span class="keyword">int</span> ts): next(<span class="literal">nullptr</span>), prev(<span class="literal">nullptr</span>), rotation(rot), time_slot(ts) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> rotation;<span class="comment">/*记录定时器在时间轮转多少圈后生效*/</span></span><br><span class="line"><span class="keyword">int</span> time_slot;<span class="comment">/*记录定时器属于时间轮上哪个槽（对应的链表，下同）*/</span></span><br><span class="line"><span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*定时器回调函数*/</span></span><br><span class="line">client_data *user_data&#123;&#125;;<span class="comment">/*客户数据*/</span></span><br><span class="line">tw_timer *next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">tw_timer *prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_wheel</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">time_wheel() : cur_slot(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">slots[i] = <span class="literal">nullptr</span>;<span class="comment">/*初始化每个槽的头结点*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~time_wheel() &#123;</span><br><span class="line"><span class="comment">/*遍历每个槽，并销毁其中的定时器*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; slot : slots) &#123;</span><br><span class="line">tw_timer *tmp = slot;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">slot = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = slot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据定时值timeout创建一个定时器，并把它插入合适的槽中*/</span></span><br><span class="line"><span class="function">tw_timer *<span class="title">add_timer</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ticks = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*下面根据待插入定时器的超时值计算它将在时间轮转动多少个滴答后被触发，并将该</span></span><br><span class="line"><span class="comment">滴答数存储于变量ticks中。如果待插入定时器的超时值小于时间轮的槽间隔SI，则将</span></span><br><span class="line"><span class="comment">ticks向上折合为1，否则就将ticks向下折合为timeout/SI*/</span></span><br><span class="line"><span class="keyword">if</span> (timeout &lt; SI) &#123;</span><br><span class="line">ticks = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ticks = timeout / SI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*计算待插入的定时器在时间轮转动多少圈后被触发*/</span></span><br><span class="line"><span class="keyword">int</span> rotation = ticks / N;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算待插入的定时器应该被插入哪个槽中*/</span></span><br><span class="line"><span class="keyword">int</span> ts = (cur_slot + (ticks % N)) % N;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建新的定时器，它在时间轮转动rotation圈之后被触发，且位于第ts个槽上*/</span></span><br><span class="line">tw_timer *timer = <span class="keyword">new</span> tw_timer(rotation, ts);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果第ts个槽中尚无任何定时器，则把新建的定时器插入其中，并将该定时器设置为该槽的头结点*/</span></span><br><span class="line"><span class="keyword">if</span> (!slots[ts]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;add timer,rotation is%d,ts is%d,cur_slotis%d\n&quot;</span>, rotation, ts, cur_slot);</span><br><span class="line">slots[ts] = timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则，将定时器插入第ts个槽中*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">timer-&gt;next = slots[ts];</span><br><span class="line">slots[ts]-&gt;prev = timer;</span><br><span class="line">slots[ts] = timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(tw_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ts = timer-&gt;time_slot;</span><br><span class="line"><span class="comment">/*slots[ts]是目标定时器所在槽的头结点。如果目标定时器就是该头结点，则需要重置第ts个槽的头结点*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == slots[ts]) &#123;</span><br><span class="line">slots[ts] = slots[ts]-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (slots[ts]) &#123;</span><br><span class="line">slots[ts]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (timer-&gt;next) &#123;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SI时间到后，调用该函数，时间轮向前滚动一个槽的间隔*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tw_timer *tmp = slots[cur_slot];<span class="comment">/*取得时间轮上当前槽的头结点*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;current slot is%d\n&quot;</span>, cur_slot);</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tick the timer once\n&quot;</span>);</span><br><span class="line"><span class="comment">/*如果定时器的rotation值大于0，则它在这一轮不起作用*/</span></span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;rotation &gt; <span class="number">0</span>) &#123;</span><br><span class="line">tmp-&gt;rotation--;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则，说明定时器已经到期，于是执行定时任务，然后删除该定时器*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line"><span class="keyword">if</span> (tmp == slots[cur_slot]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;delete header in cur_slot\n&quot;</span>);</span><br><span class="line">slots[cur_slot] = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">if</span> (slots[cur_slot]) &#123;</span><br><span class="line">slots[cur_slot]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = slots[cur_slot];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp-&gt;prev-&gt;next = tmp-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;next) &#123;</span><br><span class="line">tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line">tw_timer *tmp2 = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur_slot = ++cur_slot % N;<span class="comment">/*更新时间轮的当前槽，以反映时间轮的转动*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*时间轮上槽的数目*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每1 s时间轮转动一次，即槽间隔为1 s*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SI = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时间轮的槽，其中每个元素指向一个定时器链表，链表无序*/</span></span><br><span class="line">tw_timer *slots[N]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cur_slot;<span class="comment">/*时间轮的当前槽*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TIME_WHEEL_TIMER_H</span></span></span><br></pre></td></tr></table></figure><p><strong>可见，对时间轮而言，添加一个定时器的时间复杂度是O（1）， 删除一个定时器的时间复杂度也是O（1），执行一个定时器的时间复 杂度是O（n）。</strong>但实际上执行一个定时器任务的效率要比O（n）好得 多，因为时间轮将所有的定时器散列到了不同的链表上。时间轮的槽 越多，等价于散列表的入口（entry）越多，从而每条链表上的定时器 数量越少。</p><h5 id="11-4-2-时间堆"><a href="#11-4-2-时间堆" class="headerlink" title="11.4.2 时间堆"></a>11.4.2 时间堆</h5><p>设计 定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器。<strong>然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。</strong></p><p>最小堆很适合处理这种定时方案。最小堆是指每个节点的值都小 于或等于其子节点的值的完全二叉树。图11-2给出了一个具有6个元素 的最小堆。</p><img src="学习笔记/Linux高性能服务器编程/image-20230305174923066.png" alt="image-20230305174923066" style="zoom:33%;" /><p>由于最小堆是一种完全二叉树，所以我们可以用数组来组织其中 的元素。</p><p>比如，图11-2所示的最小堆可以用图11-5所示的数组来表示。 <strong>对于数组中的任意一个位置i上的元素，其左儿子节点在位置2i+1上， 其右儿子节点在位置2i+2上，其父节点则在位置[（i-1）/2]（i＞0） 上</strong>。与用链表来表示堆相比，用数组表示堆不仅节省空间，而且更容 易实现堆的插入、删除等操作[5]。</p><img src="/2022/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230305175239841-1678341964417.png" class="" title="image-20230305175239841"><p>假设我们已经有一个包含N个元素的数组，现在要把它初始化为一 个最小堆。那么最简单的方法是：初始化一个空堆，然后将数组中的 每个元素插入该堆中。不过这样做的效率偏低。</p><p>实际上，我们只需要 对数组中的第[（N-1）/2]～0个元素执行下虑操作，即可确保该数组构 成一个最小堆。这是因为对包含N个元素的完全二叉树而言，它具有 [（N-1）/2]个非叶子节点，这些非叶子节点正是该完全二叉树的第0～ [（N-1）/2]个节点。我们只要确保这些非叶子节点构成的子树都具有 堆序性质，整个树就具有堆序性质。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MIN_HEAP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_HEAP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::exception;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span>;</span><span class="comment">/*前向声明*/</span></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">heap_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">heap_timer</span><span class="params">(<span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">expire = time(<span class="literal">nullptr</span>) + delay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">time_t</span> expire;<span class="comment">/*定时器生效的绝对时间*/</span></span><br><span class="line"><span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*定时器的回调函数*/</span></span><br><span class="line">client_data *user_data&#123;&#125;;<span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时间堆类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_heap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*构造函数之一，初始化一个大小为cap的空堆*/</span></span><br><span class="line">explicit time_heap(int cap) throw(std::exception): capacity(cap), cur_size(0) &#123;</span><br><span class="line"><span class="built_in">array</span> = <span class="keyword">new</span> heap_timer *[capacity];<span class="comment">/*创建堆数组*/</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数之二，用已有数组来初始化堆*/</span></span><br><span class="line">time_heap(heap_timer **init_array, <span class="keyword">int</span> size, <span class="keyword">int</span> capacity) <span class="keyword">throw</span></span><br><span class="line">(<span class="built_in">std</span>::exception): cur_size(size), capacity(capacity) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity &lt; size) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span> = <span class="keyword">new</span> heap_timer *[capacity];<span class="comment">/*创建堆数组*/</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*初始化堆数组*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = init_array[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (cur_size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;<span class="comment">/*对数组中的第[(cur_size-1)/2]～0个元素执行下虑操作*/</span></span><br><span class="line">percolate_down(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁时间堆*/</span></span><br><span class="line">~time_heap() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(heap_timer *timer)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur_size &gt;= capacity)<span class="comment">/*如果当前堆数组容量不够，则将其扩大1倍*/</span></span><br><span class="line">&#123;</span><br><span class="line">resize();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*新插入了一个元素，当前堆大小加1，hole是新建空穴的位置*/</span></span><br><span class="line"><span class="keyword">int</span> hole = cur_size++;</span><br><span class="line"><span class="keyword">int</span> parent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对从空穴到根节点的路径上的所有节点执行上虑操作*/</span></span><br><span class="line"><span class="keyword">for</span> (; hole &gt; <span class="number">0</span>; hole = parent) &#123;</span><br><span class="line">parent = (hole - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[parent]-&gt;expire &lt;= timer-&gt;expire) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[hole] = <span class="built_in">array</span>[parent];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[hole] = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(heap_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*仅仅将目标定时器的回调函数设置为空，即所谓的延迟销毁。这将节省真正删除该定</span></span><br><span class="line"><span class="comment">时器造成的开销，但这样做容易使堆数组膨胀*/</span></span><br><span class="line">timer-&gt;cb_func = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获得堆顶部的定时器*/</span></span><br><span class="line"><span class="function">heap_timer *<span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除堆顶部的定时器*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (empty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">/*将原来的堆顶元素替换为堆数组中最后一个元素*/</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[--cur_size];</span><br><span class="line">percolate_down(<span class="number">0</span>);<span class="comment">/*对新的堆顶元素执行下虑操作*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*心搏函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap_timer *tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>);<span class="comment">/*循环处理堆中到期的定时器*/</span></span><br><span class="line"><span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果堆顶定时器没到期，则退出循环*/</span></span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;expire &gt; cur) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则就执行堆顶定时器中的任务*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func) &#123;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func(<span class="built_in">array</span>[<span class="number">0</span>]-&gt;user_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将堆顶元素删除，同时生成新的堆顶定时器（array[0]）*/</span></span><br><span class="line">pop_timer();</span><br><span class="line">tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> cur_size == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*最小堆的下虑操作，它确保堆数组中以第hole个节点作为根的子树拥有最小堆性质*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">percolate_down</span><span class="params">(<span class="keyword">int</span> hole)</span> </span>&#123;</span><br><span class="line">heap_timer *temp = <span class="built_in">array</span>[hole];</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ((hole * <span class="number">2</span> + <span class="number">1</span>) &lt;= (cur_size - <span class="number">1</span>)); hole = child) &#123;</span><br><span class="line">child = hole * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((child &lt; (cur_size - <span class="number">1</span>)) &amp;&amp; (<span class="built_in">array</span>[child + <span class="number">1</span>]-&gt;expire &lt; <span class="built_in">array</span>[child]-&gt;expire)) &#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[child]-&gt;expire &lt; temp-&gt;expire) &#123;</span><br><span class="line"><span class="built_in">array</span>[hole] = <span class="built_in">array</span>[child];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[hole] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将堆数组容量扩大1倍*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> **temp = <span class="keyword">new</span> heap_timer *[<span class="number">2</span> * capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * capacity; ++i) &#123;</span><br><span class="line">temp[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">capacity = <span class="number">2</span> * capacity;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line">temp[i] = <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span> = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">heap_timer **<span class="built_in">array</span>;<span class="comment">/*堆数组*/</span></span><br><span class="line"><span class="keyword">int</span> capacity;<span class="comment">/*堆数组的容量*/</span></span><br><span class="line"><span class="keyword">int</span> cur_size;<span class="comment">/*堆数组当前包含元素的个数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>由代码清单11-6可见，对时间堆而言，添加一个定时器的时间复杂 度是O（lgn），删除一个定时器的时间复杂度是O（1），执行一个定 时器的时间复杂度是O（1）。因此，时间堆的效率是很高的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;第二篇-高性能服务器框架&quot;&gt;&lt;a href=&quot;#第二篇-高性能服务器框架&quot; class=&quot;headerlink&quot; title=&quot;第二篇 高性能服务器框架&quot;&gt;&lt;/a&gt;第二篇 高性能服务器框架&lt;/h2&gt;&lt;h3 id=&quot;第5章-Linux网络编程基础API&quot;&gt;&lt;a hr</summary>
      
    
    
    
    <category term="Linux" scheme="http://okeyia.github.io/categories/Linux/"/>
    
    
    <category term="服务器编程" scheme="http://okeyia.github.io/tags/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
</feed>
