<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Gem5 Intro</title>
      <link href="/2022/01/05/Gem5%20Intro/"/>
      <url>/2022/01/05/Gem5%20Intro/</url>
      
        <content type="html"><![CDATA[<h3 id="一-gem5介绍"><a href="#一-gem5介绍" class="headerlink" title="一 gem5介绍"></a>一 gem5介绍</h3><p><img src="/2022/01/05/Gem5%20Intro/image-20211221104758184.png" alt="image-20211221104758184"></p><h4 id="cpu模型"><a href="#cpu模型" class="headerlink" title="cpu模型"></a>cpu模型</h4><p>GEM5支持四种不同的CPU模型：</p><ul><li><p>AtomicSimple是最简单规模的模型，一个cycle完成一条指令的执行，memory 模型比较理想化，访存操作为原子性操作。适用于快速功能模拟。</p></li><li><p>TimingSimple模拟器也是无流水线的模拟，但是使用了存储器访问时序模型，用以统计存储器访问延迟。</p></li><li><p>In-Order模型是GEM5模拟的新特性，流水级为默认五级流水：取值、译码、执行、访存、写回。并且模拟了cache部件、执行部件、分支预测部件等。 </p></li><li><p>O3模拟器时流水级模拟，O3模拟器模拟了乱序执行和超标量执行的指令间依赖，以及运行在多CPU上的并发执行的多线程。默认7级流水：取值、译码、重命名、发射、执行、写回、提交。模拟了物理寄存器文件、IO、LSQ、ROB功能部件池等。主要参数为流水管道间延迟、硬件线程数、    IQ/LSQ/ROB项数、FU延迟、物理寄存器重命名、分支预测、访存依赖预测等。</p><hr><p>CPU四种模型可以在模型中任意切换，支持“热插拔”。以上四种CPU模型之所以被称为“热插拔”是因为CPUs共享通用部件和接口。</p><p>​       参数定义</p><p>​      共享部件：分支预测器，TLB，译码，中断处理</p><p>​      基于时间缓冲的通信机制</p><p>​      外部接口</p></li></ul><h3 id="二-官网实验"><a href="#二-官网实验" class="headerlink" title="二 官网实验"></a>二 官网实验</h3><h4 id="一-simply-py"><a href="#一-simply-py" class="headerlink" title="一 simply.py"></a>一 simply.py</h4><p><img src="/2022/01/05/Gem5%20Intro/simple_config.png" alt="simple_config"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> m5</span><br><span class="line"><span class="keyword">from</span> m5.objects <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"> <span class="comment">#创建要模拟的系统</span></span><br><span class="line">system = System()</span><br><span class="line"><span class="comment">#设置系统时钟。1、建立时钟域，2、设置时钟频率，3、为时钟域指定电压域</span></span><br><span class="line">system.clk_domain = SrcClockDomain()</span><br><span class="line">system.clk_domain.clock = <span class="string">&#x27;1GHz&#x27;</span></span><br><span class="line">system.clk_domain.voltage_domain = VoltageDomain()</span><br><span class="line">  </span><br><span class="line"><span class="comment">#设置系统模拟内存(计时模式)，设置内存范围</span></span><br><span class="line">system.mem_mode = <span class="string">&#x27;timing&#x27;</span></span><br><span class="line">system.mem_ranges = [AddrRange(<span class="string">&#x27;512MB&#x27;</span>)]</span><br><span class="line">   </span><br><span class="line"><span class="comment">#创建CPU（基于时间），</span></span><br><span class="line">system.cpu = TimingSimpleCPU()</span><br><span class="line"><span class="comment">#创建系统范围内存总线</span></span><br><span class="line">system.membus = SystemXBar()</span><br><span class="line">     </span><br><span class="line"><span class="comment">#将CPU上的缓存端口连接到内存总线上。由于没有建立缓存cache，所以将icache和dcache直接连接到menbus</span></span><br><span class="line">system.cpu.icache_port = system.membus.cpu_side_ports</span><br><span class="line">system.cpu.dcache_port = system.membus.cpu_side_ports</span><br><span class="line">      </span><br><span class="line"><span class="comment">#连接CPU的其他端口以确保系统可以正常工作，例如I/O控制器。</span></span><br><span class="line">system.cpu.createInterruptController()</span><br><span class="line"></span><br><span class="line"><span class="comment">#将系统的一个特殊端口连接到menbus，这个端口只允许系统读写内存。</span></span><br><span class="line">system.system_port = system.membus.cpu_side_ports</span><br><span class="line">       </span><br><span class="line"><span class="comment">#x86的特定要求，将PIO和中断端口连接到内存总线</span></span><br><span class="line"><span class="keyword">if</span> m5.defines.buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;x86&quot;</span>:</span><br><span class="line">    system.cpu.interrupts[<span class="number">0</span>].pio = system.membus.mem_side_ports</span><br><span class="line">    system.cpu.interrupts[<span class="number">0</span>].int_requestor = system.membus.cpu_side_ports</span><br><span class="line">    system.cpu.interrupts[<span class="number">0</span>].int_responder = system.membus.mem_side_ports</span><br><span class="line">                        </span><br><span class="line"><span class="comment">#创建一个内存控制器，并将其连接到内存总线。这里使用的是DDR3控制器，负责内存的范围。</span></span><br><span class="line">system.mem_ctrl = MemCtrl()</span><br><span class="line">system.mem_ctrl.port = system.membus.mem_side_ports</span><br><span class="line">system.mem_ctrl.dram = DDR3_1600_8x8()</span><br><span class="line">system.mem_ctrl.dram.<span class="built_in">range</span> = system.mem_ranges[<span class="number">0</span>]</span><br><span class="line">                         </span><br><span class="line"><span class="comment">#---------设置CPU执行的进程--------------------#</span></span><br><span class="line"><span class="comment">#这里使用syscall仿真模式</span></span><br><span class="line"><span class="comment">#1、设置可执行文件，2、创建进程，设置进程执行的可执行文件，</span></span><br><span class="line"><span class="comment"># 3、将进程设置为CPU的工作负载，4、在CPU上创建进程（或者说创建执行</span></span><br><span class="line">binary = <span class="string">&#x27;tests/test-progs/hello/bin/x86/linux/hello&#x27;</span></span><br><span class="line">                          </span><br><span class="line"><span class="comment">#对于gem5 v21及更高版本，加入下面一行。</span></span><br><span class="line">system.workload = SEWorkload.init_compatible(binary)</span><br><span class="line">                           </span><br><span class="line">process = Process()</span><br><span class="line">process.cmd = [binary]</span><br><span class="line">system.cpu.workload = process</span><br><span class="line">system.cpu.createThreads()</span><br><span class="line">                            </span><br><span class="line"><span class="comment">#---------实例化系统并执行-------------#</span></span><br><span class="line"><span class="comment">#创建根对象，并实例化模拟</span></span><br><span class="line">root = Root(full_system = <span class="literal">False</span>,system = system)</span><br><span class="line">m5.instantiate()</span><br><span class="line">                             </span><br><span class="line"><span class="comment">#开始模拟。这里的print不是语句而是作为一个函数被</span></span><br><span class="line">print(<span class="string">&quot;Beginning simulation&quot;</span>)</span><br><span class="line">exit_event = m5.simulate()</span><br><span class="line">                              </span><br><span class="line"><span class="comment">#模拟结束后对系统进行检测</span></span><br><span class="line">print(<span class="string">&#x27;Exiting @ tick &#123;&#125; because &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(m5.curTick(),exit_event.getCause()))</span><br></pre></td></tr></table></figure><h4 id="二-two-level-py"><a href="#二-two-level-py" class="headerlink" title="二 two-level.py"></a>二 two-level.py</h4><p><img src="/2022/01/05/Gem5%20Intro/advanced_config.png" alt="A system configuration with a two-level cache hierarchy."></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import the m5 (gem5) library created when gem5 is built</span></span><br><span class="line"><span class="keyword">import</span> m5</span><br><span class="line"><span class="comment"># import all of the SimObjects</span></span><br><span class="line"><span class="keyword">from</span> m5.objects <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># Add the common scripts to our path</span></span><br><span class="line">m5.util.addToPath(<span class="string">&#x27;../../&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># import the caches which we made</span></span><br><span class="line"><span class="keyword">from</span> caches <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment"># import the SimpleOpts module</span></span><br><span class="line"><span class="keyword">from</span> common <span class="keyword">import</span> SimpleOpts</span><br><span class="line"></span><br><span class="line"><span class="comment"># get ISA for the default binary to run. This is mostly for simple testing</span></span><br><span class="line">isa = <span class="built_in">str</span>(m5.defines.buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>]).lower()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Default to running &#x27;hello&#x27;, use the compiled ISA to find the binary</span></span><br><span class="line"><span class="comment"># grab the specific path to the binary</span></span><br><span class="line">thispath = os.path.dirname(os.path.realpath(__file__))</span><br><span class="line">default_binary = os.path.join(thispath, <span class="string">&#x27;../../../&#x27;</span>,</span><br><span class="line">    <span class="string">&#x27;tests/test-progs/hello/bin/&#x27;</span>, isa, <span class="string">&#x27;linux/hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Binary to execute</span></span><br><span class="line">SimpleOpts.add_option(<span class="string">&quot;binary&quot;</span>, nargs=<span class="string">&#x27;?&#x27;</span>, default=default_binary)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Finalize the arguments and grab the args so we can pass it on to our objects</span></span><br><span class="line">args = SimpleOpts.parse_args()</span><br><span class="line"></span><br><span class="line"><span class="comment"># create the system we are going to simulate</span></span><br><span class="line">system = System()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set the clock fequency of the system (and all of its children)</span></span><br><span class="line">system.clk_domain = SrcClockDomain()</span><br><span class="line">system.clk_domain.clock = <span class="string">&#x27;1GHz&#x27;</span></span><br><span class="line">system.clk_domain.voltage_domain = VoltageDomain()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Set up the system</span></span><br><span class="line">system.mem_mode = <span class="string">&#x27;timing&#x27;</span>               <span class="comment"># Use timing accesses</span></span><br><span class="line">system.mem_ranges = [AddrRange(<span class="string">&#x27;512MB&#x27;</span>)] <span class="comment"># Create an address range</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a simple CPU</span></span><br><span class="line">system.cpu = TimingSimpleCPU()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an L1 instruction and data cache</span></span><br><span class="line">system.cpu.icache = L1ICache(args)</span><br><span class="line">system.cpu.dcache = L1DCache(args)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect the instruction and data caches to the CPU</span></span><br><span class="line">system.cpu.icache.connectCPU(system.cpu)</span><br><span class="line">system.cpu.dcache.connectCPU(system.cpu)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a memory bus, a coherent crossbar, in this case</span></span><br><span class="line">system.l2bus = L2XBar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hook the CPU ports up to the l2bus</span></span><br><span class="line">system.cpu.icache.connectBus(system.l2bus)</span><br><span class="line">system.cpu.dcache.connectBus(system.l2bus)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create an L2 cache and connect it to the l2bus</span></span><br><span class="line">system.l2cache = L2Cache(args)</span><br><span class="line">system.l2cache.connectCPUSideBus(system.l2bus)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a memory bus</span></span><br><span class="line">system.membus = SystemXBar()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect the L2 cache to the membus</span></span><br><span class="line">system.l2cache.connectMemSideBus(system.membus)</span><br><span class="line"></span><br><span class="line"><span class="comment"># create the interrupt controller for the CPU</span></span><br><span class="line">system.cpu.createInterruptController()</span><br><span class="line"></span><br><span class="line"><span class="comment"># For x86 only, make sure the interrupts are connected to the memory</span></span><br><span class="line"><span class="comment"># Note: these are directly connected to the memory bus and are not cached</span></span><br><span class="line"><span class="keyword">if</span> m5.defines.buildEnv[<span class="string">&#x27;TARGET_ISA&#x27;</span>] == <span class="string">&quot;x86&quot;</span>:</span><br><span class="line">    system.cpu.interrupts[<span class="number">0</span>].pio = system.membus.mem_side_ports</span><br><span class="line">    system.cpu.interrupts[<span class="number">0</span>].int_requestor = system.membus.cpu_side_ports</span><br><span class="line">    system.cpu.interrupts[<span class="number">0</span>].int_responder = system.membus.mem_side_ports</span><br><span class="line"></span><br><span class="line"><span class="comment"># Connect the system up to the membus</span></span><br><span class="line">system.system_port = system.membus.cpu_side_ports</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a DDR3 memory controller</span></span><br><span class="line">system.mem_ctrl = MemCtrl()</span><br><span class="line">system.mem_ctrl.dram = DDR3_1600_8x8()</span><br><span class="line">system.mem_ctrl.dram.<span class="built_in">range</span> = system.mem_ranges[<span class="number">0</span>]</span><br><span class="line">system.mem_ctrl.port = system.membus.mem_side_ports</span><br><span class="line"></span><br><span class="line">system.workload = SEWorkload.init_compatible(args.binary)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Create a process for a simple &quot;Hello World&quot; application</span></span><br><span class="line">process = Process()</span><br><span class="line"><span class="comment"># Set the command</span></span><br><span class="line"><span class="comment"># cmd is a list which begins with the executable (like argv)</span></span><br><span class="line">process.cmd = [args.binary]</span><br><span class="line"><span class="comment"># Set the cpu to use the process as its workload and create thread contexts</span></span><br><span class="line">system.cpu.workload = process</span><br><span class="line">system.cpu.createThreads()</span><br><span class="line"></span><br><span class="line"><span class="comment"># set up the root SimObject and start the simulation</span></span><br><span class="line">root = Root(full_system = <span class="literal">False</span>, system = system)</span><br><span class="line"><span class="comment"># instantiate all of the objects we&#x27;ve created above</span></span><br><span class="line">m5.instantiate()</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Beginning simulation!&quot;</span>)</span><br><span class="line">exit_event = m5.simulate()</span><br><span class="line">print(<span class="string">&#x27;Exiting @ tick %i because %s&#x27;</span> % (m5.curTick(), exit_event.getCause()))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="三-the-default-configuration-scripts"><a href="#三-the-default-configuration-scripts" class="headerlink" title="三 the default configuration scripts"></a>三 the default configuration scripts</h4><p>![the default configuration scripts](./Gem5%20Intro/the default configuration scripts.png)</p><h4 id="四-Options"><a href="#四-Options" class="headerlink" title="四 Options"></a>四 Options</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt configs/example/se.py --<span class="built_in">help</span></span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">Below are a few important options from that list:</span><br><span class="line"></span><br><span class="line">--cpu-type=CPU_TYPE</span><br><span class="line"></span><br><span class="line">The type of cpu to run with. This is an important parameter to always set. The default is atomic, which doesn’t perform a timing simulation.</span><br><span class="line">--sys-clock=SYS_CLOCK</span><br><span class="line"></span><br><span class="line">Top-level clock for blocks running at system speed.</span><br><span class="line">--cpu-clock=CPU_CLOCK</span><br><span class="line"></span><br><span class="line">Clock for blocks running at CPU speed. This is separate from the system clock above.</span><br><span class="line">--mem-type=MEM_TYPE</span><br><span class="line"></span><br><span class="line">Type of memory to use. Options include different DDR memories, and the ruby memory controller.</span><br><span class="line">--caches</span><br><span class="line"></span><br><span class="line">Perform the simulation with classic caches.</span><br><span class="line">--l2cache</span><br><span class="line"></span><br><span class="line">Perform the simulation with an L2 cache, if using classic caches.</span><br><span class="line">--ruby</span><br><span class="line"></span><br><span class="line">Use Ruby instead of the classic caches as the cache system simulation.</span><br><span class="line">-m TICKS, --abs-max-tick=TICKS</span><br><span class="line"></span><br><span class="line">Run to absolute simulated tick specified including ticks from a restored checkpoint. This is useful if you only want simulate for a certain amount of simulated time.</span><br><span class="line">-I MAXINSTS, --maxinsts=MAXINSTS</span><br><span class="line"></span><br><span class="line">Total number of instructions to simulate (default: run forever). This is useful if you want to stop simulation after a certain number of instructions has been executed.</span><br><span class="line">-c CMD, --cmd=CMD</span><br><span class="line"></span><br><span class="line">The binary to run in syscall emulation mode.</span><br><span class="line">-o OPTIONS, --options=OPTIONS</span><br><span class="line"></span><br><span class="line">The options to pass to the binary, use ” ” around the entire string. This is useful when you are running a command which takes options. You can pass both arguments and options (e.g., –whatever) through this variable.</span><br><span class="line">--output=OUTPUT</span><br><span class="line"></span><br><span class="line">Redirect stdout to a file. This is useful if you want to redirect the output of the simulated application to a file instead of printing to the screen. Note: to redirect gem5 output, you have to pass a parameter before the configuration script.</span><br><span class="line">--errout=ERROUT</span><br><span class="line"></span><br><span class="line">Redirect stderr to a file. Similar to above.</span><br></pre></td></tr></table></figure><h3 id="三实验中的代码"><a href="#三实验中的代码" class="headerlink" title="三实验中的代码"></a>三实验中的代码</h3><h5 id="实验二"><a href="#实验二" class="headerlink" title="实验二"></a>实验二</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt configs/example/fs.py --kernel=x86_64-vmlinux-2.6.22.9 --disk-image=linux-x86.img</span><br></pre></td></tr></table></figure><h5 id="实验三"><a href="#实验三" class="headerlink" title="实验三"></a>实验三</h5><p>三级缓存的默认设置:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">  测试l3cache</span></span><br><span class="line">build/X86/gem5.opt configs/example/se.py --caches --l2cache --l3cache --l3_size=2MB --cmd=tests/test-progs/hello/bin/x86/linux/hello</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">弹性 trace 的捕捉和重播</span></span><br><span class="line">build/X86/gem5.opt -d test_trace configs/example/se.py \</span><br><span class="line">--cpu-type=DerivO3CPU \</span><br><span class="line">--caches \</span><br><span class="line">--cmd=../gapbs/bfs --options=&quot;-f ../gapbs/test/graphs/4.el -n 1&quot; \</span><br><span class="line">--elastic-trace-en \</span><br><span class="line">--data-trace-file=data.proto.gz \</span><br><span class="line">--inst-trace-file=inst.proto.gz \</span><br><span class="line">--mem-type=SimpleMemory</span><br><span class="line"></span><br><span class="line">../util/decode_inst_dep_trace.py ./system.cpu.traceListener.data.proto.gz ./data.out</span><br><span class="line">../util/decode_packet_trace.py ./system.cpu.traceListener.inst.proto.gz ./inst.out</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">生成的指令和数据进行重播</span></span><br><span class="line">build/X86/gem5.opt -d replay_trace configs/example/etrace_replay.py \</span><br><span class="line">--cpu-type=TraceCPU \</span><br><span class="line">--data-trace-file=test_trace/system.cpu.traceListener.data.proto.gz \</span><br><span class="line">--inst-trace-file=test_trace/system.cpu.traceListener.inst.proto.gz \</span><br><span class="line">--num-cpus=1 --caches \</span><br><span class="line">--l1i_size=32kB --l1i_assoc=8 --l1d_size=32kB --l1d_assoc=8 \</span><br><span class="line">--l2cache --num-l2caches=1 --l2_size=256kB --l2_assoc=8 \</span><br><span class="line">--l3cache --num-l3caches=1 --l3_size=2MB --l3_assoc=16 \</span><br><span class="line">--cacheline_size=64 --mem-type=SimpleMemory --mem-size=4GB</span><br></pre></td></tr></table></figure><h5 id="实验四"><a href="#实验四" class="headerlink" title="实验四"></a>实验四</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">build/X86/gem5.opt -d test_vans configs/example/se.py \</span><br><span class="line">--cmd=../gapbs/bfs --options=&quot;-f ../gapbs/test/graphs/4.el -n 1&quot; \</span><br><span class="line">--num-cpus=1 --caches \</span><br><span class="line">--l1i_size=32kB --l1i_assoc=8 --l1d_size=32kB --l1d_assoc=8 \</span><br><span class="line">--l2cache --num-l2caches=1 --l2_size=256kB --l2_assoc=8 \</span><br><span class="line">--l3cache --num-l3caches=1 --l3_size=2MB --l3_assoc=16 \</span><br><span class="line">--cacheline_size=64 --mem-type=VANS --vans-config-path=../VANS/config --mem-size=4GB</span><br></pre></td></tr></table></figure><h6 id="对指定区域trace的捕捉和重播"><a href="#对指定区域trace的捕捉和重播" class="headerlink" title="对指定区域trace的捕捉和重播"></a>对指定区域trace的捕捉和重播</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">scons -C util/m5 build/x86/out/m5</span><br><span class="line">g++ -static -I include -o ../gapbs/src/bfs_m5 ../gapbs/src/bfs.cc util/m5/build/x86/out/libm5.a</span><br><span class="line"><span class="meta">#</span><span class="bash">gem5插入检查点</span></span><br><span class="line">build/X86/gem5.opt -d test_checkpoint configs/example/se.py \</span><br><span class="line">--cmd=../gapbs/src/bfs_m5 --options=&quot;-f ../gapbs/test/graphs/4.el -n 1&quot;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">从检查点处捕捉特定区域的 trace</span></span><br><span class="line">build/X86/gem5.opt -d test_checkpoint_trace configs/example/se.py \</span><br><span class="line">--cpu-type=DerivO3CPU \</span><br><span class="line">--cmd=../gapbs/src/bfs_m5 \</span><br><span class="line">--options=&quot;-f ../gapbs/test/graphs/4.el -n 1&quot; \</span><br><span class="line">--elastic-trace-en \</span><br><span class="line">--data-trace-file=datatrace.proto.gz \</span><br><span class="line">--inst-trace-file=insttrace.proto.gz \</span><br><span class="line">--num-cpus=1 --caches --mem-type=SimpleMemory \</span><br><span class="line">--restore-with-cpu=DerivO3CPU \</span><br><span class="line">--checkpoint-dir=test_checkpoint -r 1</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">对 checkpoint trace 进行重播</span></span><br><span class="line">build/X86/gem5.opt -d cktrace_replay configs/example/etrace_replay.py \</span><br><span class="line">--cpu-type=TraceCPU \</span><br><span class="line">--data-trace-file=test_checkpoint_trace/system.cpu.traceListener.datatrace.proto.gz \</span><br><span class="line">--inst-trace-file=test_checkpoint_trace/system.cpu.traceListener.insttrace.proto.gz \</span><br><span class="line">--num-cpus=1 --caches \</span><br><span class="line">--l1i_size=32kB --l1i_assoc=8 --l1d_size=32kB --l1d_assoc=8 \</span><br><span class="line">--l2cache --num-l2caches=1 --l2_size=256kB --l2_assoc=8 \</span><br><span class="line">--cacheline_size=64 --mem-type=VANS --vans-config-path=../VANS/config --mem-size=4GB</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑马C++ 核心编程</title>
      <link href="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h3><h4 id="1-程序四个分区"><a href="#1-程序四个分区" class="headerlink" title="1 程序四个分区"></a>1 程序四个分区</h4><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​    <strong>代码区：</strong></p><p>​        存放 CPU 执行的机器指令</p><p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​    <strong>全局区：</strong></p><p>​        全局变量和静态变量存放在此.</p><p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​        ==该区域的数据在程序结束后由操作系统释放==.</p><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h5 id="1-1-内存分区模型"><a href="#1-1-内存分区模型" class="headerlink" title="1.1 内存分区模型"></a>1.1 内存分区模型</h5><p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211219211614927.png" alt="image-20211219211614927"></p><p>四区的意义: 不同区域的数据,赋予不同的生命周期, 给我们更大的灵活编程.</p><h5 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h5><h6 id="1-2-1-栈区"><a href="#1-2-1-栈区" class="headerlink" title="1.2.1 栈区:"></a>1.2.1 栈区:</h6><p>​        由编译器自动分配释放, 存放函数的参数值, 局部变量等</p><p>​        **注意: **不要返回局部变量的地址, 栈区开辟的数据由编译器自动释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>* ptr = func();  <span class="comment">// </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ptr; <span class="comment">// 第一次可以打印出来</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ptr; <span class="comment">// 再次输出, 问题来了.  编译器做了一次保留,只能打印一次</span></span><br></pre></td></tr></table></figure><h6 id="1-2-2-堆区"><a href="#1-2-2-堆区" class="headerlink" title="1.2.2 堆区"></a>1.2.2 堆区</h6><p>​        由程序员分配释放, 若程序员不释放, 程序结束后由操作系统回收</p><p>​        在C++ 中主要使用new在堆区开辟内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>* ptr = func();  <span class="comment">// </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ptr; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ptr; </span><br></pre></td></tr></table></figure><h6 id="1-2-3-new操作符"><a href="#1-2-3-new操作符" class="headerlink" title="1.2.3 new操作符"></a>1.2.3 new操作符</h6><p>使用new操作符开辟区域, delete释放数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> * arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">arr[i] = <span class="number">100</span> + i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h4><h5 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h5><p>作用: 给变量起别名</p><p>语法: 数据类型 &amp;别名 = 原名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a; <span class="comment">//b就是a的别名</span></span><br></pre></td></tr></table></figure><h5 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h5><ul><li>引用必须初始化</li><li>引用初始化后, 不可更改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;c = a;  <span class="comment">//一旦初始化就不能更改</span></span><br><span class="line">c = b;     <span class="comment">// 赋值操作, 不是更改引用</span></span><br></pre></td></tr></table></figure><h5 id="2-3-引用作为函数参数"><a href="#2-3-引用作为函数参数" class="headerlink" title="2.3 引用作为函数参数"></a>2.3 引用作为函数参数</h5><p>作用: 函数传参的时候, 可以利用引用的技术让形参修饰实参</p><p>优点: 可以简化指针修饰实参</p><h5 id="2-4-引用作为函数的返回值"><a href="#2-4-引用作为函数的返回值" class="headerlink" title="2.4 引用作为函数的返回值"></a>2.4 引用作为函数的返回值</h5><ol><li><h5 id="不要返回局部变量的引用"><a href="#不要返回局部变量的引用" class="headerlink" title="不要返回局部变量的引用"></a>不要返回局部变量的引用</h5></li><li><h5 id="函数的调用可以作为左值"><a href="#函数的调用可以作为左值" class="headerlink" title="函数的调用可以作为左值"></a>函数的调用可以作为左值</h5></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// int &amp; ref = test_2_3();</span></span><br><span class="line"><span class="comment">// test_2_3() = 1000; 相当于将a的值改为了1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test_2_3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 静态变量 放在全局区  由系统释放</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;\</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h5><p>是指针常量, 指向不可更改,值可以更改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ref = &amp;a;</span><br></pre></td></tr></table></figure><h5 id="2-6-常量引用-修饰形参防止误操作"><a href="#2-6-常量引用-修饰形参防止误操作" class="headerlink" title="2.6 常量引用:  修饰形参防止误操作"></a>2.6 常量引用:  修饰形参防止误操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; ref = <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h4><h5 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h5><ul><li>如果某个位置有了默认参数,从这个位置之后,从左到右都必须有默认值</li><li>如果函数声明有默认参数, 实现就不能有默认参数</li></ul><h5 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前阶段的占位参数,我们还用不到,后面课程会用到  第二个参数没法使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span></span>&#123;  <span class="comment">//这里只写一个int就是占位</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure><h5 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h5><p>注意: 函数返回值不可以作为函数重载条件</p><p>函数重载满足条件:</p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数的类型不同或者个数不同或者顺序不同</li></ul><p>注意事项:</p><ol><li>引用作为重载的条件</li><li>函数重载碰到默认参数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp; a)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int &amp; a&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const int &amp; a&quot;</span>;</span><br><span class="line">&#125; <span class="comment">//func(10)调用第二个,因为const int &amp; a = 10是合法的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;func2(int a, int b = 10)&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;func2(int a)&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h4><p>封装 继承 多态</p><h5 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1  封装"></a>4.1  封装</h5><p>封装的意义:</p><ul><li>将属性和行为作为一个整体, 表现生活中的事物</li><li>将属性和行为加以权限控制 <ul><li>private:  私有 </li><li>protected: 保护 类内成员可以访问</li><li>public: 共有  类内类外都可以访问</li></ul></li></ul><p><code>struct</code>与class的区别: <code>struct</code>默认权限是public, class默认是private</p><h5 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h5><p>一个对象或者变量没有初始状态,对其使用后果是未知, 同样使用完一个对象或者变量,没有及时清理,也会造成一定的安全问题</p><h6 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h6><p>如果我们自己不提供构造和析构, 编译器会提供, 编译器提供的构造函数和析构函数是空实现</p><ul><li>构造函数: 主要作用在于创建对象时为对象的成员属性赋值,构造函数由编译器自动调用,无需手动调用</li><li>析构函数: 主要作用于对象销毁前系统自动调用, 执行一些清理工作</li></ul><p><strong>构造参数语法: 类名()</strong></p><ol><li>构造函数, 没有返回值也不用写void</li><li>函数名与类名相同</li><li>构造函数可以有参数, 因此可以发生重载</li><li>程序在调用对象的时候自动调用构造, 无需手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法: 类名()</strong></p><ol><li>没有返回值也不用写void</li><li>函数名与类名相同,在名称前加上 <code>~</code></li><li>析构函数不可以有参数, 因此不可以发生重载</li><li>程序在对象销毁的时候自动调用, 无需手动调用,而且只会调用一次</li></ol><h6 id="4-2-2-构造函数的分类以及调用"><a href="#4-2-2-构造函数的分类以及调用" class="headerlink" title="4.2.2 构造函数的分类以及调用"></a>4.2.2 构造函数的分类以及调用</h6><p>两种分类方式:</p><ul><li>按参数分为:  有参构造和无参构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person()&#123;  <span class="comment">// 默认构造函数自己不写的话, 系统会自动生成</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="keyword">int</span> a)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参 int a 构造&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按照类型分类: 普通构造和拷贝构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数  将一个对象的属性拷贝到另一个对象身上</span></span><br><span class="line">Peoson(<span class="keyword">const</span> Person &amp;p)&#123;</span><br><span class="line">age = p.age;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot; 拷贝构造函数&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用演示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 括号法</span></span><br><span class="line">Person p;  <span class="comment">// 默认构造函数   调用默认构造函数时, 不要加().  Person p(); 编译器会认为是函数的声明, 不会认为是创建对象</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 有参构造函数调用</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">// 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 显式法</span></span><br><span class="line">Person p1;</span><br><span class="line">Person p2 = Person(<span class="number">10</span>); </span><br><span class="line">Person(<span class="number">10</span>); <span class="comment">// 等号右边单独拿出来 称为匿名对象, 当前行结束后, 系统立即回收</span></span><br><span class="line">Person p3 = Person(p2);</span><br><span class="line"><span class="comment">// 注意不要使用拷贝构造初始化匿名对象   Person(p3);  编译器会认为 Person(p3) === Person p3; 对象声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 隐式转换法</span></span><br><span class="line">Person p1 = <span class="number">10</span>;  相当于Person p1 = Person(<span class="number">10</span>);</span><br><span class="line">person p4 = p3; 相当于Person p4 = Person(p3);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="4-2-3-拷贝调用函数使用时机"><a href="#4-2-3-拷贝调用函数使用时机" class="headerlink" title="4.2.3 拷贝调用函数使用时机"></a>4.2.3 拷贝调用函数使用时机</h6><ul><li>使用一个已经创建完毕的对象初始化一个新对象</li><li>值传递方式方式给函数参数传值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span></span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p;  <span class="comment">//调用默认构造函数</span></span><br><span class="line">    doWork(p);<span class="comment">// 调用拷贝构造函数  形参中p1 是p的复制品</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>值方式返回局部变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)&amp; p1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 地址一</span></span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;  <span class="comment">// 局部变量p1 在test函数执行完就销毁了, 编译器调用拷贝构造函数创建了一个新的对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p = test();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)&amp; p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 地址二 与地址一并不相同</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="4-2-4-构造函数的调用规则"><a href="#4-2-4-构造函数的调用规则" class="headerlink" title="4.2.4 构造函数的调用规则"></a>4.2.4 构造函数的调用规则</h6><p>默认情况下, C++ 编译器至少给一个类添加3个函数</p><ol><li>默认构造无参</li><li>默认析构函数</li><li>默认拷贝构造函数, 对属性值进行值拷贝</li></ol><p>构造函数调用规则:  自己写的高级构造函数会屏蔽编译器提供的默认构造函数</p><ol><li>如果用户定义有参构造函数, c++不再提供无参构造, 但是会提供默认拷贝函数</li><li>如果用户定义拷贝构造函数, C++ 不在提供其他构造函数</li></ol><h6 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h6><p>浅拷贝: 简单的赋值拷贝操作  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">//编译器做的拷贝构造函数 浅拷贝</span></span><br></pre></td></tr></table></figure><p>深拷贝: 在堆中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  示范浅拷贝存在的错误</span></span><br><span class="line">~Person()&#123;  <span class="comment">//析构函数的作用</span></span><br><span class="line">    <span class="keyword">if</span>(m_height!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_height;</span><br><span class="line">        m_height = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_age;</span><br><span class="line"><span class="keyword">int</span> *m_height;  <span class="comment">// 把身高的数据 开辟到堆区域</span></span><br><span class="line">Person(<span class="keyword">int</span> age, <span class="keyword">int</span> height)&#123;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="keyword">int</span>(height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">160</span>)</span></span>;  <span class="comment">// 假如p1的身高160存在区域0X0011, 对象p2直接把0x0011复制过去了</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;    <span class="comment">//  执行报错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 栈里面先进后出 所以先释放p2</span></span><br><span class="line"><span class="comment">// 这里是浅拷贝存在的问题: 释放已经释放的内存, 是非法操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己实现拷贝,实现深拷贝</span></span><br><span class="line">Person(<span class="keyword">const</span> Person &amp; p)&#123;</span><br><span class="line">    m_age = p.m_age;</span><br><span class="line">    m_height = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_height);</span><br><span class="line">&#125;  <span class="comment">// 这个m_height的地址就和原本的地址不同了</span></span><br></pre></td></tr></table></figure><h6 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h6><p>作用: 用来初始化属性</p><p>语法: 构造函数():属性1(值1), 属性2(值2),</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意冒号的位置</span><br><span class="line">Person(int a, int b, int c):m_a(a),m_b(b),m_c(c)&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person p;</span><br></pre></td></tr></table></figure><h6 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先构造A的对象, 再构造B的对象</span></span><br><span class="line"><span class="comment">// 析构的时候, 先销毁B, 在销毁A</span></span><br></pre></td></tr></table></figure><h6 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8  静态成员"></a>4.2.8  静态成员</h6><p>在成员变量和函数前加上static</p><p>静态成员变量</p><ul><li>所有的对象共享一份数据</li><li>在编译阶段分配内存</li><li>类内声明,类外初始化</li><li>可以通过类名直接访问, 也可以使用对象调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 这个函数的数据在内存中 只有一份</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_a = <span class="number">100</span>;   <span class="comment">//静态成员函数可以访问静态成员变量</span></span><br><span class="line">m_b =<span class="number">200</span>; <span class="comment">//这一行报错  当用对象p1 p2 调用的时候, 编译器不知道m_b是谁的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_a; <span class="comment">//类内声明</span></span><br><span class="line"><span class="keyword">int</span> m_b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Person::m_a = <span class="number">0</span>;  <span class="comment">//类外初始化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态成员函数</p><ul><li>所有对象共享一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul><h5 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++ 对象模型和this指针"></a>4.3 C++ 对象模型和this指针</h5><h6 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h6><p>C++中,类内的成员变量和成员函数分开存储.  只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空对象占用一个字节 , 为了区分空对象占内存的位置, 每个空对象都该有自己的内存地址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_a; <span class="comment">//只要没有static 都是非静态变量  4个字节</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_b;  <span class="comment">//不占用大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">//分开存储的  也不占用大小</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">//  也不占用大小</span></span><br><span class="line">&#125;;</span><br><span class="line">Person p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size of p&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(p);  <span class="comment">// 大小为4字节 </span></span><br></pre></td></tr></table></figure><h6 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2  this指针概念"></a>4.3.2  this指针概念</h6><p>C++中,类内的成员变量和成员函数分开存储, 每个非静态成员函数只会诞生一份函数实例, 也就是说多个同类型的对象会共用一块代码. 问题是这一块代码如何区分哪个对象调用自己?</p><p>C++ 通过提供的特殊的对象指针, this 指针, <strong>this指针指向被调用的成员函数所属的对象.</strong> </p><p>this指针是隐含每一个非静态成员函数内的一种指针, 不需要定义,直接使用</p><p>this指针的用途:</p><ul><li>当形参和成员变量同名的时候, 可以用this区分   解决名称冲突.</li><li>在类的非静态成员函数中返回对象本身, 可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加引用的话, 返回的是p2的拷贝</span></span><br><span class="line"><span class="function">Person&amp; <span class="title">funct</span><span class="params">(Person &amp; p)</span></span>&#123; <span class="comment">//要返回本体,需要用引用的方式返回</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回对象本身    </span></span><br><span class="line">&#125;</span><br><span class="line">p2.funct(p1).funct(p1).funct(p1);  <span class="comment">//链式编程思想</span></span><br></pre></td></tr></table></figure><h6 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h6><p>C++中空指针也是可以调用成员函数, 但是要注意有没有用到this指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person * p =<span class="literal">NULL</span>;</span><br><span class="line">p.showAge();  <span class="comment">//报错, this-&gt;age  是一个空的值, 访问年龄出错</span></span><br><span class="line">p.showClaaName();   <span class="comment">//可以正常运行</span></span><br></pre></td></tr></table></figure><h6 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 <code>const</code>修饰成员函数</h6><p>常函数与常对象通常是配对出现的</p><p>常函数</p><ul><li>成员函数后加<code>const</code> 我们称这个函数为常函数</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后, 在常函数中依然可以修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this指针的本质是 指针常量  指针的指向不可以修改  举例指针常量 int * const p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.m_Age = <span class="number">100</span>;  <span class="comment">//指针常量的值可以变</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"><span class="comment">// this =NULL  错误, this的指向不可以改变</span></span><br><span class="line">    <span class="comment">//  指针指向的值也不可以更改了 因为函数后面加了const</span></span><br><span class="line">    <span class="keyword">this</span>.m_B = <span class="number">100</span>;  <span class="comment">//这个变量前有关键字</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> m_B;  <span class="comment">//常函数,常对象下都可以修改</span></span><br></pre></td></tr></table></figure><p>常对象:</p><ul><li>声明对象前加<code>const</code>称对象为常对象</li><li>常对象只能调用常函数</li></ul><h5 id="4-4-友元函数"><a href="#4-4-友元函数" class="headerlink" title="4,4 友元函数"></a>4,4 友元函数</h5><p>友元函数的目的就是让一个函数或者类访问另一个函数中的私有成员</p><p>友元函数的三种实现</p><ol><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ol><h6 id="4-4-1-全局函数作为友元"><a href="#4-4-1-全局函数作为友元" class="headerlink" title="4.4.1 全局函数作为友元"></a>4.4.1 全局函数作为友元</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building &amp;building)</span></span>; <span class="comment">// 加了这一句后, 下面的那一行就不报错了</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Building()&#123;</span><br><span class="line">            SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">            Bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    strign SittingRoom;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> Bedroom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building &amp;building)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 好基友全局函数 正在访问: &quot;</span> &lt;&lt; building.sittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 好基友全局函数 正在访问: &quot;</span> &lt;&lt; building.Bedroom &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span>  <span class="comment">// goodGay类是本类的好朋友 , 可以访问私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;<span class="comment">// 告诉编译器GoodGay类下的visit函数可以访问私有成员</span></span><br></pre></td></tr></table></figure><h5 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h5><p>对已有的运算符重新定义, 富裕另一种功能, 以适应不同的数据类型(如两个Person类型如何相加)</p><p>运算符重载也可以发生函数重载(operator+ 就相当于函数名)</p><h6 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h6><p>作用: 实现两个自定义类型相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Person p1;</span><br><span class="line">p1.m_a = <span class="number">10</span>;</span><br><span class="line">p1.m_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_a = <span class="number">20</span>;</span><br><span class="line">p2.m_b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 求 p1 + p2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过成员函数重载+号 写在Person类里面</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person &amp; p)&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_a = <span class="keyword">this</span>.m_a + p.m_a;</span><br><span class="line">    temp.m_b = <span class="keyword">this</span>.m_b + p.m_b;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person p3 = p1.<span class="keyword">operator</span>+(p2);</span><br><span class="line">Person p3 = p1 + p2;  <span class="comment">//简化写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过全局函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person &amp; p1, Person&amp; p2)&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_a = p1.m_a + p2.m_a;</span><br><span class="line">    temp.m_b = p1.m_b + p2.m_b;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person p3 = <span class="keyword">operator</span>+(p1,p2);</span><br><span class="line">Person p3 = p1 + p2;  <span class="comment">//简化写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person &amp; p1, <span class="keyword">int</span> num)&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_a = p1.m_a + num;</span><br><span class="line">    temp.m_b = p1.m_b + num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person p3 = p1 + <span class="number">100</span>;</span><br></pre></td></tr></table></figure><blockquote><p>总结1: 对于内置的数据类型的表达式的运算符不可能改变</p></blockquote><blockquote><p>总结二: 不要乱用运算符重载</p></blockquote><h6 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h6><p><code>&lt;&lt;</code>  作用:  可以输出自定义的数据内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法使用成员函数重载左移运算符</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt; (Person&amp; p)&#123;  <span class="comment">// 这样写的话 调用p.operator&lt;&lt;(p), 因为是类成员函数,所以只能对象p调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.m_a  &lt;&lt; p.m_b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">cout</span>)&#123;  <span class="comment">// 这样写的话  调用的时候就是 p&lt;&lt;cout; 与预想反了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能利用全局函数重载左移运算符</span></span><br><span class="line"><span class="comment">// 本质 operator&lt;&lt; (cout, p) 简化 cout &lt;&lt; p</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt; (ostream <span class="built_in">cout</span>, Person&amp; p)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.m_a  &lt;&lt; p.m_b;</span><br><span class="line">&#125; <span class="comment">//返回类型是void,不能链式编程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量, 要返回本体,需要用引用的方式返回, 否则的话 就是cout的拷贝</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; <span class="built_in">cout</span>, Person&amp; p)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.m_a  &lt;&lt; p.m_b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h6><p>通过递增运算符, 实现自己的整型类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a++;  <span class="comment">//10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;  <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ++b; <span class="comment">//11;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b ;  <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyInteger()&#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载前置++运算符  这里使用引用和不使用引用产生的结果是相同的 为什么呢?默认情况下: </span></span><br><span class="line">    <span class="comment">// int a = 0;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; ++a; //1</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; ++(++a); //2</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; a;   //2   说明一直是对一个数操作, 也就是一直对a的本体进行操作</span></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重载后置++ 运算符  clion中显示 cout&lt;&lt;(a++)++;不合法</span></span><br><span class="line">    <span class="comment">// 后面的那个int是占位参数, 区分前置和后置</span></span><br><span class="line">    <span class="comment">// 后置返回的是值,局部对象  如果返回局部变量的引用, 这个函数结束后, 就是非法操作了</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">        <span class="comment">//先记录结果</span></span><br><span class="line">        MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h6><p>默认情况下, C++ 编译器至少给一个类添加4个函数</p><ol><li>默认构造无参</li><li>默认析构函数</li><li>默认拷贝构造函数, 对属性值进行值拷贝</li><li>赋值运算符operator= ,对属性进行值拷贝  上一次没有包括这个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *m_Age;  <span class="comment">// 开辟到堆区域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与4.2.5节相似 利用深拷贝解决问题</span></span><br><span class="line"><span class="comment">// 返回Person类型 链式编程思想   如果不知道一个函数的返回值时, 先用void, 后期再更改</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Person&amp; p)&#123;</span><br><span class="line">    <span class="comment">// 应该先判断是否有属性在堆区, 先释放再拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(m_Age != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Age;</span><br><span class="line">        m_Age = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_Age);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h6><p>作用: 让两个自定义数据类型进行对比</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Peoson&amp; p1, <span class="keyword">const</span> Person&amp; p2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.m_Age &lt; p2.m_Age)&#123;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内成员函数</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Person&amp; p2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_Age &lt; p2.m_Age)&#123;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-5-6-函数调用运算符-重载"><a href="#4-5-6-函数调用运算符-重载" class="headerlink" title="4.5.6 函数调用运算符 () 重载"></a>4.5.6 函数调用运算符 <code>()</code> 重载</h6><ul><li>函数调用运算符()也可以重载</li><li>重载后非常像函数的调用,因此也叫仿函数</li><li><strong>没有固定的写法, 非常灵活</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载函数调用符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myprint</span><span class="params">(<span class="built_in">string</span> test)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPrint myprint;</span><br><span class="line">myprint(<span class="string">&quot;hello world!&quot;</span>);<span class="comment">//仿函数</span></span><br><span class="line">Myprint(<span class="string">&quot;hello world!&quot;</span>); <span class="comment">//函数调用</span></span><br><span class="line"><span class="comment">// 匿名对象,类名加小括号 MyPrint()(&quot;Hello world!&quot;);  当前行执行完立即释放</span></span><br></pre></td></tr></table></figure><h5 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6 继承"></a>4.6 继承</h5><p>类和类之间存在特殊的关系, 如下图所示</p><p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211223224735331.png" alt="image-20211223224735331"></p><p>定义这些类时, 下级别的成员除了拥有上一级的共性, 还有自己的特性.  使用继承,减少重复代码</p><h6 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage&#123;  <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; java 内容&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h6><p>继承语法:  <code>class 子类 : 继承方式 父类</code></p><p>继承方式: </p><ul><li>公共继承</li><li>保护继承    保护权限 类内可以访问, 类外不可以</li><li>私有继承     私有权限 友元函数可以访问</li></ul><h6 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h6><p>问题: 从父类继承过来的成员, 哪些属于子类对象中?     使用<code>sizeof</code>打印对象大小. </p><p><strong>父类中所有非静态成员属性都会被子类继承下去, 父类中私有成员属性被编译器隐藏了, 访问不到, 但确实是被继承了</strong> </p><p>在<code>vs2017</code>开发工具命令提示符中  运行下列命令 </p><p><code>cl /d1 reportSingleClassLayout类名 文件名 </code></p><h6 id="4-6-4-继承中构造和析构的顺序"><a href="#4-6-4-继承中构造和析构的顺序" class="headerlink" title="4.6.4 继承中构造和析构的顺序"></a>4.6.4 继承中构造和析构的顺序</h6><p>问题:  父类和子类的构造和析构顺序先后 ?</p><ul><li>父类的构造</li><li>儿子的构造</li><li>儿子的析构</li><li>父类的析构</li></ul><h6 id="4-6-5-继承中同名成员的处理方式"><a href="#4-6-5-继承中同名成员的处理方式" class="headerlink" title="4.6.5 继承中同名成员的处理方式"></a>4.6.5 继承中同名成员的处理方式</h6><p>问题:  当子类中和父类中出现同名的成员, 如何通过子类的对象去访问</p><ul><li>访问子类同名成员, 直接访问即可</li><li>访问父类同名成员, 需加上作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()&#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的func调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()&#123;</span><br><span class="line">        m_A =<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son下的func调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名的成员属性的处理方式</span></span><br><span class="line">Son s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.m_A; <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Base::m_A;  <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名的成员函数调用的处理方式</span></span><br><span class="line">Son s;</span><br><span class="line">s.func();  <span class="comment">// 调用子类中的成员函数</span></span><br><span class="line">s.Base::func(); <span class="comment">// 调用父类中的成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结:只要子类中出现了父类中的同名的函数, 子类的同名会隐藏掉父类的所有同名函数</span></span><br></pre></td></tr></table></figure><h6 id="4-6-6-继承中同名静态成员处理方式"><a href="#4-6-6-继承中同名静态成员处理方式" class="headerlink" title="4.6.6 继承中同名静态成员处理方式"></a>4.6.6 继承中同名静态成员处理方式</h6><p><strong>静态成员 4.2.8</strong> 小节</p><ul><li>所有的对象共享一份数据</li><li>在编译阶段分配内存</li><li>类内声明,类外初始化</li><li>可以类名访问, 也可以对象访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的func调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Base::m_A =<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的func调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Son::m_A; <span class="comment">// 可以直接通过类名访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Son::Base::m_A; <span class="comment">// 通过第一个::来访问父类作用域下的静态成员</span></span><br><span class="line"></span><br><span class="line">总结:只要子类中出现了父类中的静态同名的函数, 子类的同名会隐藏掉父类的所有静态同名函数</span><br></pre></td></tr></table></figure><h6 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h6><p>语法: <code>class 子类 : 继承方式 父类1, 继承方式 父类2 ...</code></p><p>多继承可能会出现重名函数的问题, 因此需要加上作用域来区分(实际开发中不建议多继承)</p><h6 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h6><p>菱形继承概念: </p><p>​    两个派生类继承一个基类</p><p>​    又有某个类同时继承两个派生类</p><p>又称为菱形继承或者钻石继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camel</span> :</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepCamel</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Camel&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当菱形继承的时候, 两个父类具有相同的数据, 需要加数据域区分</span></span><br><span class="line">SheepCamel sc;</span><br><span class="line">sc.Sheep::m_Age = <span class="number">18</span>;</span><br><span class="line">sc.Camel::m_Age = <span class="number">28</span>; <span class="comment">// 菱形继承导致数据有两份, 两个年龄, 资源浪费</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用虚继承可以解决菱形继承的问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camel</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候只剩下一个m_Age</span></span><br><span class="line">sc.Sheep::m_Age = <span class="number">18</span>;  <span class="comment">// 将m_Age赋值为18</span></span><br><span class="line">sc.Camel::m_Age = <span class="number">28</span>;  <span class="comment">// 将m_Age赋值为28</span></span><br><span class="line">sc.m_Age ;  <span class="comment">//  这三个都是同一个数据   </span></span><br><span class="line"><span class="comment">// 虚继承实质是继承了两个指针, 加上偏移量就能指向唯一的数据</span></span><br></pre></td></tr></table></figure><h5 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h5><h6 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h6><p>多态分为两类</p><ul><li>静态多态: 函数重载和运算符重载属于静态多态, 复用函数名</li><li>动态多态: 派生类和虚函数运行时多态</li></ul><p>静态和动态的区别:</p><ul><li>静态多态的函数地址早绑定- 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定- 运行阶段确定函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;喵喵!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 地址早绑定, 编译阶段确定了函数地址, 这里是animal</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp; animal)</span></span>&#123;</span><br><span class="line">    animal.speck();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    doSpeck(cat);  <span class="comment">// 问题:  这个调用哪个说话   结果是 动物在说话</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想执行猫说话, 那么这个函数地址就需要在运行时绑定, 使用虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    doSpeck(cat);  <span class="comment">// 现在调用就是 猫在说话</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结:  </p><ul><li>继承关系                 // 重写: 返回值 函数名 参数完全相同</li><li>子类重写父类中的虚函数  </li></ul><p>动态多态的使用条件</p><ul><li><strong>使用父类的指针或者引用, 执行子类对象</strong></li></ul><p><strong>动态多态内部原理</strong></p><p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211224221916046.png" alt="image-20211224221916046"></p><p>当子类没有重写父类的虚函数,  子类中的虚函数表和父类的相同</p><p>当子类重写了父类的虚函数, <strong>子类中的虚函数表</strong> 内部会替换成 <strong>子类的虚函数地址</strong></p><p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211224222226243.png" alt="image-20211224222226243"></p><p><strong>当父类的指针或者引用指向子类的对象的时候, 就发生了多态, 就从子类的<code>vftable</code>中函数的确实的地址</strong></p><h6 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一: 计算器类"></a>4.7.2 多态案例一: 计算器类</h6><p>案例描述:</p><p>分别利用普通写法和多态技术, 设计两个操作数进行运算的计算器类</p><p>多态的优点:</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方法实现 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getresult</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; oper)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper==<span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 / m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_Num1;</span><br><span class="line"><span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Calculator calculator;</span><br><span class="line">calculator.m_Num2 = <span class="number">10</span>;</span><br><span class="line">calculator.m_Num1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; calculator.getresult(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用多态实现计算器  不需要修改源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现计算器抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> m_Num1;</span><br><span class="line"><span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 分别写一个加法类 减法类 乘法类 除法类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalcutor</span>:</span><span class="keyword">public</span> AbstractCalculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态的使用条件: 引用或者指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">AbstractCalculator *abstractCalculator = <span class="keyword">new</span> AddCalcutor;</span><br><span class="line">abstractCalculator-&gt;m_Num1 = <span class="number">100</span>;</span><br><span class="line">abstractCalculator-&gt;m_Num2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; abstractCalculator-&gt;getResult();</span><br><span class="line"><span class="keyword">delete</span> abstractCalculator;  <span class="comment">// 用完释放,数据释放了, 指针没变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结</strong>:  代码量变大了, 组织清晰了, 可读性强  不需要修改源码</p><h6 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h6><p>在多态中, 通常父类中虚函数的实现是毫无意义的,   主要是调用子类重写的内容, 可以把这个函数写作纯虚函数</p><p>纯虚函数语法: <code>virtual 返回值类型 函数名 (参数列表) = 0;</code></p><p>当类中有了纯虚函数, 这个类也称为抽象类</p><p>抽象类特点:</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数, 否则也属于抽象类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 纯虚函数 只要有一个纯虚函数,这个类就称为抽象类</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Base b; 错误, 纯虚函数无法实例化对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Son类没有重写Base类, 所以也属于抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func函数调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 利用多态的技术调用  父类的指针或者引用指向子类的对象</span></span><br><span class="line">    Base * b = <span class="keyword">new</span> Son();</span><br><span class="line">    b-&gt;func();  <span class="comment">// 调用子类的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二: 制作饮品"></a>4.7.4 多态案例二: 制作饮品</h6><p>案例描述:</p><p>制作饮品大概流程: 注水、冲泡、倒入杯中、加入佐料</p><p>利用多态技术实现本案例， 提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractDrinking</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeDrink</span><span class="params">()</span></span>&#123;</span><br><span class="line">Boil();</span><br><span class="line">Brew();</span><br><span class="line">PourInCup();</span><br><span class="line">PutSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> :</span><span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;煮水&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;加入糖和牛奶&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> :</span><span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;煮矿泉水&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;加入柠檬&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作函数  传入参数 父类的指针调用子类的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(AbstractDrinking* abstractDrinking)</span></span>&#123;</span><br><span class="line">abstractDrinking-&gt;makeDrink();</span><br><span class="line">    <span class="keyword">delete</span> abstractDrink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 制作咖啡  注意:  这里参数是个指针  </span></span><br><span class="line">doWork(<span class="keyword">new</span> Coffee);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">doWork(<span class="keyword">new</span> Tea);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h6><p><strong>多态使用时, 如果子类中有属性开辟到堆区,那么父类指针在释放的时候无法调用到子类的析构代码</strong>, 纯虚析构机试为了解决上述问题</p><p>解决方法: 将父类中的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性:</p><ul><li>都可以解决父类指针释放子类问题</li><li>都需要记得函数实现</li></ul><p>虚析构汉纯虚析构区别:</p><ul><li>如果是纯虚析构,该类属于抽象类, 无法实例化对象</li></ul><p>虚析构语法:    <code>virtual ~类名()</code></p><p>纯虚析构语法: <code>virtual ~类名() = 0  ;</code></p><p>有纯虚析构后, 这个类也属于抽象类,无法初始化对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Animal()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;animal的构造函数调用\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~Animal()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;animal的析构函数调用\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// virtual ~Animal() = 0; 纯虚析构,需要声明,也需要实现 可能父类的数据也能开辟到堆中</span></span><br><span class="line">    <span class="comment">// 因此纯虚析构也需要代码的实现, 下面三行是纯虚析构的实现</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Animal::~Animal()&#123;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt; &quot;animal 纯虚析构调用\n&quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat(<span class="built_in">string</span> name)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cat的构造函数调用\n&quot;</span>;</span><br><span class="line"><span class="comment">// 堆区创建了一个属性, 应该在cat的析构中释放干净</span></span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="string">&quot;miaomiao\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat()&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Name)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; cat的析构函数调用\n&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> Cat(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;speak();</span><br><span class="line"><span class="comment">// 父类指针在析构的时候,不会调用子类中析构函数,</span></span><br><span class="line"><span class="comment">// 导致子类如果有堆区属性, 导致内存泄漏  解决:把父类中的析构改为虚析构</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父类的析构不是虚析构::</strong></p><p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211225230321220.png" alt="image-20211225230321220"></p><p><strong>父类的析构是虚析构:</strong></p><p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211225230211672.png" alt="image-20211225230211672"></p><h6 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三: 电脑组装"></a>4.7.6 多态案例三: 电脑组装</h6><p>案例描述:</p><p>电脑主要组成部分为: CPU、显卡、内存条，将每个零件封装出抽象基类，并且提供不同的厂商提供不同的零件， 例如Intel厂商和lenovo厂商， 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口。</p><p>测试时， 组装三台不同的电脑进行工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">store</span><span class="params">()</span></span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span>&#123;</span></span><br><span class="line"><span class="comment">//传入三个零件的指针</span></span><br><span class="line"><span class="comment">// 调用每个零件工作的接口</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Computer(CPU *cpu, Graphic *graphic, Memory* memory) &#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_graphic = graphic;</span><br><span class="line">m_memory = memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供工作的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_cpu-&gt;calculate();</span><br><span class="line">m_graphic-&gt;display();</span><br><span class="line">m_memory-&gt;store();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供析构函数 释放是哪个电脑零件</span></span><br><span class="line">~Computer()&#123;</span><br><span class="line"><span class="keyword">if</span> (m_cpu) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_graphic) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_graphic;</span><br><span class="line">m_graphic = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_memory) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_memory;</span><br><span class="line">m_memory = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPU* m_cpu;</span><br><span class="line">Graphic* m_graphic;</span><br><span class="line">Memory* m_memory;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体厂商</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterCpu</span>:</span><span class="keyword">public</span> CPU&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inter 的 CPU开始计算!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterGraphic</span>:</span><span class="keyword">public</span> Graphic&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inter 的 显卡开始显示!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterMemory</span>:</span><span class="keyword">public</span> Memory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inter 的 内存条开始存储!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMDCpu</span>:</span><span class="keyword">public</span> CPU&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;AMD 的 CPU开始计算!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMDGraphic</span>:</span><span class="keyword">public</span> Graphic&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;AMD 的 显卡开始显示!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMDMemory</span>:</span><span class="keyword">public</span> Memory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;AMD 的 内存条开始存储!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 第一台电脑零件</span></span><br><span class="line">CPU *intelCpu = <span class="keyword">new</span> InterCpu;</span><br><span class="line">Graphic *interGraphic = <span class="keyword">new</span> InterGraphic;</span><br><span class="line">Memory *interMemory = <span class="keyword">new</span> InterMemory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建第一台电脑 放在堆区</span></span><br><span class="line"><span class="comment">// 下面的两种写法也可以 只不过不会放在堆区</span></span><br><span class="line"><span class="comment">// Computer cmp = Computer(intelCpu, interGraphic, interMemory);</span></span><br><span class="line"><span class="comment">//Computer computer1(intelCpu, interGraphic, interMemory);</span></span><br><span class="line">Computer *computer1 = <span class="keyword">new</span> Computer(intelCpu, interGraphic, interMemory);</span><br><span class="line">computer1-&gt;work();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------------------------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二台电脑</span></span><br><span class="line">Computer *computer2 = <span class="keyword">new</span> Computer(<span class="keyword">new</span> AMDCpu, <span class="keyword">new</span> AMDGraphic, <span class="keyword">new</span> AMDMemory);</span><br><span class="line">computer2-&gt;work();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h4><p>程序运行时产生的数据都是临时数据, 程序一旦结束都会被释放</p><p>通过<strong>文件</strong>可以将数据持久化</p><p>文件包含<fstream></fstream></p><p>文件类型分为两种:</p><ol><li>文本文件:  文件以文本的ASCII码形式存储在计算机中</li><li>二进制文件, 文件以文本二进制形式存储在计算机中</li></ol><p>操作文件的三大类:</p><ol><li><code>ofstream</code>: 写操作</li><li><code>ifstream</code>: 读操作</li><li><code>fstream</code>: 读写操作</li></ol><h5 id="5-1-ASCII文件"><a href="#5-1-ASCII文件" class="headerlink" title="5.1 ASCII文件"></a>5.1 ASCII文件</h5><h5 id="5-1-1-写文件"><a href="#5-1-1-写文件" class="headerlink" title="5.1.1 写文件"></a>5.1.1 写文件</h5><p>写文件步骤如下:</p><ol><li><p>包含头文件</p><p>#include<fstream></fstream></p></li><li><p>创建流对象</p><p><code>ofstream ofs</code>;</p></li><li><p>打开文件</p><p>默认路径: 运行<code>cpp</code>文件夹下</p><p><code>ofs.open(&quot;文件路径&quot;,打开方式);</code></p></li><li><p>写数据</p><p><code>ofs&lt;&lt;&quot;写入的数据&quot;</code>;</p></li><li><p>关闭文件</p><p><code>ofs.close();</code></p></li></ol><p>文件打开方式:</p><p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20220103205520110.png" alt="image-20220103205520110"></p><p>**注意:**文件打开方式可以配合使用,利用 <code>|</code> 操作符.</p><p><strong>例如:</strong> 用二进制方式写文件 <code>ios::binary|ios:out</code></p><h5 id="5-1-2-读文件"><a href="#5-1-2-读文件" class="headerlink" title="5.1.2 读文件"></a>5.1.2 读文件</h5><p>读文件步骤如下:</p><ol><li><p>包含头文件</p><p>#include<fstream></fstream></p></li><li><p>创建流对象</p><p><code>ifstream ifs</code>;</p></li><li><p>打开文件, 判断是否打开成功</p><p><code>ifs.open(&quot;文件路径&quot;,打开方式);</code></p></li><li><p>读数据</p><p>四种方式读取, 第四种不建议,所以下面只写了三种</p></li><li><p>关闭文件</p><p><code>ifs.close();</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;哈哈&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;第二行&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;打开文件失败!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 第二种</span></span><br><span class="line">    <span class="comment">//while (ifs.getline(buf, sizeof(buf))) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三种</span></span><br><span class="line">    <span class="comment">//string buf;</span></span><br><span class="line"><span class="comment">//while (getline(ifs, buf)) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h5><h5 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h5><p>二进制文件主要调用流对象成员函数write</p><p>函数原型:  <code>ofstream&amp; write(const char * buffer, int len)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">fstream fsm;</span><br><span class="line">fsm.open(<span class="string">&quot;person.txt&quot;</span>, ios::binary | ios::out);</span><br><span class="line">Person person=&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">fsm.write((<span class="keyword">const</span> <span class="keyword">char</span> *) &amp;person, <span class="keyword">sizeof</span>(Person));</span><br><span class="line">fsm.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h5><p>二进制文件主要调用流对象成员函数read</p><p>函数原型:  <code>ofstream&amp; read(char * buffer, int len)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">fstream fsm;</span><br><span class="line">fsm.open(<span class="string">&quot;person.txt&quot;</span>, ios::binary | ios::out);</span><br><span class="line">Person person=&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">fsm.write((<span class="keyword">const</span> <span class="keyword">char</span> *) &amp;person, <span class="keyword">sizeof</span>(Person));</span><br><span class="line">fsm.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(<span class="string">&quot;person.txt&quot;</span>, ios::binary | ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.read((<span class="keyword">char</span> *) &amp;p, <span class="keyword">sizeof</span>(Person));</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.m_Name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于C++中指针的理解及其应用</title>
      <link href="/2021/10/24/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2021/10/24/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="指针的概念"><a href="#指针的概念" class="headerlink" title="指针的概念"></a>指针的概念</h4><p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容: </p><ul><li>指针的类型</li><li>指针所指向的类型</li><li>指针的值或者指针所指向的内存区</li><li>指针本身所占的内存区</li></ul><h5 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h5><p>从语法的角度看, 只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr; <span class="comment">//指针的类型是int *  </span></span><br><span class="line"><span class="keyword">char</span> *ptr; <span class="comment">//指针的类型是char *  </span></span><br><span class="line"><span class="keyword">int</span> **ptr; <span class="comment">//指针的类型是 int **  </span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>]; <span class="comment">//指针的类型是 int(*)[3]  </span></span><br><span class="line"><span class="keyword">int</span> *(*ptr)[<span class="number">4</span>]; <span class="comment">//指针的类型是 int *(*)[4] </span></span><br></pre></td></tr></table></figure><h5 id="指针所指向的类型"><a href="#指针所指向的类型" class="headerlink" title="指针所指向的类型"></a>指针所指向的类型</h5><p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p><p>从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr; <span class="comment">//指针所指向的类型是int  </span></span><br><span class="line"><span class="keyword">char</span> *ptr; <span class="comment">//指针所指向的的类型是char  </span></span><br><span class="line"><span class="keyword">int</span> **ptr; <span class="comment">//指针所指向的的类型是 int *  </span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>]; <span class="comment">//指针所指向的的类型是 int()[3]  </span></span><br><span class="line"><span class="keyword">int</span> *(*ptr)[<span class="number">4</span>]; <span class="comment">//指针所指向的的类型是 int *()[4]</span></span><br></pre></td></tr></table></figure><h5 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a><strong>指针的值</strong></h5><p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。 </p><p>指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为<code>sizeof</code>(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。 </p><p>指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。 </p><p>以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？ </p><h5 id="指针本身所占据的内存区"><a href="#指针本身所占据的内存区" class="headerlink" title="指针本身所占据的内存区"></a>指针本身所占据的内存区</h5><p>指针本身占了多大的内存？你只要用函数<code>sizeof</code>(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。</p><p>指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。 </p><h4 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h4><p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>];  </span><br><span class="line"><span class="keyword">int</span> *ptr=a;  </span><br><span class="line">ptr++;  </span><br></pre></td></tr></table></figure><p>在上例中，指针<code>ptr</code>的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针<code>ptr</code>被加了1，编译器是这样处理的：它把指针<code>ptr</code>的值加上了<code>sizeof(int)</code>，在32位程序中，是被加上了4。由于地址是用字节做单位的，故<code>ptr</code>所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。注意: 由于char类型的长度是一个字节，所以，原来<code>ptr</code>是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。</p><p>我们可以用一个指针和一个循环来遍历一个数组，看例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">20</span>];  </span><br><span class="line"><span class="keyword">int</span> *ptr=<span class="built_in">array</span>;  </span><br><span class="line">...  </span><br><span class="line"><span class="comment">//此处略去为整型数组赋值的代码。  </span></span><br><span class="line">...  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">    (*ptr)++;  </span><br><span class="line">    ptr++；  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这个例子将整型数组中各个单元的值加1。由于每次循环都将指针<code>ptr</code>加1，所以每次循环都能访问数组的下一个单元。</p><p>总结一下，一个指针<code>ptrold</code>加上一个整数n后，结果是一个新的指针<code>ptrnew</code>，<code>ptrnew</code>的类型和<code>ptrold</code>的类型相同，<code>ptrnew</code>所指向的类型和<code>ptrold</code>所指向的类型也相同。<code>ptrnew</code>的值将比<code>ptrold</code>的值增加了n乘<code>sizeof</code>(<code>ptrold</code>所指向的类型)个字节。就是说，<code>ptrnew</code>所指向的内存区将比<code>ptrold</code>所指向的内存区向高地址方向移动了n乘<code>sizeof</code>(<code>ptrold</code>所指向的类型)个字节。一个指针<code>ptrold</code>减去一个整数n后，结果是一个新的指针<code>ptrnew</code>，<code>ptrnew</code>的类型和<code>ptrold</code>的类型相同，<code>ptrnew</code>所指向的类型和<code>ptrold</code>所指向的类型也相同。<code>ptrnew</code>的值将比<code>ptrold</code>的值减少了n乘<code>sizeof</code>(<code>ptrold</code>所指向的类型)个字节，就是说，<code>ptrnew</code>所指向的内存区将比<code>ptrold</code>所指向的内存区向低地址方向移动了n乘<code>sizeof</code>(<code>ptrold</code>所指向的类型)个字节。</p><h4 id="运算符-amp-和"><a href="#运算符-amp-和" class="headerlink" title="运算符 &amp; 和 *"></a>运算符 <code>&amp;</code> 和 <code>*</code></h4><p>这里&amp;是取地址运算符，<em>是…书上叫做“间接运算符”。&amp;a的运算结果是一个指针，指针的类型是a的类型加个</em>，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。<em>p的运算结果就五花八门了。总之</em>p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>;  <span class="keyword">int</span> b;  </span><br><span class="line"><span class="keyword">int</span> *p;  </span><br><span class="line"><span class="keyword">int</span> **ptr;  </span><br><span class="line">p=&amp;a;<span class="comment">//&amp;a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。  </span></span><br><span class="line">*p=<span class="number">24</span>;<span class="comment">//*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。</span></span><br><span class="line">ptr=&amp;p;<span class="comment">//&amp;p的结果是个指针，该指针的类型是p的类型加个*，在这里是int**。该指针所指向的类型是p的类型，这里是int*。该指针所指向的地址就是指针p自己的地址。 </span></span><br><span class="line">*ptr=&amp;b; <span class="comment">//*ptr是个指针，&amp;b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以&amp;b来给*ptr赋值就是毫无问题的了。</span></span><br><span class="line">**ptr=<span class="number">34</span>;<span class="comment">//*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果就是一个int类型的变量。</span></span><br></pre></td></tr></table></figure><h4 id="指针表达式"><a href="#指针表达式" class="headerlink" title="指针表达式"></a><strong>指针表达式</strong></h4><p>一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;  </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];  </span><br><span class="line"><span class="keyword">int</span> *pa;  </span><br><span class="line">pa=&amp;a;<span class="comment">//&amp;a是一个指针表达式。  </span></span><br><span class="line"><span class="keyword">int</span> **ptr=&amp;pa;<span class="comment">//&amp;pa也是一个指针表达式。  </span></span><br><span class="line">*ptr=&amp;b;<span class="comment">//*ptr和&amp;b都是指针表达式。  </span></span><br><span class="line">pa=<span class="built_in">array</span>;  </span><br><span class="line">pa++;<span class="comment">//这也是指针表达式。</span></span><br></pre></td></tr></table></figure><p>再比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *arr[<span class="number">20</span>];  </span><br><span class="line"><span class="keyword">char</span> **parr=arr;<span class="comment">//如果把arr看作指针的话，arr也是指针表达式  </span></span><br><span class="line"><span class="keyword">char</span> *str;  </span><br><span class="line">str=*parr;<span class="comment">//*parr是指针表达式  </span></span><br><span class="line">str=*(parr+<span class="number">1</span>);<span class="comment">//*(parr+1)是指针表达式  </span></span><br><span class="line">str=*(parr+<span class="number">2</span>);<span class="comment">//*(parr+2)是指针表达式 </span></span><br></pre></td></tr></table></figure><p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。</p><p>好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。 在例七中，&amp;a不是一个左值，因为它还没有占据明确的内存。<code>*ptr</code>是一个左值，因为<code>*ptr</code>这个指针已经占据了内存，其实<code>*ptr</code>就是指针pa，既然pa已经在内存中有了自己的位置，那么<code>*ptr</code>当然也有了自己的位置。</p><h4 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a>数组和指针的关系</h4><p>关于数组和指针, 以及多维指针, 声明一些赏识:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、实际上并不存在多维数组，所谓的多维数组本质上是用一维数组模拟的。</span><br><span class="line"></span><br><span class="line">2、数组名是一个常量（意味着不允许对其进行赋值操作），其代表数组首元素的首地址。</span><br><span class="line"></span><br><span class="line">3、数组与指针的关系是因为数组下标操作符[]，比如，int a[3][2]相当于*(*(a+3)+2) 。</span><br><span class="line"></span><br><span class="line">4、指针是一种变量，也具有类型，其占用内存空间大小和系统有关，一般32位系统下，sizeof(指针变量)&#x3D;4。</span><br><span class="line"></span><br><span class="line">5、指针可以进行加减算术运算，加减的基本单位是sizeof(指针所指向的数据类型)。</span><br><span class="line"></span><br><span class="line">6、对数组的数组名进行取地址(&amp;)操作，其类型为整个数组类型。</span><br><span class="line"></span><br><span class="line">7、对数组的数组名进行sizeof运算符操作，其值为整个数组的大小(以字节为单位)。</span><br><span class="line"></span><br><span class="line">8、数组作为函数形参时会退化为指针。</span><br></pre></td></tr></table></figure><h5 id="一维数组与指针"><a href="#一维数组与指针" class="headerlink" title="一维数组与指针"></a>一维数组与指针</h5><p>假设有一维数组如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>该数组一共有3个元素，元素的类型为char，如果想定义一个指针指向该数组，也就是如果想把数组名a赋值给一个指针变量，那么该指针变量的类型应该是什么呢？前文说过，一个数组的数组名代表其首元素的首地址，也就是相当于&amp;a[0]，而a[0]的类型为char，因此&amp;a[0]类型为char *，因此，可以定义如下的指针变量： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * p = a;<span class="comment">//相当于char * p = &amp;a[0]</span></span><br></pre></td></tr></table></figure><p> 以上文字可用如下内存模型图表示:</p><p><img src="/2021/10/24/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/592743-20160227110509240-1709127045.png"></p><p>大家都应该知道，a和&amp;a[0]代表的都是数组首元素的首地址，而如果你将&amp;a的值打印出来，会发现<strong>该值也等于数组首元素的首地址</strong>。请注意我这里的措辞，也就是说，&amp;a虽然在数值上也等于数组首元素首地址的值，但是其类型并不是数组首元素首地址类型，也就是char *p = &amp;a是错误的。</p><p>前文第6条常识已经说过，对数组名进行取地址操作，其类型为整个数组，因此，&amp;a的类型是char (*)[3]，所以正确的赋值方式如下: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*p)[<span class="number">3</span>] = &amp;a;</span><br></pre></td></tr></table></figure><h5 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针"></a>二维数组与指针</h5><p> 假如有如下二维数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>由于实际上并不存在多维数组，因此，可以将<code>a[3][2]</code>看成是一个具有3个元素的一维数组，只是这三个元素分别又是一个一维数组。实际上，在内存中，该数组的确是按照一维数组的形式存储的，存储顺序为(低地址在前)：<code>a[0][0]</code>、<code>a[0][1]</code>、<code>a[1][0]</code>、<code>a[1][1]</code>、<code>a[2][0]</code>、<code>a[2][1]</code>。(此种方式也不是绝对，也有按列优先存储的模式)。</p><p>为了方便理解，我画了一张逻辑上的内存图，之所以说是逻辑上的，是因为该图只是便于理解，并不是数组在内存中实际的存储模型（实际模型为前文所述）。</p><p><img src="/2021/10/24/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/592743-20160227122557865-606035369.png" alt="img"></p><p> 如上图所示，我们可以将数组分成两个维度来看，首先是第一维，将<code>a[3][2]</code>看成一个具有三个元素的一维数组，元素分别为：<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>，其中，<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>又分别是一个具有两个元素的一维数组(元素类型为char)。从第二个维度看，此处可以<strong>将<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>看成自己代表”第二维”数组的数组名，</strong>以a[0]为例，<code>a[0](数组名)</code>代表的一维数组是一个具有两个char类型元素的数组，而a[0]是这个数组的数组名(代表数组首元素首地址)，因此a[0]类型为<code>char *</code>，同理<code>a[1]</code>和<code>a[2]</code>类型都是char <em>。</em>而a是第一维数组的数组名，代表首元素首地址，而首元素是一个具有两个char类型元素的一维数组，因此a就是一个指向具有两个char类型元素数组的数组指针，也就是<code>char(*)[2]</code>。</p><p>也就是说，如下的赋值是正确的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*p)[<span class="number">2</span>]  = a;<span class="comment">//a为第一维数组的数组名，类型为char (*)[2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * p = a[<span class="number">0</span>];<span class="comment">//a[0]维第二维数组的数组名，类型为char *</span></span><br></pre></td></tr></table></figure><p>同样，对a取地址操作代表整个数组的首地址，类型为数组类型(请允许我暂且这么称呼)，也就是char (*)[3][2]，所以如下赋值是正确的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*p)[<span class="number">3</span>][<span class="number">2</span>] = &amp;a;</span><br></pre></td></tr></table></figure><h4 id="指针和结构类型的关系"><a href="#指针和结构类型的关系" class="headerlink" title="指针和结构类型的关系"></a><strong>指针和结构类型的关系</strong></h4><p>可以声明一个指向结构类型对象的指针。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">int</span> a;  </span><br><span class="line"><span class="keyword">int</span> b;  </span><br><span class="line"><span class="keyword">int</span> c;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">MyStruct ss=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;<span class="comment">//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。</span></span><br><span class="line">MyStruct *ptr=&amp;ss;<span class="comment">//声明了一个指向结构对象ss的指针。它的类型是</span></span><br><span class="line">MyStruct*,它指向的类型是MyStruct。</span><br><span class="line"><span class="keyword">int</span> *pstr=(<span class="keyword">int</span>*)&amp;ss;<span class="comment">//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。</span></span><br></pre></td></tr></table></figure><p>请问怎样通过指针<code>ptr</code>来访问<code>ss</code>的三个成员变量？</p><p>答案： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;a;  </span><br><span class="line">ptr-&gt;b;  </span><br><span class="line">ptr-&gt;c; </span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>本篇博客作者只用于自己对C++的学习， 无意传播。</p><p>参考：</p><p><a href="https://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html">https://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html</a></p><p><a href="https://www.cnblogs.com/chenyangyao/p/5222696.html">https://www.cnblogs.com/chenyangyao/p/5222696.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp配置</title>
      <link href="/2021/10/09/frp%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/10/09/frp%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h4 id="本文主要介绍linux下frp服务端与客户端的配置"><a href="#本文主要介绍linux下frp服务端与客户端的配置" class="headerlink" title="本文主要介绍linux下frp服务端与客户端的配置"></a>本文主要介绍linux下frp服务端与客户端的配置</h4><h5 id="源文件的下载"><a href="#源文件的下载" class="headerlink" title="源文件的下载"></a>源文件的下载</h5><p>根据硬件架构的不同下载不同的源文件, <code>github</code>仓库地址: <a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a>,  客户端和服务端分别下载相对应的源文件,  <code>ubuntu</code>下载 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure>下载完成, 解压文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.37.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><h5 id="服务器端frps-ini的配置"><a href="#服务器端frps-ini的配置" class="headerlink" title="服务器端frps.ini的配置"></a>服务器端<code>frps.ini</code>的配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.37.1_linux_amd64</span><br><span class="line">vim frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line">server_port = 7000</span><br><span class="line"><span class="meta">#</span><span class="bash">token = 1234567</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Web管理页面, 也可以不用配置</span></span><br><span class="line">admin_addr = 127.0.0.1</span><br><span class="line">admin_port = 7400</span><br><span class="line">admin_user = admin</span><br><span class="line">admin_pwd = admin</span><br></pre></td></tr></table></figure><h5 id="客户端frpc-ini的配置"><a href="#客户端frpc-ini的配置" class="headerlink" title="客户端frpc.ini的配置"></a>客户端<code>frpc.ini</code>的配置</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.37.1_linux_amd64</span><br><span class="line">vim frpc.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line"><span class="meta">#</span><span class="bash">将ip改为服务器ip</span></span><br><span class="line">server_addr = 192.168.1.1</span><br><span class="line">server_port = 7000</span><br><span class="line"><span class="meta">#</span><span class="bash">token = 1234567</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">[]里面的可以随便填写, 但是不能重复</span></span><br><span class="line"><span class="meta">#</span><span class="bash">配置ssh</span></span><br><span class="line">[ssh2_cloud]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line"><span class="meta">#</span><span class="bash">注意在服务器开放端口</span></span><br><span class="line">remote_port = 39845</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置http</span></span><br><span class="line">[cloudserver8dswp]</span><br><span class="line"><span class="meta">#</span><span class="bash">privilege_mode特权模式</span></span><br><span class="line">privilege_mode = true</span><br><span class="line">type = http</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 80</span><br><span class="line">use_encryption = true</span><br><span class="line">use_compression = true</span><br><span class="line"><span class="meta">#</span><span class="bash">二级域名</span></span><br><span class="line">subdomain = sever8</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="配置frp自启"><a href="#配置frp自启" class="headerlink" title="配置frp自启"></a>配置frp自启</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.37.1_linux_amd64&#x2F;systemd&#x2F;</span><br><span class="line">cat frps.service</span><br><span class="line"></span><br><span class="line">显示结果如下:</span><br><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Frp Server Service</span><br><span class="line">After&#x3D;network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">User&#x3D;nobody</span><br><span class="line">Restart&#x3D;on-failure</span><br><span class="line">RestartSec&#x3D;5s</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;frps -c &#x2F;etc&#x2F;frp&#x2F;frps.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br><span class="line"></span><br><span class="line">然后按照结果中的 ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;frps -c &#x2F;etc&#x2F;frp&#x2F;frps.ini, 把frps复制到&#x2F;usr&#x2F;bin&#x2F;目录下, frps.ini复制到&#x2F;etc&#x2F;frp&#x2F;目录下. </span><br><span class="line"></span><br><span class="line">sudo cp frps &#x2F;usr&#x2F;bin</span><br><span class="line">sudo mkdir &#x2F;etc&#x2F;frp</span><br><span class="line">sudo cp frps.ini &#x2F;etc&#x2F;frp</span><br><span class="line"></span><br><span class="line">将frps.service 放到&#x2F;etc&#x2F;systemd&#x2F;system</span><br><span class="line">sudo cp frps.service &#x2F;etc&#x2F;systemd&#x2F;system</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>启动<code>fpc</code>服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable frpc</span><br><span class="line">sudo systemctl start frpc</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker--ankiserver</title>
      <link href="/2021/02/03/docker-ankiserver/"/>
      <url>/2021/02/03/docker-ankiserver/</url>
      
        <content type="html"><![CDATA[<h5 id="部署到服务器"><a href="#部署到服务器" class="headerlink" title="部署到服务器"></a>部署到服务器</h5><ul><li>注意：服务器开放27701端口</li><li>确保服务器已安装docker</li><li>使用root运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_USER=root</span><br><span class="line">export ANKI_SYNC_DATA_DIR=/etc/anki-sync-server</span><br><span class="line">export HOST_PORT=27701</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$ANKI_SYNC_DATA_DIR&quot;</span><br><span class="line">chown &quot;$DOCKER_USER&quot; &quot;$ANKI_SYNC_DATA_DIR&quot;</span><br><span class="line">chmod 700 &quot;$ANKI_SYNC_DATA_DIR&quot;</span><br><span class="line"></span><br><span class="line">docker run -itd \</span><br><span class="line">   --mount type=bind,source=&quot;$ANKI_SYNC_DATA_DIR&quot;,target=/app/data \</span><br><span class="line">   -p &quot;$HOST_PORT&quot;:27701 \</span><br><span class="line">   --name anki-container \</span><br><span class="line">   --restart always \</span><br><span class="line">   kuklinistvan/anki-sync-server:latest</span><br></pre></td></tr></table></figure><h5 id="运行并配置用户"><a href="#运行并配置用户" class="headerlink" title="运行并配置用户"></a>运行并配置用户</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进入anki-sync-server容器终端</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> -it anki-container /bin/sh</span> </span><br><span class="line"></span><br><span class="line">查看使用帮助</span><br><span class="line">/app/anki-sync-server # ./ankisyncctl.py --help</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  adduser &lt;username&gt; - add a new user</span><br><span class="line">  deluser &lt;username&gt; - delete a user</span><br><span class="line">  lsuser             - list users</span><br><span class="line">  passwd &lt;username&gt;  - change password of a user</span><br><span class="line"></span><br><span class="line">添加用户示例：</span><br><span class="line">/app/anki-sync-server # ./ankisyncctl.py adduser kuklinistvan</span><br><span class="line">Enter password for kuklinistvan:</span><br><span class="line">/app/anki-sync-server #</span><br></pre></td></tr></table></figure><h5 id="电脑端配置"><a href="#电脑端配置" class="headerlink" title="电脑端配置"></a>电脑端配置</h5><p>作者本人并未使用最新版 <code>Anki</code>，使用的版本是 <code>2.1.19</code>，插件安装过程 ：工具-&gt;附加组件-&gt;获取插件-&gt;输入代码 <code>231066250</code> ，下载成功后，在插件文件中进行 <code>ip</code>或者与域名配置，这里作者使用的是域名，但并未使用https，高版本好像要求https。</p><img src="/2021/02/03/docker-ankiserver/02/03/docker-ankiserver/image-20210203154040716.png" class title="附加组件"><img src="/2021/02/03/docker-ankiserver/02/03/docker-ankiserver/image-20210203154126012.png" class title="配置文件"><h5 id="安卓端配置"><a href="#安卓端配置" class="headerlink" title="安卓端配置"></a>安卓端配置</h5><p>AnkiDroid使用的版本是 <code>v2.9.7</code>, 在高级设置中点击 “自定义同步服务器”，同步地址设为 <code>http://ip 或者 域名:27701</code> ，媒体文件同步地址设为 <code>http://ip 或者 域名:27701/msync</code>，最后在常用设置中登录用户。</p><h5 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h5><p><a href="https://github.com/tsudoko/anki-sync-server">https://github.com/tsudoko/anki-sync-server</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 服务器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora常用语法</title>
      <link href="/2021/01/13/Typora%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/01/13/Typora%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Markdown-常用结构体"><a href="#Markdown-常用结构体" class="headerlink" title="Markdown 常用结构体"></a>Markdown 常用结构体</h3><h4 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h4><p>使用 # 或者 <code>ctrl+数字 </code>    例如：<code>ctrl + 1</code> 对应一级标题</p><h4 id="1-2-段落"><a href="#1-2-段落" class="headerlink" title="1.2 段落"></a>1.2 段落</h4><p><code>ctrl + 0</code></p><h4 id="1-3-区块引用"><a href="#1-3-区块引用" class="headerlink" title="1.3 区块引用"></a>1.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>区块应用   <code>&gt;</code></p><p>&gt;嵌套引用</p></blockquote><h4 id="1-4-代码区块"><a href="#1-4-代码区块" class="headerlink" title="1.4 代码区块"></a>1.4 代码区块</h4><p><code>ctrl + shift + K</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;    </span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="1-5-强调"><a href="#1-5-强调" class="headerlink" title="1.5 强调"></a>1.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p><em>斜体</em> ，<em>斜体</em>    <code>ctrl + I</code></p><p><strong>粗体</strong>   <code>ctrl + B</code></p></blockquote><h4 id="1-6-列表"><a href="#1-6-列表" class="headerlink" title="1.6 列表"></a>1.6 列表</h4><p>有序使用：<code>ctrl+shift+[</code></p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p>无序使用：<code>ctrl+shift+]</code></p><ul><li>无序列表第一</li><li>第二</li></ul><h4 id="1-7-分割线"><a href="#1-7-分割线" class="headerlink" title="1.7 分割线"></a>1.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><hr><hr><hr><h4 id="1-8-链接"><a href="#1-8-链接" class="headerlink" title="1.8 链接"></a>1.8 链接</h4><blockquote><p><a href="https://www.github.com/okeyia">okeyia的github</a></p></blockquote><h4 id="1-9-图片"><a href="#1-9-图片" class="headerlink" title="1.9 图片"></a>1.9 图片</h4><p><code>ctrl + shift +i</code></p><h4 id="1-10-反斜杠"><a href="#1-10-反斜杠" class="headerlink" title="1.10 反斜杠"></a>1.10 反斜杠</h4><p><code>\</code>相当于<strong>反转义</strong>作用，使符号成为普通符号.</p><h4 id="1-11-符号"><a href="#1-11-符号" class="headerlink" title="1.11 符号   `"></a>1.11 符号   `</h4><p>ctrl + shift + `</p><p> 起到标记作用，用于字母或数字，例如：<code>abc</code>，<code>123</code> 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
