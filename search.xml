<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>三 高性能服务器编程</title>
      <link href="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/"/>
      <url>/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20220908201643320.png" class="" title="image-20220908201643320"><h2 id="第三篇-高性能服务器编程"><a href="#第三篇-高性能服务器编程" class="headerlink" title="第三篇 高性能服务器编程"></a>第三篇 高性能服务器编程</h2><h3 id="第12章-高性能I-O框架库Libevent"><a href="#第12章-高性能I-O框架库Libevent" class="headerlink" title="第12章 高性能I/O框架库Libevent"></a>第12章 高性能I/O框架库Libevent</h3><p>前面我们利用三章的篇幅较为细致地讨论了Linux服务器程序必须 处理的三类事件：<strong>I/O事件、信号和定时事件。</strong></p><p>在处理这三类事件时我 们通常需要考虑如下三个问题：</p><ul><li>统一事件源。统一处理这三类事件既能使代码简单易 懂，又能避免一些潜在的逻辑错误。前面我们已经讨论了实现统一事 件源的一般方法——利用I/O复用系统调用来管理所有事件。</li><li>可移植性。不同的操作系统具有不同的I/O复用方式，比如 Solaris的dev/poll文件，FreeBSD的kqueue机制，Linux的epoll系列系统 调用。</li><li>对并发编程的支持。在多进程和多线程环境下，我们需要考虑 各执行实体如何协同处理客户连接、信号和定时器，以避免竞态条 件。</li></ul><p>本章将 介绍其中相对轻量级的Libevent框架库</p><h4 id="12-1-I-O框架库概述"><a href="#12-1-I-O框架库概述" class="headerlink" title="12.1  I/O框架库概述"></a>12.1  I/O框架库概述</h4><p>I/O框架库以库函数的形式，封装了较为底层的系统调用，给应用 程序提供了一组更便于使用的接口。</p><p>各种I/O框架库的实现原理基本相似，要么以Reactor模式实现，要 么以Proactor模式实现，要么同时以这两种模式实现。举例来说，基于 Reactor模式的I/O框架库包含如下几个组件：句柄（Handle）、事件多 路分发器（EventDemultiplexer）、事件处理器（EventHandler）和具体 的事件处理器（ConcreteEventHandler）、Reactor。这些组件的关系如 图12-1所示[6]。</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230305225701977.png" class="" title="image-20230305225701977"><ul><li><strong>句柄:</strong> I/O框架库要处理的对象，即I/O事件、信号和定时事件，统一称为事件源。一个事件源通常和一个句柄绑定在一起。<strong>句柄的作用是，当内核检测到就绪事件时，它将通过句柄来通知应用程序这一事件。</strong>在 Linux环境下，I/O事件对应的句柄是文件描述符，信号事件对应的句柄就是信号值。</li><li><strong>事件多路分发器:</strong> 事件的到来是随机的、异步的。我们无法预知程序何时收到一个客户连接请求，又亦或收到一个暂停信号。所以程序需要循环地等待并处理事件，这就是事件循环。在事件循环中，等待事件一般使用I/O 复用技术来实现。<strong>I/O框架库一般将系统支持的各种I/O复用系统调用封装成统一的接口，称为事件多路分发器。</strong>事件多路分发器的demultiplex 方法是等待事件的核心函数，其内部调用的是select、poll、epoll_wait 等函数。</li><li><strong>事件处理器和具体事件处理器:</strong>  事件处理器执行事件对应的业务逻辑。它通常包含一个或多个 handle_event回调函数，这些回调函数在事件循环中被执行。<strong>I/O框架库 提供的事件处理器通常是一个接口，用户需要继承它来实现自己的事 件处理器，即具体事件处理器。</strong>因此，事件处理器中的回调函数一般 被声明为虚函数，以支持用户的扩展。</li><li><strong>Reactor:</strong>  Reactor是I/O框架库的核心。<ul><li>handle_events。该方法执行事件循环。它重复如下过程：等待事件，然后依次处理所有就绪事件对应的事件处理器。</li><li>register_handler。该方法调用事件多路分发器的register_event方法来往事件多路分发器中注册一个事件。</li><li>remove_handler。该方法调用事件多路分发器的remove_event方 法来删除事件多路分发器中的一个事件。</li></ul></li></ul><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230305230319003.png" class="" title="image-20230305230319003"><h4 id="12-2-Libevent源码分析"><a href="#12-2-Libevent源码分析" class="headerlink" title="12.2 Libevent源码分析"></a>12.2 Libevent源码分析</h4><p>作为一个I/O 框架库，Libevent具有如下特点：</p><ul><li>跨平台支持。Libevent支持Linux、UNIX和Windows。</li><li>统一事件源。Libevent对I/O事件、信号和定时事件提供统一的处理。</li><li>线程安全。Libevent使用libevent_pthreads库来提供线程安全支 持。</li><li>基于Reactor模式的实现。</li></ul><h5 id="12-2-1-一个实例"><a href="#12-2-1-一个实例" class="headerlink" title="12.2.1 一个实例"></a>12.2.1 一个实例</h5><p>分析一款软件的源代码，最简单有效的方式是从使用入手，这样 才能从整体上把握该软件的逻辑结构。</p><p>使用Libevent库 实现的一个“Hello World”程序, 代码清单12-1虽然简单，但却基本上描述了Libevent库的主要逻辑：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">signal_cb</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">short</span> event,<span class="keyword">void</span>*argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>*<span class="title">base</span>=</span>(event_base*)argc;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">delay</span>=</span>&#123;<span class="number">2</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Caught an interrupt signal;exiting cleanly in two seconds...\n&quot;</span>);</span><br><span class="line">event_base_loopexit(base,&amp;delay);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timeout_cb</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">short</span> event,<span class="keyword">void</span>*argc)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;timeout\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">base</span>=</span>event_init();</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">signal_event</span>=</span>evsignal_new(base,SIGINT,signal_cb,base);</span><br><span class="line">event_add(signal_event,<span class="literal">NULL</span>);</span><br><span class="line">timeval tv =&#123;<span class="number">1</span>,<span class="number">0</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span>* <span class="title">timeout_event</span>=</span>evtimer_new(base,timeout_cb,<span class="literal">NULL</span>);</span><br><span class="line">event_add(timeout_event,&amp;tv);</span><br><span class="line">event_base_dispatch(base);</span><br><span class="line">event_free(timeout_event);</span><br><span class="line">event_free(signal_event);</span><br><span class="line">event_base_free(base);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p>调用event_init函数创建event_base对象。一个event_base相当于 一个Reactor实例。</p></li><li><p>创建具体的事件处理器，并设置它们所从属的Reactor实例。 evsignal_new和evtimer_new分别用于创建信号事件处理器和定时事件处理器，它们是定义在include/event2/event.h文件中的宏：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evsignal_new(b,x,cb,arg)\</span></span><br><span class="line">event_new((b),(x),EV_SIGNAL|EV_PERSIST,(cb),(arg))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> evtimer_new(b,cb,arg)event_new((b),-1,0,(cb),(arg))</span></span><br></pre></td></tr></table></figure><p>可见，它们的统一入口是event_new函数，<strong>即用于创建通用事件处 理器</strong>（图12-1中的EventHandler）的函数。其定义是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct event* <span class="title">event_new</span><span class="params">(struct event_base* base,<span class="keyword">evutil_socket_t</span></span></span></span><br><span class="line"><span class="function"><span class="params">fd, <span class="keyword">short</span> events, <span class="keyword">void</span>(*cb)(<span class="keyword">evutil_socket_t</span>, <span class="keyword">short</span>, <span class="keyword">void</span>*), <span class="keyword">void</span>*arg)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>base参数指定新创建的事件处理器从属的Reactor。</p></li><li><p>fd参数指定与该事件处理器关联的句柄。<strong>创建I/O事件处理器时，应该给fd参 数传递文件描述符值；创建信号事件处理器时，应该给fd参数传递信 号值，比如代码清单12-1中的SIGINT；创建定时事件处理器时，则应该给fd参数传递-1。</strong></p></li><li><p>events参数指定事件类型，其可选值都定义在 include/event2/event.h文件中，如代码清单12-2所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_TIMEOUT 0x01<span class="comment">/*定时事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_READ 0x02<span class="comment">/*可读事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_WRITE 0x04<span class="comment">/*可写事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_SIGNAL 0x08<span class="comment">/*信号事件*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_PERSIST 0x10<span class="comment">/*永久事件*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// EV_PERSIST的作用是：事件被触发后，自动重新对这个event调用event_add函数</span></span><br><span class="line"><span class="comment">/*边沿触发事件，需要I/O复用系统调用支持，比如epoll*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> EV_ET 0x20</span></span><br></pre></td></tr></table></figure></li><li><p>cb参数指定目标事件对应的回调函数，相当于图12-1中事件处理 器的handle_event方法。</p></li><li><p>arg参数则是Reactor传递给回调函数的参数。</p></li></ul><p>event_new函数成功时返回一个event类型的对象，也就是Libevent 的事件处理器。</p><blockquote><p>约定:  </p><p><strong>事件</strong>指的是一个句柄上绑定的事件，比如文件描述符0上的可读 事件。</p><p>事件处理器，也就是event结构体类型的对象，除了包含事件必 须具备的两个要素（句柄和事件类型）外，还有很多其他成员，比如 回调函数。</p><p>事件由事件多路分发器管理，事件处理器则由事件队列管理。 事件队列包括多种，比如event_base中的注册事件队列、活动事件队列 和通用定时器队列，以及evmap中的I/O事件队列、信号事件队列。</p><p>事件循环对一个被激活事件（就绪事件）的处理，指的是执行 该事件对应的事件处理器中的回调函数。</p></blockquote></li><li><p>调用event_add函数，将事件处理器添加到注册事件队列中， 并将该事件处理器对应的事件添加到事件多路分发器中。event_add函 数相当于Reactor中的register_handler方法。</p></li><li><p>调用event_base_dispatch函数来执行事件循环。</p></li><li><p>事件循环结束后，使用*_free系列函数来释放系统资源。</p></li></ol><h5 id="12-2-2-源代码组织结构"><a href="#12-2-2-源代码组织结构" class="headerlink" title="12.2.2 源代码组织结构"></a>12.2.2 源代码组织结构</h5><p>Libevent源代码中的目录和文件按照功能可划分为如下部分：</p><ul><li>头文件目录include/event2。该目录中的头文件 是Libevent提供给应用程序使用的，比如，event.h头文件提供核心函 数，http.h头文件提供HTTP协议相关服务，rpc.h头文件提供远程过程 调用支持。</li><li>源码根目录下的头文件。这些头文件分为两类：一类是对 include/event2目录下的部分头文件的包装，另外一类是供Libevent内部 使用的辅助性头文件，它们的文件名都具有*-internal.h的形式。<ul><li>event-internal.h， 比较重要</li></ul></li><li>通用数据结构目录compat/sys。该目录下仅有一个文件—— queue.h。它封装了跨平台的基础数据结构，包括单向链表、双向链 表、队列、尾队列和循环队列</li><li><strong>event.c文件。</strong> <strong>该文件实现Libevent的整体框架，主要是event和 event_base两个结构体的相关操作。</strong></li><li>devpoll.c、kqueue.c、evport.c、select.c、win32select.c、poll.c和 epoll.c文件。它们分别封装了如下I/O复用机制：/dev/poll、kqueue、 event ports、POSIX select、Windows select、poll和epoll。</li><li><strong>evmap.c文件</strong>。它维护句柄（文件描述符或信号）与事件处理器的映射关系。</li></ul><p>在整个源码中，event-internal.h、include/event2/event_struct.h、 event.c和evmap.c等4个文件最为重要。它们定义了event和event_base结 构体，并实现了这两个结构体的相关操作。</p><h5 id="12-2-3-event-结构体"><a href="#12-2-3-event-结构体" class="headerlink" title="12.2.3 event 结构体"></a>12.2.3 event 结构体</h5><p>Libevent中的事件处理器是event结构类型。<strong>event结构 体封装了句柄、事件类型、回调函数，以及其他必要的标志和数据。</strong> </p><p>该结构体在include/event2/event_struct.h文件中定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TAILQ_ENTRY(event) ev_active_next;</span><br><span class="line">TAILQ_ENTRY(event) ev_next;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">TAILQ_ENTRY(event)ev_next_with_common_timeout;</span><br><span class="line"><span class="keyword">int</span> min_heap_idx;</span><br><span class="line">&#125;ev_timeout_pos;</span><br><span class="line"></span><br><span class="line"><span class="keyword">evutil_socket_t</span> ev_fd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">event_base</span>* <span class="title">ev_base</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">TAILQ_ENTRY(event) ev_io_next;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line">&#125;ev_io;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">TAILQ_ENTRY(event) ev_signal_next;</span><br><span class="line"><span class="keyword">short</span> ev_ncalls;</span><br><span class="line"><span class="keyword">short</span>* ev_pncalls;</span><br><span class="line">&#125;ev_signal;</span><br><span class="line">&#125;_ev;</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> ev_events;</span><br><span class="line"><span class="keyword">short</span> ev_res;</span><br><span class="line"><span class="keyword">short</span> ev_flags;</span><br><span class="line"><span class="keyword">ev_uint8_t</span> ev_pri;</span><br><span class="line"><span class="keyword">ev_uint8_t</span> ev_closure;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ev_timeout</span>;</span></span><br><span class="line"><span class="keyword">void</span>(*ev_callback)(<span class="keyword">evutil_socket_t</span>,<span class="keyword">short</span>,<span class="keyword">void</span>*arg);</span><br><span class="line"><span class="keyword">void</span>*ev_arg;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>ev_active_next。所有被激活的事件处理器通过该成员串联成一 个尾队列，我们称之为活动事件队列。活动事件队列不止一个，不同 优先级的事件处理器被激活后将被插入不同的活动事件队列中。在事 件循环中，Reactor将按优先级从高到低遍历所有活动事件队列，并依 次处理其中的事件处理器。</p></li><li><p>ev_next。<strong>所有已经注册的事件处理器（包括I/O事件处理器和信 号事件处理器）通过该成员串联成一个尾队列，我们称之为注册事件队列。</strong>宏TAILQ_ENTRY是尾队列中的节点类型，它定义在 compat/sys/queue.h文件中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TAILQ_ENTRY(type)\</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span>\</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span>* <span class="title">tqe_next</span>;</span>\<span class="comment">/*下一个元素*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type</span>** <span class="title">tqe_prev</span>;</span>\<span class="comment">/*前一个元素的地址*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>内容暂时忽略。</p><h3 id="第13章-多进程编程"><a href="#第13章-多进程编程" class="headerlink" title="第13章 多进程编程"></a>第13章 多进程编程</h3><p>进程是Linux操作系统环境的基础，它控制着系统上几乎所有的活动。</p><ul><li>复制进程映像的fork系统调用和替换进程映像的exec系列系统调 用。</li><li>僵尸进程以及如何避免僵尸进程。</li><li>进程间通信（Inter-Process Communication，IPC）最简单的方 式：管道。</li><li>3种System V进程间通信方式：信号量、消息队列和共享内存。 它们都是由AT＆T System V2版本的UNIX引入的，所以统称为System V IPC。</li><li>在进程间传递文件描述符的通用方法：通过UNIX本地域socket 传递特殊的辅助数据（关于辅助数据，参考5.8.3小节）。</li></ul><h4 id="13-1-fork系统"><a href="#13-1-fork系统" class="headerlink" title="13.1 fork系统"></a>13.1 fork系统</h4><p>Linux下创建新进程的系统调用是fork。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的每次调用都返回两次，在父进程中返回的是子进程的 PID，在子进程中则返回0。</p><p>该返回值是后续代码判断当前进程是父进 程还是子进程的依据。fork调用失败时返回-1，并设置errno。</p><blockquote><p><strong>Fork函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性和原进程相同，比如堆指针、栈指针和 标志寄存器的值。</strong></p><p>但也有许多属性被赋予了新的值，比如该进程的 PPID被设置成原进程的PID，信号位图被清除（原进程设置的信号处 理函数不再对新进程起作用）。</p><p>复制父进程的数据 （堆数据、栈数据和静态数据）。数据的复制采用的是所谓的写时复制（copy on writte），即只有在任一进程（父进程或子进程）对数据 执行了写操作时，复制才会发生</p><p>创建子进程后，父进程中打开的文件描述符默认在子进程 中也是打开的，且文件描述符的引用计数加1。不仅如此，父进程的用 户根目录、当前工作目录等变量的引用计数均会加1。</p></blockquote><h4 id="13-2-exec系列系统调用"><a href="#13-2-exec系列系统调用" class="headerlink" title="13.2 exec系列系统调用"></a>13.2 exec系列系统调用</h4><p>有时我们需要在子进程中执行其他程序，即替换当前进程映像， 这就需要使用如下exec系列函数之一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>**environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*file,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...,<span class="keyword">char</span>*<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">char</span>*<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*file,<span class="keyword">char</span>*<span class="keyword">const</span> argv[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">char</span>*<span class="keyword">const</span> argv[],<span class="keyword">char</span>*<span class="keyword">const</span> envp[])</span></span>;</span><br></pre></td></tr></table></figure><ul><li>path参数指定可执行文件的完整路径，</li><li>file参数可以接受文件名， 该文件的具体位置则在环境变量PATH中搜寻。</li><li>arg接受可变参数，argv 则接受参数数组，它们都会被传递给新程序（path或file指定的程序） 的main函数。</li><li>envp参数用于设置新程序的环境变量。如果未设置它， 则新程序将使用由全局变量environ指定的环境变量。</li></ul><p>一般情况下，exec函数是不返回的，除非出错。它出错时返 回-1，并设置errno。如果没出错，则<strong>原程序中exec调用之后的代码都不会执行，因为此时原程序已经被exec的参数指定的程序完全替换</strong> （包括代码和数据）。</p><h4 id="13-3-处理僵尸进程"><a href="#13-3-处理僵尸进程" class="headerlink" title="13.3 处理僵尸进程"></a>13.3 处理僵尸进程</h4><p>对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。 因此，<strong>当子进程结束运行时，内核不会立即释放该进程的进程表表 项，以满足父进程后续对该子进程退出信息的查询（如果父进程还在 运行）。在子进程结束运行之后，父进程读取其退出状态之前，我们 称该子进程处于僵尸态。</strong></p><p>另外一种使子进程进入僵尸态的情况是：<strong>父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被 操作系统设置为1，即init进程。init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态。</strong></p><p>下面这对函数在父进程中调用，以 等待子进程的结束，并获取子进程的返回信息，从而避免了僵尸进程 的产生，或者使子进程的僵尸态立即结束：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/wait.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* stat_loc)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* stat_loc, <span class="keyword">int</span> options)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><strong>wait函数将阻塞进程，直到该进程的某个子进程结束运行为止。</strong>它返回结束运行的子进程的PID，并将该子进程的退出状态信息存储于 stat_loc参数指向的内存中。sys/wait.h头文件中定义了几个宏来帮助解 释子进程的退出状态信息，</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306210917536.png" class="" title="image-20230306210917536"></li><li><p>wait函数的阻塞特性显然不是服务器程序期望的，而waitpid函数解 决了这个问题。<strong>waitpid只等待由pid参数指定的子进程。</strong>如果pid取值 为-1，那么它就和wait函数相同，即等待任意一个子进程结束。</p><ul><li>stat_loc 参数的含义和wait函数的stat_loc参数相同。</li><li>options参数可以控制waitpid 函数的行为。该参数最常用的取值是WNOHANG。当options的取值是 WNOHANG时，waitpid调用将是非阻塞的：<strong>如果pid指定的目标子进程还没有结束或意外终止，则waitpid立即返回0；</strong>如果目标子进程确实正常退出了，则waitpid返回该子进程的PID。waitpid调用失败时返回-1并 设置errno。</li></ul></li></ul><p><strong>要在事件已经发生的情况下执行非阻塞调用才能提高程序的效率。</strong>对waitpid函数而言，我们最好在某个子进程退出之后 再调用它。</p><p>那么父进程从何得知某个子进程已经退出了呢？这正是 SIGCHLD信号的用途。当一个进程结束时，它将给其父进程发送一个 SIGCHLD信号。因此，我们可以在父进程中捕获SIGCHLD信号，并在 信号处理函数中调用waitpid函数以“彻底结束”一个子进程, 信号处理函数如下: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_child</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span>((pid=waitpid(<span class="number">-1</span>,&amp;stat,WNOHANG))＞<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">/*对结束的子进程进行善后处理*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-4-管道"><a href="#13-4-管道" class="headerlink" title="13.4 管道"></a>13.4 管道</h4><p>管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0]和fd[1]）都保持打开。一对这样的文件描述符只能 保证父、子进程间一个方向的数据传输，<strong>父进程和子进程必须有一个关闭fd[0]，另一个关闭fd[1]。</strong></p><p>比如，我们要使用管道实现从父进程向 子进程写数据，就应该按照图13-1所示来操作。</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306211713409.png" class="" title="image-20230306211713409"><p>如果要实现父、子进程之间的双向数据传输，就必须使用两个管道。第6章中我们还介绍过，<strong>socket编程接口提供了一个创建全双工管道的系统调用：socketpair。</strong></p><p><strong>管道只能用于有关联的两个进程（比如父、子进程）间的 通信。</strong></p><p>而下面要讨论的3种System V IPC能用于无关联的多个进程之间 的通信，因为它们都使用一个全局唯一的键值来标识一条信道。</p><h4 id="13-5-信号量"><a href="#13-5-信号量" class="headerlink" title="13.5 信号量"></a>13.5 信号量</h4><h5 id="13-5-1-信号量原语"><a href="#13-5-1-信号量原语" class="headerlink" title="13.5.1 信号量原语"></a>13.5.1 信号量原语</h5><p>通常，程序对共享资源的访问的代码只是很短的一段，但就是这一段 代码引发了进程之间的竞态条件。我们称这段代码为关键代码段，或 者临界区。对进程同步，也就是确保任一时刻只有一个进程能进入关 键代码段。</p><p>对信号量的这两种操作更常 用的称呼是P、V操作。这两个字母来自于荷兰语单词passeren（传递， 就好像进入临界区）和vrijgeven（释放，就好像退出临界区）。</p><p>假设有 信号量SV，则对它的P、V操作含义如下：</p><ul><li>P(SV)，如果SV的值大于0，就将它减1；如果SV的值为0，则挂 起进程的执行。 </li><li>V(SV)，如果有其他进程因为等待SV而挂起，则唤醒之；如果没 有，则将SV加1。</li></ul><p>本书仅讨论二进制信号 量。使用二进制信号量同步两个进程，以确保关键代码段的独占式访 问的一个典型例子如图13-2所示。</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306212542683.png" class="" title="image-20230306212542683"><p>Linux信号量的API都定义在sys/sem.h头文件中，主要包含3个系统调用：<strong>semget、semop和semctl</strong>。它们都被设计为操作一组信号量，即 信号量集，而不是单个信号量</p><h5 id="13-5-2-semget"><a href="#13-5-2-semget" class="headerlink" title="13.5.2 semget"></a>13.5.2 semget</h5><p>semget系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sem.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> num_sems,<span class="keyword">int</span> sem_flags)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>key参数是一个键值，用来标识一个全局唯一的信号量集，就像文 件名全局唯一地标识一个文件一样。要通过信号量通信的进程需要使 用相同的键值来创建/获取该信号量。</li><li>num_sems参数指定要创建/获取的信号量集中信号量的数目。如果 是创建信号量，则该值必须被指定；如果是获取已经存在的信号量， 则可以把它设置为0。</li><li>sem_flags参数指定一组标志。它低端的9个比特是该信号量的权 限，其格式和含义都与系统调用open的mode参数相同。</li></ul><p><strong>semget成功时返回一个正整数值，它是信号量集的标识符</strong>；semget 失败时返回-1，并设置errno。</p><h5 id="13-5-3-semop系统调用"><a href="#13-5-3-semop系统调用" class="headerlink" title="13.5.3 semop系统调用"></a>13.5.3 semop系统调用</h5><p>semop系统调用改变信号量的值，即执行P、V操作。在讨论semop 之前，我们需要先介绍与每个信号量关联的一些重要的内核变量：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semval;   <span class="comment">/*信号量的值*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semzcnt;<span class="comment">/*等待信号量值变为0的进程数量*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt;<span class="comment">/*等待信号量值增加的进程数量*/</span></span><br><span class="line"><span class="keyword">pid_t</span> sempid;<span class="comment">/*最后一次执行semop操作的进程ID*/</span></span><br></pre></td></tr></table></figure><p>semop对信号量的操作实际上就是对这些内核变量的操作。</p><p>semop 的定义如下：#include＜sys/sem.h＞</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id, struct sembuf* sem_ops, <span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>sem_id参数是由semget调用返回的信号量集标识符，用以指定被操作的目标信号量集。</p></li><li><p>sem_ops参数指向一个sembuf结构体类型的数组， sembuf结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sem_num;</span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sem_op;</span><br><span class="line"><span class="keyword">short</span> <span class="keyword">int</span> sem_flg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><ul><li>sem_num成员是<code>信号量集</code>中信号量的编号，0表示信号量集 中的第一个信号量。</li><li>sem_op成员指定操作类型，其可选值为正整数、0 和负整数。每种类型的操作的行为又受到sem_flg成员的影响。</li><li>sem_flg 的可选值是IPC_NOWAIT和SEM_UNDO。IPC_NOWAIT的含义是，无论信号量操作是否成功，semop调用都将立即返回，这类似于非阻塞 I/O操作。<strong>SEM_UNDO的含义是，当进程退出时取消正在进行的semop 操作。</strong></li></ul></blockquote></li><li><p><strong>semop系统调用的第3个参数num_sem_ops指定要执行的操作个数，即sem_ops数组中元素的个数。</strong>semop对数组sem_ops中的每个成员按照数组顺序依次执行操作，并且该过程是原子操作，以避免别的进 程在同一时刻按照不同的顺序对该信号集中的信号量执行semop操作导 致的竞态条件。</p></li></ul><p>semop成功时返回0，失败则返回-1并设置errno。失败的时候， sem_ops数组中指定的所有操作都不被执行。</p><h5 id="13-5-4-semctl系统调用"><a href="#13-5-4-semctl系统调用" class="headerlink" title="13.5.4 semctl系统调用"></a>13.5.4 semctl系统调用</h5><p>semctl系统调用允许调用者对信号量进行直接控制。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sem.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> sem_num,<span class="keyword">int</span> command,...)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>sem_id参数是由semget调用返回的信号量集标识符，用以指定被操 作的信号量集。</p></li><li><p>sem_num参数指定被操作的信号量在信号量集中的编 号。</p></li><li><p>command参数指定要执行的命令。有的命令需要调用者传递第4个 参数。</p></li><li><p>第4个参数的类型由用户自己定义，但sys/sem.h头文件给出了它 的推荐格式，具体如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;<span class="comment">/*用于SETVAL命令*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>*<span class="title">buf</span>;</span><span class="comment">/*用于IPC_STAT和IPC_SET命令*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span>*<span class="built_in">array</span>;<span class="comment">/*用于GETALL和SETALL命令*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>*__<span class="title">buf</span>;</span><span class="comment">/*用于IPC_INFO命令*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> semmap;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line"><span class="keyword">int</span> semmni;<span class="comment">/*系统最多可以拥有的信号量集数目*/</span></span><br><span class="line"><span class="keyword">int</span> semmns;<span class="comment">/*系统最多可以拥有的信号量数目*/</span></span><br><span class="line"><span class="keyword">int</span> semmnu;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line"><span class="keyword">int</span> semmsl;<span class="comment">/*一个信号量集最多允许包含的信号量数目*/</span></span><br><span class="line"><span class="keyword">int</span> semopm;<span class="comment">/*semop一次最多能执行的sem_op操作数目*/</span></span><br><span class="line"><span class="keyword">int</span> semume;<span class="comment">/*Linux内核没有使用*/</span></span><br><span class="line"><span class="keyword">int</span> semusz;<span class="comment">/*sem_undo结构体的大小*/</span></span><br><span class="line"><span class="keyword">int</span> semvmx;<span class="comment">/*最大允许的信号量值*/</span></span><br><span class="line"><span class="comment">/*最多允许的UNDO次数（带SEM_UNDO标志的semop操作的次数）*/</span></span><br><span class="line"><span class="keyword">int</span> semaem;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306215726484.png" class="" title="image-20230306215726484"></li></ul><p>semctl成功时的返回值取决于command参数，如表13-2所示。 semctl失败时返回-1，并设置errno。</p><h5 id="13-5-5-特殊键值IPC-PRIVATE"><a href="#13-5-5-特殊键值IPC-PRIVATE" class="headerlink" title="13.5.5 特殊键值IPC_PRIVATE"></a>13.5.5 特殊键值IPC_PRIVATE</h5><p>semget的调用者可以给其key参数传递一个特殊的键值 IPC_PRIVATE（其值为0），这样无论该信号量是否已经存在，semget 都将创建一个新的信号量。  使用该键值创建的信号量并非像它的名字 声称的那样是进程私有的。其他进程，尤其是子进程，也有方法来访 问这个信号量。</p><p>比如下面 的代码清单13-3就在父、子进程间使用一个IPC_PRIVATE信号量来同 步。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/6.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span>*<span class="title">buf</span>;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span>*<span class="built_in">array</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">seminfo</span>*__<span class="title">buf</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*op为-1时执行P操作，op为1时执行V操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pv</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> op)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">sem_b</span>&#123;</span>&#125;;</span><br><span class="line">sem_b.sem_num=<span class="number">0</span>;</span><br><span class="line">sem_b.sem_op=op;</span><br><span class="line">sem_b.sem_flg=SEM_UNDO;</span><br><span class="line">semop(sem_id, &amp;sem_b ,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sem_id=semget(IPC_PRIVATE,<span class="number">1</span>,<span class="number">0666</span>);</span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">sem_un</span>&#123;</span>&#125;;</span><br><span class="line">sem_un.val=<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 0是被操作的信号量在信号集中的编号, SETVAl 是被执行的命令</span></span><br><span class="line">semctl(sem_id,<span class="number">0</span>,SETVAL,sem_un);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">pid_t</span> id=fork();</span><br><span class="line"><span class="keyword">if</span>(id&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(id==<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child try to get binary sem\n&quot;</span>);</span><br><span class="line"><span class="comment">/*在父、子进程间共享IPC_PRIVATE信号量的关键就在于二者都可以操作该信号量的标识符sem_id*/</span></span><br><span class="line">pv(sem_id,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">pv(sem_id,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent try to get binary sem\n&quot;</span>);</span><br><span class="line">pv(sem_id,<span class="number">-1</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;parent get the sem and would release it after 5 seconds\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">pv(sem_id,<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">waitpid(id,<span class="literal">NULL</span>,<span class="number">0</span>);</span><br><span class="line">semctl(sem_id,<span class="number">0</span>,IPC_RMID,sem_un);<span class="comment">/*删除信号量*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-6-共享内存"><a href="#13-6-共享内存" class="headerlink" title="13.6 共享内存"></a>13.6 共享内存</h4><p>共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据 传输。这种高效率带来的问题是，我们必须用其他辅助手段来同步进 程对共享内存的访问，否则会产生竞态条件。</p><p>Linux共享内存的API都定义在sys/shm.h头文件中，包括4个系统调 用：shmget、shmat、shmdt和shmctl。</p><h5 id="13-6-1-shmget系统调用"><a href="#13-6-1-shmget系统调用" class="headerlink" title="13.6.1 shmget系统调用"></a>13.6.1 shmget系统调用</h5><p>shmget系统调用创建一段新的共享内存，或者获取一段已经存在 的共享内存。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">size_t</span> size,<span class="keyword">int</span> shmflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>和semget系统调用一样，key参数是一个键值，用来标识一段全局 唯一的共享内存。</li><li>size参数指定共享内存的大小，单位是字节。如果是 创建新的共享内存，则size值必须被指定。如果是获取已经存在的共享 内存，则可以把size设置为0。</li><li>shmflg参数的使用和含义与semget系统调用的sem_flags参数相同。 不过shmget支持两个额外的标志——SHM_HUGETLB和 SHM_NORESERVE。它们的含义如下：<ul><li>SHM_HUGETLB，类似于mmap的MAP_HUGETLB标志，系统 将使用“大页面”来为共享内存分配空间。</li><li>SHM_NORESERVE，类似于mmap的MAP_NORESERVE标志， 不为共享内存保留交换分区（swap空间）。这样，当物理内存不足的 时候，对该共享内存执行写操作将触发SIGSEGV信号。</li></ul></li></ul><p>shmget成功时返回一个正整数值，它是共享内存的标识符。shmget 失败时返回-1，并设置errno。</p><h5 id="13-6-2-shmat和shmdt系统调用"><a href="#13-6-2-shmat和shmdt系统调用" class="headerlink" title="13.6.2 shmat和shmdt系统调用"></a>13.6.2 shmat和shmdt系统调用</h5><p>共享内存被创建/获取之后，我们不能立即访问它，而是需要先将 它关联到进程的地址空间中。使用完共享内存之后，我们也需要将它 从进程地址空间中分离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">const</span> <span class="keyword">void</span>*shm_addr,<span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*shm_addr)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>shm_id参数是由shmget调用返回的共享内存标识符。 </li><li>shm_addr参数指定将共享内存关联到进程的哪块地址空间，最终的效果还受到shmflg参数的可选标志SHM_RND的影响：<ul><li>如果shm_addr为NULL，则被关联的地址由操作系统选择。这是 推荐的做法，以确保代码的可移植性.</li><li>如果shm_addr非空，并且SHM_RND标志未被设置，则共享内存 被关联到addr指定的地址处。</li></ul></li></ul><h5 id="13-6-3-shmctl系统调用"><a href="#13-6-3-shmctl系统调用" class="headerlink" title="13.6.3 shmctl系统调用"></a>13.6.3 shmctl系统调用</h5><p>shmctl系统调用控制共享内存的某些属性。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">int</span> command, struct shmid_ds* buf)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>shm_id参数是由shmget调用返回的共享内存标识符。 </p></li><li><p>command参数指定要执行的命令。</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230306224911405.png" class="" title="image-20230306224911405"></li></ul><p>shmctl成功时的返回值取决于command参数，如表13-3所示。 shmctl失败时返回-1，并设置errno。</p><h5 id="13-6-5-共享内存实例"><a href="#13-6-5-共享内存实例" class="headerlink" title="13.6.5 共享内存实例"></a>13.6.5 共享内存实例</h5><p>在9.6.2小节中，我们介绍过一个聊天室服务器程序。下面我们将 它修改为一个多进程服务器：一个子进程处理一个客户连接。同时， 我们将所有客户socket连接的读缓冲设计为一块共享内存，如代码清单 13-4所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/6.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_LIMIT 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESS_LIMIT 65536</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理一个客户连接必要的数据*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line"></span><br><span class="line">sockaddr_in address;<span class="comment">/*客户端的socket地址*/</span></span><br><span class="line"><span class="keyword">int</span> connfd;<span class="comment">/*socket文件描述符*/</span></span><br><span class="line"><span class="keyword">pid_t</span> pid;<span class="comment">/*处理这个连接的子进程的PID*/</span></span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];<span class="comment">/*和父进程通信用的管道*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *shm_name = <span class="string">&quot;/my_shm&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> sig_pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"><span class="keyword">int</span> shmfd;</span><br><span class="line"><span class="keyword">char</span> *share_mem = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户连接数组。进程用客户连接的编号来索引这个数组，即可取得相关的客户连接数据*/</span></span><br><span class="line">client_data *users = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程和客户连接的映射关系表。用进程的PID来索引这个数组，即可取得该进程所处理的客户连接的编号*/</span></span><br><span class="line"><span class="keyword">int</span> *sub_process = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当前客户数量*/</span></span><br><span class="line"><span class="keyword">int</span> user_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">bool</span> stop_child = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(sig_pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(*handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = handler;</span><br><span class="line"><span class="keyword">if</span> (restart) &#123;</span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line">&#125;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_resource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">close(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">close(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">close(listenfd);</span><br><span class="line">close(epollfd);</span><br><span class="line">shm_unlink(shm_name);</span><br><span class="line"><span class="keyword">delete</span>[]users;</span><br><span class="line"><span class="keyword">delete</span>[]sub_process;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*停止一个子进程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">child_term_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程运行的函数。参数idx指出该子进程处理的客户连接的编号，</span></span><br><span class="line"><span class="comment"> * users是保存所有客户连接数据的数组，参数share_mem指出共享内存的起始地址*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">run_child</span><span class="params">(<span class="keyword">int</span> idx, client_data *users, <span class="keyword">char</span> *share_mem)</span> </span>&#123;</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="comment">/*子进程使用I/O复用技术来同时监听两个文件描述符：</span></span><br><span class="line"><span class="comment"> * 客户连接socket、与父进程通信的管道文件描述符*/</span></span><br><span class="line"><span class="keyword">int</span> child_epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(child_epollfd != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> connfd = users[idx].connfd;</span><br><span class="line">addfd(child_epollfd, connfd);</span><br><span class="line"><span class="keyword">int</span> pipefd = users[idx].pipefd[<span class="number">1</span>];</span><br><span class="line">addfd(child_epollfd, pipefd);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程需要设置自己的信号处理函数*/</span></span><br><span class="line">addsig(SIGTERM, child_term_handler, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span> (!stop_child) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(child_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*本子进程负责的客户连接有数据到达*/</span></span><br><span class="line"><span class="keyword">if</span> ((sockfd == connfd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="built_in">memset</span>(share_mem + idx * BUFFER_SIZE, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将客户数据读取到对应的读缓存中。该读缓存是共享内存的一段，</span></span><br><span class="line"><span class="comment"> * 它开始于idx*BUFFER_SIZE处，长度为BUFFER_SIZE字节。</span></span><br><span class="line"><span class="comment"> * 因此，各个客户连接的读缓存是共享的</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">ret = recv(connfd, share_mem + idx * BUFFER_SIZE, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*成功读取客户数据后就通知主进程（通过管道）来处理*/</span></span><br><span class="line">send(pipefd, (<span class="keyword">char</span> *) &amp;idx, <span class="keyword">sizeof</span>(idx), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*主进程通知本进程（通过管道）将第client个客户的数据发送到本进程负责的客户端*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> client = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*接收主进程发送来的数据，即有客户数据到达的连接的编号*/</span></span><br><span class="line">ret = recv(sockfd, (<span class="keyword">char</span> *) &amp;client, <span class="keyword">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">stop_child = <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">send(connfd, share_mem + client * BUFFER_SIZE,</span><br><span class="line">     BUFFER_SIZE, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">close(pipefd);</span><br><span class="line">close(child_epollfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">user_count = <span class="number">0</span>;</span><br><span class="line">users = <span class="keyword">new</span> client_data[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line">sub_process = <span class="keyword">new</span> <span class="keyword">int</span>[PROCESS_LIMIT];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; PROCESS_LIMIT; ++i) &#123;</span><br><span class="line">sub_process[i] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, sig_pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">setnonblocking(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, sig_pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">addsig(SIGCHLD, sig_handler);  <span class="comment">/*子进程状态发生变化（退出或者暂停）*/</span></span><br><span class="line">addsig(SIGTERM, sig_handler);   <span class="comment">/*主进程发给子进程的中断信号*/</span></span><br><span class="line">addsig(SIGINT, sig_handler);</span><br><span class="line">addsig(SIGPIPE, SIG_IGN);       <span class="comment">/*往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">bool</span> <span class="built_in">terminate</span> = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建共享内存，作为所有客户socket连接的读缓存*/</span></span><br><span class="line">shmfd = shm_open(shm_name, O_CREAT | O_RDWR, <span class="number">0666</span>);</span><br><span class="line">assert(shmfd != <span class="number">-1</span>);</span><br><span class="line">ret = ftruncate(shmfd, USER_LIMIT * BUFFER_SIZE);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">share_mem = (<span class="keyword">char</span> *) mmap(<span class="literal">nullptr</span>, USER_LIMIT * BUFFER_SIZE, PROT_READ | PROT_WRITE,</span><br><span class="line">                          MAP_SHARED, shmfd, <span class="number">0</span>);</span><br><span class="line">assert(share_mem != MAP_FAILED);</span><br><span class="line">close(shmfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是哪个描述符发生了变化</span></span><br><span class="line"><span class="comment">/*新的客户连接到来*/</span></span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (user_count &gt;= USER_LIMIT) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*保存第user_count个客户连接的相关数据*/</span></span><br><span class="line">users[user_count].address = client_address;</span><br><span class="line">users[user_count].connfd = connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在主进程和子进程间建立管道，以传递必要的数据*/</span></span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, users[user_count].pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">close(epollfd);</span><br><span class="line">close(listenfd);</span><br><span class="line">close(users[user_count].pipefd[<span class="number">0</span>]);</span><br><span class="line">close(sig_pipefd[<span class="number">0</span>]);</span><br><span class="line">close(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">run_child(user_count, users, share_mem);</span><br><span class="line">munmap((<span class="keyword">void</span> *) share_mem, USER_LIMIT * BUFFER_SIZE);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(connfd);</span><br><span class="line">close(users[user_count].pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, users[user_count].pipefd[<span class="number">0</span>]);</span><br><span class="line">users[user_count].pid = pid;</span><br><span class="line"><span class="comment">/*记录新的客户连接在数组users中的索引值，建立进程pid和该索引值之间的映射关系*/</span></span><br><span class="line">sub_process[pid] = user_count;</span><br><span class="line">user_count++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理信号事件*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line"><span class="comment">/*子进程退出，表示有某个客户端关闭了连接*/</span></span><br><span class="line"><span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*用子进程的pid取得被关闭的客户连接的编号*/</span></span><br><span class="line"><span class="keyword">int</span> del_user = sub_process[pid];</span><br><span class="line">sub_process[pid] = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">if</span> ((del_user &lt; <span class="number">0</span>) || (del_user &gt; USER_LIMIT)) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*清除第del_user个客户连接使用的相关数据*/</span></span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, users[del_user].pipefd[<span class="number">0</span>], <span class="number">0</span>);</span><br><span class="line">close(users[del_user].pipefd[<span class="number">0</span>]);</span><br><span class="line">users[del_user] = users[--user_count];</span><br><span class="line">sub_process[users[del_user].pid] = del_user;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">terminate</span> &amp;&amp; user_count == <span class="number">0</span>) &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM:</span><br><span class="line"><span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line"><span class="comment">/*结束服务器程序*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;kill all the clild now\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (user_count == <span class="number">0</span>) &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; user_count; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> pid = users[i].pid;</span><br><span class="line">kill(pid, SIGTERM);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">terminate</span> = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*某个子进程向父进程写入了数据*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*读取管道数据，child变量记录了是哪个客户连接有数据到达*/</span></span><br><span class="line">ret = recv(sockfd, (<span class="keyword">char</span> *) &amp;child, <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read data from child accross pipe\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*向除负责处理第child个客户连接的子进程之外的其他子进程发送消息，通知它们有客户数据要写*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; user_count; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (users[j].pipefd[<span class="number">0</span>] != sockfd) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send data to child accross pipe\n&quot;</span>);</span><br><span class="line">send(users[j].pipefd[<span class="number">0</span>], (<span class="keyword">char</span> *) &amp;child,</span><br><span class="line">     <span class="keyword">sizeof</span>(child), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">del_resource();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-7-消息队列"><a href="#13-7-消息队列" class="headerlink" title="13.7 消息队列"></a>13.7 消息队列</h4><p>消息队列是在两个进程之间传递二进制块数据的一种简单有效的 方式。<strong>每个数据块都有一个特定的类型，接收方可以根据类型来有选 择地接收数据</strong>，而不一定像管道和命名管道那样必须以先进先出的方式接收数据。</p><p>Linux消息队列的API都定义在sys/msg.h头文件中，包括4个系统调 用：msgget、msgsnd、msgrcv和msgctl。</p><h5 id="13-7-1-msgget系统调用"><a href="#13-7-1-msgget系统调用" class="headerlink" title="13.7.1 msgget系统调用"></a>13.7.1 msgget系统调用</h5><p>msgget系统调用创建一个消息队列，或者获取一个已有的消息队列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>和semget系统调用一样，key参数是一个键值，用来标识一个全局 唯一的消息队列。</li><li>msgflg参数的使用和含义与semget系统调用的sem_flags参数相同。</li></ul><p>msgget成功时返回一个正整数值，它是消息队列的标识符。msgget 失败时返回-1，并设置errno。</p><h5 id="13-7-2-msgsnd系统调用"><a href="#13-7-2-msgsnd系统调用" class="headerlink" title="13.7.2 msgsnd系统调用"></a>13.7.2 msgsnd系统调用</h5><p>msgsnd系统调用把一条消息添加到消息队列中。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid, <span class="keyword">const</span> <span class="keyword">void</span>* msg_ptr, <span class="keyword">size_t</span> msg_sz,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>msqid参数是由msgget调用返回的消息队列标识符。</p></li><li><p>msg_ptr参数指向一个准备发送的消息，消息必须被定义为如下类 型： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span> </span><br><span class="line">    <span class="keyword">long</span> mtype;<span class="comment">/*消息类型*/</span> </span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>];<span class="comment">/*消息数据*/</span> </span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure><ul><li>其中，mtype成员指定消息的类型，它必须是一个正整数。</li><li>mtext是 消息数据。</li></ul></li><li><p>msg_sz参数是消息的数据部分（mtext）的长度。这个长度 可以为0，表示没有消息数据。</p></li><li><p><strong>msgflg参数控制msgsnd的行为。它通常仅支持IPC_NOWAIT标志， 即以非阻塞的方式发送消息。</strong>默认情况下，发送消息时如果消息队列 满了，则msgsnd将阻塞。若IPC_NOWAIT标志被指定，则msgsnd将立 即返回并设置errno为EAGAIN。</p></li></ul><p>msgsnd成功时返回0，失败则返回-1并设置errno。msgsnd成功时将 修改内核数据结构msqid_ds的部分字段，如下所示：</p><ul><li>将msg_qnum加1。</li><li>将msg_lspid设置为调用进程的PID。</li><li>将msg_stime设置为当前的时间。</li></ul><h5 id="13-7-3-msgrcv系统调用"><a href="#13-7-3-msgrcv系统调用" class="headerlink" title="13.7.3 msgrcv系统调用"></a>13.7.3 msgrcv系统调用</h5><p>msgrcv系统调用从消息队列中获取消息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg·h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span>*msg_ptr,<span class="keyword">size_t</span> msg_sz,<span class="keyword">long</span> <span class="keyword">int</span> msgtype,<span class="keyword">int</span> msgflg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>msqid参数是由msgget调用返回的消息队列标识符。</li><li>msg_ptr参数用于存储接收的消息，msg_sz参数指的是消息数据部 分的长度。</li><li>msgtype参数指定接收何种类型的消息。我们可以使用如下几种方 式来指定消息类型： <ul><li>msgtype等于0。读取消息队列中的第一个消息。 </li><li>msgtype大于0。读取消息队列中第一个类型为msgtype的消息 （除非指定了标志MSG_EXCEPT，见后文）。 </li><li>msgtype小于0。读取消息队列中第一个类型值比msgtype的绝对 值小的消息。</li></ul></li><li>参数msgflg控制msgrcv函数的行为。它可以是如下一些标志的按位 或： <ul><li>IPC_NOWAIT。如果消息队列中没有消息，则msgrcv调用立即返 回并设置errno为ENOMSG。</li><li>MSG_EXCEPT。如果msgtype大于0，则接收消息队列中第一个 非msgtype类型的消息。 </li><li>MSG_NOERROR。如果消息数据部分的长度超过了msg_sz，就 将它截断。</li></ul></li></ul><p>msgrcv成功时返回0，失败则返回-1并设置errno。msgrcv成功时将 修改内核数据结构msqid_ds的部分字段，如下所示： </p><ul><li>将msg_qnum减1。 </li><li>将msg_lrpid设置为调用进程的PID。 </li><li>将msg_rtime设置为当前的时间。</li></ul><h5 id="13-7-4-msgctl系统调用"><a href="#13-7-4-msgctl系统调用" class="headerlink" title="13.7.4 msgctl系统调用"></a>13.7.4 msgctl系统调用</h5><p>msgctl系统调用控制消息队列的某些属性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">int</span> command,struct msqid_ds*buf)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>msqid参数是由msgget调用返回的共享内存标识符。</p></li><li><p>command参数 指定要执行的命令。</p></li><li><p>msgctl支持的所有命令如表13-4所示</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230307112918598.png" class="" title="image-20230307112918598"></li></ul><p>msgctl成功时的返回值取决于command参数，如表13-4所示。 msgctl函数失败时返回-1并设置errno。</p><h4 id="13-8-IPC命令"><a href="#13-8-IPC命令" class="headerlink" title="13.8 IPC命令"></a>13.8 IPC命令</h4><p>上述3种System V IPC进程间通信方式都使用一个全局唯一的键值 （key）来描述一个共享资源。当程序调用semget、shmget或者msgget 时，就创建了这些共享资源的一个实例。</p><p>Linux提供了ipcs命令，以观 察当前系统上拥有哪些共享资源实例。</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230307113151814.png" class="" title="image-20230307113151814"><p>此外，我们可以使用ipcrm命令来删除遗留在系统中的共享资源。</p><h4 id="13-9-在进程间传递文件描述符"><a href="#13-9-在进程间传递文件描述符" class="headerlink" title="13.9 在进程间传递文件描述符"></a>13.9 在进程间传递文件描述符</h4><p>由于fork调用之后，父进程中打开的文件描述符在子进程中仍然 保持打开，所以文件描述符可以很方便地从父进程传递到子进程。</p><p>需要注意的是，<strong>传递一个文件描述符并不是传递一个文件描述符的值， 而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和 发送进程中被传递的文件描述符指向内核中相同的文件表项。</strong></p><p>那么如何把子进程中打开的文件描述符传递给父进程呢？或者更通俗地说，如何在两个不相干的进程之间传递文件描述符呢？</p><p>在Linux 下，我们可以利用UNIX域socket在进程间传递特殊的辅助数据，以实 现文件描述符的传递。</p><p>它在子进程 中打开一个文件描述符，然后将它传递给父进程，父进程则通过读取 该文件描述符来获得文件的内容。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CONTROL_LEN = CMSG_LEN(<span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">/*发送文件描述符，fd参数是用来传递信息的UNIX域socket，fd_to_send参数是待发送的文件描述符*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_fd</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> fd_to_send)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line">iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">msg.msg_name = <span class="literal">NULL</span>;</span><br><span class="line">msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">msg.msg_iov = iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">cmsghdr cm&#123;&#125;;</span><br><span class="line">cm.cmsg_len = CONTROL_LEN;</span><br><span class="line">cm.cmsg_level = SOL_SOCKET;</span><br><span class="line">cm.cmsg_type = SCM_RIGHTS;</span><br><span class="line">*(<span class="keyword">int</span> *) CMSG_DATA(&amp;cm) = fd_to_send;</span><br><span class="line">msg.msg_control = &amp;cm;<span class="comment">/*设置辅助数据*/</span></span><br><span class="line">msg.msg_controllen = CONTROL_LEN;</span><br><span class="line">sendmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*接收目标文件描述符*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_fd</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line">iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">msg.msg_name = <span class="literal">nullptr</span>;</span><br><span class="line">msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">msg.msg_iov = iov;</span><br><span class="line">msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line">cmsghdr cm&#123;&#125;;</span><br><span class="line">msg.msg_control = &amp;cm;</span><br><span class="line">msg.msg_controllen = CONTROL_LEN;</span><br><span class="line">recvmsg(fd, &amp;msg, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fd_to_read = *(<span class="keyword">int</span> *) CMSG_DATA(&amp;cm);</span><br><span class="line"><span class="keyword">return</span> fd_to_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> fd_to_pass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建父、子进程间的管道，文件描述符pipefd[0]和pipefd[1]都是UNIX域socket*/</span></span><br><span class="line"><span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_DGRAM, <span class="number">0</span>, pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">assert(pid &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line">fd_to_pass = open(<span class="string">&quot;test.txt&quot;</span>, O_RDWR, <span class="number">0666</span>);</span><br><span class="line"><span class="comment">/* 子进程通过管道将文件描述符发送到父进程。如果文件test.txt打开失败，</span></span><br><span class="line"><span class="comment">        * 则子进程将标准输入文件描述符发送到父进程*/</span></span><br><span class="line">send_fd(pipefd[<span class="number">1</span>], (fd_to_pass &gt; <span class="number">0</span>) ? fd_to_pass : <span class="number">0</span>);</span><br><span class="line">close(fd_to_pass);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line">fd_to_pass = recv_fd(pipefd[<span class="number">0</span>]);<span class="comment">/*父进程从管道接收目标文件描述符*/</span></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">1024</span>);</span><br><span class="line">read(fd_to_pass, buf, <span class="number">1024</span>);<span class="comment">/*读目标文件描述符，以验证其有效性*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I got fd%d and data%s\n&quot;</span>, fd_to_pass, buf);</span><br><span class="line">close(fd_to_pass);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第14章-多线程编程"><a href="#第14章-多线程编程" class="headerlink" title="第14章 多线程编程"></a>第14章 多线程编程</h3><p>Native POSIX Thread Library， 本章要讨论的线程相关的内容都属于POSIX线程（简称pthread） 标准，而不局限于NPTL实现，具体包括：</p><ul><li>创建线程和结束线程。</li><li>读取和设置线程属性。</li><li>POSIX线程同步方式：POSIX信号量、互斥锁和条件变量。</li></ul><h4 id="14-1-Linux-线程概述"><a href="#14-1-Linux-线程概述" class="headerlink" title="14.1 Linux 线程概述"></a>14.1 Linux 线程概述</h4><h5 id="14-1-1-线程模型"><a href="#14-1-1-线程模型" class="headerlink" title="14.1.1 线程模型"></a>14.1.1 线程模型</h5><p>线程是程序中完成一个独立任务的完整执行序列，即一个可调度 的实体。</p><p>根据运行环境和调度者的身份，线程可分为内核线程和用户线程。<strong>内核线程，在有的系统上也称为LWP（Light Weight Process， 轻量级进程），运行在内核空间，由内核来调度</strong>；<strong>用户线程运行在用 户空间，由线程库来调度。</strong></p><p>当进程的一个内核线程获得CPU的使用权 时，它就加载并运行一个用户线程。可见，内核线程相当于用户线程 运行的“容器”。一个进程可以拥有M个内核线程和N个用户线程，其中 M≤N。并且在一个系统的所有进程中，M和N的比值都是固定的。</p><p><strong>按照M:N的取值，线程的实现方式可分为三种模式：完全在用户空间实现、完全由内核调度和双层调度（two level scheduler）。</strong></p><ol><li><strong>完全在用户空间实现的线程</strong>无须内核的支持，内核甚至根本不知 道这些线程的存在。线程库负责管理所有执行线程，比如线程的优先 级、时间片等。线程库利用longjmp来切换线程的执行，使它们看起来 像是“并发”执行的。<strong>但实际上内核仍然是把整个进程作为最小单位来调度的。</strong> 换句话说，一个进程的所有执行线程共享该进程的时间片， 它们对外表现出相同的优先级。因此，对这种实现方式而言，N=1， 即M个用户空间线程对应1个内核线程，而该内核线程实际上就是进程 本身。<ul><li><strong>优点：</strong> 创建和调度线程都无须 内核的干预，因此速度相当快。并且由于它不占用额外的内核资源， 所以即使一个进程创建了很多线程，也不会对系统性能造成明显的影 响。</li><li><strong>其缺点是</strong>：对于多处理器系统，一个进程的多个线程无法运行在不同的CPU上，因为内核是按照其最小调度单位来分配CPU的。此外，线程的优先级只对同一个进程中的线程有效，比较不同进程中的 线程的优先级没有意义。早期的伯克利UNIX线程就是采用这种方式实现的。</li></ul></li><li><strong>完全由内核调度的模式</strong>将创建、调度线程的任务都交给了内核， 运行在用户空间的线程库无须执行管理任务，这与完全在用户空间实 现的线程恰恰相反。<ul><li><strong>二者的优缺点也正好互换</strong>。较早的Linux内核对内 核线程的控制能力有限，线程库通常还要提供额外的控制能力，尤其 是线程同步机制，不过现代Linux内核已经大大增强了对线程的支持。 完全由内核调度的这种线程实现方式满足M:N=1:1，即1个用户空间线 程被映射为1个内核线程。</li></ul></li><li>双层调度模式是前两种实现模式的混合体：<strong>内核调度M个内核线 程，线程库调度N个用户线程。</strong>这种线程实现方式结合了前两种方式 的优点：不但不会消耗过多的内核资源，而且线程切换速度也较快， 同时它可以充分利用多处理器的优势。</li></ol><h5 id="14-1-2-Linux-线程库"><a href="#14-1-2-Linux-线程库" class="headerlink" title="14.1.2 Linux 线程库"></a>14.1.2 Linux 线程库</h5><p>Linux内核从 2.6版本开始，提供了真正的内核线程。新的NPTL线程库也应运而 生。相比LinuxThreads，NPTL的主要优势在于：</p><ul><li>内核线程不再是一个进程，因此避免了很多用进程模拟内核线 程导致的语义问题。</li><li>摒弃了管理线程，终止线程、回收线程堆栈等工作都可以由内核来完成。</li><li>由于不存在管理线程，所以一个进程的线程可以运行在不同的 CPU上，从而充分利用了多处理器系统的优势。</li><li>线程的同步由内核来完成。隶属于不同进程的线程之间也能共 享互斥锁，因此可实现跨进程的线程同步。</li></ul><h4 id="14-2-创建线程和结束线程"><a href="#14-2-创建线程和结束线程" class="headerlink" title="14.2 创建线程和结束线程"></a>14.2 创建线程和结束线程</h4><p>下面我们讨论创建和结束线程的基础API。Linux系统上，它们都 定义在pthread.h头文件中。</p><h5 id="14-2-1-pthread-create"><a href="#14-2-1-pthread-create" class="headerlink" title="14.2.1 pthread_create"></a>14.2.1 pthread_create</h5><p>创建一个线程的函数是pthread_create。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(<span class="keyword">pthread_t</span>* thread, <span class="keyword">const</span> <span class="keyword">pthread_attr_t</span>*attr,<span class="keyword">void</span>*(*start_routine)(<span class="keyword">void</span>*), <span class="keyword">void</span>*arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>thread参数是新线程的标识符，后续pthread_*函数通过它来引用新 线程。其类型pthread_t的定义如下：  可见，pthread_t是一个整型类型。实际上，Linux上几乎所有的资 源标识符都是一个整型数，比如socket、各种System V IPC标识符等。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/pthreadtypes.h＞</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">pthread_t</span>;</span><br></pre></td></tr></table></figure></li><li><p>attr参数用于设置新线程的属性。给它传递NULL表示使用默认线 程属性。</p></li><li><p>start_routine 和arg参数分别指定新线程将运行的函数及其参数。</p></li></ul><p>pthread_create成功时返回0，失败时返回错误码。</p><h5 id="14-2-3-pthread-exit"><a href="#14-2-3-pthread-exit" class="headerlink" title="14.2.3 pthread_exit"></a>14.2.3 pthread_exit</h5><p>线程一旦被创建好，内核就可以调度内核线程来执行start_routine 函数指针所指向的函数了。线程函数在结束时最好调用如下函数，以 确保安全、干净地退出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pthread_exit</span><span class="params">(<span class="keyword">void</span>* retval)</span></span>;</span><br></pre></td></tr></table></figure><p>pthread_exit函数通过retval参数向线程的回收者传递其退出信息。 它执行完之后不会返回到调用者，而且永远不会失败。</p><h5 id="14-2-4-pthread-join"><a href="#14-2-4-pthread-join" class="headerlink" title="14.2.4 pthread_join"></a>14.2.4 pthread_join</h5><p>一个进程中的所有线程都可以调用pthread_join函数来回收其他线 程（前提是目标线程是可回收的，见后文），即等待其他线程结束， 这类似于回收进程的wait和waitpid系统调用。</p><p>pthread_join的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">void</span>** retval)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>hread参数是目标线程的标识符，</li><li>retval参数则是目标线程返回的退 出信息。该函数会一直阻塞，直到被回收的线程结束为止。</li></ul><p>该函数成 功时返回0，失败则返回错误码。</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230307172622769.png" class="" title="image-20230307172622769"><h5 id="14-2-5-pthread-cancel"><a href="#14-2-5-pthread-cancel" class="headerlink" title="14.2.5 pthread_cancel"></a>14.2.5 pthread_cancel</h5><p>有时候我们希望异常终止一个线程，即取消线程，它是通过如下 函数实现的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cancel</span><span class="params">(<span class="keyword">pthread_t</span> thread)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>thread参数是目标线程的标识符。</li></ul><p>该函数成功时返回0，失败则返 回错误码。</p><h4 id="14-3-线程属性"><a href="#14-3-线程属性" class="headerlink" title="14.3 线程属性"></a>14.3 线程属性</h4><p>pthread_attr_t结构体定义了一套完整的线程属性，如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/pthreadtypes.h＞</span></span><br><span class="line">#define__SIZEOF_PTHREAD_ATTR_T <span class="number">36</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span> __size[__SIZEOF_PTHREAD_ATTR_T];</span><br><span class="line"><span class="keyword">long</span> int__align;</span><br><span class="line">&#125;<span class="keyword">pthread_attr_t</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="14-4-POSIX信号量"><a href="#14-4-POSIX信号量" class="headerlink" title="14.4 POSIX信号量"></a>14.4 POSIX信号量</h4><p>和多进程程序一样，多线程程序也必须考虑同步问题。 pthread_join可以看作一种简单的线程同步方式，不过很显然，它无法 高效地实现复杂的同步需求，比如控制对共享资源的独占式访问，又抑或是在某个条件满足之后唤醒一个线程。</p><p>接下来我们讨论3种专门用 于线程同步的机制：POSIX信号量、互斥量和条件变量。</p><blockquote><p>在Linux上，信号量API有两组。一组是第13章讨论过的System V IPC信号量，另外一组是我们现在要讨论的POSIX信号量。这两组接口 很相似，但不保证能互换。由于这两种信号量的语义完全相同，因此 我们不再赘述信号量的原理。</p></blockquote><p><code>POSIX信号量函数的名字都以sem_开头，并不像大多数线程函数 那样以pthread_开头。</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜semaphore.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_init</span><span class="params">(<span class="keyword">sem_t</span>*sem,<span class="keyword">int</span> pshared,<span class="keyword">unsigned</span> <span class="keyword">int</span> value)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_destroy</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_wait</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_trywait</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sem_post</span><span class="params">(<span class="keyword">sem_t</span>*sem)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>这些函数的第一个参数sem指向被操作的信号量。</li><li>sem_init函数用于初始化一个未命名的信号量,  pshared参数指定信号量的类 型。如果其值为0，就表示这个信号量是当前进程的局部信号量，否则 该信号量就可以在多个进程之间共享。value参数指定信号量的初始 值。此外，初始化一个已经被初始化的信号量将导致不可预期的结 果。</li><li>sem_destroy函数用于销毁信号量，以释放其占用的内核资源。如 果销毁一个正被其他线程等待的信号量，则将导致不可预期的结果。</li><li>sem_wait函数以原子操作的方式将信号量的值减1。如果信号量的 值为0，则sem_wait将被阻塞，直到这个信号量具有非0值。</li><li>sem_trywait与sem_wait函数相似，不过它始终立即返回，而不论 被操作的信号量是否具有非0值，相当于sem_wait的非阻塞版本。当信 号量的值非0时，sem_trywait对信号量执行减1操作。当信号量的值为0 时，它将返回-1并设置errno为EAGAIN。</li><li>sem_post函数以原子操作的方式将信号量的值加1。当信号量的值 大于0时，其他正在调用sem_wait等待信号量的线程将被唤醒。</li></ul><p>上面这些函数成功时返回0，失败则返回-1并设置errno。</p><h4 id="14-5-互斥锁"><a href="#14-5-互斥锁" class="headerlink" title="14.5 互斥锁"></a>14.5 互斥锁</h4><p>互斥锁（也称互斥量）可以用于保护关键代码段，以确保其独占 式的访问，这有点像一个二进制信号量（见13.5.1小节）。</p><h5 id="14-5-1-互斥锁基础API"><a href="#14-5-1-互斥锁基础API" class="headerlink" title="14.5.1 互斥锁基础API"></a>14.5.1 互斥锁基础API</h5><p>POSIX互斥锁的相关函数主要有如下5个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_init</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex, <span class="keyword">const</span> <span class="keyword">pthread_mutexattr_t</span>*mutexattr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_destroy</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>这些函数的第一个参数mutex指向要操作的目标互斥锁，互斥锁的 类型是pthread_mutex_t结构体。</p></li><li><p>pthread_mutex_init函数用于初始化互斥锁。mutexattr参数指定互 斥锁的属性。如果将它设置为NULL，则表示使用默认属性。除了这个函数外，我们<strong>还可以使用如 下方式来初始化一个互斥锁</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_mutex_t</span> mutex=PTHREAD_MUTEX_INITIALIZER; </span><br></pre></td></tr></table></figure><p>宏PTHREAD_MUTEX_INITIALIZER实际上只是把互斥锁的各个 字段都初始化为0。</p></li><li><p>pthread_mutex_destroy函数用于销毁互斥锁，以释放其占用的内核 资源。销毁一个已经加锁的互斥锁将导致不可预期的后果。</p></li><li><p>pthread_mutex_lock函数以原子操作的方式给一个互斥锁加锁。如 果目标互斥锁已经被锁上，则pthread_mutex_lock调用将阻塞，直到该 互斥锁的占有者将其解锁。</p></li><li><p>pthread_mutex_trylock与pthread_mutex_lock函数类似，不过它始 终立即返回，而不论被操作的互斥锁是否已经被加锁，相当于 pthread_mutex_lock的非阻塞版本。当目标互斥锁未被加锁时， pthread_mutex_trylock对互斥锁执行加锁操作。当互斥锁已经被加锁 时，pthread_mutex_trylock将返回错误码EBUSY。</p></li><li><p>pthread_mutex_unlock函数以原子操作的方式给一个互斥锁解锁。 如果此时有其他线程正在等待这个互斥锁，则这些线程中的某一个将 获得它。</p></li></ul><p>上面这些函数成功时返回0，失败则返回错误码。</p><h5 id="14-5-2-互斥锁属性"><a href="#14-5-2-互斥锁属性" class="headerlink" title="14.5.2 互斥锁属性"></a>14.5.2 互斥锁属性</h5><p>pthread_mutexattr_t结构体定义了一套完整的互斥锁属性。线程库 提供了一系列函数来操作pthread_mutexattr_t类型的变量，以方便我们 获取和设置互斥锁属性。</p><p>本书只讨论互斥锁的两种常用属性：pshared和type。</p><ol><li>互斥锁属性 pshared指定是否允许跨进程共享互斥锁，其可选值有两个：<ul><li>PTHREAD_PROCESS_SHARED。互斥锁可以被跨进程共享。</li><li>PTHREAD_PROCESS_PRIVATE。互斥锁只能被和锁的初始化 线程隶属于同一个进程的线程共享。</li></ul></li><li>互斥锁属性type指定互斥锁的类型。Linux支持如下4种类型的互 斥锁：<ul><li>PTHREAD_MUTEX_NORMAL，普通锁。这是互斥锁默认的类 型。当一个线程对一个普通锁加锁以后，其余请求该锁的线程将形成 一个等待队列，并在该锁解锁后按优先级获得它。这种锁类型保证了 资源分配的公平性。但这种锁也很容易引发问题：一个线程如果对一 个已经加锁的普通锁再次加锁，将引发死锁；对一个已经被其他线程 加锁的普通锁解锁，或者对一个已经解锁的普通锁再次解锁，将导致 不可预期的后果。</li><li>PTHREAD_MUTEX_ERRORCHECK，检错锁。一个线程如果 对一个已经加锁的检错锁再次加锁，则加锁操作返回EDEADLK。对 一个已经被其他线程加锁的检错锁解锁，或者对一个已经解锁的检错 锁再次解锁，则解锁操作返回EPERM</li><li>PTHREAD_MUTEX_RECURSIVE，嵌套锁。这种锁允许一个 线程在释放锁之前多次对它加锁而不发生死锁。不过其他线程如果要 获得这个锁，则当前锁的拥有者必须执行相应次数的解锁操作。对一 个已经被其他线程加锁的嵌套锁解锁，或者对一个已经解锁的嵌套锁 再次解锁，则解锁操作返回EPERM。</li><li>PTHREAD_MUTEX_DEFAULT，默认锁。一个线程如果对一个 已经加锁的默认锁再次加锁，或者对一个已经被其他线程加锁的默认 锁解锁，或者对一个已经解锁的默认锁再次解锁，将导致不可预期的 后果。这种锁在实现的时候可能被映射为上面三种锁之一。</li></ul></li></ol><h5 id="14-5-3-死锁举例"><a href="#14-5-3-死锁举例" class="headerlink" title="14.5.3 死锁举例"></a>14.5.3 死锁举例</h5><p>前文提到，在一个 线程中对一个已经加锁的普通锁再次加锁，将导致死锁。这种情况可 能出现在设计得不够仔细的递归函数中。另外，如果两个线程按照不 同的顺序来申请两个互斥锁，也容易产生死锁，如代码清单14-1所 示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_a;</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex_b;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">another</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in child thread,got mutex b,waiting for mutex a\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">++b;</span><br><span class="line">pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line">b += a++;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">pthread_exit(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line">pthread_mutex_init(&amp;mutex_a, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_mutex_init(&amp;mutex_b, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_create(&amp;id, <span class="literal">nullptr</span>, another, <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">pthread_mutex_lock(&amp;mutex_a);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in parent thread,got mutex a,waiting for mutex b\n&quot;</span>);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">++a;</span><br><span class="line">pthread_mutex_lock(&amp;mutex_b);</span><br><span class="line">a += b++;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_b);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex_a);</span><br><span class="line">pthread_join(id, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex_a);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex_b);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>主线程试图先占有互斥锁mutex_a，然后操作被 该锁保护的变量a，但操作完毕之后，主线程并没有立即释放互斥锁 mutex_a，而是又申请互斥锁mutex_b，并在两个互斥锁的保护下，操 作变量a和b，最后才一起释放这两个互斥锁；与此同时，子线程则按 照相反的顺序来申请互斥锁mutex_a和mutex_b，并在两个锁的保护下 操作变量a和b。</p><h4 id="14-6-条件变量"><a href="#14-6-条件变量" class="headerlink" title="14.6 条件变量"></a>14.6 条件变量</h4><p>如果说互斥锁是用于同步线程对共享数据的访问的话，那么条件变量则是用于在线程之间同步共享数据的值。条件变量提供了一种线 程间的通知机制：当某个共享数据达到某个值的时候，唤醒等待这个 共享数据的线程。</p><p>条件变量的相关函数主要有如下5个：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_init</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond, <span class="keyword">const</span> <span class="keyword">pthread_condattr_t</span>*cond_attr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_destroy</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_broadcast</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_signal</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_cond_wait</span><span class="params">(<span class="keyword">pthread_cond_t</span>*cond,<span class="keyword">pthread_mutex_t</span>*mutex)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>这些函数的第一个参数cond指向要操作的目标条件变量，条件变 量的类型是pthread_cond_t结构体。</p></li><li><p>pthread_cond_init函数用于初始化条件变量。cond_attr参数指定条 件变量的属性。如果将它设置为NULL，则表示使用默认属性。除了pthread_cond_init函数外，我们还可以使用如下方式来初始化 一个条件变量： 宏PTHREAD_COND_INITIALIZER实际上只是把条件变量的各个 字段都初始化为0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_cond_t</span> cond=PTHREAD_COND_INITIALIZER;</span><br></pre></td></tr></table></figure></li><li><p>pthread_cond_destroy函数用于销毁条件变量，以释放其占用的内 核资源。销毁一个正在被等待的条件变量将失败并返回EBUSY。</p></li><li><p>pthread_cond_broadcast函数以广播的方式唤醒所有等待目标条件 变量的线程。</p></li><li><p>pthread_cond_signal函数用于唤醒一个等待目标条件变量 的线程。至于哪个线程将被唤醒，则取决于线程的优先级和调度策 略。有时候我们可能想唤醒一个指定的线程，但pthread没有对该需求 提供解决方法。</p><blockquote><p>不过我们可以间接地实现该需求：定义一个能够唯一 表示目标线程的全局变量，在唤醒等待条件变量的线程前先设置该变 量为目标线程，然后采用广播方式唤醒所有等待条件变量的线程，这 些线程被唤醒后都检查该变量以判断被唤醒的是否是自己，如果是就 开始执行后续代码，如果不是则返回继续等待。</p></blockquote></li><li><p>pthread_cond_wait函数用于等待目标条件变量。mutex参数是用于 保护条件变量的互斥锁，以确保pthread_cond_wait操作的原子性。在 调用pthread_cond_wait前，必须确保互斥锁mutex已经加锁，否则将导 致不可预期的结果。pthread_cond_wait函数执行时，首先把调用线程 放入条件变量的等待队列中，然后将互斥锁mutex解锁。</p></li></ul><p>上面这些函数成功时返回0，失败则返回错误码。</p><h4 id="14-7-线程同步机制"><a href="#14-7-线程同步机制" class="headerlink" title="14.7 线程同步机制"></a>14.7 线程同步机制</h4><p>为了充分复用代码，同时由于后文的需要，我们将前面讨论的3种 线程同步机制分别封装成3个类，实现在locker.h文件中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LOCKER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOCKER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装信号量的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sem</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*创建并初始化信号量*/</span></span><br><span class="line">sem() &#123;</span><br><span class="line"><span class="keyword">if</span> (sem_init(&amp;m_sem, <span class="number">0</span>, <span class="number">0</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*构造函数没有返回值，可以通过抛出异常来报告错误*/</span></span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁信号量*/</span></span><br><span class="line">~sem() &#123;</span><br><span class="line">sem_destroy(&amp;m_sem);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*等待信号量*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sem_wait(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*增加信号量*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">post</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> sem_post(&amp;m_sem) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">sem_t</span> m_sem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装互斥锁的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">locker</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*创建并初始化互斥锁*/</span></span><br><span class="line">locker() &#123;</span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁互斥锁*/</span></span><br><span class="line">~locker() &#123;</span><br><span class="line">pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获取互斥锁*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pthread_mutex_lock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*释放互斥锁*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pthread_mutex_unlock(&amp;m_mutex) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*封装条件变量的类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cond</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*创建并初始化条件变量*/</span></span><br><span class="line">cond() &#123;</span><br><span class="line"><span class="keyword">if</span> (pthread_mutex_init(&amp;m_mutex, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (pthread_cond_init(&amp;m_cond, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*构造函数中一旦出现问题，就应该立即释放已经成功分配了的资源*/</span></span><br><span class="line">pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁条件变量*/</span></span><br><span class="line">~cond() &#123;</span><br><span class="line">pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">pthread_cond_destroy(&amp;m_cond);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*等待条件变量*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line">ret = pthread_cond_wait(&amp;m_cond, &amp;m_mutex);</span><br><span class="line">pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line"><span class="keyword">return</span> ret == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*唤醒等待条件变量的线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> pthread_cond_signal(&amp;m_cond) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">pthread_mutex_t</span> m_mutex;</span><br><span class="line"><span class="keyword">pthread_cond_t</span> m_cond;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h4 id="14-8-多线程环境"><a href="#14-8-多线程环境" class="headerlink" title="14.8 多线程环境"></a>14.8 多线程环境</h4><h5 id="14-8-1-可重入函数"><a href="#14-8-1-可重入函数" class="headerlink" title="14.8.1 可重入函数"></a>14.8.1 可重入函数</h5><p>如果一个函数能被多个线程同时调用且不发生竞态条件，则我们 称它是线程安全的（thread safe），或者说它是可重入函数。</p><p>关于 Linux上不可重入的库函数的完整列表，请读者参考相关书籍，这里不 再赘述。这些库函数之所以不可重入，主要是因为其内部使用了静态变量。</p><p>不过Linux对很多不可重入的库函数提供了对应的可重入版本， 这些可重入版本的函数名是在原函数名尾部加上_r。比如，函数 localtime对应的可重入函数是localtime_r。在多线程程序中调用库函 数，一定要使用其可重入版本，否则可能导致预想不到的结果。</p><h5 id="14-8-2-线程和进程"><a href="#14-8-2-线程和进程" class="headerlink" title="14.8.2 线程和进程"></a>14.8.2 线程和进程</h5><p>思考这样一个问题：<strong>如果一个多线程程序的某个线程调用了fork 函数，那么新创建的子进程是否将自动创建和父进程相同数量的线程呢？ **答案是“否”，正如我们期望的那样。</strong>子进程只拥有一个执行线程，它是调用fork的那个线程的完整复制。并且子进程将自动继承父 进程中互斥锁（条件变量与之类似）的状态。也就是说，父进程中已 经被加锁的互斥锁在子进程中也是被锁住的。**</p><p>这就引起了一个问题： 子进程可能不清楚从父进程继承而来的互斥锁的具体状态（是加锁状 态还是解锁状态）。这个互斥锁可能被加锁了，但并不是由调用fork 函数的那个线程锁住的，而是由其他线程锁住的。如果是这种情况， 则子进程若再次对该互斥锁执行加锁操作就会导致死锁，如代码清单</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子线程运行的函数。它首先获得互斥锁mutex，然后暂停5 s，再释放该互斥锁*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">another</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;in child thread,lock the mutex\n&quot;</span>);</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">pthread_mutex_init(&amp;mutex, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">pthread_t</span> id;</span><br><span class="line">pthread_create(&amp;id, <span class="literal">nullptr</span>, another, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="comment">/*父进程中的主线程暂停1 s，以确保在执行fork操作之前，子线程已经开始运行并获得了互斥变量mutex*/</span></span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">pthread_join(id, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I am in the child,want to get the lock\n&quot;</span>);</span><br><span class="line"><span class="comment">/* 子进程从父进程继承了互斥锁mutex的状态，该互斥锁处于锁住的状态，</span></span><br><span class="line"><span class="comment"> * 这是由父进程中的子线程执行pthread_mutex_lock引起的，</span></span><br><span class="line"><span class="comment"> * 因此，下面这句加锁操作会一直阻塞，尽管从逻辑上来说它是不应该阻塞的*/</span></span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;I can not run to here,oop...\n&quot;</span>);</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// wait 函数将阻塞进程, 直到该进程的某个子进程结束运行为止</span></span><br><span class="line">wait(<span class="literal">nullptr</span>);</span><br><span class="line">&#125;</span><br><span class="line">pthread_join(id, <span class="literal">nullptr</span>);</span><br><span class="line">pthread_mutex_destroy(&amp;mutex);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>pthread提供了一个专门的函数pthread_atfork，以确保fork 调用后父进程和子进程都拥有一个清楚的锁状态。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_atfork</span><span class="params">(<span class="keyword">void</span>(*prepare)(<span class="keyword">void</span>), <span class="keyword">void</span>(*parent)(<span class="keyword">void</span>), <span class="keyword">void</span>(*child)(<span class="keyword">void</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>该函数将建立3个fork句柄来帮助我们清理互斥锁的状态。</p><ul><li>prepare 句柄将在fork调用创建出子进程之前被执行。它可以用来锁住所有父进程中的互斥锁。</li><li>parent句柄则是fork调用创建出子进程之后，而fork 返回之前，在父进程中被执行。它的作用是释放所有在prepare句柄中 被锁住的互斥锁。</li><li>child句柄是fork返回之前，在子进程中被执行。和 parent句柄一样，child句柄也是用于释放所有在prepare句柄中被锁住的 互斥锁。</li></ul><p>该函数成功时返回0，失败则返回错误码。</p><p>如果要让代码清单14-3正常工作，就应该在其中的fork调用 前加入代码清单14-4所示的代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pthread_mutex_lock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">infork</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pthread_mutex_unlock(&amp;mutex);</span><br><span class="line">&#125;</span><br><span class="line">pthread_atfork(prepare,infork,infork);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="14-8-3-线程和信号"><a href="#14-8-3-线程和信号" class="headerlink" title="14.8.3 线程和信号"></a>14.8.3 线程和信号</h5><p>每个线程都可以独立地设置信号掩码。我们在10.3.2小节讨论过设 置进程信号掩码的函数sigprocmask，但在多线程环境下我们应该使用 如下所示的pthread版本的sigprocmask函数来设置线程信号掩码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜pthread.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_sigmask</span><span class="params">(<span class="keyword">int</span> how, <span class="keyword">const</span> <span class="keyword">sigset_t</span>* newmask, <span class="keyword">sigset_t</span>* oldmask)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>_set</code>参数指定新的信号掩码，</p></li><li><p>_oset参数则输出原来的信号掩码（如 果不为NULL的话）。</p></li><li><p>如果_set参数不为NULL，则_how参数指定设置 进程信号掩码的方式，其可选值如表10-5所示。</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230304143250709.png" class="" title="image-20230304143250709"></li></ul><p>sigprocmask成功时返回0，失败则返回-1并设置errno。</p><p>由于进程中的所有线程共享该进程的信号，所以线程库将根据线程掩码决定把信号发送给哪个具体的线程。这两点都说明，我们应该定义一个专门的线程来处理所有的 信号。这可以通过如下两个步骤来实现：</p><ol><li><p>在主线程创建出其他子线程之前就调用pthread_sigmask来设置好信号掩码，所有新创建的子线程都将自动继承这个信号掩码。这样 做之后，实际上所有线程都不会响应被屏蔽的信号了。</p></li><li><p>在某个线程中调用如下函数来等待信号并处理之：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigwait</span><span class="params">(<span class="keyword">const</span> <span class="keyword">sigset_t</span>* <span class="built_in">set</span>, <span class="keyword">int</span>* sig)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>set参数指定需要等待的信号的集合。我们可以简单地将其指定为 在第1步中创建的信号掩码，表示在该线程中等待所有被屏蔽的信号。</li><li>参数sig指向的整数用于存储该函数返回的信号值。</li></ul></li></ol><p>sigwait成功时返回 0，失败则返回错误码。一旦sigwait正确返回，我们就可以对接收到的 信号做处理了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/7.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> handle_error_en(en, msg)\</span></span><br><span class="line"><span class="keyword">do</span>&#123;errno=en;perror(msg);<span class="built_in">exit</span>(EXIT_FAILURE);&#125;<span class="keyword">while</span>(<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">sig_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> *<span class="built_in">set</span> = (<span class="keyword">sigset_t</span> *) arg;</span><br><span class="line"><span class="keyword">int</span> s, sig;</span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line"><span class="comment">/*第二个步骤，调用sigwait等待信号*/</span></span><br><span class="line">s = sigwait(<span class="built_in">set</span>, &amp;sig);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">handle_error_en(s, <span class="string">&quot;sigwait&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Signal handling thread got signal%d\n&quot;</span>, sig);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line"><span class="keyword">sigset_t</span> <span class="built_in">set</span>;</span><br><span class="line"><span class="keyword">int</span> s;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*第一个步骤，在主线程中设置信号掩码*/</span></span><br><span class="line">sigemptyset(&amp;<span class="built_in">set</span>);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGQUIT);</span><br><span class="line">sigaddset(&amp;<span class="built_in">set</span>, SIGUSR1);</span><br><span class="line"></span><br><span class="line">s = pthread_sigmask(SIG_BLOCK, &amp;<span class="built_in">set</span>, <span class="literal">nullptr</span>);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">handle_error_en(s, <span class="string">&quot;pthread_sigmask&quot;</span>);</span><br><span class="line"></span><br><span class="line">s = pthread_create(&amp;thread, <span class="literal">nullptr</span>, &amp;sig_thread, (<span class="keyword">void</span> *) &amp;<span class="built_in">set</span>);</span><br><span class="line"><span class="keyword">if</span> (s != <span class="number">0</span>)</span><br><span class="line">handle_error_en(s, <span class="string">&quot;pthread_create&quot;</span>);</span><br><span class="line">pause();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，pthread还提供了下面的方法，使得我们可以明确地将一个 信号发送给指定的线程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_kill</span><span class="params">(<span class="keyword">pthread_t</span> thread,<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><p>其中，thread参数指定目标线程，sig参数指定待发送的信号。</p><h3 id="第15章-进程池和线程池"><a href="#第15章-进程池和线程池" class="headerlink" title="第15章 进程池和线程池"></a>第15章 进程池和线程池</h3><p>在前面的章节中，我们是通过动态创建子进程（或子线程）来实 现并发服务器的。这样做有如下缺点：</p><ul><li>动态创建进程（或线程）是比较耗费时间的，这将导致较慢的客户响应。</li><li>动态创建的子进程（或子线程）通常只用来为一个客户服务 （除非我们做特殊的处理），这将导致系统上产生大量的细微进程 （或线程）。进程（或线程）间的切换将消耗大量CPU时间。</li><li>动态创建的子进程是当前进程的完整映像。当前进程必须谨慎地管理其分配的文件描述符和堆内存等系统资源，否则子进程可能复 制这些资源，从而使系统的可用资源急剧下降，进而影响服务器的性 能。</li></ul><h4 id="15-1-线程池和进程池概述"><a href="#15-1-线程池和进程池概述" class="headerlink" title="15.1 线程池和进程池概述"></a>15.1 线程池和进程池概述</h4><p>进程池和线程池相似，所以这里我们只以进程池为例进行介绍。 如没有特殊声明，下面对进程池的讨论完全适用于线程池。</p><p>进程池是由服务器预先创建的一组子进程，这些子进程的数目在3 ～10个之间（当然，这只是典型情况）。比如13.5.5小节所描述的， httpd守护进程就是使用包含7个子进程的进程池来实现并发的。<strong>线程池 中的线程数量应该和CPU数量差不多。</strong></p><p>进程池中的所有子进程都运行着相同的代码，并具有相同的属 性，比如优先级、PGID等。因为进程池在服务器启动之初就创建好 了，所以<strong>每个子进程都相对“干净”，即它们没有打开不必要的文件描 述符（从父进程继承而来），也不会错误地使用大块的堆内存（从父 进程复制得到）。</strong></p><p>当有新的任务到来时，主进程将通过某种方式选择进程池中的某 一个子进程来为之服务。相比于动态创建子进程，选择一个已经存在 的子进程的代价显然要小得多。至于主进程选择哪个子进程来为新任 务服务，则有两种方式：</p><ul><li>主进程使用某种算法来主动选择子进程。最简单、最常用的算 法是随机算法和Round Robin（轮流选取）算法，但更优秀、更智能的 算法将使任务在各个工作进程中更均匀地分配，从而减轻服务器的整 体压力。</li><li>主进程和所有子进程通过一个共享的工作队列来同步，子进程 都睡眠在该工作队列上。当有新的任务到来时，主进程将任务添加到 工作队列中。这将唤醒正在等待任务的子进程，不过只有一个子进程 将获得新任务的“接管权”，它可以从工作队列中取出任务并执行之， 而其他子进程将继续睡眠在工作队列上。</li></ul><p><strong>当选择好子进程后，主进程还需要使用某种通知机制来告诉目标子进程有新任务需要处理，并传递必要的数据。</strong>最简单的方法是，在 父进程和子进程之间预先建立好一条管道，然后通过该管道来实现所有的进程间通信（当然，要预先定义好一套协议来规范管道的使 用）。在父线程和子线程之间传递数据就要简单得多，因为我们可以 把这些数据定义为全局的，那么它们本身就是被所有线程共享的。</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230308112500214.png" class="" title="image-20230308112500214"><h4 id="15-2-处理多客户"><a href="#15-2-处理多客户" class="headerlink" title="15.2 处理多客户"></a>15.2 处理多客户</h4><p>在使用进程池处理多客户任务时，首先要考虑的一个问题是：<strong>监听socket和连接socket是否都由主进程来统一管理。</strong></p><blockquote><p>回忆第8章中我们介 绍过的几种并发模式，其中半同步/半反应堆模式是由主进程统一管理这两种socket的；而图8-11所示的高效的半同步/半异步模式，以及领导者/追随者模式，则是由主进程管理所有监听socket，而各个子进程分别 管理属于自己的连接socket的。</p><p>对于前一种情况，主进程接受新的连接 以得到连接socket，然后它需要将该socket传递给子进程（对于线程池 而言，父线程将socket传递给子线程是很简单的，因为它们可以很容易 地共享该socket。但对于进程池而言，我们必须使用13.9节介绍的方法 来传递该socket）。</p><p>后一种情况的灵活性更大一些，因为子进程可以自 己调用accept来接受新的连接，这样父进程就无须向子进程传递 socket，而只需要简单地通知一声：“我检测到新的连接，你来接受它。</p></blockquote><p>在4.6.1小节中我们曾讨论过常连接，即一个客户的多次请求可以 复用一个TCP连接。这里是指长链接和短连接. 那么，在设计进程池时还需要考虑：一个客户连接 上的所有任务是否始终由一个子进程来处理。</p><ul><li><p>如果说客户任务是无状 态的，那么我们可以考虑使用不同的子进程来为该客户的不同请求服 务，如图15-2所示:</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230308113352813.png" class="" title="image-20230308113352813"></li><li><p>但如果客户任务是存在上下文关系的，则最好一直用同一个子进 程来为之服务，否则实现起来将比较麻烦，因为我们不得不在各子进 程之间传递上下文数据。<strong>在9.3.4小节中，我们讨论了epoll的 EPOLLONESHOT事件，这一事件能够确保一个客户连接在整个生命周 期中仅被一个线程处理。</strong></p></li></ul><h4 id="15-3-半同步-半异步进程池实现"><a href="#15-3-半同步-半异步进程池实现" class="headerlink" title="15.3 半同步/半异步进程池实现"></a>15.3 半同步/半异步进程池实现</h4><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230228212643003.png" class="" title="image-20230228212643003"><p>本节我们实现一个基于图8-11所示的半同步/半 异步并发模式的进程池，如代码清单15-1所示。</p><p>为了避免在父、子进 程之间传递文件描述符，我们将接受新连接的操作放到子进程中。很 显然，对于这种模式而言，一个客户连接上的所有任务始终是由一个子进程来处理的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filename:processpool.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PROCESSPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PROCESSPOOL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*描述一个子进程的类，m_pid是目标子进程的PID，m_pipefd是父进程和子进程通</span></span><br><span class="line"><span class="comment">信用的管道*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">process</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">process() : m_pid(<span class="number">-1</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">pid_t</span> m_pid;</span><br><span class="line"><span class="keyword">int</span> m_pipefd[<span class="number">2</span>]&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池类，将它定义为模板类是为了代码复用。其模板参数是处理逻辑任务的类*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">processpool</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*将构造函数定义为私有的，因此我们只能通过后面的create静态函数来创建processpool实例*/</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">processpool</span><span class="params">(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number = <span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*单体模式，以保证程序最多创建一个processpool实例，这是程序正确处理信号的必要条件*/</span></span><br><span class="line"><span class="keyword">static</span> processpool&lt;T&gt; *</span><br><span class="line"></span><br><span class="line">create(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number = <span class="number">8</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (!m_instance) &#123;</span><br><span class="line">m_instance = <span class="keyword">new</span> processpool&lt;T&gt;(listenfd, process_number);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> m_instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~processpool() &#123; <span class="keyword">delete</span>[] m_sub_process; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*启动进程池*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup_sig_pipe</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_parent</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run_child</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*进程池允许的最大子进程数量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_PROCESS_NUMBER = <span class="number">16</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每个子进程最多能处理的客户数量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> USER_PER_PROCESS = <span class="number">65536</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*epoll最多能处理的事件数*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> MAX_EVENT_NUMBER = <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池中的进程总数*/</span></span><br><span class="line"><span class="keyword">int</span> m_process_number;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程在池中的序号，从0开始*/</span></span><br><span class="line"><span class="keyword">int</span> m_idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每个进程都有一个epoll内核事件表，用m_epollfd标识*/</span></span><br><span class="line"><span class="keyword">int</span> m_epollfd&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*监听socket*/</span></span><br><span class="line"><span class="keyword">int</span> m_listenfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*子进程通过m_stop来决定是否停止运行*/</span></span><br><span class="line"><span class="keyword">int</span> m_stop;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*保存所有子进程的描述信息*/</span></span><br><span class="line">process *m_sub_process;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池静态实例*/</span></span><br><span class="line"><span class="keyword">static</span> processpool&lt;T&gt; *m_instance;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">processpool&lt;T&gt; *processpool&lt;T&gt;::m_instance = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于处理信号的管道，以实现统一事件源。后面称之为信号管道*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sig_pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从epollfd标识的epoll内核事件表中删除fd上的所有注册事件*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(sig_pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span> &#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = handler;</span><br><span class="line"><span class="keyword">if</span> (restart) &#123;</span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line">&#125;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*进程池构造函数。参数listenfd是监听socket，它必须在创建进程池之前被创建，</span></span><br><span class="line"><span class="comment">否则子进程无法直接引用它。参数process_number指定进程池中子进程的数量*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">processpool&lt;T&gt;::processpool(<span class="keyword">int</span> listenfd, <span class="keyword">int</span> process_number)</span><br><span class="line">    : m_listenfd(listenfd), m_process_number(process_number), m_idx(<span class="number">-1</span>),</span><br><span class="line">      m_stop(<span class="literal">false</span>) &#123;</span><br><span class="line"></span><br><span class="line">assert((process_number &gt; <span class="number">0</span>) &amp;&amp; (process_number &lt;= MAX_PROCESS_NUMBER));</span><br><span class="line"></span><br><span class="line">m_sub_process = <span class="keyword">new</span> process[process_number];</span><br><span class="line">assert(m_sub_process);</span><br><span class="line"><span class="comment">/*创建process_number个子进程，并建立它们和父进程之间的管道*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; process_number; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, m_sub_process[i].m_pipefd);</span><br><span class="line">assert(ret == <span class="number">0</span>);</span><br><span class="line">m_sub_process[i].m_pid = fork();</span><br><span class="line">assert(m_sub_process[i].m_pid &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">close(m_sub_process[i].m_pipefd[<span class="number">1</span>]);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(m_sub_process[i].m_pipefd[<span class="number">0</span>]);</span><br><span class="line">m_idx = i;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*统一事件源*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::setup_sig_pipe() &#123;</span><br><span class="line"><span class="comment">/*创建epoll事件监听表和信号管道*/</span></span><br><span class="line">m_epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(m_epollfd != <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">int</span> ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, sig_pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">setnonblocking(sig_pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(m_epollfd, sig_pipefd[<span class="number">0</span>]);</span><br><span class="line"><span class="comment">/*设置信号处理函数*/</span></span><br><span class="line">addsig(SIGCHLD, sig_handler);</span><br><span class="line">addsig(SIGTERM, sig_handler);</span><br><span class="line">addsig(SIGINT, sig_handler);</span><br><span class="line">addsig(SIGPIPE, SIG_IGN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*父进程中m_idx值为-1，子进程中m_idx值大于等于0，我们据此判断接下来要运行</span></span><br><span class="line"><span class="comment">的是父进程代码还是子进程代码*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::run() &#123;</span><br><span class="line"><span class="keyword">if</span> (m_idx != <span class="number">-1</span>) &#123;</span><br><span class="line">run_child();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run_parent();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::run_child() &#123;</span><br><span class="line">setup_sig_pipe();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每个子进程都通过其在进程池中的序号值m_idx找到与父进程通信的管道*/</span></span><br><span class="line"><span class="keyword">int</span> pipefd = m_sub_process[m_idx].m_pipefd[<span class="number">1</span>];</span><br><span class="line"><span class="comment">/*子进程需要监听管道文件描述符pipefd，因为父进程将通过它来通知子进程accept</span></span><br><span class="line"><span class="comment">  新连接*/</span></span><br><span class="line">addfd(m_epollfd, pipefd);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">T *users = <span class="keyword">new</span> T[USER_PER_PROCESS];</span><br><span class="line">assert(users);</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> ((sockfd == pipefd) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> client = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*从父、子进程之间的管道读取数据，并将结果保存在变量client中。如果读取成</span></span><br><span class="line"><span class="comment">        功，则表示有新客户连接到来*/</span></span><br><span class="line">ret = recv(sockfd, (<span class="keyword">char</span> *) &amp;client, <span class="keyword">sizeof</span>(client), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (((ret &lt; <span class="number">0</span>) &amp;&amp; (errno != EAGAIN)) || ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">struct sockaddr_in client_address;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(m_listenfd, (struct sockaddr *) &amp;client_address,</span><br><span class="line">                    &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">addfd(m_epollfd, connfd);</span><br><span class="line"><span class="comment">/*模板类T必须实现init方法，以初始化一个客户连接。我们直接使用connfd来索引</span></span><br><span class="line"><span class="comment">          逻辑处理对象（T类型的对象），以提高程序效率*/</span></span><br><span class="line">users[connfd].init(m_epollfd, connfd, client_address);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下面处理子进程接收到的信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM:</span><br><span class="line"><span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">m_stop = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果是其他可读数据，那么必然是客户请求到来。调用逻辑处理对象的process方法</span></span><br><span class="line"><span class="comment">      处理之*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line">users[sockfd].</span><br><span class="line"></span><br><span class="line">        process();</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] users;</span><br><span class="line">users = <span class="literal">NULL</span>;</span><br><span class="line">close(pipefd);</span><br><span class="line"><span class="comment">// close(m_listenfd);/*我们将这句话注释掉，以提醒读者：应该由m_listenfd</span></span><br><span class="line"><span class="comment">// 的创建者来关闭这个文件描述符（见后文），即所谓的“对象（比如一个文件描述符，又或者</span></span><br><span class="line"><span class="comment">// 一段堆内存）由哪个函数创建，就应该由哪个函数销毁”*/</span></span><br><span class="line">close(m_epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> processpool&lt;T&gt;::run_parent() &#123;</span><br><span class="line">setup_sig_pipe();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*父进程监听m_listenfd*/</span></span><br><span class="line">addfd(m_epollfd, m_listenfd);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> sub_process_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> new_conn = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> number = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">number = epoll_wait(m_epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == m_listenfd) &#123;</span><br><span class="line"><span class="comment">/*如果有新连接到来，就采用Round Robin方式将其分配给一个子进程处理*/</span></span><br><span class="line"><span class="keyword">int</span> i = sub_process_counter;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid != <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">i = (i + <span class="number">1</span>) % m_process_number;</span><br><span class="line">&#125; <span class="keyword">while</span> (i != sub_process_counter);</span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid == <span class="number">-1</span>) &#123;</span><br><span class="line">m_stop = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">sub_process_counter = (i + <span class="number">1</span>) % m_process_number;</span><br><span class="line">send(m_sub_process[i].m_pipefd[<span class="number">0</span>], (<span class="keyword">char</span> *) &amp;new_conn, <span class="keyword">sizeof</span>(new_conn),</span><br><span class="line">     <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;send request to child%d\n&quot;</span>, i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下面处理父进程接收到的信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == sig_pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(sig_pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD: &#123;</span><br><span class="line"><span class="keyword">pid_t</span> pid;</span><br><span class="line"><span class="keyword">int</span> stat;</span><br><span class="line"><span class="keyword">while</span> ((pid = waitpid(<span class="number">-1</span>, &amp;stat, WNOHANG)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line"><span class="comment">/*如果进程池中第i个子进程退出了，则主进程关闭相应的通信管道，并设置相应的</span></span><br><span class="line"><span class="comment">                  m_pid为-1，以标记该子进程已经退出*/</span></span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid == pid) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;child%d join\n&quot;</span>, i);</span><br><span class="line">close(m_sub_process[i].m_pipefd[<span class="number">0</span>]);</span><br><span class="line">m_sub_process[i].m_pid = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果所有子进程都已经退出了，则父进程也退出*/</span></span><br><span class="line">m_stop = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (m_sub_process[i].m_pid != <span class="number">-1</span>) &#123;</span><br><span class="line">m_stop = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM:&#123;&#125;</span><br><span class="line"><span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line"><span class="comment">/*如果父进程接收到终止信号，那么就杀死所有子进程，并等待它们全部结束。当然，</span></span><br><span class="line"><span class="comment">              通知子进程结束更好的方法是向父、子进程之间的通信管道发送特殊数据，读者不妨自己实</span></span><br><span class="line"><span class="comment">              现之*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;kill all the clild now\n&quot;</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_process_number; ++i) &#123;</span><br><span class="line"><span class="keyword">int</span> pid = m_sub_process[i].m_pid;</span><br><span class="line"><span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">kill(pid, SIGTERM);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// close(m_listenfd);/*由创建者关闭这个文件描述符（见后文）*/</span></span><br><span class="line">close(m_epollfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="15-4-用进程池实现的简单CGI服务器"><a href="#15-4-用进程池实现的简单CGI服务器" class="headerlink" title="15.4 用进程池实现的简单CGI服务器"></a>15.4 用进程池实现的简单CGI服务器</h4><p>回忆6.2节，我们曾实现过一个非常简单的CGI服务器。下面我们 将利用前面介绍的进程池来重新实现一个并发的CGI服务器，如代码 清单15-2所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用进程池实现一个并发CGI服务器*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;processpool.h&quot;</span> <span class="comment">/*引用上一节介绍的进程池*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用于处理客户CGI请求的类，它可以作为processpool类的模板参数*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cgi_conn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">cgi_conn() = <span class="keyword">default</span>;</span><br><span class="line">~cgi_conn() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*初始化客户连接，清空读缓冲区*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in &amp;client_addr)</span> </span>&#123;</span><br><span class="line">m_epollfd = epollfd;</span><br><span class="line">m_sockfd = sockfd;</span><br><span class="line">m_address = client_addr;</span><br><span class="line"><span class="built_in">memset</span>(m_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">m_read_idx = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="comment">/*循环读取和分析客户数据*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">idx = m_read_idx;</span><br><span class="line">ret = recv(m_sockfd, m_buf + idx, BUFFER_SIZE - <span class="number">1</span> - idx, <span class="number">0</span>);</span><br><span class="line"><span class="comment">/*如果读操作发生错误,则关闭客户连接。但如果是暂时无数据可读，则退出循环*/</span></span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果对方关闭连接，则服务器也关闭连接*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">m_read_idx += ret;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;user content is:%s\n&quot;</span>, m_buf);</span><br><span class="line"><span class="comment">/*如果遇到字符“\r\n”，则开始处理客户请求*/</span></span><br><span class="line"><span class="keyword">for</span> (; idx &lt; m_read_idx; ++idx) &#123;</span><br><span class="line"><span class="keyword">if</span> ((idx &gt;= <span class="number">1</span>) &amp;&amp; (m_buf[idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>) &amp;&amp; (m_buf[idx] == <span class="string">&#x27;\n&#x27;</span>)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果没有遇到字符“\r\n”，则需要读取更多客户数据*/</span></span><br><span class="line"><span class="keyword">if</span> (idx == m_read_idx) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_buf[idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> *file_name = m_buf;</span><br><span class="line"><span class="comment">/*判断客户要运行的CGI程序是否存在*/</span></span><br><span class="line"><span class="keyword">if</span> (access(file_name, F_OK) == <span class="number">-1</span>) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*创建子进程来执行CGI程序*/</span></span><br><span class="line">ret = fork();</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*父进程只需关闭连接*/</span></span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*子进程将标准输出定向到m_sockfd，并执行CGI程序*/</span></span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">dup(m_sockfd);</span><br><span class="line">execl(m_buf, m_buf, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*读缓冲区的大小*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_epollfd;</span><br><span class="line"><span class="keyword">int</span> m_sockfd&#123;&#125;;</span><br><span class="line">sockaddr_in m_address&#123;&#125;;</span><br><span class="line"><span class="keyword">char</span> m_buf[BUFFER_SIZE]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标记读缓冲中已经读入的客户数据的最后一个字节的下一个位置*/</span></span><br><span class="line"><span class="keyword">int</span> m_read_idx&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cgi_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span> &#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">processpool&lt;cgi_conn&gt; *pool = processpool&lt;cgi_conn&gt;::create(listenfd);</span><br><span class="line"><span class="keyword">if</span> (pool) &#123;</span><br><span class="line">pool-&gt;run();</span><br><span class="line"><span class="keyword">delete</span> pool;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="comment">/*正如前文提到的，main函数创建了文件描述符listenfd，那么就由它亲自关闭之*/</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-5-半同步-半反应堆线程池实现"><a href="#15-5-半同步-半反应堆线程池实现" class="headerlink" title="15.5 半同步/半反应堆线程池实现"></a>15.5 半同步/半反应堆线程池实现</h4><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230228212216219.png" class="" title="image-20230228212216219"><p>本节我们实现一个基于图8-10所示的半同步/半反应堆并发模式的 线程池，如代码清单15-3所示。</p><p>相比代码清单15-1所示的进程池实现，该线程池的通用性要高得多，因为它使用一个工作队列完全解除 了主线程和工作线程的耦合关系：主线程往工作队列中插入任务，工 作线程通过竞争来取得任务并执行它。不过，如果要将该线程池应用 到实际服务器程序中，那么我们必须保证所有客户请求都是无状态的，因为同一个连接上的不同请求可能会由不同的线程处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> THREADPOOL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*引用第14章介绍的线程同步机制的包装类*/</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*线程池类，将它定义为模板类是为了代码复用。模板参数T是任务类*/</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadpool</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*参数thread_number是线程池中线程的数量，max_requests是请求队列中最多允许的、等待处理的请求的数量*/</span></span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">threadpool</span><span class="params">(<span class="keyword">int</span> thread_number = <span class="number">8</span>, <span class="keyword">int</span> max_requests = <span class="number">10000</span>)</span></span>;</span><br><span class="line">~threadpool();</span><br><span class="line"></span><br><span class="line"><span class="comment">/*往请求队列中添加任务*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">append</span><span class="params">(T *request)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*工作线程运行的函数，它不断从工作队列中取出任务并执行之*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> m_thread_number;        <span class="comment">/*线程池中的线程数*/</span></span><br><span class="line"><span class="keyword">int</span> m_max_requests;         <span class="comment">/*请求队列中允许的最大请求数*/</span></span><br><span class="line"><span class="keyword">pthread_t</span> *m_threads;       <span class="comment">/*描述线程池的数组，其大小为m_thread_number*/</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">list</span>&lt;T *&gt; m_workqueue; <span class="comment">/*请求队列*/</span></span><br><span class="line">locker m_queuelocker;       <span class="comment">/*保护请求队列的互斥锁*/</span></span><br><span class="line">sem m_queuestat;            <span class="comment">/*是否有任务需要处理*/</span></span><br><span class="line"><span class="keyword">bool</span> m_stop;                <span class="comment">/*是否结束线程*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::threadpool(<span class="keyword">int</span> thread_number, <span class="keyword">int</span> max_requests)</span><br><span class="line">    : m_thread_number(thread_number), m_max_requests(max_requests),</span><br><span class="line">      m_stop(<span class="literal">false</span>), m_threads(<span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((thread_number &lt;= <span class="number">0</span>) || (max_requests &lt;= <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">m_threads = <span class="keyword">new</span> <span class="keyword">pthread_t</span>[m_thread_number];</span><br><span class="line"><span class="keyword">if</span> (!m_threads) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建thread_number个线程，并将它们都设置为脱离线程*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; thread_number; ++i) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create the%dth thread\n&quot;</span>, i);</span><br><span class="line"><span class="keyword">if</span> (pthread_create(m_threads + i, <span class="literal">NULL</span>, worker, <span class="keyword">this</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_threads;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pthread_detach(m_threads[i])) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_threads;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">threadpool&lt;T&gt;::~threadpool() &#123;</span><br><span class="line"><span class="keyword">delete</span>[] m_threads;</span><br><span class="line">m_stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> threadpool&lt;T&gt;::append(T *request) &#123;</span><br><span class="line"><span class="comment">/*操作工作队列时一定要加锁，因为它被所有线程共享*/</span></span><br><span class="line">m_queuelocker.lock();</span><br><span class="line"><span class="keyword">if</span> (m_workqueue.size() &gt; m_max_requests) &#123;</span><br><span class="line">m_queuelocker.unlock();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_workqueue.push_back(request);</span><br><span class="line">m_queuelocker.unlock();</span><br><span class="line">m_queuestat.post();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> *threadpool&lt;T&gt;::worker(<span class="keyword">void</span> *arg) &#123;</span><br><span class="line"><span class="keyword">auto</span> *pool = (threadpool *) arg;</span><br><span class="line">pool-&gt;run();</span><br><span class="line"><span class="keyword">return</span> pool;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> threadpool&lt;T&gt;::run() &#123;</span><br><span class="line"><span class="keyword">while</span> (!m_stop) &#123;</span><br><span class="line">m_queuestat.wait();</span><br><span class="line">m_queuelocker.lock();</span><br><span class="line"><span class="keyword">if</span> (m_workqueue.empty()) &#123;</span><br><span class="line">m_queuelocker.unlock();</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">T *request = m_workqueue.front();</span><br><span class="line">m_workqueue.pop_front();</span><br><span class="line">m_queuelocker.unlock();</span><br><span class="line"><span class="keyword">if</span> (!request) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">request-&gt;process();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在C++程序中使用pthread_create函数时，该函数 的第3个参数必须指向一个静态函数。而要在一个静态函数中使用类的 动态成员（包括成员函数和成员变量），则只能通过如下两种方式来 实现：</p><ul><li>通过类的静态对象来调用。比如单体模式中，静态函数可以通 过类的全局唯一实例来访问动态成员函数。</li><li>将类的对象作为参数传递给该静态函数，然后在静态函数中引 用这个对象，并调用其动态方法。</li><li>代码清单15-3使用的是第2种方式：将线程参数设置为this指针， 然后在worker函数中获取该指针并调用其动态方法run。</li></ul><h4 id="15-6-用线程池实现的简单Web服务器"><a href="#15-6-用线程池实现的简单Web服务器" class="headerlink" title="15.6 用线程池实现的简单Web服务器"></a>15.6 用线程池实现的简单Web服务器</h4><p>在8.6节中，我们曾使用有限状态机实现过一个非常简单的解析 HTTP请求的服务器。下面我们将利用前面介绍的线程池来重新实现一 个并发的Web服务器。</p><h5 id="15-6-1-http-conn类"><a href="#15-6-1-http-conn类" class="headerlink" title="15.6.1 http_conn类"></a>15.6.1 http_conn类</h5><p>首先，我们需要准备线程池的模板参数类，用以封装对逻辑任务 的处理。这个类是http_conn，代码清单15-4是其头文件 （http_conn.h），代码清单15-5是其实现文件（http_conn.cpp）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> HTTPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> HTTPCONNECTION_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdarg&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">http_conn</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*文件名的最大长度*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> FILENAME_LEN = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读缓冲区的大小*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> READ_BUFFER_SIZE = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写缓冲区的大小*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> WRITE_BUFFER_SIZE = <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*HTTP请求方法，但我们仅支持GET*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">METHOD</span> &#123;</span> GET = <span class="number">0</span>,</span><br><span class="line">          POST,</span><br><span class="line">          HEAD,</span><br><span class="line">          PUT,</span><br><span class="line">          DELETE,</span><br><span class="line">          TRACE,</span><br><span class="line">          OPTIONS,</span><br><span class="line">          CONNECT,</span><br><span class="line">          PATCH &#125;;</span><br><span class="line"><span class="comment">/*解析客户请求时，主状态机所处的状态（回忆第8章）*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">CHECK_STATE</span> &#123;</span> CHECK_STATE_REQUESTLINE = <span class="number">0</span>,</span><br><span class="line">               CHECK_STATE_HEADER,</span><br><span class="line">               CHECK_STATE_CONTENT &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*服务器处理HTTP请求的可能结果*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">HTTP_CODE</span> &#123;</span> NO_REQUEST,</span><br><span class="line">             GET_REQUEST,</span><br><span class="line">             BAD_REQUEST,</span><br><span class="line">             NO_RESOURCE,</span><br><span class="line">             FORBIDDEN_REQUEST,</span><br><span class="line">             FILE_REQUEST,</span><br><span class="line">             INTERNAL_ERROR,</span><br><span class="line">             CLOSED_CONNECTION &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*行的读取状态*/</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">LINE_STATUS</span> &#123;</span> LINE_OK = <span class="number">0</span>,</span><br><span class="line">               LINE_BAD,</span><br><span class="line">               LINE_OPEN &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">http_conn() = <span class="keyword">default</span>;</span><br><span class="line">~http_conn() = <span class="keyword">default</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*初始化新接受的连接*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in&amp; addr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*关闭连接*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_conn</span><span class="params">(<span class="keyword">bool</span> real_close = <span class="literal">true</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理客户请求*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非阻塞读操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*非阻塞写操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">write</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*初始化连接*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析HTTP请求*/</span></span><br><span class="line"><span class="function">HTTP_CODE <span class="title">process_read</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*填充HTTP应答*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">process_write</span><span class="params">(HTTP_CODE ret)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面这一组函数被process_read调用以分析HTTP请求*/</span></span><br><span class="line"><span class="function">HTTP_CODE <span class="title">parse_request_line</span><span class="params">(<span class="keyword">char</span> *text)</span></span>;</span><br><span class="line"><span class="function">HTTP_CODE <span class="title">parse_headers</span><span class="params">(<span class="keyword">char</span> *text)</span></span>;</span><br><span class="line"><span class="function">HTTP_CODE <span class="title">parse_content</span><span class="params">(<span class="keyword">char</span> *text)</span></span>;</span><br><span class="line"><span class="function">HTTP_CODE <span class="title">do_request</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">get_line</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_read_buf + m_start_line; &#125;</span><br><span class="line"><span class="function">LINE_STATUS <span class="title">parse_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*下面这一组函数被process_write调用以填充HTTP应答*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">unmap</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_response</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_content</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *content)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_status_line</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span> *title)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_headers</span><span class="params">(<span class="keyword">int</span> content_length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_content_length</span><span class="params">(<span class="keyword">int</span> content_length)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_linger</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">add_blank_line</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*所有socket上的事件都被注册到同一个epoll内核事件表中，所以将epoll文件描述符设置为静态的*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_epollfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*统计用户数量*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_user_count;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*该HTTP连接的socket和对方的socket地址*/</span></span><br><span class="line"><span class="keyword">int</span> m_sockfd&#123;&#125;;</span><br><span class="line">sockaddr_in m_address&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*读缓冲区*/</span></span><br><span class="line"><span class="keyword">char</span> m_read_buf[READ_BUFFER_SIZE]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*标识读缓冲中已经读入的客户数据的最后一个字节的下一个位置*/</span></span><br><span class="line"><span class="keyword">int</span> m_read_idx&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当前正在分析的字符在读缓冲区中的位置*/</span></span><br><span class="line"><span class="keyword">int</span> m_checked_idx&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当前正在解析的行的起始位置*/</span></span><br><span class="line"><span class="keyword">int</span> m_start_line&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写缓冲区*/</span></span><br><span class="line"><span class="keyword">char</span> m_write_buf[WRITE_BUFFER_SIZE]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写缓冲区中待发送的字节数*/</span></span><br><span class="line"><span class="keyword">int</span> m_write_idx&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主状态机当前所处的状态*/</span></span><br><span class="line">CHECK_STATE m_check_state;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*请求方法*/</span></span><br><span class="line">METHOD m_method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户请求的目标文件的完整路径，其内容等于doc_root+m_url，doc_root是网站根目录*/</span></span><br><span class="line"><span class="keyword">char</span> m_real_file[FILENAME_LEN]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户请求的目标文件的文件名*/</span></span><br><span class="line"><span class="keyword">char</span> *m_url&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*HTTP协议版本号，我们仅支持HTTP/1.1*/</span></span><br><span class="line"><span class="keyword">char</span> *m_version&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主机名*/</span></span><br><span class="line"><span class="keyword">char</span> *m_host&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*HTTP请求的消息体的长度*/</span></span><br><span class="line"><span class="keyword">int</span> m_content_length&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*HTTP请求是否要求保持连接*/</span></span><br><span class="line"><span class="keyword">bool</span> m_linger&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*客户请求的目标文件被mmap到内存中的起始位置*/</span></span><br><span class="line"><span class="keyword">char</span> *m_file_address&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*目标文件的状态。通过它我们可以判断文件是否存在、是否为目录、是否可读，并获</span></span><br><span class="line"><span class="comment">取文件大小等信息*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">m_file_stat</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们将采用writev来执行写操作，所以定义下面两个成员，其中m_iv_count表示</span></span><br><span class="line"><span class="comment">被写内存块的数量*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">m_iv</span>[2]&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_iv_count&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="15-6-2-http-conn实现"><a href="#15-6-2-http-conn实现" class="headerlink" title="15.6.2 http_conn实现"></a>15.6.2 http_conn实现</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../include/http_conn.h&quot;</span></span></span><br><span class="line"><span class="comment">/*定义HTTP响应的一些状态信息*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ok_200_title = <span class="string">&quot;OK&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_400_title = <span class="string">&quot;Bad Request&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_400_form = <span class="string">&quot;Your request has bad syntax or is inherently impossible to satisfy.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_403_title = <span class="string">&quot;Forbidden&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_403_form = <span class="string">&quot;You do not have permission to get file from this server.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_404_title = <span class="string">&quot;Not Found&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_404_form = <span class="string">&quot;The requested file was not found on this server.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_500_title = <span class="string">&quot;Internal Error&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *error_500_form = <span class="string">&quot;There was an unusual problem serving the requested file.\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*网站的根目录*/</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *doc_root = <span class="string">&quot;/home/sen/html/&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 通过fcntl函数通来将一个文件描述符设置为非阻塞的</span></span><br><span class="line"><span class="comment"> * 类似于listenfd = socket(AF_INET, SOCK_NONBLOCK | SOCK_STREAM, 0);</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 注册 POLLIN(数据可读) EPOLLET(高效EPOLL) EPOLLRDHUB(TCP链接被对方关闭)</span></span><br><span class="line"><span class="comment"> * oneshot = true , 操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次, 除非重置</span></span><br><span class="line"><span class="comment"> * EPOLLONESHOT标志 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET | EPOLLRDHUP;</span><br><span class="line"><span class="keyword">if</span> (one_shot) &#123;</span><br><span class="line">event.events |= EPOLLONESHOT;</span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 使用epoll_ctl 删除内核事件表, 并且关闭文件描述符 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">modfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">int</span> ev)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = ev | EPOLLET | EPOLLONESHOT | EPOLLRDHUP;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> http_conn::m_user_count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> http_conn::m_epollfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::close_conn</span><span class="params">(<span class="keyword">bool</span> real_close)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (real_close &amp;&amp; (m_sockfd != <span class="number">-1</span>)) &#123;</span><br><span class="line">removefd(m_epollfd, m_sockfd);</span><br><span class="line">m_sockfd = <span class="number">-1</span>;</span><br><span class="line">m_user_count--; <span class="comment">/*关闭一个连接时，将客户总量减1*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> sockaddr_in &amp;addr)</span> </span>&#123;</span><br><span class="line">m_sockfd = sockfd;</span><br><span class="line">m_address = addr;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如下两行是为了避免TIME_WAIT状态，仅用于调试，实际使用时应该去掉*/</span></span><br><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">setsockopt(m_sockfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse));</span><br><span class="line"></span><br><span class="line">addfd(m_epollfd, sockfd, <span class="literal">true</span>);</span><br><span class="line">m_user_count++;</span><br><span class="line">init();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* htp_coon 初始化 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">m_check_state = CHECK_STATE_REQUESTLINE;</span><br><span class="line">m_linger = <span class="literal">false</span>;</span><br><span class="line">m_method = GET;</span><br><span class="line">m_url = <span class="literal">nullptr</span>;</span><br><span class="line">m_version = <span class="literal">nullptr</span>;</span><br><span class="line">m_content_length = <span class="number">0</span>;</span><br><span class="line">m_host = <span class="literal">nullptr</span>;</span><br><span class="line">m_start_line = <span class="number">0</span>;</span><br><span class="line">m_checked_idx = <span class="number">0</span>;</span><br><span class="line">m_read_idx = <span class="number">0</span>;</span><br><span class="line">m_write_idx = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  &#x27;\0&#x27;是字符串结束标志，不计入串长，但要占内存空间。</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  &#x27;\0&#x27;是一个ASCII控制字符，是转义字符。</span></span><br><span class="line"><span class="comment"> *  意思是告诉编译器，这不是字符0，而是空字符。空字符\0对应的二进制为0000 0000，而数字0的二进制为0011 0000。</span></span><br><span class="line"><span class="comment"> *  这里的话 可以使用 bzero代替</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">memset</span>(m_read_buf, <span class="string">&#x27;\0&#x27;</span>, READ_BUFFER_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(m_write_buf, <span class="string">&#x27;\0&#x27;</span>, WRITE_BUFFER_SIZE);</span><br><span class="line"><span class="built_in">memset</span>(m_real_file, <span class="string">&#x27;\0&#x27;</span>, FILENAME_LEN);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从状态机，其分析请参考8.6节，这里不再赘述*/</span></span><br><span class="line"><span class="function">http_conn::LINE_STATUS <span class="title">http_conn::parse_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> temp;</span><br><span class="line"><span class="keyword">for</span> (; m_checked_idx &lt; m_read_idx; ++m_checked_idx) &#123;</span><br><span class="line">temp = m_read_buf[m_checked_idx];</span><br><span class="line"><span class="keyword">if</span> (temp == <span class="string">&#x27;\r&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((m_checked_idx + <span class="number">1</span>) == m_read_idx) &#123;</span><br><span class="line"><span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (m_read_buf[m_checked_idx + <span class="number">1</span>] == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> LINE_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LINE_BAD;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (temp == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((m_checked_idx &gt; <span class="number">1</span>) &amp;&amp; (m_read_buf[m_checked_idx - <span class="number">1</span>] == <span class="string">&#x27;\r&#x27;</span>)) &#123;</span><br><span class="line">m_read_buf[m_checked_idx - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">m_read_buf[m_checked_idx++] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> LINE_OK;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LINE_BAD;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> LINE_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*循环读取客户数据，直到无数据可读或者对方关闭连接*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::read</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_read_idx &gt;= READ_BUFFER_SIZE) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">bytes_read = recv(m_sockfd, m_read_buf + m_read_idx, READ_BUFFER_SIZE - m_read_idx, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EAGAIN || errno == EWOULDBLOCK) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_read_idx += bytes_read;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析HTTP请求行，获得请求方法、目标URL，以及HTTP版本号*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_request_line</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">m_url = <span class="built_in">strpbrk</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!m_url) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line">*m_url++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> *method = text;</span><br><span class="line"><span class="keyword">if</span> (strcasecmp(method, <span class="string">&quot;GET&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">m_method = GET;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line">m_url += <span class="built_in">strspn</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">m_version = <span class="built_in">strpbrk</span>(m_url, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (!m_version) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line">*m_version++ = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">m_version += <span class="built_in">strspn</span>(m_version, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (strcasecmp(m_version, <span class="string">&quot;HTTP/1.1&quot;</span>) != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (strncasecmp(m_url, <span class="string">&quot;http://&quot;</span>, <span class="number">7</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">m_url += <span class="number">7</span>;</span><br><span class="line">m_url = <span class="built_in">strchr</span>(m_url, <span class="string">&#x27;/&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!m_url || m_url[<span class="number">0</span>] != <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line">m_check_state = CHECK_STATE_HEADER;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*解析HTTP请求的一个头部信息*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_headers</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*遇到空行，表示头部字段解析完毕*/</span></span><br><span class="line"><span class="keyword">if</span> (text[<span class="number">0</span>] == <span class="string">&#x27;\0&#x27;</span>) &#123;</span><br><span class="line"><span class="comment">/*如果HTTP请求有消息体，则还需要读取m_content_length字节的消息体，状态机转移到CHECK_STATE_CONTENT状态*/</span></span><br><span class="line"><span class="keyword">if</span> (m_content_length != <span class="number">0</span>) &#123;</span><br><span class="line">m_check_state = CHECK_STATE_CONTENT;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则说明我们已经得到了一个完整的HTTP请求*/</span></span><br><span class="line"><span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理Connection头部字段*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(text, <span class="string">&quot;Connection:&quot;</span>, <span class="number">11</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">text += <span class="number">11</span>;</span><br><span class="line">text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (strcasecmp(text, <span class="string">&quot;keep-alive&quot;</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">m_linger = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理Content-Length头部字段*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(text, <span class="string">&quot;Content-Length:&quot;</span>, <span class="number">15</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">text += <span class="number">15</span>;</span><br><span class="line">text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">m_content_length = atol(text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理Host头部字段*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (strncasecmp(text, <span class="string">&quot;Host:&quot;</span>, <span class="number">5</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">text += <span class="number">5</span>;</span><br><span class="line">text += <span class="built_in">strspn</span>(text, <span class="string">&quot; \t&quot;</span>);</span><br><span class="line">m_host = text;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;oop!unknow header%s\n&quot;</span>, text);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*我们没有真正解析HTTP请求的消息体，只是判断它是否被完整地读入了*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::parse_content</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_read_idx &gt;= (m_content_length + m_checked_idx)) &#123;</span><br><span class="line">text[m_content_length] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="keyword">return</span> GET_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主状态机。其分析请参考8.6节，这里不再赘述*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::process_read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LINE_STATUS line_status = LINE_OK;</span><br><span class="line">HTTP_CODE ret = NO_REQUEST;</span><br><span class="line"><span class="keyword">char</span> *text = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (((m_check_state == CHECK_STATE_CONTENT) &amp;&amp; (line_status == LINE_OK))</span><br><span class="line">       || ((line_status = parse_line()) == LINE_OK)) &#123;</span><br><span class="line">text = get_line();</span><br><span class="line">m_start_line = m_checked_idx;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got 1 http line: %s\n&quot;</span>, text);</span><br><span class="line"><span class="keyword">switch</span> (m_check_state) &#123;</span><br><span class="line"><span class="keyword">case</span> CHECK_STATE_REQUESTLINE: &#123;</span><br><span class="line">ret = parse_request_line(text);</span><br><span class="line"><span class="keyword">if</span> (ret == BAD_REQUEST) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CHECK_STATE_HEADER: &#123;</span><br><span class="line">ret = parse_headers(text);</span><br><span class="line"><span class="keyword">if</span> (ret == BAD_REQUEST) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == GET_REQUEST) &#123;</span><br><span class="line"><span class="keyword">return</span> do_request();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> CHECK_STATE_CONTENT: &#123;</span><br><span class="line">ret = parse_content(text);</span><br><span class="line"><span class="keyword">if</span> (ret == GET_REQUEST) &#123;</span><br><span class="line"><span class="keyword">return</span> do_request();</span><br><span class="line">&#125;</span><br><span class="line">line_status = LINE_OPEN;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">return</span> INTERNAL_ERROR;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> NO_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当得到一个完整、正确的HTTP请求时，我们就分析目标文件的属性。如果目标文件存在、</span></span><br><span class="line"><span class="comment"> * 对所有用户可读，且不是目录，则使用mmap将其映射到内存地址m_file_address</span></span><br><span class="line"><span class="comment">处，并告诉调用者获取文件成功*/</span></span><br><span class="line"><span class="function">http_conn::HTTP_CODE <span class="title">http_conn::do_request</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">strcpy</span>(m_real_file, doc_root);</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in">strlen</span>(doc_root);</span><br><span class="line"><span class="built_in">strncpy</span>(m_real_file + len, m_url, FILENAME_LEN - len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (stat(m_real_file, &amp;m_file_stat) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> NO_RESOURCE;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!(m_file_stat.st_mode &amp; S_IROTH)) &#123;</span><br><span class="line"><span class="keyword">return</span> FORBIDDEN_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (S_ISDIR(m_file_stat.st_mode)) &#123;</span><br><span class="line"><span class="keyword">return</span> BAD_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> fd = open(m_real_file, O_RDONLY);</span><br><span class="line">m_file_address = (<span class="keyword">char</span> *) mmap(<span class="number">0</span>, m_file_stat.st_size, PROT_READ, MAP_PRIVATE, fd, <span class="number">0</span>);</span><br><span class="line">close(fd);</span><br><span class="line"><span class="keyword">return</span> FILE_REQUEST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对内存映射区执行munmap操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::unmap</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_file_address) &#123;</span><br><span class="line">munmap(m_file_address, m_file_stat.st_size);</span><br><span class="line">m_file_address = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*写HTTP响应*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::write</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bytes_have_send = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> bytes_to_send = m_write_idx;</span><br><span class="line"><span class="keyword">if</span> (bytes_to_send == <span class="number">0</span>) &#123;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line">init();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">temp = writev(m_sockfd, m_iv, m_iv_count);</span><br><span class="line"><span class="keyword">if</span> (temp &lt;= <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">/*如果TCP写缓冲没有空间，则等待下一轮EPOLLOUT事件。虽然在此期间，服务器无</span></span><br><span class="line"><span class="comment">法立即接收到同一客户的下一个请求，但这可以保证连接的完整性*/</span></span><br><span class="line"><span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">unmap();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">bytes_to_send -= temp;</span><br><span class="line">bytes_have_send += temp;</span><br><span class="line"><span class="keyword">if</span> (bytes_to_send &lt;= bytes_have_send) &#123;</span><br><span class="line"><span class="comment">/*发送HTTP响应成功，根据HTTP请求中的Connection字段决定是否立即关闭连接*/</span></span><br><span class="line">unmap();</span><br><span class="line"><span class="keyword">if</span> (m_linger) &#123;</span><br><span class="line">init();</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*往写缓冲中写入待发送的数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_response</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *format, ...)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (m_write_idx &gt;= WRITE_BUFFER_SIZE) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">va_list arg_list;</span><br><span class="line">va_start(arg_list, format);</span><br><span class="line"><span class="keyword">int</span> len = vsnprintf(m_write_buf + m_write_idx, WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx, format, arg_list);</span><br><span class="line"><span class="keyword">if</span> (len &gt;= (WRITE_BUFFER_SIZE - <span class="number">1</span> - m_write_idx)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_write_idx += len;</span><br><span class="line">va_end(arg_list);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_status_line</span><span class="params">(<span class="keyword">int</span> status, <span class="keyword">const</span> <span class="keyword">char</span> *title)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;%s%d%s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status, title);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_headers</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line">add_content_length(content_len);</span><br><span class="line">add_linger();</span><br><span class="line">add_blank_line();</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content_length</span><span class="params">(<span class="keyword">int</span> content_len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;Content-Length:%d\r\n&quot;</span>, content_len);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_linger</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;Connection:%s\r\n&quot;</span>, (m_linger == <span class="literal">true</span>) ? <span class="string">&quot;keep-alive&quot;</span> : <span class="string">&quot;close&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_blank_line</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::add_content</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *content)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> add_response(<span class="string">&quot;%s&quot;</span>, content);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据服务器处理HTTP请求的结果，决定返回给客户端的内容*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">http_conn::process_write</span><span class="params">(HTTP_CODE ret)</span> </span>&#123;</span><br><span class="line"><span class="keyword">switch</span> (ret) &#123;</span><br><span class="line"><span class="keyword">case</span> INTERNAL_ERROR: &#123;</span><br><span class="line">add_status_line(<span class="number">500</span>, error_500_title);</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(error_500_form));</span><br><span class="line"><span class="keyword">if</span> (!add_content(error_500_form)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> BAD_REQUEST: &#123;</span><br><span class="line">add_status_line(<span class="number">400</span>, error_400_title);</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(error_400_form));</span><br><span class="line"><span class="keyword">if</span> (!add_content(error_400_form)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> NO_RESOURCE: &#123;</span><br><span class="line">add_status_line(<span class="number">404</span>, error_404_title);</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(error_404_form));</span><br><span class="line"><span class="keyword">if</span> (!add_content(error_404_form)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> FORBIDDEN_REQUEST: &#123;</span><br><span class="line">add_status_line(<span class="number">403</span>, error_403_title);</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(error_403_form));</span><br><span class="line"><span class="keyword">if</span> (!add_content(error_403_form)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> FILE_REQUEST: &#123;</span><br><span class="line">add_status_line(<span class="number">200</span>, ok_200_title);</span><br><span class="line"><span class="keyword">if</span> (m_file_stat.st_size != <span class="number">0</span>) &#123;</span><br><span class="line">add_headers(m_file_stat.st_size);</span><br><span class="line">m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">m_iv[<span class="number">1</span>].iov_base = m_file_address;</span><br><span class="line">m_iv[<span class="number">1</span>].iov_len = m_file_stat.st_size;</span><br><span class="line">m_iv_count = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ok_string = <span class="string">&quot;&lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;&quot;</span>;</span><br><span class="line">add_headers(<span class="built_in">strlen</span>(ok_string));</span><br><span class="line"><span class="keyword">if</span> (!add_content(ok_string)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span>: &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">m_iv[<span class="number">0</span>].iov_base = m_write_buf;</span><br><span class="line">m_iv[<span class="number">0</span>].iov_len = m_write_idx;</span><br><span class="line">m_iv_count = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*由线程池中的工作线程调用，这是处理HTTP请求的入口函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">http_conn::process</span><span class="params">()</span> </span>&#123;</span><br><span class="line">HTTP_CODE read_ret = process_read();</span><br><span class="line"><span class="keyword">if</span> (read_ret == NO_REQUEST) &#123;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLIN);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> write_ret = process_write(read_ret);</span><br><span class="line"><span class="keyword">if</span> (!write_ret) &#123;</span><br><span class="line">close_conn();</span><br><span class="line">&#125;</span><br><span class="line">modfd(m_epollfd, m_sockfd, EPOLLOUT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="15-6-3-main-cpp"><a href="#15-6-3-main-cpp" class="headerlink" title="15.6.3 main.cpp"></a>15.6.3 main.cpp</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/8.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;http_conn.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;locker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;threadpool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_FD 65536</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 10000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> one_shot)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">removefd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">void</span>(handler)(<span class="keyword">int</span>), <span class="keyword">bool</span> restart = <span class="literal">true</span>)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = handler;</span><br><span class="line"><span class="keyword">if</span> (restart) &#123;</span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line">&#125;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">NULL</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_error</span><span class="params">(<span class="keyword">int</span> connfd, <span class="keyword">const</span> <span class="keyword">char</span> *info)</span> </span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="comment">/*忽略SIGPIPE信号*/</span></span><br><span class="line">addsig(SIGPIPE, SIG_IGN);</span><br><span class="line"><span class="comment">/*创建线程池*/</span></span><br><span class="line">threadpool&lt;http_conn&gt; *pool = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">pool = <span class="keyword">new</span> threadpool&lt;http_conn&gt;;</span><br><span class="line">&#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*预先为每个可能的客户连接分配一个http_conn对象*/</span></span><br><span class="line"><span class="keyword">auto</span> *users = <span class="keyword">new</span> http_conn[MAX_FD];</span><br><span class="line">assert(users);</span><br><span class="line"><span class="keyword">int</span> user_count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> <span class="title">tmp</span> =</span> &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">setsockopt(listenfd, SOL_SOCKET, SO_LINGER, &amp;tmp, <span class="keyword">sizeof</span>(tmp));</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret &gt;= <span class="number">0</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">addfd(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line">http_conn::m_epollfd = epollfd;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (http_conn::m_user_count &gt;= MAX_FD) &#123;</span><br><span class="line">show_error(connfd, <span class="string">&quot;Internal server busy&quot;</span>);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*初始化客户连接*/</span></span><br><span class="line">users[connfd].init(connfd, client_address);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; (EPOLLRDHUP | EPOLLHUP | EPOLLERR)) &#123;</span><br><span class="line"><span class="comment">/*如果有异常，直接关闭客户连接*/</span></span><br><span class="line">users[sockfd].close_conn();</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="comment">/*根据读的结果，决定是将任务添加到线程池，还是关闭连接*/</span></span><br><span class="line"><span class="keyword">if</span> (users[sockfd].read()) &#123;</span><br><span class="line">pool-&gt;append(users + sockfd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">users[sockfd].close_conn();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line"><span class="comment">/*根据写的结果，决定是否关闭连接*/</span></span><br><span class="line"><span class="keyword">if</span> (!users[sockfd].write()) &#123;</span><br><span class="line">users[sockfd].close_conn();</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(epollfd);</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">delete</span>[] users;</span><br><span class="line"><span class="keyword">delete</span> pool;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="15-6-4-Cmakelists-txt"><a href="#15-6-4-Cmakelists-txt" class="headerlink" title="15.6.4 Cmakelists.txt"></a>15.6.4 Cmakelists.txt</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br><span class="line"><span class="keyword">project</span>(http_server)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_CXX_STANDARD <span class="number">17</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp http_connection/http_conn.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main Threads::Threads)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>目录结构:</p><img src="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B/image-20230311190929809.png" class="" title="image-20230311190929809">]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四 性能检测和优化</title>
      <link href="/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E4%B8%8E%E6%A3%80%E6%B5%8B/"/>
      <url>/2023/03/10/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BC%98%E5%8C%96%E4%B8%8E%E6%A3%80%E6%B5%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="第四篇-高性能服务器优化与监测"><a href="#第四篇-高性能服务器优化与监测" class="headerlink" title="第四篇 高性能服务器优化与监测"></a>第四篇 高性能服务器优化与监测</h2><h3 id="第十六章-服务器调制、调试和测试"><a href="#第十六章-服务器调制、调试和测试" class="headerlink" title="第十六章 服务器调制、调试和测试"></a>第十六章 服务器调制、调试和测试</h3><p>我们要从系统的角度来优化、改进服务器，这包括3个方面的 内容：系统调制、服务器调试和压力测试。</p><h4 id="16-1-最大文件描述符数"><a href="#16-1-最大文件描述符数" class="headerlink" title="16.1 最大文件描述符数"></a>16.1 最大文件描述符数</h4><p>文件描述符是服务器程序的宝贵资源，几乎所有的系统调用都是和文件描述符打交道。系统分配给应用程序的文件描述符数量是有限制的，所以我们必须总是关闭那些已经不再使用的文件描述符，以释放它们占用的资源。</p><blockquote><p>比如作为守护进程运行的服务器程序就应该总是 关闭标准输入、标准输出和标准错误这3个文件描述符。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br></pre></td></tr></table></figure></blockquote><p>Linux对应用程序能打开的最大文件描述符数量有两个层次的限 制：用户级限制和系统级限制。</p><ul><li>用户级限制是指目标用户运行的所有进程总共能打开的文件描述符数；</li><li>系统级的限制是指所有用户总共能打开的文件描述符数。</li></ul><p>为永久修改<strong>用户级文件</strong>描述符数限制，可以在<code>/etc/security/limits.conf</code>文件中加入如 下两项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*hard nofile max-file-number   // 第一行是指系统的硬限制，</span><br><span class="line">*soft nofile max-file-number// 第二行是软限制。</span><br></pre></td></tr></table></figure><p>如果要修改<strong>系统级</strong>文件描述符数限制，则可以使用如下命令：在<code>/etc/sysctl.conf</code>文件中添加如下一项：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fs.file-max=max-file-number</span><br></pre></td></tr></table></figure><p>然后通过执行 <code>sysctl -p</code>命令使更改生效。</p><h4 id="16-2-调整内核参数"><a href="#16-2-调整内核参数" class="headerlink" title="16.2 调整内核参数"></a>16.2 调整内核参数</h4><p>几乎所有的内核模块，包括内核核心模块和驱动程序，都 在<code>/proc/sys</code>文件系统下提供了某些配置文件以供用户调整模块的属性 和行为。通常一个配置文件对应一个内核参数，文件名就是参数的名 字，文件的内容是参数的值。</p><p>我们可以通过命令<code>sysctl -a</code>查看所有这些 内核参数。</p><h5 id="16-2-1-proc-sys-fs目录下的部分文件"><a href="#16-2-1-proc-sys-fs目录下的部分文件" class="headerlink" title="16.2.1 /proc/sys/fs目录下的部分文件"></a>16.2.1 <code>/proc/sys/fs</code>目录下的部分文件</h5><p><code>/proc/sys/fs</code> 目录下的内核参数都与文件系统相关。</p><ul><li><p><code>/proc/sys/fs/file-max</code>，系统级文件描述符数限制。直接修改这个 参数和16.1节讨论的修改方法有相同的效果（不过这是临时修改）。</p></li><li><p><code>/proc/sys/fs/epoll/max_user_watches</code>，一个用户能够往epoll内核 事件表中注册的事件的总量。它是指该用户打开的所有epoll实例总共 能监听的事件数目，而不是单个epoll实例能监听的事件数目。</p><blockquote><p>往epoll 内核事件表中注册一个事件，在32位系统上大概消耗90字节的内核空 间，在64位系统上则消耗160字节的内核空间。所以，这个内核参数限 制了epoll使用的内核内存总量。</p></blockquote></li></ul><h5 id="16-2-2-proc-sys-net-目录下的部分文件"><a href="#16-2-2-proc-sys-net-目录下的部分文件" class="headerlink" title="16.2.2 /proc/sys/net 目录下的部分文件"></a>16.2.2 <code>/proc/sys/net</code> 目录下的部分文件</h5><p>内核中网络模块的相关参数都位于/proc/sys/net目录下，其中和 TCP/IP协议相关的参数主要位于如下三个子目录中：core、ipv4和 ipv6。</p><ul><li><code>/proc/sys/net/core/somaxconn</code>，指定listen监听队列里，能够建立完整连接从而进入ESTABLISHED状态的socket的最大数目。</li><li><code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>，指定listen监听队列里， 能够转移至ESTABLISHED或者 SYN_RCVD 状态的socket的最大数目。</li><li><code>/proc/sys/net/ipv4/tcp_wmem</code>，它包含3个值，分别指定一个 socket的TCP<strong>写缓冲区</strong>的最小值、默认值和最大值。</li><li><code>/proc/sys/net/ipv4/tcp_rmem</code>，它包含3个值，分别指定一个socket 的TCP<strong>读缓冲区</strong>的最小值、默认值和最大值。</li><li>/<code>proc/sys/net/ipv4/tcp_syncookies</code>，指定是否打开TCP同步标签 （syncookie）。同步标签通过启动cookie来防止一个监听socket因不停 地重复接收来自同一个地址的连接请求（同步报文段），而导致listen 监听队列溢出（所谓的SYN风暴）。</li></ul><p>除了通过<strong>直接修改文件的方式来修改这些系统参数</strong>外，我们也可以<strong>使用sysctl命令来修改</strong>它们。这两种修改方式都是<strong>临时</strong>的。</p><p>永久的修改方法是在**/etc/sysctl.conf文件中加入相应网络参数及其数值**，并执行 sysctl-p使之生效，就像修改系统最大允许打开的文件描述符数那样。</p><h4 id="16-3-gdb调试"><a href="#16-3-gdb调试" class="headerlink" title="16.3 gdb调试"></a>16.3 <code>gdb</code>调试</h4><h5 id="16-3-1-用gdb调试多进程程序"><a href="#16-3-1-用gdb调试多进程程序" class="headerlink" title="16.3.1 用gdb调试多进程程序"></a>16.3.1 用gdb调试多进程程序</h5><p>如果一个进程通过fork系统调用创建了子进程，gdb会继续调试原来的进程，子进程则正常运行。</p><p>那么该如何调试子进程呢？常用的方法有如下两种。</p><ol><li><p>单独调试子进程</p><p>子进程从本质上说也是一个进程，因此我们可以用通用的gdb调试 方法来调试它。举例来说，如果要调试代码清单15-2描述的 <code>CGI</code> 进程池服务器的某一个子进程，则我们可以先运行服务器，然后<strong>找到目标 子进程的PID，再将其附加（attach）到gdb调试器上</strong></p></li><li><p>使用调试器选项follow-fork-mode</p><p>gdb调试器的选项follow-fork-mode允许我们选择程序在执行fork系 统调用后是继续调试父进程还是调试子进程。其用法如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(gdb)set follow-fork-mode mode</span><br></pre></td></tr></table></figure><p>其中，mode的可选值是parent和child，分别表示调试父进程和子进程。</p></li></ol><h5 id="16-3-2-用gdb调试多线程程序"><a href="#16-3-2-用gdb调试多线程程序" class="headerlink" title="16.3.2 用gdb调试多线程程序"></a>16.3.2 用gdb调试多线程程序</h5><p>gdb有一组命令可辅助多线程程序的调试。下面我们仅列举其中常用的一些：</p><ul><li>info threads，显示当前可调试的所有线程。gdb会为每个线程分 配一个ID，我们可以使用这个ID来操作对应的线程。ID前面有“*”号 的线程是当前被调试的线程。</li><li>thread ID，调试目标ID指定的线程。</li><li>set scheduler-locking[off|on|step]。调试多线程程序时，默认除了 被调试的线程在执行外，其他线程也在继续执行，但有的时候我们希 望只让被调试的线程运行。这可以通过这个命令来实现。该命令设置 scheduler-locking的值：off表示不锁定任何线程，即所有线程都可以继 续执行，这是默认值；on表示只有当前被调试的线程会继续执行； step表示在单步执行的时候，只有当前线程会执行。</li></ul><p>最后，关于调试进程池和线程池程序的一个不错的方法，是<strong>先将池中的进程个数或线程个数减少至1，以观察程序的逻辑是否正确</strong>，比 如代码清单16-3就是这样做的；然后逐步增加进程或线程的数量，以 调试进程或线程的同步是否正确。</p><h4 id="16-4-压力测试"><a href="#16-4-压力测试" class="headerlink" title="16.4 压力测试"></a>16.4 压力测试</h4><p>压力测试程序有很多种实现方式，比如I/O复用方式，多线程、多 进程并发编程方式，以及这些方式的结合使用。</p><p>单纯的I/O复用 方式的施压程度是最高的，因为线程和进程的调度本身也是要占用一 定CPU时间的。</p><p>使用epoll实现一个通用的服务器压力测试程序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/10.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">/*每个客户连接不停地向服务器发送这个请求*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span> *request = <span class="string">&quot;GET http://localhost/index.html &quot;</span></span><br><span class="line">                             <span class="string">&quot;HTTP/1.1\r\nConnection:keep-alive\r\n\r\nxxxxxxxxxxxx&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLOUT | EPOLLET | EPOLLERR;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向服务器写入len字节的数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">write_nbytes</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">char</span> *buffer, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bytes_write = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;write out%d bytes to socket%d\n&quot;</span>, len, sockfd);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">bytes_write = send(sockfd, buffer, len, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (bytes_write == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_write == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">len -= bytes_write;</span><br><span class="line">buffer = buffer + bytes_write;</span><br><span class="line"><span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*从服务器读取数据*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">read_once</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">char</span> *buffer, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bytes_read = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">memset</span>(buffer, <span class="string">&#x27;\0&#x27;</span>, len);</span><br><span class="line">bytes_read = recv(sockfd, buffer, len, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (bytes_read == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (bytes_read == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read in%d bytes from socket%d with content:%s\n&quot;</span>, bytes_read, sockfd, buffer);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*向服务器发起num个TCP连接，我们可以通过改变num来调整测试压力*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">start_conn</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> num, <span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; num; ++i) &#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;create 1 sock\n&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (connect(sockfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address)) == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;build connection%d\n&quot;</span>, i);</span><br><span class="line">addfd(epoll_fd, sockfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close_conn</span><span class="params">(<span class="keyword">int</span> epoll_fd, <span class="keyword">int</span> sockfd)</span> </span>&#123;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_DEL, sockfd, <span class="number">0</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">assert(argc == <span class="number">4</span>);</span><br><span class="line"><span class="keyword">int</span> epoll_fd = epoll_create(<span class="number">100</span>);</span><br><span class="line">start_conn(epoll_fd, atoi(argv[<span class="number">3</span>]), argv[<span class="number">1</span>], atoi(argv[<span class="number">2</span>]));</span><br><span class="line">epoll_event events[<span class="number">10000</span>];</span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">2048</span>];</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> fds = epoll_wait(epoll_fd, events, <span class="number">10000</span>, <span class="number">2000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; fds; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">if</span> (!read_once(sockfd, buffer, <span class="number">2048</span>)) &#123;</span><br><span class="line">close_conn(epoll_fd, sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>&#123;</span>&#125;;</span><br><span class="line">event.events = EPOLLOUT | EPOLLET | EPOLLERR;</span><br><span class="line">event.data.fd = sockfd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &amp;event);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLOUT) &#123;</span><br><span class="line"><span class="keyword">if</span> (!write_nbytes(sockfd, request, <span class="built_in">strlen</span>(request))) &#123;</span><br><span class="line">close_conn(epoll_fd, sockfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">event</span>&#123;</span>&#125;;</span><br><span class="line">event.events = EPOLLIN | EPOLLET | EPOLLERR;</span><br><span class="line">event.data.fd = sockfd;</span><br><span class="line">epoll_ctl(epoll_fd, EPOLL_CTL_MOD, sockfd, &amp;event);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLERR) &#123;</span><br><span class="line">close_conn(epoll_fd, sockfd);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第十七章-系统监测工具"><a href="#第十七章-系统监测工具" class="headerlink" title="第十七章 系统监测工具"></a>第十七章 系统监测工具</h3><p>Linux提供了很多有用的工具，以方便开发人员调试和测评服务器程序。</p><h4 id="17-1-tcpdump"><a href="#17-1-tcpdump" class="headerlink" title="17.1 tcpdump"></a>17.1 tcpdump</h4><p>tcpdump是一款经典的网络抓包工具。tcpdump给使用者提供了大量的选项，用以过滤数据包或者定制输 出格式。</p><p>现在我们把常见的选项 总结如下：</p><ul><li><p>-n，使用 IP 地址表示主机，而不是主机名；使用数字表示端口 号，而不是服务名称。</p></li><li><p>-i，指定要监听的网卡接口。“-i any”表示抓取所有网卡接口上 的数据包。</p></li><li><p>-v，输出一个稍微详细的信息，例如，显示IP数据包中的TTL和 TOS信息。</p></li><li><p>-t，不打印时间戳。 </p></li><li><p>-e，显示以太网帧头部信息。 </p></li><li><p>-c，仅抓取指定数量的数据包。 </p></li><li><p>-x，以十六进制数显示数据包的内容，但不显示包中以太网帧 的头部信息。 </p></li><li><p>-X，与-x选项类似，不过还打印每个十六进制字节对应的ASCII 字符。 </p></li><li><p>-XX，与-X相同，不过还打印以太网帧的头部信息。 </p></li><li><p>-s，设置抓包时的抓取长度。当数据包的长度超过抓取长度 时，tcpdump抓取到的将是被截断的数据包。</p><blockquote><p>在4.0以及之前的版本 中，默认的抓包长度是68字节。这对于IP、TCP和UDP等协议就已经 足够了，但对于像DNS、NFS这样的协议，68字节通常不能容纳一个 完整的数据包。比如我们在1.6.3小节抓取DNS数据包时，就使用了-s 选项（测试机器ernest-laptop上，tcpdump的版本是4.0.0）。不过4.0之 后的版本，默认的抓包长度被修改为65 535字节，因此我们不用再担 心抓包长度的问题了。 </p></blockquote></li><li><p>-S，以绝对值来显示TCP报文段的序号，而不是相对值。 </p></li><li><p>-w，将tcpdump的输出以特殊的格式定向到某个文件。 </p></li><li><p>-r，从文件读取数据包信息并显示之。</p></li></ul><h4 id="17-2-lsof"><a href="#17-2-lsof" class="headerlink" title="17.2 lsof"></a>17.2 lsof</h4><p>lsof（list open file）是一个列出当前系统打开的文件描述符的工 具。通过它我们可以了解感兴趣的进程打开了哪些文件描述符，或者 我们感兴趣的文件描述符被哪些进程打开了。</p><ul><li><p>-i，显示socket文件描述符。  如果-i选项后不指定任何参数，则lsof命令将显示所有socket文件 描述符。  该选项的使用方法是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsof-i[46][protocol][@hostname|ipaddr][:service|port]</span><br></pre></td></tr></table></figure><p>其中，4表示IPv4协议，6表示IPv6协议；protocol指定传输层协 议，可以是TCP或者UDP；hostname指定主机名；ipaddr指定主机的IP 地址；service指定服务名；port指定端口号。</p></li><li><p>-u，显示指定用户启动的所有进程打开的所有文件描述符。</p></li><li><p>-c，显示指定的命令打开的所有文件描述符。</p></li><li><p>-p，显示指定进程打开的所有文件描述符。</p></li><li><p>-t，仅显示打开了目标文件描述符的进程的PID。</p></li></ul><h4 id="17-3-nc"><a href="#17-3-nc" class="headerlink" title="17.3 nc"></a>17.3 nc</h4><p>它主要被用来快速构建网络连接。我们可以让它以服务器方式运行， 监听某个端口并接收客户连接，因此它可用来调试客户端程序。我们 也可以使之以客户端方式运行，向服务器发起连接并收发数据，因此 它可以用来调试服务器程序，此时它有点像telnet程序。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- Listen on a specified port and <span class="built_in">print</span> any data received:</span><br><span class="line">   nc -l &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Connect to a certain port:</span><br><span class="line">   nc &#123;&#123;ip_address&#125;&#125; &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Set a timeout:</span><br><span class="line">   nc -w &#123;&#123;timeout_in_seconds&#125;&#125; &#123;&#123;ipaddress&#125;&#125; &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Keep the server up after the client detaches:</span><br><span class="line">   nc -k -l &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Keep the client up even after EOF:</span><br><span class="line">   nc -q &#123;&#123;timeout&#125;&#125; &#123;&#123;ip_address&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Scan the open ports of a specified host:</span><br><span class="line">   nc -v -z &#123;&#123;ip_address&#125;&#125; &#123;&#123;port&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Act as proxy and forward data from a <span class="built_in">local</span> TCP port to the given remote host:</span><br><span class="line">   nc -l &#123;&#123;local_port&#125;&#125; | nc &#123;&#123;hostname&#125;&#125; &#123;&#123;remote_port&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="17-4-strace"><a href="#17-4-strace" class="headerlink" title="17.4 strace"></a>17.4 strace</h4><p>strace是测试服务器性能的重要工具。它跟踪程序运行过程中执行 的系统调用和接收到的信号，并将系统调用名、参数、返回值及信号 名输出到标准输出或者指定的文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- Start tracing a specific process by its PID:</span><br><span class="line">   strace -p &#123;&#123;pid&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Trace a process and filter output by system call:</span><br><span class="line">   strace -p &#123;&#123;pid&#125;&#125; -e &#123;&#123;system_call_name&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Count time, calls, and errors for each system call and report a summary on program exit:</span><br><span class="line">   strace -p &#123;&#123;pid&#125;&#125; -c</span><br><span class="line"></span><br><span class="line"> - Show the time spent in every system call:</span><br><span class="line">   strace -p &#123;&#123;pid&#125;&#125; -T</span><br><span class="line"></span><br><span class="line"> - Start tracing a program by executing it:</span><br><span class="line">   strace &#123;&#123;program&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Start tracing file operations of a program:</span><br><span class="line">   strace -e trace=file &#123;&#123;program&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="17-5-netstat"><a href="#17-5-netstat" class="headerlink" title="17.5 netstat"></a>17.5 netstat</h4><p>netstat是一个功能很强大的网络信息统计工具。它可以打印本地 网卡接口上的全部连接、路由表信息、网卡接口信息等。</p><p><strong>对本书而 言，我们主要利用的是上述功能中的第一个，即显示TCP连接及其状 态信息。</strong>毕竟，要获得路由表信息和网卡接口信息，我们可以使用输 出内容更丰富的route和ifconfig命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">- List all ports:</span><br><span class="line">  netstat --all</span><br><span class="line"></span><br><span class="line">- List all listening ports:</span><br><span class="line">  netstat --listening</span><br><span class="line"></span><br><span class="line">- List listening TCP ports:</span><br><span class="line">  netstat --tcp</span><br><span class="line"></span><br><span class="line">- Display PID and program names:</span><br><span class="line">  netstat --program</span><br><span class="line"></span><br><span class="line">- List information continuously:</span><br><span class="line">  netstat --continuous</span><br><span class="line"></span><br><span class="line">- List routes and do not resolve IP addresses to hostnames:</span><br><span class="line">  netstat --route --numeric</span><br><span class="line"></span><br><span class="line">- List listening TCP and UDP ports (+ user and process if you&#x27;re root):</span><br><span class="line">  netstat --listening --program --numeric --tcp --udp --extend</span><br></pre></td></tr></table></figure><h4 id="17-6-vmstat"><a href="#17-6-vmstat" class="headerlink" title="17.6 vmstat"></a>17.6 vmstat</h4><p>vmstat是virtual memory statistics的缩写，它能实时输出系统的各 种资源的使用情况，比如进程信息、内存使用、CPU使用率以及I/O使 用情况。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- Display virtual memory statistics:</span><br><span class="line">  vmstat</span><br><span class="line"></span><br><span class="line">- Display reports every 2 seconds for 5 times:</span><br><span class="line">  vmstat &#123;&#123;2&#125;&#125; &#123;&#123;5&#125;&#125;</span><br></pre></td></tr></table></figure><h4 id="17-7-ifstat"><a href="#17-7-ifstat" class="headerlink" title="17.7 ifstat"></a>17.7 ifstat</h4><p>ifstat是interface statistics的缩写，它是一个简单的网络流量监测工 具。</p><ul><li>-a，监测系统上的所有网卡接口。 </li><li>-i，指定要监测的网卡接口。 </li><li>-t，在每行输出信息前加上时间戳。 </li><li>-b，以Kbit/s为单位显示数据，而不是默认的KB/s。 </li><li>delay，采样间隔（单位是s），即每隔delay的时间输出一次统 计信息。 </li><li>count，采样次数，即共输出count次统计信息。</li></ul><h4 id="17-8-mpstat"><a href="#17-8-mpstat" class="headerlink" title="17.8 mpstat"></a>17.8 mpstat</h4><p>mpstat是multi-processor statistics的缩写，它能实时监测多处理器 系统上每个CPU的使用情况。mpstat命令和iostat命令通常都集成在包 sysstat中，安装sysstat即可获得这两个命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- Display CPU statistics every 2 seconds:</span><br><span class="line">   mpstat &#123;&#123;2&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Display 5 reports, one by one, at 2 second intervals:</span><br><span class="line">   mpstat &#123;&#123;2&#125;&#125; &#123;&#123;5&#125;&#125;</span><br><span class="line"></span><br><span class="line"> - Display 5 reports, one by one, from a given processor, at 2 second intervals:</span><br><span class="line">   mpstat -P &#123;&#123;0&#125;&#125; &#123;&#123;2&#125;&#125; &#123;&#123;5&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二 高性能服务器框架</title>
      <link href="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/"/>
      <url>/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/</url>
      
        <content type="html"><![CDATA[<h2 id="第二篇-高性能服务器框架"><a href="#第二篇-高性能服务器框架" class="headerlink" title="第二篇 高性能服务器框架"></a>第二篇 高性能服务器框架</h2><h3 id="第5章-Linux网络编程基础API"><a href="#第5章-Linux网络编程基础API" class="headerlink" title="第5章 Linux网络编程基础API"></a>第5章 Linux网络编程基础API</h3><p>我们将从如 下3个方面讨论Linux网络API：</p><ul><li>socket地址API。socket最开始的含义是一个IP地址和端口对 （ip，port）。它唯一地表示了使用TCP通信的一端。本书称其为socket 地址。</li><li>socket基础API。socket的主要API都定义在sys/socket.h头文件 中，包括创建socket、命名socket、监听socket、接受连接、发起连接、 读写数据、获取地址信息、检测带外标记，以及读取和设置socket选 项。</li><li>网络信息API。Linux提供了一套网络信息API，以实现主机名和 IP地址之间的转换，以及服务名称和端口号之间的转换。这些API都定 义在netdb.h头文件中，我们将讨论其中几个主要的函数。</li></ul><h4 id="5-1-socket地址API"><a href="#5-1-socket地址API" class="headerlink" title="5.1 socket地址API"></a>5.1 socket地址API</h4><h5 id="5-1-1-主机字节序和网络字节序"><a href="#5-1-1-主机字节序和网络字节序" class="headerlink" title="5.1.1 主机字节序和网络字节序"></a>5.1.1 主机字节序和网络字节序</h5><p>现代CPU的累加器一次都能装载（至少）4字节（这里考虑32位 机，下同），即一个整数。那么这4字节在内存中排列的顺序将影响它 被累加器装载成的整数的值。这就是字节序问题。</p><p>字节序分为大端字 节序（big endian）和小端字节序（little endian）。</p><ul><li>大端字节序是指一 个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0 ～7 bit）存储在内存的高地址处。</li><li>小端字节序则是指整数的高位字节存 储在内存的高地址处，而低位字节则存储在内存的低地址处。</li></ul><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224104317174-1678341964415.png" class="" title="image-20230224104317174"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 判断机器字节序</span></span><br><span class="line"><span class="comment">// union 参考https://www.cnblogs.com/linyx/p/3998893.html</span></span><br><span class="line"><span class="comment">// 在一个union类型结构中,所有的成员公用同样的存储空间,其占用的大小为其成员中需要空间最大者；</span></span><br><span class="line"><span class="comment">// union本身只保留一块地址空间，因为只有一个成员真正存储于该地址， 但这块地址也要满足内存对齐原则。</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">byteorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line"><span class="keyword">short</span> value;</span><br><span class="line"><span class="keyword">char</span> union_bytes[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">&#125; test;</span><br><span class="line"></span><br><span class="line">test.value = <span class="number">0x0102</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">1</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">2</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;big endian\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> ((test.union_bytes[<span class="number">0</span>] == <span class="number">2</span>) &amp;&amp; (test.union_bytes[<span class="number">1</span>] == <span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;little endian\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unknown...\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发送端总是把要发送的数据转化成大端字节序数据后 再发送，而接收端知道对方传送过来的数据总是采用大端字节序，所 以接收端可以根据自身采用的字节序决定是否对接收到的数据进行转 换（小端机转换，大端机不转换）。</p><p>因此大端字节序也称为网络字节 序，它给所有接收数据的主机提供了一个正确解释收到的格式化数据 的保证。</p><p>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的 转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="comment">// 如htonl表示“host to network long”，即将长整型（32 bit）的主机字节序数据转化为网络字节序数据。这4个函数中，长整型函数通常用来转换IP地址，短整型函数用来转换端口号</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="5-1-2-通用socket地址"><a href="#5-1-2-通用socket地址" class="headerlink" title="5.1.2 通用socket地址"></a>5.1.2 通用socket地址</h5><p>socket网络编程接口中表示socket地址的是结构体sockaddr，其定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>sa_family成员是地址族类型（sa_family_t）的变量。地址族类型通 常与协议族类型对应。常见的协议族（protocol family，也称domain， 见后文）和对应的地址族如表5-1所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224120412533-1678341964416.png" class="" title="image-20230224120412533"><p>宏PF_<em>和AF_</em>都定义在bits/socket.h头文件中，且后者与前者有完 全相同的值，所以二者通常混用。</p><p>sa_data成员用于存放socket地址值。但是，不同的协议族的地址值 具有不同的含义和长度，如表5-2所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224133658704-1678341964416.png" class="" title="image-20230224133658704"><p>由表5-2可见，<strong>14字节的sa_data根本无法完全容纳多数协议族的地 址值。</strong>因此，Linux定义了下面这个新的通用socket地址结构体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> int__ss_align;</span><br><span class="line"><span class="keyword">char</span> __ss_padding[<span class="number">128</span>-<span class="keyword">sizeof</span>(__ss_align)];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-1-3-专用socket地址"><a href="#5-1-3-专用socket地址" class="headerlink" title="5.1.3 专用socket地址"></a>5.1.3 专用socket地址</h5><p>上面这两个通用socket地址结构体显然很不好用，比如设置与获取 IP地址和端口号就需要执行烦琐的位操作。</p><p>所以Linux为各个协议族提 供了专门的socket地址结构体。UNix忽略.</p><p>TCP/IP协议族有sockaddr_in和sockaddr_in6两个专用socket地址结构 体，它们分别用于IPv4和IPv6：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ipV4</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_INET*/</span></span><br><span class="line"><span class="keyword">u_int16_t</span> sin_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/*IPv4地址结构体，见下面*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">u_int32_t</span> s_addr;  <span class="comment">/*IPv4地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//ipV6</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin6_family;<span class="comment">/*地址族：AF_INET6*/</span></span><br><span class="line"><span class="keyword">u_int16_t</span> sin6_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line"><span class="keyword">u_int32_t</span> sin6_flowinfo;<span class="comment">/*流信息，应设置为0*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/*IPv6地址结构体，见下面*/</span></span><br><span class="line"><span class="keyword">u_int32_t</span> sin6_scope_id;<span class="comment">/*scope ID，尚处于实验阶段*/</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];<span class="comment">/*IPv6地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使 用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因 为所有socket编程接口使用的地址参数的类型都是sockaddr。</strong></p><h5 id="5-1-4-IP地址转换函数"><a href="#5-1-4-IP地址转换函数" class="headerlink" title="5.1.4 IP地址转换函数"></a>5.1.4 IP地址转换函数</h5><p>下 面3个函数可用于用<strong>点分十进制字符串表示的IPv4地址</strong>和用<strong>网络字节序 整数表示的IPv4地址</strong>之间的转换：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* strptr)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* cp, struct in_addr* inp)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>inet_addr函数将用点分十进制字符串表示的IPv4地址转化为用网络 字节序整数表示的IPv4地址。它失败时返回INADDR_NONE。</p></li><li><p>inet_aton函数完成和inet_addr同样的功能，但是将转化结果存储于 参数inp指向的地址结构中。它成功时返回1，失败则返回0。</p></li><li><p>inet_ntoa函数将用网络字节序整数表示的IPv4地址转化为用点分十 进制字符串表示的IPv4地址。但需要注意的是，该函数内部用一个静态变量存储转化结果，<strong>函数的返回值指向该静态内存</strong>，因此inet_ntoa是 不可重入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* szValue1=inet_ntoa(“<span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>”);</span><br><span class="line"><span class="keyword">char</span>* szValue2=inet_ntoa(“<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span>”);</span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">1</span>:%s\n”,szValue1);</span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">2</span>:%s\n”,szValue2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果</span></span><br><span class="line">address1:<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br><span class="line">address2:<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span></span><br></pre></td></tr></table></figure></li></ul><p>下面这对更新的函数也能完成和前面3个函数同样的功能，并且它 们同时适用于IPv4地址和IPv6地址：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af,<span class="keyword">const</span> <span class="keyword">char</span>* src,<span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>* src,<span class="keyword">char</span>* dst,<span class="keyword">socklen_t</span> cnt)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>inet_pton函数将用字符串表示的IP地址src（用点分十进制字符串表 示的IPv4地址或用十六进制字符串表示的IPv6地址）转换成用网络字节 序整数表示的IP地址，并把<strong>转换结果存储于dst指向的内存中</strong>。其中，af 参数指定地址族，可以是AF_INET或者AF_INET6。inet_pton成功时返 回1，失败则返回0并设置errno[1]。</li><li>inet_ntop函数进行相反的转换，前三个参数的含义与inet_pton的参 数相同，最后一个参数cnt指定目标存储单元的大小。</li></ul><h4 id="5-2-创建socket"><a href="#5-2-创建socket" class="headerlink" title="5.2 创建socket"></a>5.2 创建socket</h4><p>UNIX/Linux的一个哲学是：所有东西都是文件。socket也不例 外，它就是可读、可写、可控制、可关闭的文件描述符。</p><p>下面的 socket系统调用可创建一个socket：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>domain参数告诉系统使用哪个底层协议族。对TCP/IP协议族而 言，该参数应该设置为PF_INET（Protocol Family of Internet，用于 IPv4）或PF_INET6（用于IPv6）；对于UNIX本地域协议族而言，该 参数应该设置为PF_UNIX。</li><li>type参数指定服务类型。服务类型主要有SOCK_STREAM服务 （流服务）和SOCK_UGRAM（数据报）服务。<strong>对TCP/IP协议族而 言，其值取SOCK_STREAM表示传输层使用TCP协议，取 SOCK_DGRAM表示传输层使用UDP协议。</strong></li><li>protocol参数是在前两个参数构成的协议集合下，再选择一个具体 的协议。不过这个值通常都是唯一的（前两个参数已经完全决定了它 的值）。几乎在所有情况下，我们都应该把它设置为0，表示使用默认 协议。</li></ul><p>socket系统调用成功时返回一个socket文件描述符，失败则返回-1 并设置errno。</p><h4 id="5-3-命名socket"><a href="#5-3-命名socket" class="headerlink" title="5.3 命名socket"></a>5.3 命名socket</h4><p>创建socket时，我们给它指定了地址族，但是并未指定使用该地 址族中的哪个具体socket地址。将一个socket与socket地址绑定称为给 socket命名。</p><p>只有命名 后客户端才能知道该如何连接它。客户端则通常不需要命名socket， 而是采用匿名方式，即使用操作系统自动分配的socket地址。命名 socket的系统调用是bind，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>bind将my_addr所指的socket地址分配给未命名的sockfd文件描述 符，addrlen参数指出该socket地址的长度。</p><p>bind成功时返回0，失败则返回-1并设置errno。其中两种常见的 errno是EACCES和EADDRINUSE，它们的含义分别是：</p><ul><li>EACCES，被绑定的地址是受保护的地址，仅超级用户能够访 问。比如普通用户将socket绑定到知名服务端口（端口号为0～1023） 上时，bind将返回EACCES错误。</li><li>EADDRINUSE，被绑定的地址正在使用中。比如将socket绑定 到一个处于TIME_WAIT状态的socket地址。</li></ul><h4 id="5-4-监听socket"><a href="#5-4-监听socket" class="headerlink" title="5.4 监听socket"></a>5.4 监听socket</h4><p>socket被命名之后，还不能马上接受客户连接，我们需要使用如 下系统调用来创建一个监听队列以存放待处理的客户连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数指定被监听的socket。backlog参数提示内核监听队列的最大长度。监听队列的长度如果超过backlog，服务器将不受理新的客 户连接，客户端也将收到ECONNREFUSED错误信息。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/2/24.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGTERM信号的处理函数，触发时结束主程序中的循环*/</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_term</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">signal(SIGTERM, handle_term);</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number backlog\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> backlog = atoi(argv[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sock&gt;=<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建一个IPv4 socket地址*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line"><span class="comment">// inet_pton函数将用字符串表示的IP地址 src 转换成用网络字节 序整数表示的IP地址，</span></span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line"></span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> ret = bind(sock,(struct sockaddr*)&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = listen(sock, backlog);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*循环等待连接，直到有SIGTERM信号将它中断*/</span></span><br><span class="line"><span class="keyword">while</span> (!stop) &#123;</span><br><span class="line">sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*关闭socket，见后文*/</span></span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224203335190-1678341964416.png" class="" title="image-20230224203335190"><p>可见，在监听队列中，处于ESTABLISHED状态的连接只有6个 （backlog值加1），其他的连接都处于SYN_RCVD状态。</p><h4 id="5-5-接受连接"><a href="#5-5-接受连接" class="headerlink" title="5.5 接受连接"></a>5.5 接受连接</h4><p>下面的系统调用从listen监听队列中接受一个连接：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd参数是执行过listen系统调用的监听socket[1]。</li><li>addr参数用来获取被接受连接的远端socket地址，该socket地址的长度由addrlen参数 指出。</li></ul><p>accept成功时返回一个新的连接socket，该socket唯一地标识了 被接受的这个连接，服务器可通过读写该socket来与被接受连接对应 的客户端通信。accept失败时返回-1并设置errno。</p><p>如果监听队列中处于ESTABLISHED状态的 连接对应的客户端出现网络异常（比如掉线），或者提前退出，那么 服务器对这个连接执行的accept调用是否成功？</p><p>做实验说明,   <strong>accept只是从监听队列中取出连接，而不论连接处于 何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更 不关心任何网络状况的变化。</strong></p><h4 id="5-6-发起连接"><a href="#5-6-发起连接" class="headerlink" title="5.6 发起连接"></a>5.6 发起连接</h4><p>客户端主动建立连接</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数由socket系统调用返回一个socket。serv_addr参数是服 务器监听的socket地址，addrlen参数则指定这个地址的长度。</p><p>connect成功时返回0。一旦成功建立连接，sockfd就唯一地标识了 这个连接，客户端就可以通过读写sockfd来与服务器通信。connect失 败则返回-1并设置errno。</p><p>其中两种常见的errno是ECONNREFUSED和 ETIMEDOUT，它们的含义如下： </p><ul><li><p>ECONNREFUSED，目标端口不存在，连接被拒绝。我们在 3.5.1小节讨论过这种情况。 </p></li><li><p>ETIMEDOUT，连接超时。我们在3.3.3小节讨论过这种情况。</p></li></ul><h4 id="5-7-关闭连接"><a href="#5-7-关闭连接" class="headerlink" title="5.7 关闭连接"></a>5.7 关闭连接</h4><p>关闭一个连接实际上就是关闭该连接对应的socket，这可以通过如下<strong>关闭普通文件描述符的系统调用</strong>来完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure><p>fd参数是待关闭的socket。不过，close系统调用并非总是立即关闭 一个连接，而是将fd的引用计数减1。<strong>只有当fd的引用计数为0时，才真正关闭连接。</strong>多进程程序中，一次fork系统调用默认将使父进程中打开 的socket的引用计数加1，因此我们必须在父进程和子进程中都对该 socket执行close调用才能将连接关闭。</p><p>如果想强制关闭的话, 可以使用如下的shutdown系统调用（相对于close来说，它是专门 为网络编程设计的）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure><p>sockfd参数是待关闭的socket。howto参数决定了shutdown的行为， 它可取表5-3中的某个值。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224204515803-1678341964416.png" class="" title="image-20230224204515803"><p>由此可见，shutdown能够分别关闭socket上的读或写，或者都关 闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p><h4 id="5-8-数据读写"><a href="#5-8-数据读写" class="headerlink" title="5.8 数据读写"></a>5.8 数据读写</h4><h5 id="5-8-1-TCP数据读写"><a href="#5-8-1-TCP数据读写" class="headerlink" title="5.8.1 TCP数据读写"></a>5.8.1 TCP数据读写</h5><p><strong>对文件的读写操作read和write同样适用于socket。</strong>但是socket编程接 口提供了几个专门用于socket数据读写的系统调用，它们增加了对数据 读写的控制。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>*buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>*buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>recv读取sockfd上的数据，buf和len参数分别指定读缓冲区的位置和大小，flags参数的含义见后文，通常设置为0即可。</strong></p><p>recv成功时返回实际读取到的数据的长度，它可能小于我们期望的长度len。因此我们 可能要多次调用recv，才能读取到完整的数据。recv可能返回0，这意 味着通信对方已经关闭连接了。recv出错时返回-1并设置errno。</p><p>send往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置 和大小。send成功时返回实际写入的数据的长度，失败则返回-1并设置 errno。</p><p>flags参数为数据收发提供了额外的控制，它可以取表5-4所示选项 中的一个或几个的逻辑或。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224205138815-1678341964416.png" class="" title="image-20230224205138815"><p>实验结果: </p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230224211104916-1678341964416.png" class="" title="image-20230224211104916"><p>客户端发送给服务器的3字节的带外数据“abc”中，仅有 最后一个字符“c”被服务器当成真正的带外数据接收（正如3.8节讨论的 那样）。并且，服务器对正常数据的接收将被带外数据截断，即前一 部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全 部读出的。</p><h5 id="5-8-2-UDP数据读写"><a href="#5-8-2-UDP数据读写" class="headerlink" title="5.8.2 UDP数据读写"></a>5.8.2 UDP数据读写</h5><p>socket编程接口中用于UDP数据报读写的系统调用是：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags,struct sockaddr* src_addr,<span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf,<span class="keyword">size_t</span> len,<span class="keyword">int</span> flags,<span class="keyword">const</span> struct sockaddr* dest_addr,<span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>recvfrom读取sockfd上的数据，buf和len参数分别指定读缓冲区的位 置和大小。因为UDP通信没有连接的概念，所以我们每次读取数据都 需要获取发送端的socket地址，即参数src_addr所指的内容，addrlen参数则指定该地址的长度。</li><li>sendto往sockfd上写入数据，buf和len参数分别指定写缓冲区的位置 和大小。dest_addr参数指定接收端的socket地址，addrlen参数则指定该 地址的长度。 </li><li>这两个系统调用的flags参数以及返回值的含义均与send/recv系统调 用的flags参数及返回值相同。</li></ul><h5 id="5-8-3-通用数据读写函数"><a href="#5-8-3-通用数据读写函数" class="headerlink" title="5.8.3 通用数据读写函数"></a>5.8.3 通用数据读写函数</h5><p>socket编程接口还提供了一对通用的数据读写系统调用。它们不仅 能用于TCP流数据，也能用于UDP数据报, 在第13.9章节进程间传递文件描述符 用到了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd,struct msghdr*msg,<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd,struct msghdr*msg,<span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>sockfd参数指定被操作的目标socket。</p></li><li><p>msg参数是msghdr结构体类 型的指针，msghdr结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span>*msg_name;<span class="comment">/*socket地址*/</span></span><br><span class="line"><span class="keyword">socklen_t</span> msg_namelen;<span class="comment">/*socket地址的长度*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>*<span class="title">msg_iov</span>;</span><span class="comment">/*分散的内存块，见后文*/</span></span><br><span class="line"><span class="keyword">int</span> msg_iovlen;<span class="comment">/*分散内存块的数量*/</span></span><br><span class="line">    <span class="keyword">void</span>*msg_control;<span class="comment">/*指向辅助数据的起始位置*/</span></span><br><span class="line"><span class="keyword">socklen_t</span> msg_controllen;<span class="comment">/*辅助数据的大小*/</span></span><br><span class="line"><span class="keyword">int</span> msg_flags;<span class="comment">/*复制函数中的flags参数，并在调用过程中更新*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>msg_name成员指向一个socket地址结构变量。它指定通信对方的 socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置 为NULL。这是因为对数据流socket而言，对方的地址已经知道。</p></li><li><p>msg_namelen成员则指定了msg_name所指socket地址的长度。</p></li><li><p>msg_iov成员是iovec结构体类型的指针，iovec结构体封装了一块内存的起始位置和长度。 iovec结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span>* iov_base;<span class="comment">/*内存起始地址*/</span></span><br><span class="line"><span class="keyword">size_t</span> iov_len;<span class="comment">/*这块内存的长度*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>msg_iovlen指定这样的iovec结构对象有多少个。对于recvmsg而言，数 据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长 度则由msg_iov指向的数组指定，这称为分散读（scatter read）；对于 sendmsg而言，msg_iovlen块分散内存中的数据将被一并发送，这称为 集中写（gather write）</p></li><li><p>msg_control和msg_controllen成员用于辅助数据的传送。我们不详 细讨论它们，仅在第13章介绍如何使用它们来实现在进程间传递文件 描述符。</p></li><li><p>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的 内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后 的标志设置到msg_flags中。</p></li></ul></li></ul><h4 id="5-9-带外标记"><a href="#5-9-带外标记" class="headerlink" title="5.9 带外标记"></a>5.9 带外标记</h4><p>在实际应用中， 我们通常无法预期带外数据何时到来。好在<strong>Linux内核检测到TCP紧急 标志</strong>时，将通知应用程序有带外数据需要接收。内核通知应用程序带 外数据到达的两种常见方式是：I/O复用产生的异常事件和SIGURG信 号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br></pre></td></tr></table></figure><p>sockatmark判断sockfd是否处于带外标记，即下一个被读取到的数 据是否是带外数据。如果是，sockatmark返回1，此时我们就可以利用 带MSG_OOB标志的recv调用来接收带外数据。如果不是，则 sockatmark返回0。</p><h4 id="5-10-地址信息函数"><a href="#5-10-地址信息函数" class="headerlink" title="5.10 地址信息函数"></a>5.10 地址信息函数</h4><p>在某些情况下，我们想知道一个连接socket的本端socket地址，以 及远端的socket地址。下面这两个函数正是用于解决这个问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br></pre></td></tr></table></figure><p>getsockname获取sockfd对应的本端socket地址，并将其存储于 address参数指定的内存中，该socket地址的长度则存储于address_len参 数指向的变量中。</p><p>getpeername获取sockfd对应的远端socket地址，其参数及返回值的 含义与getsockname的参数及返回值相同。</p><h4 id="5-11-socket-选项"><a href="#5-11-socket-选项" class="headerlink" title="5.11 socket 选项"></a>5.11 socket 选项</h4><p>如果说<strong>fcntl系统调用（文件描述符控制）</strong>是控制文件描述符属性的通用POSIX（可移植操作系统接口）方法，那 么下面两个系统调用则是专门用来读取和设置socket文件描述符属性的 方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> level,<span class="keyword">int</span> option_name,<span class="keyword">void</span>* option_value,<span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> level,<span class="keyword">int</span> option_name,<span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sockfd参数指定被操作的目标socket。level参数指定要操作哪个协 议的选项（即属性），比如IPv4、IPv6、TCP等。option_name参数则指 定选项的名字。我们在表5-5中列举了socket通信中几个比较常用的 socket选项。option_value和option_len参数分别是被操作选项的值和长 度。</li><li><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304223735943.png" class="" title="image-20230304223735943"></li></ul><p>暂时用不到， 略过一部分。</p><h5 id="5-11-1-SO-REUSEADDR选项"><a href="#5-11-1-SO-REUSEADDR选项" class="headerlink" title="5.11.1 SO_REUSEADDR选项"></a>5.11.1 SO_REUSEADDR选项</h5><p>我们在3.4.2小节讨论过TCP连接的TIME_WAIT状态，并提到服务 器程序可以通过设置socket选项SO_REUSEADDR来强制使用被处于 TIME_WAIT状态的连接占用的socket地址。具体实现方法如代码清单5- 9所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reuse=<span class="number">1</span>;</span><br><span class="line">setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,＆reuse,<span class="keyword">sizeof</span>(reuse));</span><br></pre></td></tr></table></figure><p>经过setsockopt的设置之后，即使sock处于TIME_WAIT状态，与之 绑定的socket地址也可以立即被重用。</p><h5 id="5-11-4-SO-LINGER选项"><a href="#5-11-4-SO-LINGER选项" class="headerlink" title="5.11.4 SO_LINGER选项"></a>5.11.4 SO_LINGER选项</h5><p>SO_LINGER选项用于控制close系统调用在关闭TCP连接时的行为。</p><p>默认情况下，当我们使用close系统调用来关闭一个socket时，close 将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的 数据发送给对方。</p><p>设置（获取）SO_LINGER选项的值时，我们需要给 setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定 义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> l_onoff;<span class="comment">/*开启（非0）还是关闭（0）该选项*/</span></span><br><span class="line"><span class="keyword">int</span> l_linger;<span class="comment">/*滞留时间*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>根据linger结构体中两个成员变量的不同值，close系统调用可能产 生如下3种行为之一：</p><ul><li>l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为 来关闭socket。</li><li>l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP 模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时 给对方发送一个复位报文段（见3.5.2小节）。因此，这种情况给服务 器提供了异常终止一个连接的方法。</li><li>l_onoff不为0，l_linger大于0。此时close的行为取决于两个条 件：一是被关闭的socket对应的TCP发送缓冲区中是否还有残留的数 据；二是该socket是阻塞的，还是非阻塞的。对于阻塞的socket，close 将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并 得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到 对方的确认，那么close系统调用将返回-1并设置errno为 EWOULDBLOCK。如果socket是非阻塞的，close将立即返回，此时我 们需要根据其返回值和errno来判断残留数据是否已经发送完毕。</li></ul><h4 id="5-12-网络信息API"><a href="#5-12-网络信息API" class="headerlink" title="5.12 网络信息API"></a>5.12 网络信息API</h4><p>socket地址的两个要素，即IP地址和端口号，都是用数值表示的。 这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。因此在前面 的章节中，我们用主机名来访问一台机器，而避免直接使用其IP地 址。同样，我们用服务名称来代替端口号。</p><h5 id="5-12-1-gethostbyname和gethostbyaddr"><a href="#5-12-1-gethostbyname和gethostbyaddr" class="headerlink" title="5.12.1 gethostbyname和gethostbyaddr"></a>5.12.1 gethostbyname和gethostbyaddr</h5><p>gethostbyname函数<strong>根据主机名称获取主机的完整信息</strong>， gethostbyaddr函数<strong>根据IP地址获取主机的完整信息。</strong></p><ul><li>gethostbyname函数 通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访 问DNS服务器。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function">struct hostent*<span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*name)</span></span>;</span><br><span class="line"><span class="function">struct hostent*<span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>name参数指定目标主机的主机名，</li><li>addr参数指定目标主机的IP地 址，</li><li>len参数指定addr所指IP地址的长度，</li><li>type参数指定addr所指IP地址 的类型，其合法取值包括AF_INET（用于IPv4地址）和AF_INET6（用 于IPv6地址）。</li></ul><p>这两个函数返回的都是hostent结构体类型的指针，hostent结构体的 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>*h_name;<span class="comment">/*主机名*/</span></span><br><span class="line"><span class="keyword">char</span>**h_aliases;<span class="comment">/*主机别名列表，可能有多个*/</span></span><br><span class="line"><span class="keyword">int</span> h_addrtype;<span class="comment">/*地址类型（地址族）*/</span></span><br><span class="line"><span class="keyword">int</span> h_length;<span class="comment">/*地址长度*/</span></span><br><span class="line"><span class="keyword">char</span>**h_addr_list;<span class="comment">/*按网络字节序列出的主机IP地址列表*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="5-12-2-getservbyname和getservbyport"><a href="#5-12-2-getservbyname和getservbyport" class="headerlink" title="5.12.2 getservbyname和getservbyport"></a>5.12.2 getservbyname和getservbyport</h5><p>getservbyname函数根据名称获取某个服务的完整信息， getservbyport函数根据端口号获取某个服务的完整信息。</p><p>它们实际上都 是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name,<span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port,<span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>name参数指定目标服务的名字，</li><li>port参数指定目标服务对应的端口 号。</li><li>proto参数指定服务类型，给它传递“tcp”表示获取流服务，给它传 递“udp”表示获取数据报服务，给它传递NULL则表示获取所有类型的 服务。</li></ul><p>这两个函数返回的都是servent结构体类型的指针，结构体servent的 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">char</span>*s_name;<span class="comment">/*服务名称*/</span></span><br><span class="line"><span class="keyword">char</span>**s_aliases;<span class="comment">/*服务的别名列表，可能有多个*/</span></span><br><span class="line"><span class="keyword">int</span> s_port;<span class="comment">/*端口号*/</span></span><br><span class="line"><span class="keyword">char</span>*s_proto;<span class="comment">/*服务类型,通常是tcp或者udp*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="5-12-3-getaddrinfo"><a href="#5-12-3-getaddrinfo" class="headerlink" title="5.12.3 getaddrinfo"></a>5.12.3 getaddrinfo</h5><p>getaddrinfo函数既能通过主机名获得IP地址（内部使用的是 gethostbyname函数），也能通过服务名获得端口号（内部使用的是 getservbyname函数）。它是否可重入取决于其内部调用的 gethostbyname和getservbyname函数是否是它们的可重入版本。</p><p>该函数 的定义如下： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname,<span class="keyword">const</span> <span class="keyword">char</span>* service,<span class="keyword">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span>;</span><br></pre></td></tr></table></figure><p>hostname参数可以接收主机名，也可以接收字符串表示的IP地址 （IPv4采用点分十进制字符串，IPv6则采用十六进制字符串）。同样， service参数可以接收服务名，也可以接收字符串表示的十进制端口号。 hints参数是应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出 进行更精确的控制。hints参数可以被设置为NULL，表示允许 getaddrinfo反馈任何可用的结果。<strong>result参数指向一个链表，该链表用于 存储getaddrinfo反馈的结果。</strong></p><p>剩下内容 忽略.</p><h3 id="第6章-高级I-O函数"><a href="#第6章-高级I-O函数" class="headerlink" title="第6章 高级I/O函数"></a>第6章 高级I/O函数</h3><p>Linux提供了很多高级的I/O函数。它们并不像Linux基础I/O函数 （比如open和read）那么常用（编写内核模块时一般要实现这些I/O函 数），但在<strong>特定的条件下却表现出优秀的性能</strong>。</p><p><strong>本章将讨论其中和网络编程相关的几个，这些函数大致分为三类：</strong></p><ul><li>用于创建文件描述符的函数，包括pipe、dup/dup2函数。</li><li>用于读写数据的函数，包括readv/writev、sendfile、 mmap/munmap、splice和tee函数。</li><li>用于控制I/O行为和属性的函数，包括fcntl函数。</li></ul><h4 id="6-1-pipe函数"><a href="#6-1-pipe函数" class="headerlink" title="6.1 pipe函数"></a>6.1 pipe函数</h4><p>pipe函数可用于创建一个管道，以实现进程间通信。13.4节会讲解如何使用管道实现进程间通信.</p><p>pipe函数定义如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>pipe函数的参数是一个包含两个int型整数的数组指针。该函数成功时返回0，并将一对打开的文件描述符值填入其参数指向的数组。如 果失败，则返回-1并设置errno。</p><p><strong>通过pipe函数创建的这两个文件描述符fd[0]和fd[1]分别构成管道的两端，往fd[1]写入的数据可以从fd[0]读出。并且，fd[0]只能用于从管道读出数据，fd[1]则只能用于往管道写入数据，而不能反过来使用。</strong>如果要实现双向的数据传输，就应该使用两个管道。</p><p>默认情况 下，这一对文件描述符都是阻塞的。此时如果我们用read系统调用来 读取一个空的管道，则read将被阻塞，直到管道内有数据可读；如果 我们用write系统调用来往一个满的管道（见后文）中写入数据，则 write亦将被阻塞，直到管道有足够多的空闲空间可用。</p><p>管道内部传输的数据是字节流, 自Linux 2.6.11 内核起，管道容量的大小默认是65536字节。我们可以使用fcntl函数来 修改管道容量（见后文）。</p><p>此外，socket的基础API中有一个socketpair函数。它能够方便地创建双向管道。其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol,<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>socketpair前三个参数的含义与socket系统调用的三个参数完全相 同，但domain只能使用UNIX本地域协议族AF_UNIX，因为我们仅能 在本地使用这个双向管道。最后一个参数则和pipe系统调用的参数一 样，只不过socketpair创建的这对文件描述符都是既可读又可写的。 socketpair成功时返回0，失败时返回-1并设置errno。</p><h4 id="6-2-dup-函数和dup2函数"><a href="#6-2-dup-函数和dup2函数" class="headerlink" title="6.2 dup 函数和dup2函数"></a>6.2 dup 函数和dup2函数</h4><p>有时我们希望把标准输入重定向到一个文件，或者把标准输出重 定向到一个网络连接（比如CGI编程）。这可以通过下面的用于复制 文件描述符的dup或dup2函数来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> file_descriptor)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> file_descriptor_one,<span class="keyword">int</span> file_descriptor_two)</span></span>;</span><br></pre></td></tr></table></figure><p>dup函数创建一个新的文件描述符，该新文件描述符和原有文件描 述符file_descriptor指向相同的文件、管道或者网络连接。并且dup返回 的文件描述符总是取系统当前可用的最小整数值。</p><p>dup2和dup类似，不 过它将返回第一个不小于file_descriptor_two的整数值。dup和dup2系统 调用失败时返回-1并设置errno。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> connfd, sock;</span><br><span class="line">&#123;</span><br><span class="line">sock = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sock &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret = bind(sock, (struct sockaddr *) &amp; address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(sock, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client);</span><br><span class="line">connfd = accept(sock, (struct sockaddr *) &amp;client, &amp;client_addrlength);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">dup(connfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;abcd\n&quot;</span>);</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>我们先关闭标准输出文件描述符 STDOUT_FILENO（其值是1）</li><li>然后复制socket文件描述符connfd。 因为dup总是返回系统中最小的可用文件描述符，所以它的返回值实际 上是1，即之前关闭的标准输出文件描述符的值。</li><li>这样一来，服务器输 出到标准输出的内容（这里是“abcd”）就会直接发送到与客户连接对 应的socket上，因此printf调用的输出将被客户端获得（而不是显示在 服务器程序的终端上）。<strong>这就是CGI服务器的基本工作原理。</strong></li></ul><h4 id="6-3-readv函数和writev函数"><a href="#6-3-readv函数和writev函数" class="headerlink" title="6.3 readv函数和writev函数"></a>6.3 readv函数和writev函数</h4><p><strong>readv函数将数据从文件描述符读到分散的内存块中，即分散读； writev函数则将多块分散的内存数据一并写入文件描述符中，即集中写。</strong>它们的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/uio.h＞</span></span><br><span class="line">ssize_t readv(int fd,const struct iovec* vector, int count)；</span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">const</span> struct iovec* <span class="built_in">vector</span>, <span class="keyword">int</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p>fd参数是被操作的目标文件描述符。vector参数的类型是iovec结构 数组。我们在第5章讨论过结构体iovec，该结构体描述一块内存区。 count参数是vector数组的长度，即有多少块内存数据需要从fd读出或 写到fd。</p><p>readv和writev在成功时返回读出/写入fd的字节数，失败则返 回-1并设置errno。</p><p>清单6.2 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-4-sendfile函数"><a href="#6-4-sendfile函数" class="headerlink" title="6.4 sendfile函数"></a>6.4 sendfile函数</h4><p>sendfile函数在两个文件描述符之间直接传递数据（完全在内核中 操作），从而避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率 很高，这被称为零拷贝。</p><p>sendfile函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sendfile.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd,<span class="keyword">int</span> in_fd,<span class="keyword">off_t</span>*offset,<span class="keyword">size_t</span> count)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>in_fd参数是待读出内容的文件描述符，out_fd参数是待写入内容的文件描述符。</strong> offset参数指定从读入文件流的哪个位置开始读，如果 为空，则使用读入文件流默认的起始位置。count参数指定在文件描述 符in_fd和out_fd之间传输的字节数。</p><p><strong>in_fd 必须是一个支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；而out_fd则必须是一个socket。由此可见， sendfile几乎是专门为在网络上传输文件而设计的。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 关键部分</span></span><br><span class="line"><span class="comment">// connfd 是socket, filefd是打开的文件描述符, </span></span><br><span class="line"><span class="keyword">int</span> filefd=open(file_name,O_RDONLY);</span><br><span class="line">assert(filefd＞<span class="number">0</span>);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">fstat(filefd, &amp;stat_buf);</span><br><span class="line"></span><br><span class="line">sendfile(connfd,filefd,<span class="literal">NULL</span>,stat_buf.st_size);</span><br></pre></td></tr></table></figure><p>我们将目标文件作为第3个参数传递给服务器程 序，客户telnet到该服务器上即可获得该文件。代码清单6-3没有为目标文件分配任何用户空间的缓存，也没有执行读取 文件的操作，但同样实现了文件的发送，其效率显然要高得多。</p><h4 id="6-5-mmap函数和nummap函数"><a href="#6-5-mmap函数和nummap函数" class="headerlink" title="6.5 mmap函数和nummap函数"></a>6.5 mmap函数和nummap函数</h4><p><strong>mmap函数用于申请一段内存空间。我们可以将这段内存作为进程间通信的共享内存，也可以==将文件直接映射到其中==。</strong>munmap函数则释 放由mmap创建的这段内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/mman.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>*<span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot,<span class="keyword">int</span> flags,<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>*start,<span class="keyword">size_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>start参数允许用户使用某个特定的地址作为这段内存的起始地址。 如果它被设置成NULL，则系统自动分配一个地址。</p></li><li><p>length参数指定内 存段的长度。</p></li><li><p>prot参数用来设置内存段的访问权限。它可以取以下几个 值的按位或：</p><ul><li>PROT_READ，内存段可读。 </li><li>PROT_WRITE，内存段可写。 </li><li>PROT_EXEC，内存段可执行。 </li><li>PROT_NONE，内存段不能被访问。</li></ul></li><li><p>flags参数控制内存段内容被修改后程序的行为。它可以被设置为 表6-1中的某些值（这里仅列出了常用的值）的按位或（其中MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226134942673-1678341964416.png" class="" title="image-20230226134942673"></li><li><p>fd参数是被映射文件对应的文件描述符。它一般通过open系统调用获得。</p></li><li><p>offset参数设置从文件的何处开始映射（对于不需要读入整个文 件的情况）。</p></li></ul><p><strong>mmap函数成功时返回指向目标内存区域的指针</strong>，失败则返回 MAP_FAILED（(void*)-1）并设置errno。munmap函数成功时返回0， 失败则返回-1并设置errno。</p><h4 id="6-6-splice函数"><a href="#6-6-splice函数" class="headerlink" title="6.6 splice函数"></a>6.6 splice函数</h4><p>splice函数用于在两个文件描述符之间移动数据，也是零拷贝操 作。splice函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in,<span class="keyword">loff_t</span>* off_in,<span class="keyword">int</span> fd_out,<span class="keyword">loff_t</span>* off_out,<span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>fd_in参数是<strong>待输入数据</strong>的文件描述符。</p><p>如果fd_in是一个管道文件 描述符，那么off_in参数必须被设置为NULL。如果fd_in不是一个管道 文件描述符（比如socket），那么off_in表示从输入数据流的何处开始 读取数据。此时，若off_in被设置为NULL，则表示从输入数据流的当 前偏移位置读入；若off_in不为NULL，则它将指出具体的偏移位置。 </p><p>fd_out/off_out参数的含义与fd_in/off_in相同，不过用于输出数据流。len 参数指定移动数据的长度；flags参数则控制数据如何移动，它可以被 设置为表6-2中的某些值的按位或。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226135725302-1678341964416.png" class="" title="image-20230226135725302"><p><strong>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。</strong></p><h4 id="6-7-tee函数"><a href="#6-7-tee函数" class="headerlink" title="6.7 tee函数"></a>6.7 tee函数</h4><p><strong>tee函数在两个管道文件描述符之间复制数据，也是零拷贝操作。</strong> 它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操 作。tee函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="keyword">int</span> fd_in,<span class="keyword">int</span> fd_out,<span class="keyword">size_t</span> len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数的参数的含义与splice相同（但fd_in和fd_out必须都是管道 文件描述符）。tee函数成功时返回在两个文件描述符之间复制的数据 数量（字节数）。返回0表示没有复制任何数据。tee失败时返回-1并设 置errno。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-8-fcntl函数"><a href="#6-8-fcntl函数" class="headerlink" title="6.8 fcntl函数"></a>6.8 fcntl函数</h4><p>fcntl函数，正如其名字（file control）描述的那样，提供了对文件 描述符的各种控制操作。另外一个常见的控制文件描述符属性和行为 的系统调用是ioctl，而且ioctl比fcntl能够执行更多的控制。但是，对于控制文件描述符常用的属性和行为，<strong>fcntl函数是由POSIX规范指定的首 选方法。所以本书仅讨论fcntl函数</strong>。fcntl函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd,<span class="keyword">int</span> cmd,…)</span></span>;</span><br></pre></td></tr></table></figure><p>fd参数是被操作的文件描述符，cmd参数指定执行何种类型的操 作。根据操作类型的不同，该函数可能还需要第三个可选参数arg。 </p><p>fcntl函数支持的常用操作及其参数如表6-4所示。</p><p>![image-20230226141140857](二 高性能服务器框架/image-20230226141140857.png)</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230226141206370-1678341964416.png" class="" title="image-20230226141206370"><p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的，如代码清单6-6所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option=fcntl(fd,F_GETFL);<span class="comment">/*获取文件描述符旧的状态标志*/</span></span><br><span class="line"><span class="keyword">int</span> new_option=old_option|O_NONBLOCK;<span class="comment">/*设置非阻塞标志*/</span></span><br><span class="line">fcntl(fd,F_SETFL,new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;<span class="comment">/*返回文件描述符旧的状态标志，以便*/</span></span><br><span class="line"><span class="comment">/*日后恢复该状态标志*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第7章-Linux服务器程序规范"><a href="#第7章-Linux服务器程序规范" class="headerlink" title="第7章 Linux服务器程序规范"></a>第7章 Linux服务器程序规范</h3><p>除了网络通信外，服务器程序通常还必须考虑许多其他细节问 题。这些细节问题涉及面广且零碎，而且基本上是模板式的，所以我 们称之为服务器程序规范。比如：</p><ul><li>Linux服务器程序一般以后台进程形式运行。后台进程又称<strong>守护进程（daemon）</strong>。它没有控制终端，因而也不会意外接收到用户输 入。守护进程的父进程通常是init进程（PID为1的进程）。</li><li>Linux服务器程序通常有一套日志系统，它至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台 进程都在/var/log目录下拥有自己的日志目录。</li><li>Linux服务器程序一般以某个专门的非root身份运行。比如 mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、 apache和syslog。</li><li>Linux服务器程序通常是可配置的。服务器程序通常能处理很多 命令行选项，<strong>如果一次运行的选项太多，则可以用配置文件来管理。</strong> 绝大多数服务器程序都有配置文件，并存放在/etc目录下。比如第4章 讨论的squid服务器的配置文件是/etc/squid3/squid.conf。</li><li>Linux服务器进程通常会在启动的时候生成一个PID文件并存 入/var/run目录中，以记录该后台进程的PID。比如syslogd的PID文件 是/var/run/syslogd.pid。</li><li>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能 承受多大负荷，比如进程可用文件描述符总数和内存总量等。</li></ul><h4 id="7-1-日志"><a href="#7-1-日志" class="headerlink" title="7.1 日志"></a>7.1 日志</h4><h5 id="7-1-1-Linux系统日志"><a href="#7-1-1-Linux系统日志" class="headerlink" title="7.1.1 Linux系统日志"></a>7.1.1 Linux系统日志</h5><p>服务器的调试和维护都需要一个专业 的日志系统。Linux提供一个守护进程来处理系统日志——syslogd，不 过现在的Linux系统上使用的都是它的升级版——rsyslogd。</p><p>rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日 志。<strong>用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件/dev/log中， rsyslogd则监听该文件以获取用户进程的输出。</strong></p><p><strong>内核日志在老的系统上</strong>是通过另外一个守护进程rklogd来管理的，rsyslogd利用额外的模块实现了相同的功能。内核日志由printk等函数打印至内核的环状缓存 （ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。 rsyslogd则通过读取该文件获得内核日志。</p><p>rsyslogd守护进程在接收到用户进程或内核输入的日志后，会把它们输出至某些特定的日志文件。<strong>默认情况下，调试信息会保存 至/var/log/debug文件，普通信息保存至/var/log/messages文件，内核消息则保存至/var/log/kern.log文件。</strong></p><p>rsyslogd的主配置文件 是/etc/rsyslog.conf，其中主要可以设置的项包括：</p><ul><li>内核日志输入路径</li><li>是否接收UDP日志及其监听端口（默认是514，见/etc/services文件）</li><li>是否接收TCP日志及其监听端口</li><li>日志文件的权限</li><li>包含哪些子配置文 件（比如/etc/rsyslog.d/*.conf）</li></ul><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092105214-1678341964416.png" class="" title="image-20230228092105214"><h5 id="7-1-2-syslog-函数"><a href="#7-1-2-syslog-函数" class="headerlink" title="7.1.2 syslog 函数"></a>7.1.2 syslog 函数</h5><p><strong>应用程序使用syslog函数与rsyslogd守护进程通信。</strong> syslog函数的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span>*message,...)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数采用可变参数（第二个参数message和第三个参数…）来结 构化输出。</p><ul><li><p>priority参数是所谓的<strong>设施值与日志级别的按位或</strong>。设施值的默认值是LOG_USER，我们下面的讨论也只限于这一种设施值。日 志级别有如下几个：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092428475-1678341964416.png" class="" title="image-20230228092428475"></li></ul><p>下面这个函数可以改变syslog的默认输出方式，进一步结构化日志 内容：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ident,<span class="keyword">int</span> logopt,<span class="keyword">int</span> facility)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>ident参数指定的字符串将被添加到日志消息的日期和时间之后， 它通常被设置为程序的名字</p></li><li><p>logopt参数对后续syslog调用的行为进行配置，它可取<strong>下列值的按位或</strong>：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228092709404-1678341964416.png" class="" title="image-20230228092709404"></li><li><p>facility参数可用来修改syslog函数中的默认设施值。</p></li></ul><p>此外，日志的过滤也很重要。程序在开发阶段可能需要输出很多 调试信息，而发布之后我们又需要将这些调试信息关闭。简单地设置日志掩码，使<strong>日志级别大于日志掩码的日志信息被系统忽略。</strong>下面这个函数用于设置syslog的日志掩码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>maskpri参数指定日志掩码值。该函数始终会成功，它返回调用进程先前的日志掩码值。</li></ul><p>最后，不要忘了使用如下函数关闭日志功能：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="7-2-用户信息"><a href="#7-2-用户信息" class="headerlink" title="7.2 用户信息"></a>7.2 用户信息</h4><h5 id="7-2-1-UID、EUID和EGID"><a href="#7-2-1-UID、EUID和EGID" class="headerlink" title="7.2.1 UID、EUID和EGID"></a>7.2.1 UID、EUID和EGID</h5><p>用户信息对于服务器程序的安全性来说是很重要的，比如大部分 服务器就必须以root身份启动，但不能以root身份运行。</p><p>下面这一组函 数可以获取和设置当前进程的<strong>真实用户ID（UID）</strong>、<strong>有效用户 ID（EUID）</strong>、真实组ID（GID）和<strong>有效组ID（EGID）</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;<span class="comment">/*获取真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;<span class="comment">/*获取有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;<span class="comment">/*获取真实组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;<span class="comment">/*获取有效组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置真实用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置有效用户ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置真实组ID*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置有效组ID*/</span></span><br></pre></td></tr></table></figure><p>需要指出的是，一个进程拥有两个用户ID：UID和EUID。<strong>EUID 存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。</strong> </p><blockquote><p>比如su程序，任何用户都可以使用它来修改自己的账 户信息，但修改账户时su程序不得不访问/etc/passwd文件，而访问该 文件是需要root权限的。那么以普通用户身份启动的su程序如何能访 问/etc/passwd文件呢？窍门就在EUID。用ls命令可以查看到，su程序的所有者是root，<strong>并且它被设置了set-user-id标志。</strong></p><p>这个标志表示，任 何普通用户运行su程序时，其有效用户就是该程序的所有者root。那 么，根据有效用户的含义，任何运行su程序的普通用户都能够访 问/etc/passwd文件。有效用户为root的进程称为特权进程（privileged processes）。</p></blockquote><p>EGID的含义与EUID类似：<strong>给运行目标程序的组用户提 供有效组的权限</strong>。</p><p>代码: 编译该文件，将生成的可执行文件（名为test_uid）的所有者设置 为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID 和EUID。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo chown root:root test_uid<span class="comment">#修改目标文件的所有者为root</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo chmod+s test_uid<span class="comment">#设置目标文件的set-user-id标志</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./test_uid<span class="comment">#运行程序</span></span></span><br><span class="line">userid is 1000,effective userid is:0</span><br></pre></td></tr></table></figure><p>从测试程序的输出来看，进程的UID是启动程序的用户的ID，而 EUID则是root账户（文件所有者）的ID。</p><h5 id="7-2-2-切换用户"><a href="#7-2-2-切换用户" class="headerlink" title="7.2.2 切换用户"></a>7.2.2 切换用户</h5><p>下面的代码清单7-2展示了如何将以root身份启动的进程切换为以 一个普通用户身份运行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">switch_to_user</span><span class="params">(<span class="keyword">uid_t</span> user_id, <span class="keyword">gid_t</span> gp_id)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*先确保目标用户不是root*/</span></span><br><span class="line"><span class="keyword">if</span> ((user_id == <span class="number">0</span>) &amp;&amp; (gp_id == <span class="number">0</span>))</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*确保当前用户是合法用户：root或者目标用户*/</span></span><br><span class="line"><span class="keyword">gid_t</span> gid = getgid();</span><br><span class="line"><span class="keyword">uid_t</span> uid = getuid();</span><br><span class="line"><span class="keyword">if</span> (((gid != <span class="number">0</span>) || (uid != <span class="number">0</span>)) &amp;&amp; ((gid != gp_id) || (uid != user_id))) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果不是root，则已经是目标用户*/</span></span><br><span class="line"><span class="keyword">if</span> (uid != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切换到目标用户*/</span></span><br><span class="line"><span class="keyword">if</span> ((setgid(gp_id) &lt; <span class="number">0</span>) || (setuid(user_id) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-进程间关系"><a href="#7-3-进程间关系" class="headerlink" title="7.3 进程间关系"></a>7.3 进程间关系</h4><h5 id="7-3-1-进程组"><a href="#7-3-1-进程组" class="headerlink" title="7.3.1 进程组"></a>7.3.1 进程组</h5><p>Linux下每个进程都隶属于一个进程组，因此它们除了PID信息 外，还有进程组ID（PGID）。我们可以用如下函数来获取指定进程的 PGID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>该函数成功时返回进程pid所属进程组的PGID，失败则返回-1并设 置errno。</li></ul><p><strong>每个进程组都有一个首领进程，其PGID和PID相同</strong>。进程组将一 直存在，直到其中所有进程都退出，或者加入到其他进程组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数将PID为pid的进程的PGID设置为pgid。</p><ul><li>如果pid和pgid相 同，则由pid指定的进程将被设置为进程组首领；</li><li>如果pid为0，则表示 设置当前进程的PGID为pgid；</li><li>如果pgid为0，则使用pid作为目标 PGID。</li></ul><p>一个进程只能设置自己或者其子进程的PGID。并且，当子进程调 用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p><h5 id="7-3-2-会话（session）"><a href="#7-3-2-会话（session）" class="headerlink" title="7.3.2 会话（session）"></a>7.3.2 会话（session）</h5><p>一些有关联的进程组将形成一个会话（session）。下面的函数用于创建一个会话：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>该函数不能由进程组的首领进程调用，否则将产生一个错误。</strong></p><p>对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：</p><ul><li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li><li>新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领。</li><li>调用进程将甩开终端（如果有的话）。</li></ul><p>Linux进程并未提供所谓会话ID（SID）的概念，但Linux系统认为 它等于会话首领所在的进程组的PGID，并提供了如下函数来读取 SID：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="7-3-3-用ps命令查看进程关系"><a href="#7-3-3-用ps命令查看进程关系" class="headerlink" title="7.3.3 用ps命令查看进程关系"></a>7.3.3 用ps命令查看进程关系</h5><p>执行ps命令可查看进程、进程组和会话之间的关系：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228100733965-1678341964416.png" class="" title="image-20230228100733965"><ul><li>我们是在bash shell下执行ps和less命令的，所以ps和less命令的父进程是bash命令，这可以从PPID（父进程PID）一列看出。</li><li>这3条命令创 建了1个会话（SID是1943）和2个进程组（PGID分别是1943和 2298）。</li><li>bash命令的PID、PGID和SID都相同，很明显它既是会话的首 领，也是组1943的首领。</li><li>ps命令则是组2298的首领，因为其PID也是 2298。</li></ul><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228100847532-1678341964416.png" class="" title="image-20230228100847532"><h4 id="7-4-系统资源限制"><a href="#7-4-系统资源限制" class="headerlink" title="7.4 系统资源限制"></a>7.4 系统资源限制</h4><p>Linux上运行的程序都会受到资源限制的影响，比如物理设备限制 （CPU数量、内存数量等）、系统策略限制（CPU时间等），以及具 体实现的限制（比如文件名的最大长度）。</p><p>Linux系统资源限制可以通 过如下一对函数来读取和设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/resource.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource,struct rlimit* rlim)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource,<span class="keyword">const</span> struct rlimit* rlim)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>resource参数指定资源限制类型。</p><p>![image-20230228101329120](二 高性能服务器框架/image-20230228101329120.png)</p></li><li><p>setrlimit和getrlimit成功时返回0，失败则返回-1并设置errno。</p></li></ul><p>rlim参数是rlimit结构体类型的指针，rlimit结构体的定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">rlim_t</span> rlim_cur;</span><br><span class="line"><span class="keyword">rlim_t</span> rlim_max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li><p>rlim_t是一个整数类型，它描述资源级别。</p></li><li><p>rlim_cur成员指定资源 的软限制，rlim_max成员指定资源的硬限制。</p><blockquote><p>软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。例如，当进程CPU时间超过其软限制时，系统将向进 程发送SIGXCPU信号；当文件尺寸超过其软限制时，系统将向进程发 送SIGXFSZ信号（见第10章）。</p><p>硬限制一般是软限制的上限。普通程 序可以减小硬限制，而只有以root身份运行的程序才能增加硬限制。</p></blockquote></li><li><p>我们可以使用ulimit命令修改当前shell环境下的资源限制（软限制 或/和硬限制），这种修改将对该shell启动的所有后续程序有效。</p></li></ul><h4 id="7-5-改变工作目录和根目录"><a href="#7-5-改变工作目录和根目录" class="headerlink" title="7.5 改变工作目录和根目录"></a>7.5 改变工作目录和根目录</h4><p>有些服务器程序还需要改变工作目录和根目录，<strong>获取进程当前工作目录和改变进程工作目录的函数分别是：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">size_t</span> size)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>buf参数指向的内存用于存储进程当前工作目录的绝对路径名，其 大小由size参数指定。</li><li>如果当前工作目录的绝对路径的长度（再加上 一个空结束字符“\0”）超过了size，则getcwd将返回NULL，并设置 errno为ERANGE。</li><li>如果buf为NULL并且size非0，则getcwd可能在内部 使用malloc动态分配内存，并将进程的当前工作目录存储在其中。如 果是这种情况，则我们必须自己来释放getcwd在内部创建的这块内 存。</li><li>getcwd函数成功时返回一个指向目标存储区（buf指向的缓存区或 是getcwd在内部动态创建的缓存区）的指针，失败则返回NULL并设 置errno。</li></ul><p><strong>改变进程根目录</strong>的函数是chroot，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>只有特权进程才能改变根目录。</li><li>path参数指定要切换到的目标根目录。它成功时返回0，失败时返 回-1并设置errno。</li><li><strong>chroot并不改变进程的当前工作目录，所以调用 chroot之后，我们仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。</strong></li><li>在调用chroot之后，进程原先打开的文件描述符依然生效，所以我们 可以利用这些早先打开的文件描述符来访问调用chroot之后不能直接 访问的文件（和目录），尤其是一些日志文件。</li></ul><h4 id="7-6-服务器程序后台化"><a href="#7-6-服务器程序后台化" class="headerlink" title="7.6 服务器程序后台化"></a>7.6 服务器程序后台化</h4><p>最后，我们讨论如何在代码中让一个进程以守护进程的方式运 行。守护进程的编写遵循一定的步骤[2]，下面我们通过一个具体实现 来探讨，如代码清单7-3所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">daemonize</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*创建子进程，关闭父进程，这样可以使程序在后台运行*/</span></span><br><span class="line"><span class="keyword">pid_t</span> pid = fork();</span><br><span class="line"><span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置文件权限掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，</span></span><br><span class="line"><span class="comment"> * 文件的权限将是mode &amp;0777*/</span></span><br><span class="line">umask(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建新的会话，设置本进程为进程组的首领*/</span></span><br><span class="line"><span class="keyword">pid_t</span> sid = setsid();</span><br><span class="line"><span class="keyword">if</span> (sid &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*切换工作目录*/</span></span><br><span class="line"><span class="keyword">if</span> ((chdir(<span class="string">&quot;/&quot;</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*关闭标准输入设备、标准输出设备和标准错误输出设备*/</span></span><br><span class="line">close(STDIN_FILENO);</span><br><span class="line">close(STDOUT_FILENO);</span><br><span class="line">close(STDERR_FILENO);</span><br><span class="line"><span class="comment">/*关闭其他已经打开的文件描述符，代码省略*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将标准输入、标准输出和标准错误输出都定向到/dev/null文件*/</span></span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>, O_RDONLY);</span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>, O_RDWR);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Linux提供了完成同样功能的库函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir,<span class="keyword">int</span> noclose)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>其中，nochdir参数用于指定是否改变工作目录，如果给它传递 0，则工作目录将被设置为“/”（根目录），否则继续使用当前工作目 录。</li><li>noclose参数为0时，标准输入、标准输出和标准错误输出都被重 定向到/dev/null文件，否则依然使用原来的设备。</li><li>该函数成功时返回 0，失败则返回-1并设置errno。</li></ul><h3 id="第8章-高性能服务器程序框架"><a href="#第8章-高性能服务器程序框架" class="headerlink" title="第8章 高性能服务器程序框架"></a>第8章 高性能服务器程序框架</h3><p>在这一章中，我们 按照服务器程序的一般原理，将服务器解构为如下三个主要模块：</p><ul><li>I/O处理单元。本章将介绍I/O处理单元的四种I/O模型和两种高效事件处理模式。</li><li>逻辑单元。本章将介绍逻辑单元的两种高效并发模式，以及高效的逻辑处理方式——有限状态机。</li><li>存储单元。本书不讨论存储单元，因为它只是服务器程序的可选模块，而且其内容与网络编程本身无关。</li></ul><h4 id="8-1-服务器模型"><a href="#8-1-服务器模型" class="headerlink" title="8.1 服务器模型"></a>8.1 服务器模型</h4><h5 id="8-1-1-C-S-模型"><a href="#8-1-1-C-S-模型" class="headerlink" title="8.1.1 C/S 模型"></a>8.1.1 C/S 模型</h5><p>所有客户端都通过访问 服务器来获取所需的资源。</p><img src="学习笔记/Linux高性能服务器编程/image-20230228201337000.png" alt="image-20230228201337000" style="zoom: 33%;" /><p>C/S模型的逻辑很简单。服务器启动后，首先创建一个（或多个） 监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后 调用listen函数等待客户连接。</p><p>服务器稳定运行之后，<strong>客户端就可以调 用connect函数向服务器发起连接了</strong>。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。</p><img src="学习笔记/Linux高性能服务器编程/image-20230228201534348.png" alt="image-20230228201534348" style="zoom:67%;" /><p>I/O模型有多种，图8-2中，<strong>服务器使用的是I/O复用技术之一的select系统调用。</strong>当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。<strong>逻辑单元可以是新创建的子进程、子线程或者 其他。</strong> 图8-2中，服务器给客户端分配的逻辑单元是由fork系统调用创 建的子进程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。客户端接收到服务器反馈的结果之后，可以继续向服 务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连 接，则服务器执行被动关闭连接。至此，双方的通信结束。</p><h5 id="8-1-2-P2P模型"><a href="#8-1-2-P2P模型" class="headerlink" title="8.1.2 P2P模型"></a>8.1.2 P2P模型</h5><p>P2P（Peer to Peer，点对点）模型比C/S模型更符合网络通信的实 际情况。它摒弃了以服务器为中心的格局，让网络上所有主机重新回 归对等的地位。P2P模型如图8-3a所示。</p><p>但P2P模型的缺点也很明显：当用户之间传输的请求过多时，网络 的负载将加重。</p><p>图8-3a所示的P2P模型存在一个显著的问题，即主机之间很难互相 发现。所以实际使用的P2P模型通常带有一个专门的发现服务器，如图 8-3b所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228201859415-1678341964416.png" class="" title="image-20230228201859415"><h4 id="8-2-服务器编程框架"><a href="#8-2-服务器编程框架" class="headerlink" title="8.2 服务器编程框架"></a>8.2 服务器编程框架</h4><p>为了让读者能从设计的角度把握服务器编程，本章先讨论 基本框架，如图8-4所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228201956583-1678341964416.png" class="" title="image-20230228201956583"><p>该图既能用来描述一台服务器，也能用来描述一个服务器机群。 各个部件的含义和功能如下表所示:</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228202116872-1678341964417.png" class="" title="image-20230228202116872"><ul><li>I/O处理单元是服务器管理客户连接的模块。它通常要完成以下工 作：<strong>等待并接受新的客户连接，接收客户数据，将服务器响应数据返 回给客户端。</strong>但是，数据的收发不一定在I/O处理单元中执行，也可能 在逻辑单元中执行，具体在何处执行取决于事件处理模式（见后 文）。</li><li>一个逻辑单元通常是一个进程或线程。它分析并处理客户数据， 然后将结果传递给I/O处理单元或者直接发送给客户端（具体使用哪种 方式取决于事件处理模式）。</li><li>网络存储单元可以是数据库、缓存和文件，甚至是一台独立的服 务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单 元。</li><li>请求队列是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。同样， 多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调 处理竞态条件。<strong>请求队列通常被实现为池的一部分，我们将在后面讨 论池的概念</strong>。</li></ul><h4 id="8-3-I-O模型"><a href="#8-3-I-O模型" class="headerlink" title="8.3 I/O模型"></a>8.3 I/O模型</h4><p>第5章讲到，socket在创建的时候默认是阻塞的。我们可以给socket 系统调用的第2个参数传递SOCK_NONBLOCK标志，或者通过fcntl系统调用的F_SETFL命令，将其设置为非阻塞的。</p><p>阻塞和非阻塞的概念能应用于所有文件描述符，而不仅仅是socket。<strong>我们称阻塞的文件描述符为阻塞I/O，称非阻塞的文件描述符为非阻塞I/O。</strong></p><blockquote><p><strong>针对阻塞I/O执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。</strong>比如，客户端通过connect向服务器 发起连接时，connect将首先发送同步报文段给服务器，然后等待服务 器返回确认报文段。如果服务器的确认报文段没有立即到达客户端， 则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调 用。socket的基础API中，可能被阻塞的系统调用包括accept、send、 recv和connect。</p><p><strong>针对非阻塞I/O执行的系统调用则总是立即返回，而不管事件是否已经发生。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。</strong>此时我们必须根据errno来区分这两种情况。对accept、send 和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一 次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言， errno则被设置成EINPROGRESS（意为“在处理中”）。</p></blockquote><p>很显然，<strong>我们只有在事件已经发生的情况下操作非阻塞I/O（读、 写等），才能提高程序的效率。</strong>因此，<strong>非阻塞I/O通常要和其他I/O通知机制一起使用</strong>，比如I/O复用和SIGIO信号。</p><p><strong>I/O复用是最常使用的I/O通知机制。它指的是，应用程序通过I/O 复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。</strong> Linux上常用的I/O复用函数是select、poll和 epoll_wait，我们将在第9章详细讨论它们。  需要指出的是，<strong>I/O复用函数本身是阻塞的，它们能提高程序效率的原因在于它们具有同时监听多个I/O事件的能力。</strong></p><p><strong>SIGIO信号也可以用来报告I/O事件。6.8节的最后一段提到，我们可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。</strong> 这样，当目标文件描述符上有事件发生时，SIGIO 信号的信号处理函数将被触发，我们也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了。关于信号的使用，我们将在第 10章讨论。</p><p>从理论上说，<strong>阻塞I/O、I/O复用和信号驱动I/O都是同步I/O模型。</strong> 因为在这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后， 由应用程序来完成的。</p><p>而POSIX规范所定义的异步I/O模型则不同。<strong>对异步I/O而言，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已经由内核接管。</strong></p><blockquote><p>也就是说，<strong>同步I/O模型要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据 从用户缓冲区写入内核缓冲区），而异步I/O机制则由内核来执行I/O操 作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完 成的）。</strong>你可以这样认为，<strong>同步I/O向应用程序通知的是I/O就绪事件， 而异步I/O向应用程序通知的是I/O完成事件。</strong></p></blockquote><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228203724545-1678341964417.png" class="" title="image-20230228203724545"><h4 id="8-4-两种高效的事件处理模式"><a href="#8-4-两种高效的事件处理模式" class="headerlink" title="8.4 两种高效的事件处理模式"></a>8.4 两种高效的事件处理模式</h4><p>这一节先从整体上介绍一下两种高效的事件处理模式：Reactor和Proactor。同步I/O模型通常用于实现Reactor模式，异步I/O模型则用于实现 Proactor模式。</p><h5 id="8-4-1-Reactor模式"><a href="#8-4-1-Reactor模式" class="headerlink" title="8.4.1 Reactor模式"></a>8.4.1 Reactor模式</h5><p>Reactor是这样一种模式，它要求<strong>主线程（I/O处理单元，下同）只负责监听文件描述上是否有事件发生，有的话就立即将该事件通知工作线程</strong>（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。<strong>读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</strong></p><p>工作流程如下:</p><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将 socket可读事件放入请求队列。 </li><li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，<strong>然后往epoll内核事件表中注册该socket上的写就绪事件。</strong></li><li>主线程调用epoll_wait等待socket可写。 </li><li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。 </li><li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入 服务器处理客户请求的结果。</li></ol><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228204723763-1678341964417.png" class="" title="image-20230228204723763"><h5 id="8-4-2-Proactor模式"><a href="#8-4-2-Proactor模式" class="headerlink" title="8.4.2 Proactor模式"></a>8.4.2 Proactor模式</h5><p>与Reactor模式不同，Proactor模式将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p><p>使用异步I/O模型（以aio_read和aio_write为例）实现的Proactor模 式的工作流程是：</p><ol><li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序 （这里以信号为例，详情请参考sigevent的man手册）。</li><li>主线程继续处理其他逻辑。</li><li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操 作完成时如何通知应用程序（仍然以信号为例）。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善 后处理，比如决定是否关闭socket。</li></ol><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228205315653-1678341964417.png" class="" title="image-20230228205315653"><p>在图8-6中，连接socket上的读写事件是通过aio_read/aio_write向内 核注册的，<strong>因此内核将通过信号来向应用程序报告连接socket上的读写 事件。</strong> 所以，主线程中的epoll_wait调用仅能用来检测监听socket上的连 接请求事件，而不能用来检测连接socket上的读写事件。</p><h5 id="8-4-3-模拟Proactor模式"><a href="#8-4-3-模拟Proactor模式" class="headerlink" title="8.4.3 模拟Proactor模式"></a>8.4.3 模拟Proactor模式</h5><p>使用同步I/O方式模拟出Proactor模式的一种方 法。其原理是：<strong>主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</strong></p><p>使用同步I/O模型（仍然以epoll_wait为例）模拟出的Proactor模式 的工作流程如下：</p><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程从 socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封 装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并 处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</li><li>主线程调用epoll_wait等待socket可写。</li><li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入 服务器处理客户请求的结果。</li></ol><img src="学习笔记/Linux高性能服务器编程/image-20230228210636117.png" alt="image-20230228210636117" style="zoom:67%;" /><h4 id="8-5-两种高效的并发模式"><a href="#8-5-两种高效的并发模式" class="headerlink" title="8.5 两种高效的并发模式"></a>8.5 两种高效的并发模式</h4><p>并发编程的目的是让程序“同时”执行多个任务。如果程序是计算密集型的，并发编程并没有优势，反而由于任务的切换使效率降低。 但如果程序是I/O密集型的，比如经常读写文件，访问数据库等，则情况就不同了。由于I/O操作的速度远没有CPU的计算速度快，所以让程 序阻塞于I/O操作将浪费大量的CPU时间。如果程序有多个执行线程， 则当前被I/O操作所阻塞的执行线程可主动放弃CPU（或由操作系统来 调度），并将执行权转移到其他线程。</p><p>从实现上来说，并发编程主要有多进程和多线程两种方式，我们 将在后续章节详细讨论它们，这一节先讨论并发模式。 <strong>并发模式是指I/O处理单元和多个逻辑单元之间协调完成任务的方法。 服务器主要有两种并发编程模式：半同步/半异步（half-sync/half-async）模式和领导者/追随者（Leader/Followers）模式。</strong></p><h5 id="8-5-1-半同步-半异步模式"><a href="#8-5-1-半同步-半异步模式" class="headerlink" title="8.5.1 半同步/半异步模式"></a>8.5.1 半同步/半异步模式</h5><p>首先，半同步/半异步模式中的“同步”和“异步”与前面讨论的I/O模 型中的“同步”和“异步”是完全不同的概念。</p><blockquote><p>在I/O模型中，“同步”和“异步”区分的是内核向应用程序通知的是何种I/O事件（是就绪事件还是完成事件），以及该由谁来完成I/O读写（是应用程序还是内核）。</p></blockquote><p>在并发模式中，“同步”指的是程序完全按照代码序列的顺序执行；“<strong>异步”指 的是程序的执行需要由系统事件来驱动。常见的系统事件包括中断、 信号等。</strong>比如，图8-8a描述了同步的读操作，而图8-8b则描述了异步的 读操作。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228211515292-1678341964417.png" class="" title="image-20230228211515292"><p>对于像服务器 这种既要求较好的实时性，又要求能同时处理多个客户请求的应用程 序，我们就应该同时使用同步线程和异步线程来实现，即采用半同步/ 半异步模式来实现。</p><p><strong>半同步/半异步模式中，同步线程用于处理客户逻辑，相当于图8-4 中的逻辑单元；异步线程用于处理I/O事件，相当于图8-4中的I/O处理单元。</strong> 异步线程监听到客户请求后，就将其封装成请求对象并插入请 求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并 处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则 取决于请求队列的设计。</p><p>在服务器程序中，如果结合考虑两种事件处理模式和几种I/O模 型，则半同步/半异步模式就存在多种变体。其中有一种变体称为半同步/半反应堆（half-sync/half-reactive）模式，如图8-10所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228212216219-1678341964417.png" class="" title="image-20230228212216219"><p>异步线程只有一个，由主线程来充当。它负责监听所有 socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生， 即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接 socket插入请求队列中。</p><p>所有工作线程都睡眠在请求队列上，当有任务 到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这 种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。</p><blockquote><p>主线程插入请求队列中的任务是就绪的连接socket。这 说明该图所示的半同步/半反应堆模式采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中“half-reactive”的含义。</p></blockquote><p>存在的缺点:</p><ul><li>主线程和工作线程共享请求队列。主线程往请求队列中添加任 务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保 护，从而白白耗费CPU时间。</li><li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题， 则工作线程的切换也将耗费大量CPU时间。</li></ul><p>下图描述了一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230228212643003-1678341964417.png" class="" title="image-20230228212643003"><p>图8-11中，主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。</p><p>主线程向工作线程派发socket的最 简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测 到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。 如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表 中。</p><p>可见，图8-11中，每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同 步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义 上的半同步/半异步模式。</p><h5 id="8-5-2-领导者-追随者模式"><a href="#8-5-2-领导者-追随者模式" class="headerlink" title="8.5.2 领导者/追随者模式"></a>8.5.2 领导者/追随者模式</h5><h4 id="8-6-有限状态机"><a href="#8-6-有限状态机" class="headerlink" title="8.6 有限状态机"></a>8.6 有限状态机</h4><p>前面两节探讨的是服务器的I/O处理单元、请求队列和逻辑单元之 间协调完成任务的各种模式，这一节我们介绍逻辑单元内部的一种高 效编程方法：有限状态机（finite state machine）。</p><p>有的应用层协议头部包含数据包类型字段，每种类型可以映射为 逻辑单元的一种执行状态，服务器可以根据它来编写相应的处理逻 辑，如代码清单8-1所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE(Package_pack)</span><br><span class="line">&#123;</span><br><span class="line">PackageType _type=_pack.GetType();</span><br><span class="line"><span class="keyword">switch</span>(_type)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">process_package_A(_pack);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">process_package_B(_pack);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这就是一个简单的有限状态机，只不过该状态机的每个状态都是相互独立的，即状态之间没有相互转移。</p><p>状态之间的转移是需要状态 机内部驱动的，如代码清单8-2所示。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">STATE_MACHINE()</span><br><span class="line">&#123;</span><br><span class="line">State cur_State=type_A;</span><br><span class="line"><span class="keyword">while</span>(cur_State!=type_C)</span><br><span class="line">&#123;</span><br><span class="line">Package _pack=getNewPackage();</span><br><span class="line"><span class="keyword">switch</span>(cur_State)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> type_A:</span><br><span class="line">process_package_state_A(_pack);</span><br><span class="line">cur_State=type_B;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> type_B:</span><br><span class="line">process_package_state_B(_pack);</span><br><span class="line">cur_State=type_C;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>该状态机包含三种状态：type_A、type_B和type_C，其中type_A是 状态机的开始状态，type_C是状态机的结束状态。状态机的当前状态 记录在cur_State变量中。在一趟循环过程中，状态机先通过 getNewPackage方法获得一个新的数据包，然后根据cur_State变量的值 判断如何处理该数据包。数据包处理完之后，状态机通过给cur_State变 量传递目标状态值来实现状态转移。那么当状态机进入下一趟循环 时，它将执行新的状态对应的逻辑。</p></blockquote><h5 id="8-6-1-有限状态机实例"><a href="#8-6-1-有限状态机实例" class="headerlink" title="8.6.1 有限状态机实例"></a>8.6.1 有限状态机实例</h5><p>HTTP请求的读取和分 析。很多网络协议，包括TCP协议和IP协议，都在其头部中提供头部长度字段。程序根据该字段的值就可以知道是否接收到一个完整的协议头部。</p><p>但HTTP协议并未提供这样的头部长度字段，并且其头部长度变 化也很大，可以只有十几字节，也可以有上百字节。根据协议规定， <strong>我们判断HTTP头部结束的依据是遇到一个空行，该空行仅包含一对回 车换行符（＜CR＞＜LF＞）。</strong>如果一次读操作没有读入HTTP请求的 整个头部，即没有遇到空行，那么我们必须等待客户继续写数据并再 次读入。因此，我们每完成一次读操作，就要分析新读入的数据中是 否有空行。不过在寻找空行的过程中，我们可以同时完成对整个HTTP 请求头部的分析（记住，空行前面还有请求行和头部域），以提高解 析HTTP请求的效率。</p><p>代码清单8-3使用主、从两个有限状态机实现了最 简单的HTTP请求的读取和分析。为了使表述简洁，我们约定，直接称 HTTP请求的一行（包括请求行和头部字段）为行。</p><p><strong>我们将代码清单8-3中的两个有限状态机分别称为主状态机和从状 态机，这体现了它们之间的关系：主状态机在内部调用从状态机。下 面先分析从状态机，即parse_line函数，它从buffer中解析出一个行。图 8-15描述了其可能的状态及状态转移过程。</strong></p><img src="高性能服务器框架/image-20230309185019935.png" alt="image-20230309185019935" style="zoom: 33%;" /><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h4 id="8-7-提高服务器的其他建议"><a href="#8-7-提高服务器的其他建议" class="headerlink" title="8.7 提高服务器的其他建议"></a>8.7 提高服务器的其他建议</h4><p>前面我们介绍了几种高效的事件处理模式和并发模式，以及高效 的逻辑处理方式——有限状态机，它们都有助于提高服务器的整体性 能。</p><h5 id="8-7-1-池"><a href="#8-7-1-池" class="headerlink" title="8.7.1 池"></a>8.7.1 池</h5><p>既然服务器的硬件资源“充裕”，那么提高服务器性能的一个很直接的方法就是以空间换时间，即“浪费”服务器的硬件资源，以换取其 运行效率。这就是池（pool）的概念。</p><p>池是一组资源的集合，这组资 源在服务器启动之初就被完全创建好并初始化，这称为静态资源分配。 <strong>当服务器进入正式运行阶段，即开始处理客户请求的时候，如果 它需要相关的资源，就可以直接从池中获取，无须动态分配。 ** **当服务器处理完一个客户连 接后，可以把相关的资源放回池中，无须执行系统调用来释放资源。</strong></p><p>根据不同的资源类型，池可分为多种，常见的有内存池、进程池、线程池和连接池。它们的含义都很明确。</p><ul><li>内存池通常用于socket的接收缓存和发送缓存。对于某些长度有限的客户请求，比如HTTP请求，预先分配一个大小足够（比如5000字 节）的接收缓存区是很合理的。当客户请求的长度超过接收缓冲区的 大小时，我们可以选择丢弃请求或者动态扩大接收缓冲区。</li><li>进程池和线程池都是并发编程常用的“伎俩”。当我们需要一个工 作进程或工作线程来处理新到来的客户请求时，我们可以直接从进程 池或线程池中取得一个执行实体，而无须动态地调用fork或 pthread_create等函数来创建进程和线程。</li><li>连接池通常用于服务器或服务器机群的内部永久连接。图8-4中， 每个逻辑单元可能都需要频繁地访问本地的某个数据库。连接池是服务器预先和数据库程序建立的一组 连接的集合。当某个逻辑单元需要访问数据库时，它可以直接从连接 池中取得一个连接的实体并使用之。待完成数据库的访问之后，逻辑 单元再将该连接返还给连接池。</li></ul><h5 id="8-7-2-数据复制"><a href="#8-7-2-数据复制" class="headerlink" title="8.7.2 数据复制"></a>8.7.2 数据复制</h5><p>高性能服务器应该<strong>避免不必要的数据复制</strong>，尤其是当数据复制发 生在用户代码和内核之间的时候。如果内核可以直接处理从socket或 者文件读入的数据，则应用程序就没必要将这些数据从内核缓冲区复 制到应用程序缓冲区中。这里说的“直接处理”指的是应用程序不关心 这些数据的内容，不需要对它们做任何分析。</p><blockquote><p>比如ftp服务器，当客户 请求一个文件时，服务器只需要检测目标文件是否存在，以及客户是 否有读取它的权限，而绝对不会关心文件的具体内容。这样的话，ftp 服务器就无须把目标文件的内容完整地读入到应用程序缓冲区中并调 用send函数来发送，而是可以使用“零拷贝”函数sendfile来直接将其发 送给客户端。</p></blockquote><p>此外，用户代码内部（不访问内核）的数据复制也是应该避免 的。当两个工作进程之间要传递大量的数据时，我们就应 该考虑使用共享内存来在它们之间直接共享这些数据，而不是使用管 道或者消息队列来传递。</p><h5 id="8-7-3-上下文切换和锁"><a href="#8-7-3-上下文切换和锁" class="headerlink" title="8.7.3 上下文切换和锁"></a>8.7.3 上下文切换和锁</h5><p>并发程序必须考虑上下文切换（context switch）的问题，即进程 切换或线程切换导致的的系统开销。</p><p>即使是I/O密集型的服务器，也不 应该使用过多的工作线程（或工作进程，下同），否则线程间的切换 将占用大量的CPU时间，服务器真正用于处理业务逻辑的CPU时间的 比重就显得不足了。</p><p>因此，为每个客户连接都创建一个工作线程的服 务器模型是不可取的。图8-11所描述的半同步/半异步模式是一种比较 合理的解决方案，它允许一个线程同时处理多个客户连接</p><p>并发程序需要考虑的另外一个问题是<strong>共享资源的加锁保护</strong>。锁通 常被认为是导致服务器效率低下的一个因素，因为由它引入的代码不 仅不处理任何业务逻辑，而且需要访问内核资源。</p><p>如果服务器必须使用“锁”，则可以考虑减小锁的粒度，比如使用读写锁。</p><h3 id="第9章-I-O复用"><a href="#第9章-I-O复用" class="headerlink" title="第9章 I/O复用"></a>第9章 I/O复用</h3><p><strong>I/O复用使得程序能同时监听多个文件描述符，这对提高程序的性能至关重要。</strong>通常，网络程序在下列情况下需要使用I/O复用技术：</p><ul><li>客户端程序要同时处理多个socket。比如本章将要讨论的非阻塞 connect技术。</li><li>客户端程序要同时处理用户输入和网络连接。比如本章将要讨论的聊天室程序。</li><li>TCP服务器要同时处理监听socket和连接socket。这是I/O复用使 用最多的场合。</li><li>服务器要同时处理TCP请求和UDP请求。比如本章将要讨论的 回射服务器。</li><li>服务器要同时监听多个端口，或者处理多种服务。比如本章将 要讨论的xinetd服务器。</li></ul><h4 id="9-1-select系统调用"><a href="#9-1-select系统调用" class="headerlink" title="9.1 select系统调用"></a>9.1 select系统调用</h4><p><strong>select系统调用的用途是：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</strong></p><h5 id="9-1-1-select-API"><a href="#9-1-1-select-API" class="headerlink" title="9.1.1 select API"></a>9.1.1 select API</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>nfds参数指定被监听的文件描述符的总数。它通常被设置为 select监听的所有文件描述符中的最大值加1，因为文件描述符是从0开 始计数的。</p></li><li><p><strong>readfds、writefds和exceptfds参数分别指向可读、可写和异常等事件对应的文件描述符集合。</strong>应用程序调用select函数时，通过这3 个参数传入自己感兴趣的文件描述符。select调用返回时，内核将修改它们来通知应用程序哪些文件描述符已经就绪。</p></li><li><p>fd_set结构体仅包含一个整型数组，该数组的每 个元素的每一位（bit）标记一个文件描述符。fd_set能容纳的文件描述 符数量由FD_SETSIZE指定，这就限制了select能同时处理的文件描述 符的总量。由于位操作过于烦琐，我们应该使用下面的一系列宏来访问fd_set 结构体中的位：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞</span></span><br><span class="line">FD_ZERO(fd_set* fdset);<span class="comment">/*清除fdset的所有位*/</span></span><br><span class="line">FD_SET(<span class="keyword">int</span> fd, fd_set* fdset);<span class="comment">/*设置fdset的位fd*/</span></span><br><span class="line">FD_CLR(<span class="keyword">int</span> fd, fd_set* fdset);<span class="comment">/*清除fdset的位fd*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FD_ISSET</span><span class="params">(<span class="keyword">int</span> fd, fd_set* fdset)</span></span>;<span class="comment">/*测试fdset的位fd是否被设置*/</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>timeout参数用来设置select函数的超时时间。它是一个timeval 结构类型的指针，采用指针参数是因为内核将修改它以告诉应用程序 select等待了多久。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">long</span> tv_sec;<span class="comment">/*秒数*/</span></span><br><span class="line"><span class="keyword">long</span> tv_usec;<span class="comment">/*微秒数*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>select成功时返回就绪（可读、可写和异常）文件描述符的总数。 如果在超时时间内没有任何文件描述符就绪，select将返回0。select失 败时返回-1并设置errno。如果在select等待期间，程序接收到信号，则 select立即返回-1，并设置errno为EINTR。</p><h5 id="9-1-2-文件描述符就绪条件"><a href="#9-1-2-文件描述符就绪条件" class="headerlink" title="9.1.2 文件描述符就绪条件"></a>9.1.2 文件描述符就绪条件</h5><p>哪些情况下文件描述符可以被认为是可读、可写或者出现异常， 对于select的使用非常关键。</p><p>在网络编程中，下列情况下socket可读：</p><ul><li>socket内核接收缓存区中的字节数大于或等于其低水位标记 SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返 回的字节数大于0。</li><li>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</li><li>监听socket上有新的连接请求。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取 和清除该错误。</li></ul><p>下列情况下socket可写：</p><ul><li>socket内核发送缓存区中的可用字节数大于或等于其低水位标记 SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返 回的字节数大于0。</li><li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将 触发一个SIGPIPE信号。</li><li>socket使用非阻塞connect连接成功或者失败（超时）之后。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取 和清除该错误。</li></ul><p>网络程序中，select能处理的异常情况只有一种：socket上接收到 带外数据。下面我们详细讨论之。</p><h5 id="9-1-3-处理带外数据"><a href="#9-1-3-处理带外数据" class="headerlink" title="9.1.3 处理带外数据"></a>9.1.3 处理带外数据</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// select是如何同时接收普通数据和带外数据</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;clocale&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line">close(listenfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">fd_set read_fds;</span><br><span class="line">fd_set exception_fds;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清除fdset的所有位</span></span><br><span class="line">FD_ZERO(&amp;read_fds);</span><br><span class="line">FD_ZERO(&amp;exception_fds);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line"><span class="comment">/*每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，</span></span><br><span class="line"><span class="comment"> * 因为事件发生之后，文件描述符集合将被内核修改</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">FD_SET(connfd, &amp;read_fds);</span><br><span class="line">FD_SET(connfd, &amp;exception_fds);</span><br><span class="line">ret = select(connfd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, &amp;exception_fds, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;selection failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对于可读事件，采用普通的recv函数读取数据*/</span></span><br><span class="line"><span class="keyword">if</span> (FD_ISSET(connfd, &amp;read_fds)) &#123;</span><br><span class="line">ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of normal data:%s\n&quot;</span>, ret, buf);</span><br><span class="line"><span class="comment">/*对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据*/</span></span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (FD_ISSET(connfd, &amp;exception_fds)) &#123;</span><br><span class="line">ret = recv(connfd, buf, <span class="keyword">sizeof</span>(buf) - <span class="number">1</span>, MSG_OOB);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of oob data:%s\n&quot;</span>, ret, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">close(connfd);</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-poll系统调用"><a href="#9-2-poll系统调用" class="headerlink" title="9.2 poll系统调用"></a>9.2 poll系统调用</h4><p>poll系统调用和select类似，也是在指定时间内轮询一定数量的文件 描述符，以测试其中是否有就绪者。poll的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜poll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>fds参数是一个pollfd结构类型的数组，它指定所有我们感兴趣的文件描述符上发生的可读、可写和异常等事件。pollfd结构体的定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> fd;<span class="comment">/*文件描述符*/</span></span><br><span class="line"><span class="keyword">short</span> events;<span class="comment">/*注册的事件*/</span></span><br><span class="line"><span class="keyword">short</span> revents;<span class="comment">/*实际发生的事件，由内核填充*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 其中，fd成员指定文件描述符；</span></span><br><span class="line"><span class="comment">// events成员告诉poll监听fd上的哪些事件，它是一系列事件的按位或；</span></span><br><span class="line"><span class="comment">// revents成员则由内核修改，以通知应用程序fd上实际发生了哪些事件。</span></span><br></pre></td></tr></table></figure><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230301214431734-1678341964417.png" class="" title="image-20230301214431734"></li><li><p>nfds参数指定被监听事件集合fds的大小。其类型nfds_t的定义 如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="keyword">nfds_t</span>;</span><br></pre></td></tr></table></figure></li><li><p>timeout参数指定poll的超时值，单位是毫秒。当timeout为-1 时，poll调用将永远阻塞，直到某个事件发生；当timeout为0时，poll调用将立即返回。</p></li></ul><p>poll系统调用的返回值的含义与select相同。</p><h4 id="9-3-epoll系列系统调用"><a href="#9-3-epoll系列系统调用" class="headerlink" title="9.3 epoll系列系统调用"></a>9.3 epoll系列系统调用</h4><h5 id="9-3-1-内核事件表"><a href="#9-3-1-内核事件表" class="headerlink" title="9.3.1 内核事件表"></a>9.3.1 内核事件表</h5><p>epoll是Linux特有的I/O复用函数。它在实现和使用上与select、 poll有很大差异。</p><p>首先，epoll使用一组函数来完成任务，而不是单个 函数。其次，epoll把用户关心的文件描述符上的事件放在内核里的一 个事件表中，从而无须像select和poll那样每次调用都要重复传入文件 描述符集或事件集。<strong>但epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。</strong></p><p>这个文件描述符使用如下epoll_create函数 来创建：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span></span><br></pre></td></tr></table></figure><ul><li>size参数现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。</li><li><strong>该函数返回的文件描述符将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。</strong></li></ul><p>下面的函数用来操作epoll的内核事件表：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span></span><br></pre></td></tr></table></figure><ul><li><p>fd参数是要操作的文件描述符，</p></li><li><p>op参数则指定操作类型。</p><ul><li>EPOLL_CTL_ADD，往事件表中注册fd上的事件。</li><li>EPOLL_CTL_MOD，修改fd上的注册事件。</li><li>EPOLL_CTL_DEL，删除fd上的注册事件。</li></ul></li><li><p>event参数指定事件，它是epoll_event结构指针类型。epoll_event的 定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">__uint32_t</span> events;<span class="comment">/*epoll事件*/</span></span><br><span class="line"><span class="keyword">epoll_data_t</span> data;<span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">void</span>*ptr;</span><br><span class="line"><span class="keyword">int</span> fd;</span><br><span class="line"><span class="keyword">uint32_t</span> u32;</span><br><span class="line"><span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125;<span class="keyword">epoll_data_t</span>;</span><br></pre></td></tr></table></figure><p>epoll_data_t是一个联合体，其4个成员中使用最多的是fd，它指定 事件所从属的目标文件描述符。ptr成员可用来指定与fd相关的用户数 据。</p></li><li><p>其中events成员描述事件类型。epoll支持的事件类型和poll基本相 同。表示epoll事件类型的宏是在poll对应的宏前加上“E”，比如epoll的 数据可读事件是EPOLLIN。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230301214431734-1678341964417.png" class="" title="image-20230301214431734"></li><li><p>但epoll有两个额外的事件类型—— EPOLLET和EPOLLONESHOT。它们对于epoll的高效运作非常关键， 我们将在后面讨论它们。</p></li></ul><p>epoll_ctl成功时返回0，失败则返回-1并设置errno。</p><h5 id="9-3-2-epoll-wait函数"><a href="#9-3-2-epoll-wait函数" class="headerlink" title="9.3.2 epoll_wait函数"></a>9.3.2 epoll_wait函数</h5><p>epoll系列系统调用的主要接口是epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>该函数成功时返回就绪的文件描述符的个数，失败时返回-1并设 置errno。</p><ul><li>timeout参数的含义与 poll接口的timeout参数相同。</li><li>maxevents参数指定最多监听多少个事 件，它必须大于0。</li><li>epoll_wait函数如果检测到事件，就 <strong>将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。</strong> <strong>这个数组只用于输出epoll_wait检测到的就绪事件，而不像select和poll 的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到 的就绪事件</strong>。这就极大地提高了应用程序索引就绪文件描述符的效率。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  如何索引poll返回的就绪文件描述符</span></span><br><span class="line"><span class="comment">// 当timeout为-1 时，poll调用将永远阻塞，直到某个事件发生</span></span><br><span class="line"><span class="keyword">int</span> ret = poll(fds, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (fds[i].revents &amp; POLLIN)<span class="comment">/*判断第i个文件描述符是否就绪*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = fds[i].fd;</span><br><span class="line"><span class="comment">/*处理sockfd*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  如何索引epoll返回的就绪文件描述符</span></span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*仅遍历就绪的ret个文件描述符*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">/*sockfd肯定就绪，直接处理*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="9-3-3-LT和ET模式"><a href="#9-3-3-LT和ET模式" class="headerlink" title="9.3.3 LT和ET模式"></a>9.3.3 LT和ET模式</h5><p>epoll对文件描述符的操作有两种模式：LT（Level Trigger，电平 触发）模式和ET（Edge Trigger，边沿触发）模式。</p><p><strong>LT模式是默认的 工作模式，这种模式下epoll相当于一个效率较高的poll。</strong> 对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事 件。这样，<strong>当应用程序下一次调用epoll_wait时，epoll_wait还会再次向 应用程序通告此事件，直到该事件被处理。</strong></p><p><strong>当往epoll内 核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET 模式来操作该文件描述符。ET模式是epoll的高效工作模式。</strong>而对于采用ET工作模式的 文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，<strong>应用程序必须立即处理该事件，因为后续的epoll_wait调用将 不再向应用程序通知这一事件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/1.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将文件描述符设置成非阻塞的*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);  <span class="comment">// 获取状态标志</span></span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中，</span></span><br><span class="line"><span class="comment"> * 参数enable_et指定是否对fd启用ET模式</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN;</span><br><span class="line"><span class="keyword">if</span> (enable_et) &#123;</span><br><span class="line">event.events |= EPOLLET;</span><br><span class="line"><span class="comment">// 等价于 event.events = event.events | EPOLLET</span></span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*LT模式的工作流程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address,</span><br><span class="line">&amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd, <span class="literal">false</span>); <span class="comment">/*对connfd禁用ET模式*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123; <span class="comment">/*只要socket读缓存中还有未读出的数据，这段代码就被触发*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of content:%s\n&quot;</span>, ret, buf);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*ET模式的工作流程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">(epoll_event *events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;</span><br><span class="line">client_addrlength);</span><br><span class="line">addfd(epollfd, connfd, <span class="literal">true</span>); <span class="comment">/*对connfd开启ET模式*/</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="comment">/*这段代码不会被重复触发，所以我们循环读取数据，以确保把socket读缓存中的所有数据读出*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;event trigger once\n&quot;</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。</span></span><br><span class="line"><span class="comment"> * 此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of content:%s\n&quot;</span>, ret, buf);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret, listenfd;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line">listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line">addfd(epollfd, listenfd, <span class="literal">true</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">lt(events, ret, epollfd, listenfd); <span class="comment">/*使用LT模式*/</span></span><br><span class="line"><span class="comment">//et(events,ret,epollfd,listenfd);    /*使用ET模式*/</span></span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读者不妨运行一下这段代码，然后telnet到这个服务器程序上并一 次传输超过10字节（BUFFER_SIZE的大小）的数据，然后比较LT模式 和ET模式的异同。你会发现，正如我们预期的，ET模式下事件被触发 的次数要比LT模式下少很多。 </p><p>注意每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直 处于阻塞状态（饥渴状态）。</p><h5 id="9-3-4-EPOLLONESHOT事件"><a href="#9-3-4-EPOLLONESHOT事件" class="headerlink" title="9.3.4 EPOLLONESHOT事件"></a>9.3.4 EPOLLONESHOT事件</h5><p>即使我们使用ET模式，一个socket上的某个事件还是可能被触发多次。这在并发程序中就会引起一个问题。比如一个线程（或进程， 下同）在读取完某个socket上的数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发）， 此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线 程同时操作一个socket的局面。</p><p><strong>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非我们使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事 件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fds</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中，参</span></span><br><span class="line"><span class="comment">数oneshot指定是否注册fd上的EPOLLONESHOT事件*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> oneshot)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line"><span class="keyword">if</span> (oneshot) &#123;</span><br><span class="line">event.events |= EPOLLONESHOT;</span><br><span class="line">&#125;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，但是操</span></span><br><span class="line"><span class="comment">作系统仍然会触发fd上的EPOLLIN事件，且只触发一次*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_oneshot</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_MOD, fd, &amp;event);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*工作线程*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> * <span class="title">worker</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = ((fds *) arg)-&gt;sockfd;</span><br><span class="line"><span class="keyword">int</span> epollfd = ((fds *) arg)-&gt;epollfd;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;start new thread to receive data on fd:%d\n&quot;</span>, sockfd);</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line"><span class="comment">/*循环读取sockfd上的数据，直到遇到EAGAIN错误*/</span></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = recv(sockfd, buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;foreiner closed the connection\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (errno == EAGAIN) &#123;</span><br><span class="line">reset_oneshot(epollfd, sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;read later\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get content:%s\n&quot;</span>, buf);</span><br><span class="line"><span class="comment">/*休眠5s，模拟数据处理过程*/</span></span><br><span class="line">sleep(<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;end thread receiving data on fd:%d\n&quot;</span>, sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (</span><br><span class="line">struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 注意，监听socket listenfd上是不能注册EPOLLONESHOT事件的，否则应用程序</span></span><br><span class="line"><span class="comment"> * 只能处理一个客户连接！因为后续的客户连接请求将不再触发listenfd上的EPOLLIN事件</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">addfd(epollfd, listenfd, <span class="literal">false</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> ret = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (</span><br><span class="line">struct sockaddr *) &amp;client_address, &amp;</span><br><span class="line">                    client_addrlength);</span><br><span class="line"><span class="comment">/*对每个非监听文件描述符都注册EPOLLONESHOT事件*/</span></span><br><span class="line">addfd(epollfd, connfd, <span class="literal">true</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">pthread_t</span> thread;</span><br><span class="line">fds fds_for_new_worker&#123;&#125;;</span><br><span class="line">fds_for_new_worker.epollfd = epollfd;</span><br><span class="line">fds_for_new_worker.sockfd = sockfd;</span><br><span class="line"><span class="comment">/*新启动一个工作线程为sockfd服务*/</span></span><br><span class="line">pthread_create(&amp;thread, <span class="literal">NULL</span>, worker, (<span class="keyword">void</span> *) &amp;fds_for_new_worker);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从工作线程函数worker来看，如果一个工作线程处理完某个socket 上的一次请求（我们用休眠5 s来模拟这个过程）之后，又接收到该 socket上新的客户请求，则该线程将继续为这个socket服务。并且因为该socket上注册了EPOLLONESHOT事件，其他线程没有机会接触这个 socket，如果工作线程等待5 s后仍然没收到该socket上的下一批客户数 据，则它将放弃为该socket服务。</p><p>同时，它调用reset_oneshot函数来重 置该socket上的注册事件，这将使epoll有机会再次检测到该socket上的 EPOLLIN事件，进而使得其他线程有机会为该socket服务。</p><h4 id="9-4-三组I-O复用函数的比较"><a href="#9-4-三组I-O复用函数的比较" class="headerlink" title="9.4 三组I/O复用函数的比较"></a>9.4 三组I/O复用函数的比较</h4><p>前面我们讨论了select、poll和epoll三组I/O复用系统调用，这3组系 统调用都能同时监听多个文件描述符。它们将等待由timeout参数指定 的超时时间，直到一个或者多个文件描述符上有事件发生时返回，返 回值是就绪的文件描述符的数量。返回0表示没有事件发生。</p><ul><li>事件集合<ul><li>select的参数类型fd_set没有将文件描述符和事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件。这一方面使得select不能处理更多类型的 事件，另一方面由于内核对fd_set集合的在线修改，应用程序下次调用 select前不得不重置这3个fd_set集合。</li><li>poll的参数类型pollfd则多少“聪 明”一些。它把文件描述符和事件都定义其中，任何事件都被统一处理，从而使得编程接口简洁得多。并且内核每次修改的是pollfd结构体 的revents成员，而events成员保持不变，因此下次调用poll时应用程序 无须重置pollfd类型的事件集参数。由于每次select和poll调用都返回整 个用户注册的事件集合（其中包括就绪的和未就绪的），所以应用程 序索引就绪文件描述符的时间复杂度为O（n）。</li><li>epoll则采用与select和 poll完全不同的方式来管理用户注册的事件。它在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除、 修改事件。这样，每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文 件描述符的时间复杂度达到O（1）。</li></ul></li><li>最大文件描述符</li></ul><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302141655751-1678341964417.png" class="" title="image-20230302141655751"><h4 id="9-5-I-O复用的高级应用一：非阻塞connect"><a href="#9-5-I-O复用的高级应用一：非阻塞connect" class="headerlink" title="9.5 I/O复用的高级应用一：非阻塞connect"></a>9.5 I/O复用的高级应用一：非阻塞connect</h4><p>在对非阻塞的socket调用connect，而连接又没有立即建立时。会出现一种errno值：EINPROGRESS。 根据man文档的解释，在这种情况下，我们可以调用select、poll 等函数来监听这个连接失败的socket上的可写事件。当select、poll等函数返回后，再利用getsockopt来读取错误码并清除该socket上的错误。 如果错误码是0，表示连接成功建立，否则连接失败。</p><p>通过上面描述的非阻塞connect方式，我们就能同时发起多个连接 并一起等待。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1023</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 超时连接函数，参数分别是服务器IP地址、端口号和超时时间（毫秒）。</span></span><br><span class="line"><span class="comment"> * 函数成功时返回已经处于连接状态的socket，失败则返回-1</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unblock_connect</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *ip, <span class="keyword">int</span> port, <span class="keyword">int</span> time)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> fdopt = setnonblocking(sockfd);</span><br><span class="line">ret = connect(sockfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果连接成功，则恢复sockfd的属性，并立即返回之*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connect with server immediately\n&quot;</span>);</span><br><span class="line">fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (errno != EINPROGRESS) &#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 如果连接没有立即建立，那么只有当errno是EINPROGRESS时才表示连接还在进行，否则出错返回</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;unblock connect not support\n&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fd_set writefds;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">timeout</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">FD_ZERO(&amp;writefds);</span><br><span class="line">FD_SET(sockfd, &amp;writefds);</span><br><span class="line">timeout.tv_sec = time;</span><br><span class="line">timeout.tv_usec = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = select(sockfd + <span class="number">1</span>, <span class="literal">nullptr</span>, &amp;writefds, <span class="literal">nullptr</span>, &amp;timeout);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*select超时或者出错，立即返回*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection time out\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试fdset的位fd是否被设置</span></span><br><span class="line"><span class="keyword">if</span> (!FD_ISSET(sockfd, &amp;writefds)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;no events on sockfd found\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> error = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(error);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用getsockopt来获取并清除sockfd上的错误, getsockopt和setsockopt这两个函数成功时返回0，</span></span><br><span class="line"><span class="comment">// 失败时返回-1并设置errno。</span></span><br><span class="line"><span class="keyword">if</span> (getsockopt(sockfd, SOL_SOCKET, SO_ERROR, &amp;error, &amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误号不为0表示连接出错</span></span><br><span class="line"><span class="keyword">if</span> (error != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection failed after select with the error:%d\n&quot;</span>, error);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接成功</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection ready after select with the socket:%d\n&quot;</span>, sockfd);</span><br><span class="line">fcntl(sockfd, F_SETFL, fdopt);</span><br><span class="line"><span class="keyword">return</span> sockfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> sockfd = unblock_connect(ip, port, <span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (sockfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>**5.11 章节 socket选项 : **     getsockopt, setsockopt, 两个系统调用则是专门用来读取和设置socket文件描述符属性的 方法。</p><h4 id="9-6-I-O复用的高级应用二：聊天室程序"><a href="#9-6-I-O复用的高级应用二：聊天室程序" class="headerlink" title="9.6 I/O复用的高级应用二：聊天室程序"></a>9.6 I/O复用的高级应用二：聊天室程序</h4><p>本节我们以poll为例实现一个简单的聊天室 程序，以阐述如何使用I/O复用技术来同时处理网络连接和用户输入。 该聊天室程序能让所有用户同时在线群聊，它分为客户端和服务器两个部分。</p><p>其中客户端程序有两个功能：一是从标准输入终端读入用户 数据，并将用户数据发送至服务器；二是往标准输出终端打印服务器 发送给它的数据。</p><p>服务器的功能是接收客户数据，并把客户数据发送 给每一个登录到该服务器上的客户端（数据发送者除外）。</p><h5 id="9-6-1-客户端"><a href="#9-6-1-客户端" class="headerlink" title="9.6.1 客户端"></a>9.6.1 客户端</h5><p>客户端程序使用poll同时监听用户输入和网络连接，并利用splice 函数将用户输入内容直接定向到网络连接上以发送之，从而实现数据 零拷贝，提高了程序执行效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">bzero(&amp;server_address, <span class="keyword">sizeof</span>(server_address));</span><br><span class="line">server_address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;server_address.sin_addr);</span><br><span class="line">server_address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> sockfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(sockfd &gt;= <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (connect(sockfd, (struct sockaddr *) &amp;server_address, <span class="keyword">sizeof</span>(server_address)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;connection failed\n&quot;</span>);</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pollfd fds[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册文件描述符0（标准输入）和文件描述符sockfd上的可读事件*/</span></span><br><span class="line">fds[<span class="number">0</span>].fd = <span class="number">0</span>;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line">fds[<span class="number">1</span>].fd = sockfd;</span><br><span class="line">fds[<span class="number">1</span>].events = POLLIN | POLLRDHUP;</span><br><span class="line">fds[<span class="number">1</span>].revents = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> read_buf[BUFFER_SIZE];</span><br><span class="line"><span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">int</span> ret = pipe(pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ret = poll(fds, <span class="number">2</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLRDHUP) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;server close the connection\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[<span class="number">1</span>].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="built_in">memset</span>(read_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">recv(fds[<span class="number">1</span>].fd, read_buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, read_buf);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (fds[<span class="number">0</span>].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="comment">/*使用splice将用户输入的数据直接写到sockfd上（零拷贝）*/</span></span><br><span class="line">ret = splice(<span class="number">0</span>, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">ret = splice(pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, sockfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="9-6-2-服务端"><a href="#9-6-2-服务端" class="headerlink" title="9.6.2 服务端"></a>9.6.2 服务端</h5><p>服务器程序使用poll同时管理监听socket和连接socket，并且使用牺牲空间换取时间的策略来提高服务器性能</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> USER_LIMIT 5    <span class="comment">/*最大用户数量*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64  <span class="comment">/*读缓冲区的大小*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535  <span class="comment">/*文件描述符数量限制*/</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户数据：客户端socket地址、待写到客户端的数据的位置、从客户端读入的数据</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">char</span> *write_buf;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 创建users数组，分配FD_LIMIT个client_data对象。可以预期：</span></span><br><span class="line"><span class="comment"> * 每个可能的socket连接都可以获得一个这样的对象，并且socket的值可以直接用来索引（作为数组的下标）</span></span><br><span class="line"><span class="comment"> * socket连接对应的client_data对象，这是将socket和客户数据关联的简单而高效的方式</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line">client_data *users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 尽管我们分配了足够多的client_data对象，但为了提高poll的性能，仍然有必要限制用户的数量</span></span><br><span class="line">pollfd fds[USER_LIMIT + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> user_counter = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= USER_LIMIT; ++i) &#123;</span><br><span class="line">fds[i].fd = <span class="number">-1</span>;</span><br><span class="line">fds[i].events = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">fds[<span class="number">0</span>].fd = listenfd;</span><br><span class="line">fds[<span class="number">0</span>].events = POLLIN | POLLERR;</span><br><span class="line">fds[<span class="number">0</span>].revents = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">ret = poll(fds, user_counter + <span class="number">1</span>, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;poll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; user_counter + <span class="number">1</span>; ++i) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// fds[0] 用于建立连接</span></span><br><span class="line"><span class="keyword">if</span> ((fds[i].fd == listenfd) &amp;&amp; (fds[i].revents &amp; POLLIN)) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span> (connfd &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果请求太多，则关闭新到的连接*/</span></span><br><span class="line"><span class="keyword">if</span> (user_counter &gt;= USER_LIMIT) &#123;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *info = <span class="string">&quot;too many users\n&quot;</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, info);</span><br><span class="line">send(connfd, info, <span class="built_in">strlen</span>(info), <span class="number">0</span>);</span><br><span class="line">close(connfd);</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 对于新的连接，同时修改fds和users数组。前文已经提到，</span></span><br><span class="line"><span class="comment"> * users[connfd]对应于新连接文件描述符connfd的客户数据</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"></span><br><span class="line">user_counter++;</span><br><span class="line">users[connfd].address = client_address;</span><br><span class="line">setnonblocking(connfd);</span><br><span class="line">fds[user_counter].fd = connfd;</span><br><span class="line">fds[user_counter].events = POLLIN | POLLRDHUP | POLLERR;</span><br><span class="line">fds[user_counter].revents = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;comes a new user,now have%d users\n&quot;</span>, user_counter);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLERR) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get an error from%d\n&quot;</span>, fds[i].fd);</span><br><span class="line"><span class="keyword">char</span> errors[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memset</span>(errors, <span class="string">&#x27;\0&#x27;</span>, <span class="number">100</span>);</span><br><span class="line"><span class="keyword">socklen_t</span> length = <span class="keyword">sizeof</span>(errors);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (getsockopt(fds[i].fd, SOL_SOCKET, SO_ERROR, &amp;errors,&amp;length) &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get socket option failed\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLRDHUP) &#123;</span><br><span class="line"><span class="comment">// 如果客户端关闭连接，则服务器也关闭对应的连接，并将用户总数减1</span></span><br><span class="line">users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">close(fds[i].fd);</span><br><span class="line">fds[i] = fds[user_counter];</span><br><span class="line">i--;</span><br><span class="line">user_counter--;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;a client left\n&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLIN) &#123;</span><br><span class="line"><span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line"><span class="built_in">memset</span>(users[connfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">ret = recv(connfd, users[connfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of client data%s from%d\n&quot;</span>, ret, users[connfd].buf, connfd);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果读操作出错，则关闭连接*/</span></span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">close(connfd);</span><br><span class="line">users[fds[i].fd] = users[fds[user_counter].fd];</span><br><span class="line">fds[i] = fds[user_counter];</span><br><span class="line">i--;</span><br><span class="line">user_counter--;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*如果接收到客户数据，则通知其他socket连接准备写数据*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= user_counter; ++j) &#123;</span><br><span class="line"><span class="keyword">if</span> (fds[j].fd == connfd) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">fds[j].events |= ~POLLIN;</span><br><span class="line">fds[j].events |= POLLOUT;</span><br><span class="line">users[fds[j].fd].write_buf = users[connfd].buf;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (fds[i].revents &amp; POLLOUT) &#123;</span><br><span class="line"><span class="keyword">int</span> connfd = fds[i].fd;</span><br><span class="line"><span class="keyword">if</span> (!users[connfd].write_buf) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = send(connfd, users[connfd].write_buf, <span class="built_in">strlen</span>(users[connfd].write_buf), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt;= <span class="number">0</span>)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;error\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">users[connfd].write_buf = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*写完数据后需要重新注册fds[i]上的可读事件*/</span></span><br><span class="line">fds[i].events |= ~POLLOUT;</span><br><span class="line">fds[i].events |= POLLIN;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]users;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="9-7-I-O-复用的高级应用三-同时处理TCP和UDP服务"><a href="#9-7-I-O-复用的高级应用三-同时处理TCP和UDP服务" class="headerlink" title="9.7 I/O 复用的高级应用三: 同时处理TCP和UDP服务"></a>9.7 I/O 复用的高级应用三: 同时处理TCP和UDP服务</h4><p>在实际应用 中，有不少服务器程序能同时监听多个端口，比如超级服务inetd和 android的调试服务adbd。</p><p>从bind系统调用的参数来看，一个socket只能与一个socket地址绑 定，即一个socket只能用来监听一个端口。因此，服务器如果要同时 监听多个端口，就必须创建多个socket，并将它们分别绑定到各个端 口上。这样一来，服务器程序就需要同时管理多个监听socket，I/O复 用技术就有了用武之地。</p><p>另外，即使是同一个端口，如果服务器要同 时处理该端口上的TCP和UDP请求，则也需要创建两个不同的socket： 一个是流socket，另一个是数据报socket，并将它们都绑定到该端口 上。比如代码清单9-8所示的回射服务器(比如echo)就能同时处理一个端口上的 TCP和UDP请求。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/2.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/poll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/poll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TCP_BUFFER_SIZE 512</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UDP_BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建TCP socket，并将其绑定到端口port上*/</span></span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建UDP socket，并将其绑定到端口port上*/</span></span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> udpfd = socket(PF_INET, SOCK_DGRAM, <span class="number">0</span>);</span><br><span class="line">assert(udpfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(udpfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*注册TCP socket和UDP socket上的可读事件*/</span></span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line">addfd(epollfd, udpfd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> (number &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *)&amp;client_address, &amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (sockfd == udpfd) &#123;</span><br><span class="line"><span class="keyword">char</span> buf[UDP_BUFFER_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, UDP_BUFFER_SIZE);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="comment">// udp数据读取</span></span><br><span class="line">ret = recvfrom(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>,(struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret &gt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">// udp 数据发送</span></span><br><span class="line">sendto(udpfd, buf, UDP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>,(struct sockaddr *) &amp;client_address, client_addrlength);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="keyword">char</span> buf[TCP_BUFFER_SIZE];</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">memset</span>(buf, <span class="string">&#x27;\0&#x27;</span>, TCP_BUFFER_SIZE);</span><br><span class="line">ret = recv(sockfd, buf, TCP_BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> ((errno == EAGAIN) || (errno == EWOULDBLOCK)) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">close(sockfd);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line">close(sockfd);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">send(sockfd, buf, ret, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;something else happened\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-8-超级服务xinetd"><a href="#9-8-超级服务xinetd" class="headerlink" title="9.8 超级服务xinetd"></a>9.8 超级服务xinetd</h4><p>Linux因特网服务inetd是超级服务。它同时管理着多个子服务，即 监听多个端口。现在Linux系统上使用的inetd服务程序通常是其升级版 本xinetd。</p><h5 id="9-8-1-xinetd-配置文件"><a href="#9-8-1-xinetd-配置文件" class="headerlink" title="9.8.1 xinetd 配置文件"></a>9.8.1 xinetd 配置文件</h5><p>xinetd采用/etc/xinetd.conf主配置文件和/etc/xinetd.d目录下的子配置 文件来管理所有服务。主配置文件包含的是通用选项，这些选项将被 所有子配置文件继承。不过子配置文件可以覆盖这些选项。每一个子 配置文件用于设置一个子服务的参数。</p><p>比如，telnet子服务的配置文 件/etc/xinetd.d/telnet的典型内容如下：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211328677-1678341964417.png" class="" title="image-20230302211328677"><p>/etc/xinetd. d/telnet文件中的每一项的含义如表9-3所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211402685-1678341964417.png" class="" title="image-20230302211402685"><h5 id="9-8-2-xinetd-服务流程"><a href="#9-8-2-xinetd-服务流程" class="headerlink" title="9.8.2 xinetd 服务流程"></a>9.8.2 xinetd 服务流程</h5><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230302211732296-1678341964417.png" class="" title="image-20230302211732296"><h3 id="第10章-信号"><a href="#第10章-信号" class="headerlink" title="第10章 信号"></a>第10章 信号</h3><p><strong>信号是由用户、系统或者进程发送给目标进程的信息</strong>，以通知目 标进程某个状态的改变或系统异常。Linux信号可由如下条件产生：</p><ul><li>对于前台进程，用户可以通过输入特殊的终端字符来给它发送信号。比如输入Ctrl+C通常会给进程发送一个中断信号。</li><li>系统异常。比如浮点异常和非法内存段访问。</li><li>系统状态变化。比如alarm定时器到期将引起SIGALRM信号。</li><li>运行kill命令或调用kill函数。</li></ul><h4 id="10-1-Linux信号概述"><a href="#10-1-Linux信号概述" class="headerlink" title="10.1 Linux信号概述"></a>10.1 Linux信号概述</h4><h5 id="10-1-1-发送信号"><a href="#10-1-1-发送信号" class="headerlink" title="10.1.1 发送信号"></a>10.1.1 发送信号</h5><p>Linux下，一个进程给其他进程发送信号的API是kill函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kill</span><span class="params">(<span class="keyword">pid_t</span> pid,<span class="keyword">int</span> sig)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>该函数把信号sig发送给目标进程，Linux定义的信号值都大于0，如果sig取值为0，则kill函数不发送 任何信号。但将sig设置为0可以用来检测目标进程或进程组是否存在， 因为检查工作总是在信号发送之前就执行。</p></li><li><p>目标进程由pid参数指定，其可 能的取值及含义如表10-1所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304135652650-1678341964417.png" class="" title="image-20230304135652650"></li></ul><h5 id="10-1-2-信号处理方式"><a href="#10-1-2-信号处理方式" class="headerlink" title="10.1.2 信号处理方式"></a>10.1.2 信号处理方式</h5><p>目标进程在收到信号时，需要定义一个接收函数来处理之。信号 处理函数的原型如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(*<span class="keyword">__sighandler_t</span>)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>信号处理函数只带有一个整型参数，该参数用来指示信号类型。</p><h5 id="10-1-3-Linux信号"><a href="#10-1-3-Linux信号" class="headerlink" title="10.1.3 Linux信号"></a>10.1.3 Linux信号</h5><p>Linux的可用信号都定义在bits/signum.h头文件中，其中包括标准信 号和POSIX实时信号。本书仅讨论标准信号， 以下列举几种与网络编程关系紧密的几个信号：</p><ol><li>SIGHUP：控制终端挂起</li><li>SIGPIPE：往读端被关闭的管道或者socket连接中写数据</li><li>SIGURG：socket连接上接收到紧急数据</li><li>SIGALRM：由alarm或setitimer设置的实时闹钟超时引起</li><li>SIGCHLD：子进程状态发生变化（退出或者暂停）</li></ol><h5 id="10-1-4-中断系统调用"><a href="#10-1-4-中断系统调用" class="headerlink" title="10.1.4 中断系统调用"></a>10.1.4 中断系统调用</h5><p>如果程序在执行处于阻塞状态的系统调用时接收到信号，并且我 们为该信号设置了信号处理函数，则默认情况下系统调用将被中断， 并且errno被设置为EINTR。</p><p>我们可以使用sigaction函数（见后文）为信 号设置SA_RESTART标志以自动重启被该信号中断的系统调用。</p><h4 id="10-2-信号函数"><a href="#10-2-信号函数" class="headerlink" title="10.2 信号函数"></a>10.2 信号函数</h4><h5 id="10-2-1-signal系统调用"><a href="#10-2-1-signal系统调用" class="headerlink" title="10.2.1 signal系统调用"></a>10.2.1 signal系统调用</h5><p>要为一个<strong>信号设置处理函数</strong>，可以使用下面的signal系统调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">_sighandler_t</span> <span class="title">signal</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">_sighandler_t</span> _handler)</span></span></span><br></pre></td></tr></table></figure><ul><li>sig参数指出要捕获的信号类型。</li><li>_handler参数是_sighandler_t类型 的函数指针，用于指定信号sig的处理函数。</li></ul><p>signal函数成功时返回一个函数指针，该函数指针的类型也是 _sighandler_t。 <strong>这个返回值是前一次调用signal函数时传入的函数指针， 或者是信号sig对应的默认处理函数指针SIG_DEF（如果是第一次调用 signal的话）。</strong></p><p>signal系统调用出错时返回SIG_ERR，并设置errno。</p><h5 id="10-2-2-sigaction系统调用"><a href="#10-2-2-sigaction系统调用" class="headerlink" title="10.2.2 sigaction系统调用"></a>10.2.2 sigaction系统调用</h5><p>设置<strong>信号处理函数</strong>的更健壮的接口是如下的系统调用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaction</span><span class="params">(<span class="keyword">int</span> sig, <span class="keyword">const</span> struct sigaction* act,struct sigaction* oact)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>sig参数指出要捕获的信号类型</li><li>act参数指定新的信号处理方式</li><li>oact参数则输出信号先前的处理方式（如果不为NULL的话）</li></ul><p>sigaction结构体描述了信号处理 的细节，其定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Structure describing the action to be taken when a signal arrives.  */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span></span></span><br><span class="line"><span class="class">  &#123;</span></span><br><span class="line">    <span class="comment">/* Signal handler.  */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined __USE_POSIX199309 || defined __USE_XOPEN_EXTENDED</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span></span></span><br><span class="line"><span class="class">      &#123;</span></span><br><span class="line"><span class="comment">/* Used if SA_SIGINFO is not set.  */</span></span><br><span class="line"><span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line"><span class="comment">/* Used if SA_SIGINFO is set.  */</span></span><br><span class="line"><span class="keyword">void</span> (*sa_sigaction) (<span class="keyword">int</span>, <span class="keyword">siginfo_t</span> *, <span class="keyword">void</span> *);</span><br><span class="line">      &#125;</span><br><span class="line">    __sigaction_handler;</span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> sa_handler__sigaction_handler.sa_handler</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> sa_sigaction__sigaction_handler.sa_sigaction</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">__sighandler_t</span> sa_handler;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Additional set of signals to be blocked.  */</span></span><br><span class="line">    <span class="keyword">__sigset_t</span> sa_mask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Special flags.  */</span></span><br><span class="line">    <span class="keyword">int</span> sa_flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Restore handler.  */</span></span><br><span class="line">    <span class="keyword">void</span> (*sa_restorer) (<span class="keyword">void</span>);</span><br><span class="line">    <span class="comment">// 指向返回值是void, 参数是void类型的 函数指针</span></span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure><ul><li><p>该结构体中的sa_hander成员指定信号处理函数。</p></li><li><p>sa_mask成员设置进程的信号掩码（确切地说是在进程原有信号掩码的基础上增加信号 掩码），以指定哪些信号不能发送给本进程。<strong>sa_mask是信号集 sigset_t（_sigset_t的同义词）类型，该类型指定一组信号。</strong> 下一节介绍sigset_t</p></li><li><p>sa_flags成员用于设置程序收到信号时的行 为，其可选值如表10-4所示：</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304142154845-1678341964417.png" class="" title="image-20230304142154845"></li></ul><h4 id="10-3-信号集"><a href="#10-3-信号集" class="headerlink" title="10.3 信号集"></a>10.3 信号集</h4><h5 id="10-3-1-信号集函数"><a href="#10-3-1-信号集函数" class="headerlink" title="10.3.1 信号集函数"></a>10.3.1 信号集函数</h5><p>前文提到，Linux使用数据结构sigset_t来表示一组信号。其定义如 下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/sigset.h＞</span></span><br><span class="line">#define_SIGSET_NWORDS(<span class="number">1024</span>/(<span class="number">8</span>*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span>)))</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> int__val[_SIGSET_NWORDS];</span><br><span class="line">&#125;<span class="keyword">__sigset_t</span>;</span><br></pre></td></tr></table></figure><p>sigset_t实际上是一个长整型数组，数组的每个元素的每个位表示一个信号。这种定义方式和文件描述符集fd_set类似。</p><p>Linux提供了如下一组函数来设置、修改、删除和查询信号集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigemptyset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*清空信号集*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigfillset</span><span class="params">(<span class="keyword">sigset_t</span>* _set)</span><span class="comment">/*在信号集中设置所有信号*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigaddset</span><span class="params">(<span class="keyword">sigset_t</span>*_set,<span class="keyword">int</span> _signo)</span><span class="comment">/*将信号_signo添加至信号集中*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigdelset</span><span class="params">(<span class="keyword">sigset_t</span>* _set,<span class="keyword">int</span> _signo)</span><span class="comment">/*将信号_signo从信号集中删除*/</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigismember</span><span class="params">(_const <span class="keyword">sigset_t</span>* _set, int_signo)</span><span class="comment">/*测试_signo是否在信号集中*/</span></span></span><br></pre></td></tr></table></figure><h5 id="10-3-2-进程信号掩码"><a href="#10-3-2-进程信号掩码" class="headerlink" title="10.3.2 进程信号掩码"></a>10.3.2 进程信号掩码</h5><p>我们可以利用<strong>sigaction结构体的sa_mask成员来设置进程的信号掩码</strong>。此外，如下函数也可以用于设置或查看进程的信号掩 码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigprocmask</span><span class="params">(<span class="keyword">int</span> _how, _const <span class="keyword">sigset_t</span>* _set, <span class="keyword">sigset_t</span>* _oset)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p><code>_set</code>参数指定新的信号掩码，</p></li><li><p>_oset参数则输出原来的信号掩码（如 果不为NULL的话）。</p></li><li><p>如果_set参数不为NULL，则_how参数指定设置 进程信号掩码的方式，其可选值如表10-5所示。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304143250709-1678341964417.png" class="" title="image-20230304143250709"></li></ul><p>sigprocmask成功时返回0，失败则返回-1并设置errno。</p><h5 id="10-3-3-被挂起的信号"><a href="#10-3-3-被挂起的信号" class="headerlink" title="10.3.3 被挂起的信号"></a>10.3.3 被挂起的信号</h5><p>设置进程信号掩码后，被屏蔽的信号将不能被进程接收。<strong>如果给进程发送一个被屏蔽的信号，则操作系统将该信号设置为进程的一个被挂起的信号。</strong>如果我们取消对被挂起信号的屏蔽，则它能立即被进 程接收到</p><p>如下函数可以获得进程当前被挂起的信号集：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜signal.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sigpending</span><span class="params">(<span class="keyword">sigset_t</span>* <span class="built_in">set</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>set参数用于保存被挂起的信号集。显然，进程即使多次接收到同 一个被挂起的信号，sigpending函数也只能反映一次。并且，当我们再 次使用sigprocmask使能该挂起的信号时，该信号的处理函数也只被触 发一次。</p><p>sigpending成功时返回0，失败时返回-1并设置errno。</p><h4 id="10-4-统一事件源"><a href="#10-4-统一事件源" class="headerlink" title="10.4 统一事件源"></a>10.4 统一事件源</h4><p>信号是一种异步事件：信号处理函数和程序的主循环是两条不同 的执行路线。很显然，信号处理函数需要尽可能快地执行完毕，以确 保该信号不被屏蔽（前面提到过，为了避免一些竞态条件，信号在处 理期间，系统不会再次触发它）太久。</p><p>一种典型的解决方案是：<strong>把信号的主要处理逻辑放到程序的主循环中</strong>，当信号处理函数被触发时， 它<strong>只是简单地通知主循环程序接收到信号</strong>，并把信号值传递给主循环，主循环再根据接收到的信号值执行目标信号对应的逻辑代码。</p><p><strong>信号处理函数通常使用管道来将信号“传递”给主循环</strong>：信号处理函数往管道的写端写入信号值，主循环则从管道的读端读出该信号值。那么 主循环怎么知道管道上何时有数据可读呢  ?</p><p>这很简单，<strong>我们只需要使用 I/O复用系统调用来监听管道的读端文件描述符上的可读事件</strong>。如此一 来，信号事件就能和其他I/O事件一样被处理，即统一事件源。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将事件添加到 epoll的内核事件表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*信号处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*保留原来的errno，在函数最后恢复，以保证函数的可重入性*/</span></span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);<span class="comment">/*将信号值写入管道，以通知主循环*/</span></span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置信号的处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = sig_handler;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SA_RESTART 重新调用被该信号终止的系统调用</span></span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*在信号集中设置所有信号*/</span></span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> listenfd;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line">listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is%d\n&quot;</span>, errno);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * epoll需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表</span></span><br><span class="line"><span class="comment"> * 文件描述符使用如下epoll_create函数 来创建</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="keyword">int</span> epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用socketpair创建管道，注册pipefd[0]上的可读事件*/</span></span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line"></span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置一些信号的处理函数*/</span></span><br><span class="line">addsig(SIGHUP);</span><br><span class="line">addsig(SIGCHLD);</span><br><span class="line">addsig(SIGTERM);</span><br><span class="line">addsig(SIGINT);</span><br><span class="line"><span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"><span class="comment">/*如果就绪的文件描述符是listenfd，则处理新的连接*/</span></span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果就绪的文件描述符是pipefd[0]，则处理信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*因为每个信号值占1字节，所以按字节来逐个接收信号。我们以SIGTERM为例，</span></span><br><span class="line"><span class="comment"> * 来说明如何安全地终止服务器主循环*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[i]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGCHLD:</span><br><span class="line"><span class="keyword">case</span> SIGHUP: &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM:</span><br><span class="line"><span class="keyword">case</span> SIGINT: &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;close fds\n&quot;</span>);</span><br><span class="line">close(listenfd);</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-5-网络编程相关信号"><a href="#10-5-网络编程相关信号" class="headerlink" title="10.5 网络编程相关信号"></a>10.5 网络编程相关信号</h4><p>本节中我们详细探讨三个和网络编程密切相关的信号。</p><h5 id="10-5-1-SIGHUP"><a href="#10-5-1-SIGHUP" class="headerlink" title="10.5.1 SIGHUP"></a>10.5.1 SIGHUP</h5><p><strong>当挂起进程的控制终端时，SIGHUP信号将被触发。</strong>对于没有控 制终端的网络后台程序而言，它们通常利用SIGHUP信号来强制服务 器重读配置文件。一个典型的例子是xinetd超级服务程序。</p><p>xinetd程序在接收到SIGHUP信号之后将调用hard_reconfig函数 （见xinetd源码），它循环读取/etc/xinetd.d/目录下的每个子配置文 件，并检测其变化。如果某个正在运行的子服务的配置文件被修改以停止服务，则xinetd主进程将给该子服务进程发送SIGTERM信号以结 束它。如果某个子服务的配置文件被修改以开启服务，则xinetd将创建 新的socket并将其绑定到该服务对应的端口上。</p><h5 id="10-5-2-SIGPIPE"><a href="#10-5-2-SIGPIPE" class="headerlink" title="10.5.2 SIGPIPE"></a>10.5.2 SIGPIPE</h5><p>默认情况下，往一个读端关闭的管道或socket连接中写数据将引发SIGPIPE信号。我们需要在<strong>代码中捕获并处理该信号</strong>，或者至少忽 略它，因为程序接收到SIGPIPE信号的默认行为是结束进程，而我们 绝对不希望因为错误的写操作而导致程序退出。引起SIGPIPE信号的 写操作将设置errno为EPIPE。</p><p>第5章提到，我们可以使用send函数的MSG_NOSIGNAL标志来禁 止写操作触发SIGPIPE信号。在这种情况下，我们应该使用send函数反 馈的errno值来判断管道或者socket连接的读端是否已经关闭。 </p><p>此外，我们也可以利用I/O复用系统调用来检测管道和socket连接 的读端是否已经关闭。以poll为例，当管道的读端关闭时，写端文件 描述符上的POLLHUP事件将被触发；当socket连接被对方关闭时， socket上的POLLRDHUP事件将被触发。</p><h5 id="10-5-3-SIGURG"><a href="#10-5-3-SIGURG" class="headerlink" title="10.5.3 SIGURG"></a>10.5.3 SIGURG</h5><p>在Linux环境下，内核通知应用程序带外数据到达主要有两种方 法：</p><ol><li>一种是第9章介绍的I/O复用技术，select等系统调用在接收到带外 数据时将返回，并向应用程序报告socket上的异常事件, 代码9_1</li><li>另外一种方法就是使用SIGURG信号，如 代码清单10-3所示。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGURG信号的处理函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_urg</span><span class="params">(<span class="keyword">int</span> sig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno=errno;</span><br><span class="line"><span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line"><span class="keyword">int</span> ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,MSG_OOB);<span class="comment">/*接收带外数据*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of oob data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">errno=save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig,<span class="keyword">void</span>(*sig_handler)(<span class="keyword">int</span>))</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa,<span class="string">&#x27;\0&#x27;</span>,<span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler=sig_handler;</span><br><span class="line">sa.sa_flags|=SA_RESTART;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig,&amp;sa,<span class="literal">nullptr</span>)!=<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>*argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(argc&lt;=<span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>,basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>*ip=argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port=atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family=AF_INET;</span><br><span class="line">inet_pton(AF_INET,ip,&amp;address.sin_addr);</span><br><span class="line">address.sin_port=htons(port);</span><br><span class="line"><span class="keyword">int</span> sock=socket(PF_INET,SOCK_STREAM,<span class="number">0</span>);</span><br><span class="line">assert(sock&gt;=<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> ret=bind(sock,(struct sockaddr*)&amp;address,<span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line">ret=listen(sock,<span class="number">5</span>);</span><br><span class="line">assert(ret!=<span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength=<span class="keyword">sizeof</span>(client);</span><br><span class="line">connfd=accept(sock,(struct sockaddr*)&amp;client,&amp;client_addrlength);</span><br><span class="line"><span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;errno is:%d\n&quot;</span>,errno);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">addsig(SIGURG,sig_urg);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*使用SIGURG信号之前，我们必须设置socket的宿主进程或进程组</span></span><br><span class="line"><span class="comment"> * F_SETOWN 设定SIGIO和SIGURG信号的宿主进程的PID或者进程组的组id</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line">fcntl(connfd,F_SETOWN, getpid());</span><br><span class="line"><span class="keyword">char</span> buffer[BUF_SIZE];</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)<span class="comment">/*循环接收普通数据*/</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">memset</span>(buffer,<span class="string">&#x27;\0&#x27;</span>,BUF_SIZE);</span><br><span class="line">ret=recv(connfd,buffer,BUF_SIZE<span class="number">-1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;got%d bytes of normal data&#x27;%s&#x27;\n&quot;</span>,ret,buffer);</span><br><span class="line">&#125;</span><br><span class="line">close(connfd);</span><br><span class="line">&#125;</span><br><span class="line">close(sock);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第11章-定时器"><a href="#第11章-定时器" class="headerlink" title="第11章 定时器"></a>第11章 定时器</h3><hr><p>网络程序需要处理的第三类事件是定时事件，比如定期检测一个客户连接的活动状态。服务器程序通常管理着众多定时事件，因此有效地组织这些定时事件，使之能在预期的时间点被触发且不影响服务器的主要逻辑，对于服务器的性能有着至关重要的影响。</p><p>为此，<strong>我们要将每个定时事件分别封装成定时器，并使用某种容器类数据结构</strong>， 比如链表、排序链表和时间轮，将所有定时器串联起来，以实现对定 时事件的统一管理。本章主要讨论的就是两种高效的管理定时器的容器：时间轮和时间堆。</p><p><strong>注</strong>: 定时器容器是容器类数据结构，比如时间轮；定时器则是容器内容纳的一个个对象，它是对定时事件的封装。</p><p>我们先要介绍定时的方法。 定时是指在一段时间之后触发某段代码的机制，我们可以在这段代码 中依次处理所有到期的定时器。换言之，定时机制是定时器得以被处 理的原动力。Linux提供了三种定时方法，它们是：</p><ul><li>socket选项SO_RCVTIMEO和SO_SNDTIMEO。</li><li>SIGALRM信号。</li><li>I/O复用系统调用的超时参数</li></ul><h4 id="11-1-socket选项SO-RCVTIMEO和-SO-SNDTIMEO"><a href="#11-1-socket选项SO-RCVTIMEO和-SO-SNDTIMEO" class="headerlink" title="11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO"></a>11.1 socket选项SO_RCVTIMEO和 SO_SNDTIMEO</h4><p>第5章中我们介绍过socket选项SO_RCVTIMEO和 SO_SNDTIMEO，它们分别用来设置socket接收数据超时时间和发送数 据超时时间。</p><p>这两个选项仅对与数据接收和发送相关的socket专用系统调用有效，这些系统调用包括send、sendmsg、recv、recvmsg、 accept和connect。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230304222359944-1678341964417.png" class="" title="image-20230304222359944"><p>我们可以<strong>根据系统调用（send、 sendmsg、recv、recvmsg、accept和connect）的返回值以及errno来判断 超时时间是否已到</strong>，进而决定是否开始处理定时任务。</p><h4 id="11-2-SIGALRM-信号"><a href="#11-2-SIGALRM-信号" class="headerlink" title="11.2 SIGALRM 信号"></a>11.2 SIGALRM 信号</h4><p>第10章提到，<strong>由alarm和setitimer函数设置的实时闹钟一旦超时</strong>， 将触发SIGALRM信号。因此，我们可以利用该信号的信号处理函数来 处理定时任务。</p><p>但是，如果要处理多个定时任务，我们就需要不断地 触发SIGALRM信号，并在其信号处理函数中执行到期的任务。一般而言，<strong>SIGALRM信号按照固定的频率生成，即由alarm或setitimer函数设 置的定时周期T保持不变。</strong>如果某个定时任务的超时时间不是T的整数 倍，那么它实际被执行的时间和预期的时间将略有偏差。因此定时周 期T反映了定时的精度。</p><p>我们需要先给出一种简单的定时器实现 ——基于升序链表的定时器，并把它应用到处理非活动连接这个实例 中。</p><p>这样，我们才能观察到<strong>SIGALRM信号处理函数是如何处理定时器 并执行定时任务的</strong>。此外，我们介绍这种定时器也是为了和后面要讨论的高效定时器——时间轮和时间堆做对比。</p><h5 id="11-2-1-基于升序链表的定时器"><a href="#11-2-1-基于升序链表的定时器" class="headerlink" title="11.2.1 基于升序链表的定时器"></a>11.2.1 基于升序链表的定时器</h5><p>定时器通常至少要包含两个成员：</p><ul><li>一个超时时间（相对时间或者 绝对时间）</li><li>一个任务回调函数</li><li>有的时候还可能包含回调函数被执 行时需要传入的参数，以及是否重启定时器等信息。</li><li>如果使用链表作为容器来串联所有的定时器，则每个定时器还要包含指向下一个定时 器的指针成员。进一步，如果链表是双向的，则每个定时器还需要包 含指向前一个定时器的指针成员。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/4.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> LST_TIMER</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LST_TIMER</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span>;</span><span class="comment">/*前向声明*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*用户数据结构：客户端socket地址、socket文件描述符、读缓存和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">util_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">util_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">util_timer() : prev(<span class="literal">nullptr</span>), next(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">time_t</span> expire&#123;&#125;;<span class="comment">/*任务的超时时间，这里使用绝对时间*/</span></span><br><span class="line"><span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*任务回调函数*/</span></span><br><span class="line"><span class="comment">/*回调函数处理的客户数据，由定时器的执行者传递给回调函数*/</span></span><br><span class="line"></span><br><span class="line">client_data *user_data&#123;&#125;;</span><br><span class="line">util_timer *prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">util_timer *next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器链表。它是一个升序、双向链表，且带有头结点和尾节点*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">sort_timer_lst</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">sort_timer_lst() : head(<span class="literal">nullptr</span>), tail(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*链表被销毁时，删除其中所有的定时器*/</span></span><br><span class="line">~sort_timer_lst() &#123;</span><br><span class="line">util_timer *tmp = head;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">head = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将目标定时器timer添加到链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line">head = tail = timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 如果目标定时器的超时时间小于当前链表中所有定时器的超时时间，</span></span><br><span class="line"><span class="comment"> * 则把该定时器插入链表头部，作为链表新的头节点。否则就需要调用重载函数</span></span><br><span class="line"><span class="comment">add_timer(util_timer*timer,util_timer*lst_head)，把它插入链表中合适的位</span></span><br><span class="line"><span class="comment">置，以保证链表的升序特性</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">if</span> (timer-&gt;expire &lt; head-&gt;expire) &#123;</span><br><span class="line">timer-&gt;next = head;</span><br><span class="line">head-&gt;prev = timer;</span><br><span class="line">head = timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">add_timer(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*当某个定时任务发生变化时，调整对应的定时器在链表中的位置。这个函数只考虑被</span></span><br><span class="line"><span class="comment">调整的定时器的超时时间延长的情况，即该定时器需要往链表的尾部移动*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">util_timer *tmp = timer-&gt;next;</span><br><span class="line"><span class="comment">/*如果被调整的目标定时器处在链表尾部，或者该定时器新的超时值仍然小于其下一个</span></span><br><span class="line"><span class="comment">定时器的超时值，则不用调整*/</span></span><br><span class="line"><span class="keyword">if</span> (!tmp || (timer-&gt;expire &lt; tmp-&gt;expire)) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器是链表的头节点，则将该定时器从链表中取出并重新插入链表*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">add_timer(timer, head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果目标定时器不是链表的头节点，则将该定时器从链表中取出，然后插入其原来所</span></span><br><span class="line"><span class="comment">在位置之后的部分链表中*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">add_timer(timer, timer-&gt;next);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将目标定时器timer从链表中删除*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(util_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*下面这个条件成立表示链表中只有一个定时器，即目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span> ((timer == head) &amp;&amp; (timer == tail)) &#123;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">head = <span class="literal">nullptr</span>;</span><br><span class="line">tail = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的头结点，</span></span><br><span class="line"><span class="comment"> * 则将链表的头结点重置为原头节点的下一个节点，然后删除目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == head) &#123;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果链表中至少有两个定时器，且目标定时器是链表的尾结点，</span></span><br><span class="line"><span class="comment"> * 则将链表的尾结点重置为原尾节点的前一个节点，然后删除目标定时器*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == tail) &#123;</span><br><span class="line">tail = tail-&gt;prev;</span><br><span class="line">tail-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果目标定时器位于链表的中间，则把它前后的定时器串联起来，然后删除目标定时器*/</span></span><br><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SIGALRM信号每次被触发就在其信号处理函数（如果使用统一事件源，则是主函数）</span></span><br><span class="line"><span class="comment">中执行一次tick函数，以处理链表上到期的任务*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;timer tick\n&quot;</span>);</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);<span class="comment">/*获得系统当前的时间*/</span></span><br><span class="line"></span><br><span class="line">util_timer *tmp = head;</span><br><span class="line"><span class="comment">/*从头结点开始依次处理每个定时器，直到遇到一个尚未到期的定时器，这就是定时器的核心逻辑*/</span></span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 因为每个定时器都使用绝对时间作为超时值，所以我们可以把定时器的超时值和系统当前时间，</span></span><br><span class="line"><span class="comment"> * 比较以判断定时器是否到期*/</span></span><br><span class="line"><span class="keyword">if</span> (cur &lt; tmp-&gt;expire) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*调用定时器的回调函数，以执行定时任务*/</span></span><br><span class="line">tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*执行完定时器中的定时任务之后，就将它从链表中删除，并重置链表头结点*/</span></span><br><span class="line">head = tmp-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (head) &#123;</span><br><span class="line">head-&gt;prev = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = head;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*一个重载的辅助函数，它被公有的add_timer函数和adjust_timer函数调用。</span></span><br><span class="line"><span class="comment"> * 该函数表示将目标定时器timer添加到节点lst_head之后的部分链表中*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(util_timer *timer, util_timer *lst_head)</span> </span>&#123;</span><br><span class="line">util_timer *prev = lst_head;</span><br><span class="line">util_timer *tmp = prev-&gt;next;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 遍历lst_head节点之后的部分链表，直到找到一个超时时间大于目标定时器的超时时间的节点，</span></span><br><span class="line"><span class="comment"> * 并将目标定时器插入该节点之前*/</span></span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"><span class="keyword">if</span> (timer-&gt;expire &lt; tmp-&gt;expire) &#123;</span><br><span class="line">prev-&gt;next = timer;</span><br><span class="line">timer-&gt;next = tmp;</span><br><span class="line">tmp-&gt;prev = timer;</span><br><span class="line">timer-&gt;prev = prev;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">prev = tmp;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果遍历完lst_head节点之后的部分链表，仍未找到超时时间大于目标定时器的超</span></span><br><span class="line"><span class="comment">时时间的节点，则将目标定时器插入链表尾部，并把它设置为链表新的尾节点*/</span></span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line">prev-&gt;next = timer;</span><br><span class="line">timer-&gt;prev = prev;</span><br><span class="line">timer-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">tail = timer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">util_timer *head;</span><br><span class="line">util_timer *tail;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>sort_timer_lst是一 个升序链表。其核心函数tick相当于一个心搏函数，它每隔一段固定的 时间就执行一次，以检测并处理到期的任务。判断定时任务到期的依据是定时器的expire值小于当前的系统时间。</p><p><strong>从执行效率来看，添加定时器的时间复杂度是O(n)，删除定时器的时间复杂度是O(1)（因为是双向链表），执行定时任务的时间复杂度是O(1)。</strong></p><h5 id="11-2-2-处理非活动连接"><a href="#11-2-2-处理非活动连接" class="headerlink" title="11.2.2 处理非活动连接"></a>11.2.2 处理非活动连接</h5><p>现在我们考虑上述升序定时器链表的实际应用——处理非活动连 接。服务器程序通常要定期处理非活动连接：给客户端发一个重连请 求，或者关闭该连接，或者其他。</p><blockquote><p>Linux在内核中提供了对连接是否处 于活动状态的定期检查机制，我们可以通过socket选项KEEPALIVE来 激活它。不过使用这种方式将使得应用程序对连接的管理变得复杂。</p></blockquote><p>比如，代码清单11-3利用alarm函 数周期性地触发SIGALRM信号，该信号的信号处理函数利用管道通知主循环执行定时器链表上的定时任务——关闭非活动的连接。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;csignal&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;../11 timer/lst_timer.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> FD_LIMIT 65535</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMESLOT 5</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line"><span class="keyword">static</span> sort_timer_lst timer_lst; <span class="comment">/*利用代码清单11-2中的升序链表来管理定时器*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> epollfd = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> old_option = fcntl(fd, F_GETFL);</span><br><span class="line"><span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">fcntl(fd, F_SETFL, new_option);</span><br><span class="line"><span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll 添加到内核表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">epoll_event event&#123;&#125;;</span><br><span class="line">event.data.fd = fd;</span><br><span class="line">event.events = EPOLLIN | EPOLLET;</span><br><span class="line">epoll_ctl(epfd, EPOLL_CTL_ADD, fd, &amp;event);</span><br><span class="line">setnonblocking(fd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 信号处理函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sig_handler</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> save_errno = errno;</span><br><span class="line"><span class="keyword">int</span> msg = sig;</span><br><span class="line">send(pipefd[<span class="number">1</span>], (<span class="keyword">char</span> *) &amp;msg, <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">errno = save_errno;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addsig</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> <span class="title">sa</span>&#123;</span>&#125;;</span><br><span class="line"><span class="built_in">memset</span>(&amp;sa, <span class="string">&#x27;\0&#x27;</span>, <span class="keyword">sizeof</span>(sa));</span><br><span class="line">sa.sa_handler = sig_handler;</span><br><span class="line">sa.sa_flags |= SA_RESTART;</span><br><span class="line">sigfillset(&amp;sa.sa_mask);</span><br><span class="line">assert(sigaction(sig, &amp;sa, <span class="literal">nullptr</span>) != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timer_handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">/*定时处理任务，实际上就是调用tick函数*/</span></span><br><span class="line">timer_lst.tick();</span><br><span class="line"><span class="comment">/*因为一次alarm调用只会引起一次SIGALRM信号，所以我们要重新定时，以不断触发SIGALRM信号*/</span></span><br><span class="line">alarm(TIMESLOT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器回调函数，它删除非活动连接socket上的注册事件，并关闭之*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cb_func</span><span class="params">(client_data *user_data)</span> </span>&#123;</span><br><span class="line">epoll_ctl(epollfd, EPOLL_CTL_DEL, user_data-&gt;sockfd, <span class="number">0</span>);</span><br><span class="line">assert(user_data);</span><br><span class="line">close(user_data-&gt;sockfd);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;close fd%d\n&quot;</span>, user_data-&gt;sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;usage:%s ip_address port_number\n&quot;</span>, basename(argv[<span class="number">0</span>]));</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = atoi(argv[<span class="number">2</span>]);</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>&#123;</span>&#125;;</span><br><span class="line">bzero(&amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">inet_pton(AF_INET, ip, &amp;address.sin_addr);</span><br><span class="line">address.sin_port = htons(port);</span><br><span class="line"><span class="keyword">int</span> listenfd = socket(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">assert(listenfd &gt;= <span class="number">0</span>);</span><br><span class="line">ret = bind(listenfd, (struct sockaddr *) &amp;address, <span class="keyword">sizeof</span>(address));</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">ret = listen(listenfd, <span class="number">5</span>);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">epoll_event events[MAX_EVENT_NUMBER];</span><br><span class="line">epollfd = epoll_create(<span class="number">5</span>);</span><br><span class="line">assert(epollfd != <span class="number">-1</span>);</span><br><span class="line"></span><br><span class="line">addfd(epollfd, listenfd);</span><br><span class="line">ret = socketpair(PF_UNIX, SOCK_STREAM, <span class="number">0</span>, pipefd);</span><br><span class="line">assert(ret != <span class="number">-1</span>);</span><br><span class="line">setnonblocking(pipefd[<span class="number">1</span>]);</span><br><span class="line">addfd(epollfd, pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*设置信号处理函数*/</span></span><br><span class="line">addsig(SIGALRM);</span><br><span class="line">addsig(SIGTERM);  <span class="comment">// 主进程发给子进程的结束信号</span></span><br><span class="line"><span class="keyword">bool</span> stop_server = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> *users = <span class="keyword">new</span> client_data[FD_LIMIT];</span><br><span class="line"><span class="keyword">bool</span> timeout = <span class="literal">false</span>;</span><br><span class="line">alarm(TIMESLOT);<span class="comment">/*定时*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!stop_server) &#123;</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++) &#123;</span><br><span class="line"><span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*处理新到的客户连接*/</span></span><br><span class="line"><span class="keyword">if</span> (sockfd == listenfd) &#123;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>&#123;</span>&#125;;</span><br><span class="line"><span class="keyword">socklen_t</span> client_addrlength = <span class="keyword">sizeof</span>(client_address);</span><br><span class="line"><span class="keyword">int</span> connfd = accept(listenfd, (struct sockaddr *) &amp;client_address, &amp;client_addrlength);</span><br><span class="line">addfd(epollfd, connfd);</span><br><span class="line">users[connfd].address = client_address;</span><br><span class="line">users[connfd].sockfd = connfd;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建定时器，设置其回调函数与超时时间，然后绑定定时器与用户数据，最后将定时器添加到链表timer_lst中*/</span></span><br><span class="line"><span class="keyword">auto</span> *timer = <span class="keyword">new</span> util_timer;</span><br><span class="line">timer-&gt;user_data = &amp;users[connfd];</span><br><span class="line">timer-&gt;cb_func = cb_func;</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line">users[connfd].timer = timer;</span><br><span class="line">timer_lst.add_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理信号*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((sockfd == pipefd[<span class="number">0</span>]) &amp;&amp; (events[i].events &amp; EPOLLIN)) &#123;</span><br><span class="line"><span class="keyword">int</span> sig;</span><br><span class="line"><span class="keyword">char</span> signals[<span class="number">1024</span>];</span><br><span class="line">ret = recv(pipefd[<span class="number">0</span>], signals, <span class="keyword">sizeof</span>(signals), <span class="number">0</span>);</span><br><span class="line">                <span class="comment">// recv成功时返回实际读取到的数据的长度</span></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">-1</span>) &#123;</span><br><span class="line"><span class="comment">//handle the error</span></span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ret; ++j) &#123;</span><br><span class="line"><span class="keyword">switch</span> (signals[j]) &#123;</span><br><span class="line"><span class="keyword">case</span> SIGALRM: &#123;</span><br><span class="line"><span class="comment">/* 用timeout变量标记有定时任务需要处理，但不立即处理定时任务。这是因为定时任</span></span><br><span class="line"><span class="comment">务的优先级不是很高，我们优先处理其他更重要的任务*/</span></span><br><span class="line">timeout = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> SIGTERM: &#123;</span><br><span class="line">stop_server = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*处理客户连接上接收到的数据*/</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (events[i].events &amp; EPOLLIN) &#123;</span><br><span class="line"><span class="built_in">memset</span>(users[sockfd].buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE);</span><br><span class="line">ret = recv(sockfd, users[sockfd].buf, BUFFER_SIZE - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;get%d bytes of client data%s from%d\n&quot;</span>, ret, users[sockfd].buf, sockfd);</span><br><span class="line">util_timer *timer = users[sockfd].timer;</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果发生读错误，则关闭连接，并移除其对应的定时器*/</span></span><br><span class="line"><span class="keyword">if</span> (errno != EAGAIN) &#123;</span><br><span class="line">cb_func(&amp;users[sockfd]);</span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line">timer_lst.del_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*如果对方已经关闭连接，则我们也关闭连接，并移除对应的定时器*/</span></span><br><span class="line">cb_func(&amp;users[sockfd]);</span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line">timer_lst.del_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">/*如果某个客户连接上有数据可读，则我们要调整该连接对应的定时器，以延迟该连接被关闭的时间*/</span></span><br><span class="line"><span class="keyword">if</span> (timer) &#123;</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">nullptr</span>);</span><br><span class="line">timer-&gt;expire = cur + <span class="number">3</span> * TIMESLOT;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;adjust timer once\n&quot;</span>);</span><br><span class="line">timer_lst.adjust_timer(timer);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//others</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*最后处理定时事件，因为I/O事件有更高的优先级。当然，这样做将导致定时任务不能精确地按照预期的时间执行*/</span></span><br><span class="line"><span class="keyword">if</span> (timeout) &#123;</span><br><span class="line">timer_handler();</span><br><span class="line">timeout = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">close(listenfd);</span><br><span class="line">close(pipefd[<span class="number">1</span>]);</span><br><span class="line">close(pipefd[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">delete</span>[]users;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="11-3-I-O复用系统调用的超时参数"><a href="#11-3-I-O复用系统调用的超时参数" class="headerlink" title="11.3 I/O复用系统调用的超时参数"></a>11.3 I/O复用系统调用的超时参数</h4><p>Linux下的3组I/O复用系统调用都带有超时参数，因此它们不仅能 统一处理信号和I/O事件，也能统一处理定时事件。</p><p>但是由于I/O复用 系统调用可能在超时时间到期之前就返回（有I/O事件发生），所以如 果我们要利用它们来定时，就需要不断更新定时参数以反映剩余的时间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMEOUT 5000</span></span><br><span class="line"><span class="keyword">int</span> timeout = TIMEOUT;</span><br><span class="line"><span class="keyword">time_t</span> start = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">time_t</span> end = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;the timeout is now%d mil-seconds\n&quot;</span>, timeout);</span><br><span class="line">start = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">int</span> number = epoll_wait(epollfd, events, MAX_EVENT_NUMBER, timeout);</span><br><span class="line"><span class="keyword">if</span> ((number &lt; <span class="number">0</span>) &amp;&amp; (errno != EINTR)) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;epoll failure\n&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">       </span><br><span class="line"><span class="comment">/*如果epoll_wait成功返回0，则说明超时时间到，此时便可处理定时任务，并重置定时时间*/</span></span><br><span class="line"><span class="keyword">if</span> (number == <span class="number">0</span>) &#123;</span><br><span class="line">timeout = TIMEOUT;</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">end = time(<span class="literal">NULL</span>);</span><br><span class="line"><span class="comment">/*如果epoll_wait的返回值大于0，则本次epoll_wait调用持续的时间是(endstart)*1000 ms，</span></span><br><span class="line"><span class="comment"> * 我们需要将定时时间timeout减去这段时间，以获得下次epoll_wait调用的超时参数*/</span></span><br><span class="line">timeout -= (end - start) * <span class="number">1000</span>;</span><br><span class="line"><span class="comment">/*重新计算之后的timeout值有可能等于0，说明本次epoll_wait调用返回时，不仅有文件描述符就绪，</span></span><br><span class="line"><span class="comment"> * 而且其超时时间也刚好到达，此时我们也要处理定时任务，并重置定时时间*/</span></span><br><span class="line"><span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">timeout = TIMEOUT;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//handle connections</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-4-高性能计时器"><a href="#11-4-高性能计时器" class="headerlink" title="11.4 高性能计时器"></a>11.4 高性能计时器</h4><h5 id="11-4-1-时间轮"><a href="#11-4-1-时间轮" class="headerlink" title="11.4.1 时间轮"></a>11.4.1 时间轮</h5><p>前文提到，基于排序链表的定时器存在一个问题：添加定时器的 效率偏低。</p><p>下面我们要讨论的时间轮解决了这个问题。一种简单的时 间轮如图11-1所示。</p><img src="学习笔记/Linux高性能服务器编程/image-20230305172536051.png" alt="image-20230305172536051" style="zoom:67%;" /><p>图11-1所示的时间轮内，（实线）指针指向轮子上的一个槽 （slot）。它以恒定的速度顺时针转动，每转动一步就指向下一个槽 （虚线指针指向的槽），每次转动称为一个滴答（tick）。一个滴答的 时间称为时间轮的槽间隔si（slot interval），它实际上就是心搏时间。该时间轮共有N个槽，因此它运转一周的时间是<code>N*si</code>。每个槽指向一条 定时器链表，每条链表上的定时器具有相同的特征：它们的定时时间 相差<code>N*si</code>的整数倍。</p><p>时间轮正是利用这个关系将定时器散列到不同的 链表中。假如现在指针指向槽cs，我们要添加一个定时时间为ti的定时 器，则该定时器将被插入槽ts（timer slot）对应的链表中：</p><p><strong>ts = (cs + (ti / si)) % N</strong></p><p>很显然，对时间轮而言，要提高定时精度，就要使si值足够小；要 提高执行效率，则要求N值足够大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TIME_WHEEL_TIMER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIME_WHEEL_TIMER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">tw_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">tw_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">tw_timer(<span class="keyword">int</span> rot, <span class="keyword">int</span> ts): next(<span class="literal">nullptr</span>), prev(<span class="literal">nullptr</span>), rotation(rot), time_slot(ts) &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> rotation;<span class="comment">/*记录定时器在时间轮转多少圈后生效*/</span></span><br><span class="line"><span class="keyword">int</span> time_slot;<span class="comment">/*记录定时器属于时间轮上哪个槽（对应的链表，下同）*/</span></span><br><span class="line"><span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*定时器回调函数*/</span></span><br><span class="line">client_data *user_data&#123;&#125;;<span class="comment">/*客户数据*/</span></span><br><span class="line">tw_timer *next;<span class="comment">/*指向下一个定时器*/</span></span><br><span class="line">tw_timer *prev;<span class="comment">/*指向前一个定时器*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_wheel</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">time_wheel() : cur_slot(<span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; ++i) &#123;</span><br><span class="line">slots[i] = <span class="literal">nullptr</span>;<span class="comment">/*初始化每个槽的头结点*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~time_wheel() &#123;</span><br><span class="line"><span class="comment">/*遍历每个槽，并销毁其中的定时器*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp; slot : slots) &#123;</span><br><span class="line">tw_timer *tmp = slot;</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">slot = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = slot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*根据定时值timeout创建一个定时器，并把它插入合适的槽中*/</span></span><br><span class="line"><span class="function">tw_timer *<span class="title">add_timer</span><span class="params">(<span class="keyword">int</span> timeout)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (timeout &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ticks = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/*下面根据待插入定时器的超时值计算它将在时间轮转动多少个滴答后被触发，并将该</span></span><br><span class="line"><span class="comment">滴答数存储于变量ticks中。如果待插入定时器的超时值小于时间轮的槽间隔SI，则将</span></span><br><span class="line"><span class="comment">ticks向上折合为1，否则就将ticks向下折合为timeout/SI*/</span></span><br><span class="line"><span class="keyword">if</span> (timeout &lt; SI) &#123;</span><br><span class="line">ticks = <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">ticks = timeout / SI;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*计算待插入的定时器在时间轮转动多少圈后被触发*/</span></span><br><span class="line"><span class="keyword">int</span> rotation = ticks / N;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算待插入的定时器应该被插入哪个槽中*/</span></span><br><span class="line"><span class="keyword">int</span> ts = (cur_slot + (ticks % N)) % N;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*创建新的定时器，它在时间轮转动rotation圈之后被触发，且位于第ts个槽上*/</span></span><br><span class="line">tw_timer *timer = <span class="keyword">new</span> tw_timer(rotation, ts);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如果第ts个槽中尚无任何定时器，则把新建的定时器插入其中，并将该定时器设置为该槽的头结点*/</span></span><br><span class="line"><span class="keyword">if</span> (!slots[ts]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;add timer,rotation is%d,ts is%d,cur_slotis%d\n&quot;</span>, rotation, ts, cur_slot);</span><br><span class="line">slots[ts] = timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则，将定时器插入第ts个槽中*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">timer-&gt;next = slots[ts];</span><br><span class="line">slots[ts]-&gt;prev = timer;</span><br><span class="line">slots[ts] = timer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(tw_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ts = timer-&gt;time_slot;</span><br><span class="line"><span class="comment">/*slots[ts]是目标定时器所在槽的头结点。如果目标定时器就是该头结点，则需要重置第ts个槽的头结点*/</span></span><br><span class="line"><span class="keyword">if</span> (timer == slots[ts]) &#123;</span><br><span class="line">slots[ts] = slots[ts]-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (slots[ts]) &#123;</span><br><span class="line">slots[ts]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">timer-&gt;prev-&gt;next = timer-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (timer-&gt;next) &#123;</span><br><span class="line">timer-&gt;next-&gt;prev = timer-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> timer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*SI时间到后，调用该函数，时间轮向前滚动一个槽的间隔*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">tw_timer *tmp = slots[cur_slot];<span class="comment">/*取得时间轮上当前槽的头结点*/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;current slot is%d\n&quot;</span>, cur_slot);</span><br><span class="line"><span class="keyword">while</span> (tmp) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;tick the timer once\n&quot;</span>);</span><br><span class="line"><span class="comment">/*如果定时器的rotation值大于0，则它在这一轮不起作用*/</span></span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;rotation &gt; <span class="number">0</span>) &#123;</span><br><span class="line">tmp-&gt;rotation--;</span><br><span class="line">tmp = tmp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则，说明定时器已经到期，于是执行定时任务，然后删除该定时器*/</span></span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">tmp-&gt;cb_func(tmp-&gt;user_data);</span><br><span class="line"><span class="keyword">if</span> (tmp == slots[cur_slot]) &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;delete header in cur_slot\n&quot;</span>);</span><br><span class="line">slots[cur_slot] = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line"><span class="keyword">if</span> (slots[cur_slot]) &#123;</span><br><span class="line">slots[cur_slot]-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">tmp = slots[cur_slot];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmp-&gt;prev-&gt;next = tmp-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;next) &#123;</span><br><span class="line">tmp-&gt;next-&gt;prev = tmp-&gt;prev;</span><br><span class="line">&#125;</span><br><span class="line">tw_timer *tmp2 = tmp-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> tmp;</span><br><span class="line">tmp = tmp2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cur_slot = ++cur_slot % N;<span class="comment">/*更新时间轮的当前槽，以反映时间轮的转动*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*时间轮上槽的数目*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">60</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*每1 s时间轮转动一次，即槽间隔为1 s*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> SI = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时间轮的槽，其中每个元素指向一个定时器链表，链表无序*/</span></span><br><span class="line">tw_timer *slots[N]&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> cur_slot;<span class="comment">/*时间轮的当前槽*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//TIME_WHEEL_TIMER_H</span></span></span><br></pre></td></tr></table></figure><p><strong>可见，对时间轮而言，添加一个定时器的时间复杂度是O（1）， 删除一个定时器的时间复杂度也是O（1），执行一个定时器的时间复 杂度是O（n）。</strong>但实际上执行一个定时器任务的效率要比O（n）好得 多，因为时间轮将所有的定时器散列到了不同的链表上。时间轮的槽 越多，等价于散列表的入口（entry）越多，从而每条链表上的定时器 数量越少。</p><h5 id="11-4-2-时间堆"><a href="#11-4-2-时间堆" class="headerlink" title="11.4.2 时间堆"></a>11.4.2 时间堆</h5><p>设计 定时器的另外一种思路是：将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔。这样，一旦心搏函数tick被调用，超时时间最小的定时器必然到期，我们就可以在tick函数中处理该定时器。<strong>然后，再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。如此反复，就实现了较为精确的定时。</strong></p><p>最小堆很适合处理这种定时方案。最小堆是指每个节点的值都小 于或等于其子节点的值的完全二叉树。图11-2给出了一个具有6个元素 的最小堆。</p><img src="学习笔记/Linux高性能服务器编程/image-20230305174923066.png" alt="image-20230305174923066" style="zoom:33%;" /><p>由于最小堆是一种完全二叉树，所以我们可以用数组来组织其中 的元素。</p><p>比如，图11-2所示的最小堆可以用图11-5所示的数组来表示。 <strong>对于数组中的任意一个位置i上的元素，其左儿子节点在位置2i+1上， 其右儿子节点在位置2i+2上，其父节点则在位置[（i-1）/2]（i＞0） 上</strong>。与用链表来表示堆相比，用数组表示堆不仅节省空间，而且更容 易实现堆的插入、删除等操作[5]。</p><img src="/2023/01/29/%E9%AB%98%E6%80%A7%E8%83%BD%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A1%86%E6%9E%B6/image-20230305175239841-1678341964417.png" class="" title="image-20230305175239841"><p>假设我们已经有一个包含N个元素的数组，现在要把它初始化为一 个最小堆。那么最简单的方法是：初始化一个空堆，然后将数组中的 每个元素插入该堆中。不过这样做的效率偏低。</p><p>实际上，我们只需要 对数组中的第[（N-1）/2]～0个元素执行下虑操作，即可确保该数组构 成一个最小堆。这是因为对包含N个元素的完全二叉树而言，它具有 [（N-1）/2]个非叶子节点，这些非叶子节点正是该完全二叉树的第0～ [（N-1）/2]个节点。我们只要确保这些非叶子节点构成的子树都具有 堆序性质，整个树就具有堆序性质。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2023/3/5.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MIN_HEAP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MIN_HEAP</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="built_in">std</span>::exception;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 64</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span>;</span><span class="comment">/*前向声明*/</span></span><br><span class="line"><span class="comment">/*绑定socket和定时器*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">client_data</span> &#123;</span></span><br><span class="line">sockaddr_in address;</span><br><span class="line"><span class="keyword">int</span> sockfd;</span><br><span class="line"><span class="keyword">char</span> buf[BUFFER_SIZE];</span><br><span class="line">heap_timer *timer;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*定时器类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">heap_timer</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">heap_timer</span><span class="params">(<span class="keyword">int</span> delay)</span> </span>&#123;</span><br><span class="line">expire = time(<span class="literal">nullptr</span>) + delay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">time_t</span> expire;<span class="comment">/*定时器生效的绝对时间*/</span></span><br><span class="line"><span class="keyword">void</span> (*cb_func)(client_data *)&#123;&#125;;<span class="comment">/*定时器的回调函数*/</span></span><br><span class="line">client_data *user_data&#123;&#125;;<span class="comment">/*用户数据*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*时间堆类*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">time_heap</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">/*构造函数之一，初始化一个大小为cap的空堆*/</span></span><br><span class="line">explicit time_heap(int cap) throw(std::exception): capacity(cap), cur_size(0) &#123;</span><br><span class="line"><span class="built_in">array</span> = <span class="keyword">new</span> heap_timer *[capacity];<span class="comment">/*创建堆数组*/</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*构造函数之二，用已有数组来初始化堆*/</span></span><br><span class="line">time_heap(heap_timer **init_array, <span class="keyword">int</span> size, <span class="keyword">int</span> capacity) <span class="keyword">throw</span></span><br><span class="line">(<span class="built_in">std</span>::exception): cur_size(size), capacity(capacity) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity &lt; size) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span> = <span class="keyword">new</span> heap_timer *[capacity];<span class="comment">/*创建堆数组*/</span></span><br><span class="line"><span class="keyword">if</span> (!<span class="built_in">array</span>) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; capacity; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (size != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="comment">/*初始化堆数组*/</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line"><span class="built_in">array</span>[i] = init_array[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (cur_size - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;<span class="comment">/*对数组中的第[(cur_size-1)/2]～0个元素执行下虑操作*/</span></span><br><span class="line">percolate_down(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*销毁时间堆*/</span></span><br><span class="line">~time_heap() &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">/*添加目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_timer</span><span class="params">(heap_timer *timer)</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (cur_size &gt;= capacity)<span class="comment">/*如果当前堆数组容量不够，则将其扩大1倍*/</span></span><br><span class="line">&#123;</span><br><span class="line">resize();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*新插入了一个元素，当前堆大小加1，hole是新建空穴的位置*/</span></span><br><span class="line"><span class="keyword">int</span> hole = cur_size++;</span><br><span class="line"><span class="keyword">int</span> parent = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*对从空穴到根节点的路径上的所有节点执行上虑操作*/</span></span><br><span class="line"><span class="keyword">for</span> (; hole &gt; <span class="number">0</span>; hole = parent) &#123;</span><br><span class="line">parent = (hole - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[parent]-&gt;expire &lt;= timer-&gt;expire) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[hole] = <span class="built_in">array</span>[parent];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[hole] = timer;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除目标定时器timer*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">del_timer</span><span class="params">(heap_timer *timer)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!timer) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*仅仅将目标定时器的回调函数设置为空，即所谓的延迟销毁。这将节省真正删除该定</span></span><br><span class="line"><span class="comment">时器造成的开销，但这样做容易使堆数组膨胀*/</span></span><br><span class="line">timer-&gt;cb_func = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*获得堆顶部的定时器*/</span></span><br><span class="line"><span class="function">heap_timer *<span class="title">top</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (empty()) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*删除堆顶部的定时器*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop_timer</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (empty()) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]) &#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="comment">/*将原来的堆顶元素替换为堆数组中最后一个元素*/</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>] = <span class="built_in">array</span>[--cur_size];</span><br><span class="line">percolate_down(<span class="number">0</span>);<span class="comment">/*对新的堆顶元素执行下虑操作*/</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*心搏函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tick</span><span class="params">()</span> </span>&#123;</span><br><span class="line">heap_timer *tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">time_t</span> cur = time(<span class="literal">NULL</span>);<span class="comment">/*循环处理堆中到期的定时器*/</span></span><br><span class="line"><span class="keyword">while</span> (!empty()) &#123;</span><br><span class="line"><span class="keyword">if</span> (!tmp) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*如果堆顶定时器没到期，则退出循环*/</span></span><br><span class="line"><span class="keyword">if</span> (tmp-&gt;expire &gt; cur) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*否则就执行堆顶定时器中的任务*/</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func) &#123;</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>]-&gt;cb_func(<span class="built_in">array</span>[<span class="number">0</span>]-&gt;user_data);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*将堆顶元素删除，同时生成新的堆顶定时器（array[0]）*/</span></span><br><span class="line">pop_timer();</span><br><span class="line">tmp = <span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> cur_size == <span class="number">0</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">/*最小堆的下虑操作，它确保堆数组中以第hole个节点作为根的子树拥有最小堆性质*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">percolate_down</span><span class="params">(<span class="keyword">int</span> hole)</span> </span>&#123;</span><br><span class="line">heap_timer *temp = <span class="built_in">array</span>[hole];</span><br><span class="line"><span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; ((hole * <span class="number">2</span> + <span class="number">1</span>) &lt;= (cur_size - <span class="number">1</span>)); hole = child) &#123;</span><br><span class="line">child = hole * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> ((child &lt; (cur_size - <span class="number">1</span>)) &amp;&amp; (<span class="built_in">array</span>[child + <span class="number">1</span>]-&gt;expire &lt; <span class="built_in">array</span>[child]-&gt;expire)) &#123;</span><br><span class="line">++child;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">array</span>[child]-&gt;expire &lt; temp-&gt;expire) &#123;</span><br><span class="line"><span class="built_in">array</span>[hole] = <span class="built_in">array</span>[child];</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">array</span>[hole] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*将堆数组容量扩大1倍*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">resize</span><span class="params">()</span> <span class="title">throw</span><span class="params">(<span class="built_in">std</span>::exception)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> **temp = <span class="keyword">new</span> heap_timer *[<span class="number">2</span> * capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span> * capacity; ++i) &#123;</span><br><span class="line">temp[i] = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!temp) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="built_in">std</span>::exception();</span><br><span class="line">&#125;</span><br><span class="line">capacity = <span class="number">2</span> * capacity;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cur_size; ++i) &#123;</span><br><span class="line">temp[i] = <span class="built_in">array</span>[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[]<span class="built_in">array</span>;</span><br><span class="line"><span class="built_in">array</span> = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">heap_timer **<span class="built_in">array</span>;<span class="comment">/*堆数组*/</span></span><br><span class="line"><span class="keyword">int</span> capacity;<span class="comment">/*堆数组的容量*/</span></span><br><span class="line"><span class="keyword">int</span> cur_size;<span class="comment">/*堆数组当前包含元素的个数*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>由代码清单11-6可见，对时间堆而言，添加一个定时器的时间复杂 度是O（lgn），删除一个定时器的时间复杂度是O（1），执行一个定 时器的时间复杂度是O（1）。因此，时间堆的效率是很高的。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一 TCP/IP协议详解</title>
      <link href="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="第一篇-TCP-IP协议详解"><a href="#第一篇-TCP-IP协议详解" class="headerlink" title="第一篇 TCP/IP协议详解"></a>第一篇 TCP/IP协议详解</h2><h3 id="第1章-TCP-IP协议族"><a href="#第1章-TCP-IP协议族" class="headerlink" title="第1章 TCP/IP协议族"></a>第1章 TCP/IP协议族</h3><p>本章则简单介绍其中几个相关协议：ICMP协议、ARP协 议和DNS协议，学习它们对于理解网络通信很有帮助。</p><h4 id="1-1-TCP-IP协议族体系结构以及主要协议"><a href="#1-1-TCP-IP协议族体系结构以及主要协议" class="headerlink" title="1.1 TCP/IP协议族体系结构以及主要协议"></a>1.1 TCP/IP协议族体系结构以及主要协议</h4><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223191117670.png" class="" title="image-20230223191117670"><h5 id="1-1-1-数据链路层"><a href="#1-1-1-数据链路层" class="headerlink" title="1.1.1 数据链路层"></a>1.1.1 数据链路层</h5><p>数据链路层实现了网卡接口的网络驱动程序，以处理数据在物理 媒介（比如以太网、令牌环等）上的传输。</p><p>数据链路层两个常用的协议是ARP协议（Address Resolve Protocol，地址解析协议）和RARP协议（Reverse Address Resolve Protocol，逆地址解析协议）。它们实现了IP地址和机器物理地址（通 常是MAC地址，以太网、令牌环和802.11无线网络都使用MAC地址） 之间的相互转换。</p><p>网络层使用IP地址寻址一台机器，而数据链路层使用物理地址寻 址一台机器，因此<strong>网络层必须先将目标机器的IP地址转化成其物理地址，才能使用数据链路层提供的服务，这就是ARP协议的用途。</strong></p><p>RARP 协议仅用于网络上的某些无盘工作站。因为缺乏存储设备，无盘工作 站无法记住自己的IP地址，但它们可以利用网卡上的物理地址来向网 络管理者（服务器或网络管理软件）查询自身的IP地址。运行RARP服 务的网络管理者通常存有该网络上所有机器的物理地址到IP地址的映射。</p><h5 id="1-1-3-传输层"><a href="#1-1-3-传输层" class="headerlink" title="1.1.3 传输层"></a>1.1.3 传输层</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223203039797.png" class="" title="image-20230223203039797"><p>垂直的实线箭头表示TCP/IP协议族各层之间的实体通信 （数据包确实是沿着这些线路传递的），而水平的虚线箭头表示逻辑 通信线路。该图中还附带描述了不同物理网络的连接方法。</p><p>可见，数 据链路层（驱动程序）封装了物理网络的电气细节；网络层封装了网 络连接的细节；传输层则为应用程序封装了一条端到端的逻辑通信链 路，它负责数据的收发、链路的超时重连等。</p><p>传输层协议主要有三个：TCP协议、UDP协议和SCTP协议。</p><p>TCP协议（Transmission Control Protocol，传输控制协议）为应用 层提供可靠的、面向连接的和基于流（stream）的服务。</p><p>TCP协议使用 超时重传、数据确认等方式来确保数据包被正确地发送至目的端，因 此TCP服务是可靠的。使用TCP协议通信的双方必须先建立TCP连接， 并在内核中为该连接维持一些必要的数据结构，比如连接的状态、读 写缓冲区，以及诸多定时器等。当通信结束时，双方必须关闭连接以 释放这些内核数据。<strong>TCP服务是基于流的。基于流的数据没有边界（长 度）限制，它源源不断地从通信的一端流入另一端。发送端可以逐个 字节地向数据流中写入数据，接收端也可以逐个字节地将它们读出。</strong></p><p>UDP协议（User Datagram Protocol，用户数据报协议）则与TCP协 议完全相反，它为应用层提供不可靠、无连接和基于数据报的服 务。“不可靠”意味着UDP协议无法保证数据从发送端正确地传送到目 的端。如果数据在中途丢失，或者目的端通过数据校验发现数据错误 而将其丢弃，则UDP协议只是简单地通知应用程序发送失败。因此， 使用UDP协议的应用程序通常要自己处理数据确认、超时重传等逻 辑。UDP协议是无连接的，即通信双方不保持一个长久的联系，因此 应用程序每次发送数据都要明确指定接收端的地址（IP地址等信 息）。<strong>基于数据报的服务，是相对基于流的服务而言的。每个UDP数 据报都有一个长度，接收端必须以该长度为最小单位将其所有内容一 次性读出，否则数据将被截断。</strong></p><h4 id="1-7-socket和TCP-IP协议族的关系"><a href="#1-7-socket和TCP-IP协议族的关系" class="headerlink" title="1.7  socket和TCP/IP协议族的关系"></a>1.7  socket和TCP/IP协议族的关系</h4><p>由socket定义的这一组API提供如下两点功能：</p><ol><li>将应用程序数 据从用户缓冲区中复制到TCP/UDP内核发送缓冲区，以交付内核来发 送数据（比如图1-5所示的send函数），或者是从内核TCP/UDP接收缓 冲区中复制数据到用户缓冲区，以读取数据；</li><li>应用程序可以通过 它们来修改内核中各层协议的某些头部信息或其他数据结构，从而精 细地控制底层通信的行为。比如可以通过setsockopt函数来设置IP数据 报在网络上的存活时间。我们将在第5章详细讨论这一组API。</li></ol><h3 id="第2章-IP协议详解"><a href="#第2章-IP协议详解" class="headerlink" title="第2章 IP协议详解"></a>第2章 IP协议详解</h3><p>P协议是TCP/IP协议族的核心协议，也是socket网络编程的基础之 一。</p><p>本章从两个方面较为深入地探讨IP协议：</p><ul><li>IP头部信息。IP头部信息出现在每个IP数据报中，用于指定IP通 信的源端IP地址、目的端IP地址，指导IP分片和重组，以及指定部分 通信行为。</li><li>IP数据报的路由和转发。IP数据报的路由和转发发生在除目标 机器之外的所有主机和路由器上。它们决定数据报是否应该转发以及 如何转发。</li></ul><h4 id="2-1-IP服务的特点"><a href="#2-1-IP服务的特点" class="headerlink" title="2.1 IP服务的特点"></a>2.1 IP服务的特点</h4><p><strong>IP协议是TCP/IP协议族的动力，它为上层协议提供无状态、无连接、不可靠的服务。</strong></p><ul><li><strong>无状态（stateless）是指IP通信双方不同步传输数据的状态信息， 因此所有IP数据报的发送、传输和接收都是相互独立、没有上下文关系的。</strong>这种服务最大的缺点是无法处理乱序和重复的IP数据报。比如发送端发送出的第N个IP数据报可能比第N+1个IP数据报后到达接收 端，而同一个IP数据报也可能经过不同的路径多次到达接收端。在这 两种情况下，接收端的IP模块无法检测到乱序和重复，因为这些IP数 据报之间没有任何上下文关系。</li><li><strong>无连接（connectionless）是指IP通信双方都不长久地维持对方的 任何信息。这样，上层协议每次发送数据的时候，都必须明确指定对 方的IP地址。</strong></li><li><strong>不可靠是指IP协议不能保证IP数据报准确地到达接收端，它只是 承诺尽最大努力（best effort）。</strong>很多种情况都能导致IP数据报发送失 败。比如，某个中转路由器发现IP数据报在网络上存活的时间太长 （根据IP数据报头部字段TTL判断，见后文），那么它将丢弃之，并 返回一个ICMP错误消息（超时错误）给发送端。又比如，接收端发现 收到的IP数据报不正确（通过校验机制），它也将丢弃之，并返回一 个ICMP错误消息（IP头部参数错误）给发送端。</li></ul><h4 id="2-2-IPv4头部结构"><a href="#2-2-IPv4头部结构" class="headerlink" title="2.2 IPv4头部结构"></a>2.2 IPv4头部结构</h4><h5 id="2-2-1-IPv4头部结构"><a href="#2-2-1-IPv4头部结构" class="headerlink" title="2.2.1 IPv4头部结构"></a>2.2.1 IPv4头部结构</h5><p>通常为20字节</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223192622355.png" class="" title="image-20230223192622355"><h4 id="2-3-IP分片"><a href="#2-3-IP分片" class="headerlink" title="2.3 IP分片"></a>2.3 IP分片</h4><p>前文曾提到，当IP数据报的长度超过帧的MTU时，它将被分片传 输。分片可能发生在发送端，也可能发生在中转路由器上，而且可能 在传输过程中被多次分片，但只有在最终的目标机器上，这些分片才 会被内核中的IP模块重新组装。</p><p>IP头部中的如下三个字段给IP的分片和重组提供了足够的信息：<strong>数据报标识、标志和片偏移</strong>。一个IP数据报的每个分片都具有自己的IP头 部，它们具有相同的标识值，但具有不同的片偏移。并且除了最后一 个分片外，其他分片都将设置MF标志。此外，每个分片的IP头部的总 长度字段将被设置为该分片的长度。</p><p>以太网帧的MTU是1500字节（可以通过ifconfig命令或者netstat命 令查看），因此它携带的IP数据报的数据部分最多是1480字节（IP头部 占用20字节）。考虑用IP数据报封装一个长度为1481字节的ICMP报文 （包括8字节的ICMP头部，所以其数据部分长度为1473字节），则该 数据报在使用以太网帧传输时必须被分片，如图2-2所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223194207843.png" class="" title="image-20230223194207843"><p>图2-2中，长度为1501字节的IP数据报被拆分成两个IP分片，第一 个IP分片长度为1500字节，第二个IP分片的长度为21字节。每个IP分片 都包含自己的IP头部（20字节），且第一个IP分片的IP头部设置了MF 标志，而第二个IP分片的IP头部则没有设置该标志，因为它已经是最后 一个分片了。原始IP数据报中的ICMP头部内容被完整地复制到了第一 个IP分片中。第二个IP分片不包含ICMP头部信息，因为IP模块重组该 ICMP报文的时候只需要一份ICMP头部信息，重复传送这个信息没有 任何益处。1473字节的ICMP报文数据的前1472字节被IP模块复制到第 一个IP分片中，使其总长度为1500字节，从而满足MTU的要求；而多 出的最后1字节则被复制到第二个IP分片中。</p><h4 id="2-4-IP路由"><a href="#2-4-IP路由" class="headerlink" title="2.4 IP路由"></a>2.4 IP路由</h4><h3 id="第3章-TCP协议详解"><a href="#第3章-TCP协议详解" class="headerlink" title="第3章 TCP协议详解"></a>第3章 TCP协议详解</h3><p>和IP协议相比， TCP协议更靠近应用层，因此在应用程序中具有更强的可操作性。一些 重要的socket选项都和TCP协议相关。</p><p>本章从如下四方面来讨论TCP协议：</p><ol><li>TCP头部信息。TCP头部信息出现在每个TCP报文段中，用于指定通信的源端端口号、目的端端口号，管理TCP连接，控制两个方向的 数据流。</li><li>TCP状态转移过程。TCP连接的任意一端都是一个状态机。在 TCP连接从建立到断开的整个过程中，连接两端的状态机将经历不同的状态变迁。</li><li>TCP数据流。通过分析TCP数据流，我们就可以从网络应用程序 外部来了解应用层协议和通信双方交换的应用程序数据。这一部分将 讨论两种类型的TCP数据流：交互数据流和成块数据流。TCP数据流中 有一种特殊的数据，称为紧急数据，我们也将简单讨论之。</li><li>TCP数据流的控制。为了保证可靠传输和提高网络通信质量，内核需要对TCP数据流进行控制。这一部分讨论TCP数据流控制的两个方 面：超时重传和拥塞控制。</li></ol><h4 id="3-1-TCP服务的特点"><a href="#3-1-TCP服务的特点" class="headerlink" title="3.1 TCP服务的特点"></a>3.1 TCP服务的特点</h4><p><strong>TCP协议相对于 UDP协议的特点是：面向连接、字节流和可靠传输。</strong>使用TCP协议通信的双方必须先建立连接，然后才能开始数据的读 写。双方都必须为该连接分配必要的内核资源，以管理连接的状态和 连接上数据的传输。TCP连接是全双工的，即双方的数据读写可以通过 一个连接进行。完成数据交换之后，通信双方都必须断开连接以释放 系统资源。</p><p>TCP协议的这种连接是一对一的，所以基于广播和多播（目标是多 个主机地址）的应用程序不能使用TCP服务。而无连接协议UDP则非常 适合于广播和多播。</p><p>当接收端收到一个或多个TCP报文段后，TCP模块将它们携带的应 用程序数据按照TCP报文段的序号（见后文）依次放入TCP接收缓冲区 中，并通知应用程序读取数据。接收端应用程序可以一次性将TCP接收 缓冲区中的数据全部读出，也可以分多次读取，这取决于用户指定的 应用程序读缓冲区的大小。因此，应用程序执行的读操作次数和TCP模 块接收到的TCP报文段个数之间也没有固定的数量关系。</p><p>UDP则不然。发送端应用程序每执行一 次写操作，UDP模块就将其封装成一个UDP数据报并发送之。<strong>接收端 必须及时针对每一个UDP数据报执行读操作（通过recvfrom系统调 用），否则就会丢包（这经常发生在较慢的服务器上）。</strong>并且，如果 用户没有指定足够的应用程序缓冲区来读取UDP数据，则UDP数据将 被截断。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223203748839.png" class="" title="image-20230223203748839"><p>TCP传输是可靠的。首先，TCP协议采用发送应答机制，即发送端 发送的每个TCP报文段都必须得到接收方的应答，才认为这个TCP报文 段传输成功。其次，TCP协议采用超时重传机制，发送端在发送出一个 TCP报文段之后启动定时器，如果在定时时间内未收到应答，它将重发 该报文段。最后，因为TCP报文段最终是以IP数据报发送的，而IP数据 报到达接收端可能乱序、重复，所以TCP协议还会对接收到的TCP报文 段重排、整理，再交付给应用层。</p><h4 id="3-2-TCP头部结构"><a href="#3-2-TCP头部结构" class="headerlink" title="3.2 TCP头部结构"></a>3.2 TCP头部结构</h4><h4 id="3-3-TCP的建立与关闭"><a href="#3-3-TCP的建立与关闭" class="headerlink" title="3.3 TCP的建立与关闭"></a>3.3 TCP的建立与关闭</h4><h5 id="3-3-1-使用tcpdump观察TCP连接的建立和关闭"><a href="#3-3-1-使用tcpdump观察TCP连接的建立和关闭" class="headerlink" title="3.3.1 使用tcpdump观察TCP连接的建立和关闭"></a>3.3.1 使用tcpdump观察TCP连接的建立和关闭</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223204422693.png" class="" title="image-20230223204422693"><p>因为整个过程并没有发生应用层数据的交换，所以TCP报文段的数 据部分的长度（length）总是0。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223204455397.png" class="" title="image-20230223204455397"><p>第1个TCP报文段包含SYN标志，因此它是一个同步报文段，即 ernest-laptop（客户端）向Kongming20（服务器）发起连接请求。同 时，该同步报文段包含一个ISN值为535734930的序号。</p><p>第2个TCP报文 段也是同步报文段，表示Kongming20同意与ernest-laptop建立连接。同 时它发送自己的ISN值为2159701207的序号，并对第1个同步报文段进 行确认。确认值是535734931，即第1个同步报文段的序号值加1。</p><p>第3个TCP报文段是ernest-laptop对第2个同步报文段的确认。至 此，TCP连接就建立起来了。建立TCP连接的这3个步骤被称为TCP三 次握手。 （从第3个TCP报文段开始，tcpdump输出的序号值和确认值都是相对 初始ISN值的偏移。当然，我们可以开启tcpdump的-S选项来选择打印 序号的绝对值。)</p><p><strong>后面4个TCP报文段是关闭连接的过程。</strong></p><p>第4个TCP报文段包含FIN 标志，因此它是一个结束报文段，即ernest-laptop要求关闭连接。结束 报文段和同步报文段一样，也要占用一个序号值。</p><p>Kongming20用TCP 报文段5来确认该结束报文段。</p><p>紧接着Kongming20发送自己的结束报文 段6，ernest-laptop则用TCP报文段7给予确认。实际上，仅用于确认目 的的确认报文段5是可以省略的，因为结束报文段6也携带了该确认信 息。确认报文段5是否出现在连接断开的过程中，取决于TCP的延迟确 认特性。延迟确认将在后面讨论。</p><h5 id="3-3-2-半关闭状态"><a href="#3-3-2-半关闭状态" class="headerlink" title="3.3.2 半关闭状态"></a>3.3.2 半关闭状态</h5><p>TCP连接是全双工的，所以它允许两个方向的数据传输被独立关闭。换言之，<strong>通信的一端可以发送结束报文段给对方，告诉它本端已 经完成了数据的发送，但允许继续接收来自对方的数据，</strong>直到对方也 发送结束报文段以关闭连接。TCP连接的这种状态称为半关闭（half close）状态，如图3-7所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230223204900972.png" class="" title="image-20230223204900972"><p>在图3-7中，服务器和客户端应用程序判断对方是否已经 关闭连接的方法是：read系统调用返回0（收到结束报文段）。当然， Linux还提供其他检测连接是否被对方关闭的方法，这将在后续章节讨 论。</p><h4 id="3-4-TCP-状态转移"><a href="#3-4-TCP-状态转移" class="headerlink" title="3.4 TCP 状态转移"></a>3.4 TCP 状态转移</h4><h5 id="3-4-2-TIME-WAIT状态"><a href="#3-4-2-TIME-WAIT状态" class="headerlink" title="3.4.2 TIME_WAIT状态"></a>3.4.2 TIME_WAIT状态</h5><img src="TCPIP协议详解/image-20230310104904354.png" alt="image-20230310104904354" style="zoom:50%;" /><p>从图3-9来看，客户端连接在收到服务器的结束报文段（TCP报文 段6）之后，并没有直接进入CLOSED状态[1]，而是转移到TIME_WAIT 状态。在这个状态，客户端连接要等待一段长为2MSL（Maximum Segment Life，报文段最大生存时间）的时间，才能完全关闭。MSL是 TCP报文段在网络中的最大生存时间，标准文档RFC 1122的建议值是2 min。</p><p>TIME_WAIT状态存在的原因有两点：</p><ul><li><p>可靠地终止TCP连接。</p><blockquote><p>假设图3-9中用于确认服务器结束报文段6的 TCP报文段7丢失，那么服务器将重发结束报文段。<strong>因此客户端需要停留在某个状态以处理重复收到的结束报文段（即向服务器发送确认报 文段）。</strong> 否则，客户端将以复位报文段来回应服务器，服务器则认为 这是一个错误，因为它期望的是一个像TCP报文段7那样的确认报文 段。</p></blockquote></li><li><p>保证让迟来的TCP报文段有足够的时间被识别并丢弃。</p><blockquote><p>在Linux系统上，一个TCP端口不能被同时打开多次（两次及以 上）。当一个TCP连接处于TIME_WAIT状态时，我们将无法立即使用 该连接占用着的端口来建立一个新连接。反过来思考，<strong>如果不存在 TIME_WAIT状态，则应用程序能够立即建立一个和刚关闭的连接相似 的连接（这里说的相似，是指它们具有相同的IP地址和端口号）。</strong> 这 个新的、和原来相似的连接被称为原来的连接的化身（incarnation）。 新的化身可能接收到属于原来的连接的、携带应用程序数据的TCP报文 段（迟到的报文段），这显然是不应该发生的。这就是TIME_WAIT状 态存在的第二个原因。</p></blockquote></li></ul><h4 id="3-6-TCP交互数据流"><a href="#3-6-TCP交互数据流" class="headerlink" title="3.6 TCP交互数据流"></a>3.6 TCP交互数据流</h4><p>TCP报文段所携带的应用程序数据按照长度 分为两种：交互数据和成块数据。</p><ul><li><p>交互数据仅包含很少的字节。使用 交互数据的应用程序（或协议）对实时性要求高，比如telnet、ssh等。</p></li><li><p>成块数据的长度则通常为TCP报文段允许的最大数据长度。使用成块 数据的应用程序（或协议）对传输效率要求高，比如ftp。本节我们讨 论交互数据流。</p></li></ul><h4 id="3-8-带外数据"><a href="#3-8-带外数据" class="headerlink" title="3.8 带外数据"></a>3.8 带外数据</h4><p>有些传输层协议具有带外（Out Of Band，OOB）数据的概念，用 于迅速通告对方本端发生的重要事件。</p><p>因此，带外数据比普通数据 （也称为带内数据）有更高的优先级，它应该总是立即被发送，而不 论发送缓冲区中是否有排队等待发送的普通数据。带外数据的传输可 以使用一条独立的传输层连接，也可以映射到传输普通数据的连接 中。实际应用中，带外数据的使用很少见，已知的仅有telnet、ftp等远 程非活跃程序。</p><p>UDP没有实现带外数据传输，TCP也没有真正的带外数据。不过 TCP利用其头部中的紧急指针标志和紧急指针两个字段，给应用程序提 供了一种紧急方式。TCP的紧急方式利用传输普通数据的连接来传输紧 急数据。这种紧急数据的含义和带外数据类似，因此后文也将TCP紧急 数据称为带外数据。</p><ul><li>我们先来介绍TCP发送带外数据的过程。假设一个进程已经往某个 TCP连接的发送缓冲区中写入了N字节的普通数据，并等待其发送。</li><li>在 数据被发送前，该进程又向这个连接写入了3字节的带外数据“abc”。</li><li>此 时，待发送的TCP报文段的<strong>头部将被设置URG标志</strong>，并且紧急指针被 设置为指向最后一个带外数据的下一字节（进一步减去当前TCP报文段 的序号值得到其头部中的紧急偏移值），如图3-10所示。<img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224211617697.png" class="" title="image-20230224211617697"></li></ul><p>由图3-10可见，发送端一次发送的多字节的带外数据中只有最后一 字节被当作带外数据（字母c），而其他数据（字母a和b）被当成了普 通数据。<strong>如果TCP模块以多个TCP报文段来发送图3-10所示TCP发送缓 冲区中的内容，则每个TCP报文段的头部都将设置URG标志，并且它们的紧 急指针指向同一个位置（数据流中带外数据的下一个位置），但只有 一个TCP报文段真正携带带外数据。</strong></p><p>现在考虑TCP接收带外数据的过程。TCP接收端只有在接收到紧急 指针标志时才检查紧急指针，然后根据紧急指针所指的位置确定带外 数据的位置，并将它读入一个特殊的缓存中。<strong>这个缓存只有1字节，称 为带外缓存。</strong>如果上层应用程序没有及时将带外数据从带外缓存中读 出，则后续的带外数据（如果有的话）将覆盖它。</p><h4 id="3-10-拥塞控制"><a href="#3-10-拥塞控制" class="headerlink" title="3.10 拥塞控制"></a>3.10 拥塞控制</h4><p>慢启动（slow start）、</p><p>拥塞避免（congestion avoidance）、</p><p>快速重传（fast retransmit）</p><p>快速恢复（fast recovery）。</p><p><strong>拥塞控制的最终受控变量是发送端向网络一次连续写入（收到其 中第一个数据的确认之前）的数据量，我们称为SWND（Send Window，发送窗口[1]）。不过，发送端最终以TCP报文段来发送数据，所以SWND限定了发送端能连续发送的TCP报文段数量。</strong>这些TCP 报文段的最大长度（仅指数据部分）称为SMSS（Sender Maximum Segment Size，发送者最大段大小），其值一般等于MSS。</p><h3 id="第4章-TCP-IP通信案例：访问Internet上的Web服务器"><a href="#第4章-TCP-IP通信案例：访问Internet上的Web服务器" class="headerlink" title="第4章 TCP/IP通信案例：访问Internet上的Web服务器"></a>第4章 TCP/IP通信案例：访问Internet上的Web服务器</h3><h4 id="4-1-实例综图"><a href="#4-1-实例综图" class="headerlink" title="4.1 实例综图"></a>4.1 实例综图</h4><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224091619497.png" class="" title="image-20230224091619497"><p>wget客户端程序和代理服务器之间，以及代理服务 器与Web服务器之间都是使用HTTP协议通信的。</p><h4 id="4-2-部署代理服务器"><a href="#4-2-部署代理服务器" class="headerlink" title="4.2 部署代理服务器"></a>4.2 部署代理服务器</h4><p>在HTTP通信链上，客户端和目标服务器之间通常存在某些中转代 理服务器，它们提供对目标资源的中转访问。一个HTTP请求可能被多 个代理服务器转发，后面的服务器称为前面服务器的上游服务器。</p><p>代 理服务器按照其使用方式和作用，分为<strong>正向代理服务器、反向代理服 务器和透明代理服务器。</strong></p><ul><li>正向代理要求客户端自己设置代理服务器的地址。客户的每次请 求都将直接发送到该代理服务器，并由代理服务器来请求目标资源。</li><li>反向代理则被设置在服务器端，因而客户端无须进行任何设置。 反向代理是指用代理服务器来接收Internet上的连接请求，然后将请求 转发给内部网络上的服务器，并将从内部服务器上得到的结果返回给 客户端。</li><li>透明代理只能设置在网关上。用户访问Internet的数据报必然都经 过网关，如果在网关上设置代理，则该代理对用户来说显然是透明 的。透明代理可以看作正向代理的一种特殊情况。</li></ul><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224091945626.png" class="" title="image-20230224091945626"><h4 id="4-3-使用tcpdump抓取传输数据包"><a href="#4-3-使用tcpdump抓取传输数据包" class="headerlink" title="4.3 使用tcpdump抓取传输数据包"></a>4.3 使用tcpdump抓取传输数据包</h4><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224101238917.png" class="" title="image-20230224101238917"><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224092256808.png" class="" title="image-20230224092256808"><p>但为了讨论问题的方便，我们将这43个数据包按照其逻辑关 系分为如下4个部分：</p><ul><li>代理服务器访问DNS服务器以查询域名<a href="http://www.baidu.com对应的ip/">www.baidu.com对应的IP</a> 地址，包括数据包8、9。</li><li>代理服务器查询路由器MAC地址的ARP请求和应答，包括数据 包6、7。</li><li>wget客户端（192.168.1.109）和代理服务器（192.168.1.108）之 间的HTTP通信，包括数据包1～5、23～25、32～40、42和43。</li><li>代理服务器和Web服务器（119.75.218.77）之间的HTTP通信， 包括数据包10～22、26～31和41。</li></ul><h4 id="4-4-访问DNS服务器"><a href="#4-4-访问DNS服务器" class="headerlink" title="4.4 访问DNS服务器"></a>4.4 访问DNS服务器</h4><p>数据包8、9表示代理服务器ernest-laptop向DNS服务器 （219.239.26.42，首选DNS服务器的IP地址，见1.6.2节）查询域名 <a href="http://www.baidu.com对应的ip地址,并得到了回复.该回复包括一个主机别/">www.baidu.com对应的IP地址，并得到了回复。该回复包括一个主机别</a> 名（<a href="http://www.a.shifen.com)和两个ip地址(119.75.218.77和/">www.a.shifen.com）和两个IP地址（119.75.218.77和</a> 119.75.217.56）。</p><p>代理服务器执行DNS查询的完整过程如图4-3所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224093159050.png" class="" title="image-20230224093159050"><p>根据路由策略，目标IP地址（219.239.26.42）仅能匹配路由表 中的默认路由项，因此该IP数据报先被发送至路由器（IP地址为 192.168.1.1），然后通过路由器来转发。<strong>因为ernest-laptop的ARP缓存 中没有与路由器对应的缓存项（我们手动将其删除了），所以ernest-aptop需要发起一个ARP广播以查询路由器的IP地址，而这正是数据包6 描述的内容。</strong></p><p><strong>路由器则通过ARP应答告诉ernest-laptop自己的MAC地址 是14:e6:e4:93:5b:78，如数据包7所示。</strong>最终，以太网驱动程序将IP数据 报封装成以太网帧发送给路由器。此后，代理服务器再次发送数据到 Internet时将不再需要ARP查询，因为ernest-laptop的ARP高速缓存中已 经记录了路由器的IP地址和MAC地址的映射关系。</p><p>==注意:== 虽然IP数据报是先发送到路由器，再由它转发给 目标主机，但是其头部的目标IP地址却是最终的目标主机（DNS服务 器）的IP地址，而不是中转路由器的IP地址（192.168.1.1）。</p><p>这说明， IP头部的源端IP地址和目的端IP地址在转发过程中是始终不变的（一种 例外是源路由选择）。但帧头部的源端物理地址和目的端物理地址在 转发过程中则是一直在变化的。</p><h4 id="4-5-本地名称查询"><a href="#4-5-本地名称查询" class="headerlink" title="4.5 本地名称查询"></a>4.5 本地名称查询</h4><p>Linux将目标主机名及其对应的IP地址存储在/etc/hosts配置文件 中。当需要查询某个主机名对应的IP地址时，程序将首先检查这个文 件。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224094308966.png" class="" title="image-20230224094308966"><p>当wget访问某个Web服务器时，它先读取环境变 量http_proxy。如果该环境变量被设置，并且我们没有阻止wget使用代 理服务，则wget将通过http_proxy指定的代理服务器来访问Web服务。 但http_proxy环境变量中包含主机名ernest-laptop，因此wget将首先读 取/etc/hosts配置文件，试图通过它来解析主机名ernest-laptop对应的IP 地址。其结果正如wget的输出所示，解析成功。</p><p>如果程序在/etc/hosts文件中未找到目标机器名对应的IP地址，它 将求助于DNS服务。</p><h4 id="4-6-HTTP通信"><a href="#4-6-HTTP通信" class="headerlink" title="4.6 HTTP通信"></a>4.6 HTTP通信</h4><p>为了方便讨论，我们将wget客户端和代理服务器之间的通信过程 画成图4-4所示的TCP时序图</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224095552897.png" class="" title="image-20230224095552897"><p>首先应该注意的是，TCP连接从建立到关闭的过程中，客户端仅给 服务器发送了一个HTTP请求（即TCP报文段4），该请求的长度为136 字节（见代码清单4-2中TCP报文段4的length值）。</p><p>代理服务器则用6个 TCP报文段（23、24、25、33、35和36）给客户端返回了总长度为8522 字节（<strong>这可以从对方的最后一个确认报文段42的确认值计算得到，考虑同步报文段和结束报文段各占用一个序号</strong>）的HTTP应答。客户端使 用了7个TCP报文段（32、34、37、38、39、40和42）来确认这8522字 节的HTTP应答数据。</p><p>下面我们简单分析一下这136字节的HTTP请求和8522字节的HTTP 应答的部分主要内容（开启tcpdump的-X选项来查看）。</p><h5 id="4-6-1-HTTP-请求"><a href="#4-6-1-HTTP-请求" class="headerlink" title="4.6.1 HTTP 请求"></a>4.6.1 HTTP 请求</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224100629900.png" class="" title="image-20230224100629900"><p>第1行是请求行。其中“GET”是请求方法，表示客户端以只读的方 式来申请资源。常见的HTTP请求方法有9种，如表4-1所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224100838654.png" class="" title="image-20230224100838654"><p>GET、HEAD、OPTIONS、TRACE、PUT和DELETE 等请求方法被认为是等幂的（idempotent），即多次连续的、重复的请 求和只发送一次该请求具有完全相同的效果。而POST方法则不同，连 续多次发送同样一个请求可能进一步影响服务器上的资源。</p><p>“<a href="http://www.baidu.com/index.html%E2%80%9D%E6%98%AF%E7%9B%AE%E6%A0%87%E8%B5%84%E6%BA%90%E7%9A%84URL%E3%80%82%E5%85%B6">http://www.baidu.com/index.html”是目标资源的URL。其</a> 中“http”是所谓的scheme，表示获取目标资源需要使用的应用层协议。 其他常见的scheme还有ftp、rtsp和file等。“<a href="http://www.baidu.com”指定资源所/">www.baidu.com”指定资源所</a> 在的目标主机。<strong>“index.html”指定资源文件的名称，这里指的是服务器 根目录（站点的根目录，而不是服务器的文件系统根目录“/”）中的索 引文件。</strong></p><ul><li><p>“HTTP/1. 0”表示客户端（wget程序）使用的HTTP的版本号是1.0。 目前的主流HTTP版本是1.1。</p></li><li><p>HTTP请求内容中的第2～4行都是HTTP请求的头部字段。一个 HTTP请求可以包含多个头部字段。一个头部字段用一行表示，包含字 段名称、冒号、空格和字段的值。HTTP请求中的头部字段可按任意顺 序排列。</p></li><li><p>“User-Agent:Wget/1. 12(linux-gnu)”表示客户端使用的程序是wget。 </p></li><li><p>“Host:www. baidu.com”表示目标主机名是<a href="http://www.baidu.com.http/">www.baidu.com。HTTP</a> 协议规定HTTP请求中必须包含的头部字段就是目标主机名。</p></li><li><p>“Connection:close”是我们执行wget命令时传入的（见代码清单4- 1），用以告诉服务器处理完这个HTTP请求之后就关闭连接。</p><blockquote><p>在旧的 HTTP协议中，Web客户端和Web服务器之间的一个TCP连接只能为一 个HTTP请求服务。当处理完客户的一个HTTP请求之后，Web服务器就 （主动）将TCP连接关闭了。此后，同一客户如果要再发送一个HTTP 请求的话，必须与服务器建立一个新的TCP连接。也就是说，<strong>同一个客户的多个连续的HTTP请求不能共用同一个TCP连接，这称为短连接。</strong></p><p><strong>长连接与之相反，是指多个请求可以使用同一个TCP连接。长连接在编程上稍微复杂一些，但性能上却有很大提高：它极大地减少了网络上 为建立TCP连接导致的负荷，同时对每次请求而言缩减了处理时间。</strong></p></blockquote></li></ul><p><strong>在所有头部字段之后，HTTP请求必须包含一个空行，以标识头部 字段的结束。</strong>请求行和每个头部字段都必须以＜CR＞＜LF＞结束（回 车符和换行符）；而空行则必须只包含一个＜CR＞＜LF＞，不能有其 他字符，甚至是空白字符。 </p><p>在空行之后，HTTP请求可以包含可选的消息体。如果消息体非 空，则HTTP请求的头部字段中必须包含描述该消息体长度的字 段“Content-Length”。我们的实例只是获取目标服务器上的资源，所以 没有消息体。</p><h5 id="4-6-2-HTTP应答"><a href="#4-6-2-HTTP应答" class="headerlink" title="4.6.2 HTTP应答"></a>4.6.2 HTTP应答</h5><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224101613564.png" class="" title="image-20230224101613564"><p><strong>第一行是状态行。</strong>“HTTP/1.0”是服务器使用的HTTP协议的版本 号。通常，服务器需要使用和客户端相同的HTTP协议版本。“200 OK”是状态码和状态信息。常见的状态码和状态信息及其含义如表4-2 所示。</p><img src="/2022/12/09/TCPIP%E5%8D%8F%E8%AE%AE%E8%AF%A6%E8%A7%A3/image-20230224101716998.png" class="" title="image-20230224101716998"><p>第2～7行是HTTP应答的头部字段。其表示方法与HTTP请求中的 头部字段相同。</p><ul><li>“Server:BWS/1. 0”表示目标Web服务器程序的名字是BWS（Baidu Web Server）。 </li><li>“Content-Length:8024”表示目标文档的长度为8024字节。这个值和 wget输出的文档长度一致。</li><li>“Content-Type:text/html;charset=gbk”表示目标文档的MIME类型。 其中“text”是主文档类型，“html”是子文档类型。“text/html”表示目标文 档index.html是text类型中的html文档。“charset”是text文档类型的一个参 数，用于指定文档的字符编码。</li><li>“Set-Cookie:BAIDUID=A5B6C72D68CF639CE8896FD79A03FBD8:FG=1;expires=Wed,04-Jul-42 00:10:47 GMT;path=/;domain=. baidu.com”表示服务器 传送一个Cookie给客户端。其中，“BAIDUID”指定Cookie的名 字，“expires”指定Cookie的生存时间，“domain”和“path”指定该Cookie 生效的域名和路径。下面我们简单分析一下Cookie的作用。</li><li>“Via:1. 0 localhost(squid/3.0 STABLE18)”表示HTTP应答在返回过程 中经历过的所有代理服务器的地址和名称。这里的localhost实际上指的 是“192.168.1.108”。这个头部字段的功能有点类似于IP协议的记录路由 功能。</li></ul><p>第2章中曾提到，<strong>HTTP协议是一种无状态的协议，即每个HTTP请求之间没有任何上下文关系。</strong>如果服务器处理后续HTTP请求时需要用 到前面的HTTP请求的相关信息，客户端必须重传这些信息。这样就导 致HTTP请求必须传输更多的数据。</p><p>在交互式Web应用程序兴起之后，HTTP协议的这种无状态特性就显得不适应了，因为交互程序通常要承上启下。因此，我们要使用额 外的手段来保持HTTP连接状态，常见的解决方法就是Cookie。<strong>Cookie 是服务器发送给客户端的特殊信息（通过HTTP应答的头部字段“Set-Cookie”），客户端每次向服务器发送请求的时候都需要带上这些信息 （通过HTTP请求的头部字段“Cookie”）。这样服务器就可以区分不同 的客户了。基于浏览器的自动登录就是用Cookie实现的。</strong></p><p>在所有头部字段之后，HTTP应答必须包含一个空行，以标识头部 字段的结束。状态行和每个头部字段都必须以＜CR＞＜LF＞结束；而 空行则必须只包含一个＜CR＞＜LF＞，不能有其他字符，甚至是空白 字符。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 服务器编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代 C++ 教程</title>
      <link href="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/"/>
      <url>/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="现代-C-教程"><a href="#现代-C-教程" class="headerlink" title="现代 C++ 教程"></a>现代 C++ 教程</h2><p><strong>现代 C++</strong> (本书中均指 C++11/14/17/20) 为传统 C++ 注入的大量特性使得整个 C++ 变得更加像一门现代化的语言。</p><h3 id="一-迈向现代C"><a href="#一-迈向现代C" class="headerlink" title="一 迈向现代C++"></a>一 迈向现代C++</h3><h4 id="1-1-被弃用的特性"><a href="#1-1-被弃用的特性" class="headerlink" title="1.1 被弃用的特性"></a>1.1 被弃用的特性</h4><p><strong>注意</strong>：弃用并非彻底不能用，只是用于暗示程序员这些特性将从未来的标准中消失，应该尽 量避免使用。但是，已弃用的特性依然是标准库的一部分，并且出于兼容性的考虑，大部分 特性其实会『永久』保留。</p><ul><li>不再允许字符串字面值常量赋值给一个 char *。如果需要用字符串字面值常量赋值和初始化一个 char *，应该使用 const char * 或者 auto。 如 char *str = “hello world!”;    // 将出现弃用警告</li><li>auto_ptr 被弃用，应使用 unique_ptr。</li><li>特别地，在最新的 C++17 标准中弃用了一些可以使用的 C 标准库，例如 <code>&lt;ccomplex&gt;</code>与**<cstdalign>**  等</li></ul><h4 id="1-2-与C的兼容性"><a href="#1-2-与C的兼容性" class="headerlink" title="1.2 与C的兼容性"></a>1.2 与C的兼容性</h4><p>出于一些不可抗力、历史原因，我们不得不在 C++ 中使用一些 C 语言代码，例如 Linux 系统调用。</p><p>从现在开始，你的脑子里应该树立『C++ 不是 C 的一个超集』这个观念。在编写 C++ 时，也应该尽可能 的避免使用诸如 void* 之类的程序风格。</p><p>而在不得不使用 C 时，应该注意使用 ==extern “C”== 这种特性， 将 C 语言的代码与 C++ 代码进行分离编译，再统一链接这种做法。</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118155902628.png" class="" title="image-20221118155902628"><p>标识: <code>-std=c++2a</code> 启用预先批准的部分C++ 特性</p><h3 id="二-语言可用性的强化"><a href="#二-语言可用性的强化" class="headerlink" title="二 语言可用性的强化"></a>二 语言可用性的强化</h3><p>当我们声明、定义一个变量或者常量，对代码进行流程控制、面向对象的功能、模板编程等这些都 是运行时之前，可能发生在编写代码或编译器编译代码时的行为。为此，我们通常谈及语言可用性，是 指那些发生在运行时之前的语言行为。</p><h4 id="2-1-常量"><a href="#2-1-常量" class="headerlink" title="2.1 常量"></a>2.1 常量</h4><h5 id="2-1-1-nullptr"><a href="#2-1-1-nullptr" class="headerlink" title="2.1.1 nullptr"></a>2.1.1 nullptr</h5><blockquote><p>在某种意义上来说，传统 C++ 会把 NULL、0 视为同一种东 西，这取决于编译器如何定义 NULL，有些编译器会将 NULL 定义为 ((void*)0)，有些则会直接将其定义 为 0。但是C++ 不允许直接将 void * 隐式转换到其他类型。</p><p>但如果编译器尝试把 NULL 定义为 ((void*)0)， 那么在下面这句代码中： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ch = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p> 没有了 void * 隐式转换的 C++ 只好将 NULL 定义为 0。而这依然会产生新的问题，将 NULL 定义 成 0 将导致 C++ 中重载特性发生混乱。 <strong>那么 foo(NULL); 这个语句将会去调用 foo(int)，从而导致代码违反直觉。</strong></p></blockquote><p>C++11 引入了 nullptr 关键字，专门用来区分空指针、0。而 nullptr 的类型 为 nullptr_t，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。</p><p>下面的程序会判断 **NULL, nullptr, 0是否是同一种类型: **</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>(<span class="number">0</span>)&gt;::value)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == 0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="keyword">decltype</span>((<span class="keyword">void</span>*)<span class="number">0</span>)&gt;::value)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == (void *)0&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="literal">NULL</span>), <span class="built_in">std</span>::<span class="keyword">nullptr_t</span>&gt;::value)</span><br><span class="line">   <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL == nullptr&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-1-2-constexpr"><a href="#2-1-2-constexpr" class="headerlink" title="2.1.2  constexpr"></a>2.1.2  constexpr</h5><blockquote><p>常量表达式：比如 1+2, 3*4 这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。</p></blockquote><p>C++11 提供了 constexpr 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这 个关键字明确的告诉编译器应该去验证 foo 在编译期就应该是一个常量表达式。</p><p>从 C++14 开始，constexpr 函数可以在内部使用局部变量、循环和分支等简单语句。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(n == <span class="number">2</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">return</span> fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码在C++ 11 中编译不过, 因为含有分支, 改为以下代码可以编译通过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> <span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n == <span class="number">1</span> || n == <span class="number">2</span> ? <span class="number">1</span> : fibonacci(n<span class="number">-1</span>) + fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-变量及其初始化"><a href="#2-2-变量及其初始化" class="headerlink" title="2.2 变量及其初始化"></a>2.2 变量及其初始化</h4><h5 id="2-2-1-if-switch-变量声明强化"><a href="#2-2-1-if-switch-变量声明强化" class="headerlink" title="2.2.1 if/switch 变量声明强化"></a>2.2.1 if/switch 变量声明强化</h5><p>在传统 C++ 中，变量的声明虽然能够位于任何位置，甚至于 for 语句内能够声明一个临时变量 int，但始终<strong>没有办法在 if 和 switch 语句中声明一个临时的变量。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 c++17 之前</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将临时变量放到 if 语句内</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itr = <span class="built_in">std</span>::find(vec.begin(), vec.end(), <span class="number">3</span>);</span><br><span class="line">itr != vec.end()) &#123;</span><br><span class="line">*itr = <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 和Go 语言有点像</span></span><br></pre></td></tr></table></figure><h5 id="2-2-2-初始化列表"><a href="#2-2-2-初始化列表" class="headerlink" title="2.2.2 初始化列表"></a>2.2.2 初始化列表</h5><p>初始化是一个非常重要的语言特性，最常见的就是在对象进行初始化时进行使用。这就为类对象的初始化与普通数组和 POD(Plain Old Data，即没有构造、析构和虚函 数的类或结构体) 的初始化方法提供了<strong>统一的桥梁</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicFoo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">MagicFoo(<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">list</span>) &#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = <span class="built_in">list</span>.begin();</span><br><span class="line">it != <span class="built_in">list</span>.end(); ++it)</span><br><span class="line">vec.push_back(*it);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// after C++11</span></span><br><span class="line">MagicFoo magicFoo = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;magicFoo: &quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = magicFoo.vec.begin();</span><br><span class="line">it != magicFoo.vec.end(); ++it)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种构造函数被叫做初始化列表构造函数，具有这种构造函数的类型将在初始化时被特殊关照。</p><h5 id="2-2-3-结构化绑定"><a href="#2-2-3-结构化绑定" class="headerlink" title="2.2.3 结构化绑定"></a>2.2.3 结构化绑定</h5><p>结构化绑定提供了类似其他语言中提供的多返回值的功能。C++11 新 增了 std::tuple 容器用于构造一个元组，进而囊括多个返回值。</p><p>但是，C++11/14 并没有提供一种 ==简单的方法== 直接从元组中拿到并定义元组中的元素，尽管我们可以使用 std::tie 对元组进行拆包，但我们依然必须非常清楚这个元组包含多少个对象，各个对象是什么类型，非常麻烦。</p><p>C++ 17进行了完善, 给出的结构化绑定可以让我们写出这样的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;int, double, std::string&gt; f() &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1</span>, <span class="number">2.3</span>, <span class="string">&quot;456&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> [x, y, z] = f();   <span class="comment">// 简单的进行拆包</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;, &quot;</span> &lt;&lt; z &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-3-类型推导"><a href="#2-3-类型推导" class="headerlink" title="2.3 类型推导"></a>2.3 类型推导</h4><p>C++11 引入了 auto 和 decltype 这两个关键字实现了类型推导，让编译器来操心变量的类型。这 使得 C++ 也具有了和其他现代编程语言一样，某种意义上提供了无需操心变量类型的使用习惯。</p><h5 id="2-3-1-auto"><a href="#2-3-1-auto" class="headerlink" title="2.3.1 auto"></a>2.3.1 auto</h5><p>使用 auto 进行类型推导的一个最为常见而且显著的例子就是迭代器。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// C++ 11 之前</span></span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = vec.cbegin(); it != vec.cend(); ++it)</span><br><span class="line">    </span><br><span class="line"><span class="comment">// C++ 11, 避免代码臭长</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">list</span>.begin(); it != <span class="built_in">list</span>.end(); ++it)</span><br></pre></td></tr></table></figure><p>从C++ 20 起, auto 还支持函数传参</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">auto</span> x, <span class="keyword">auto</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">auto</span> i = <span class="number">5</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="keyword">auto</span> j = <span class="number">6</span>; <span class="comment">// 被推导为 int</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(i, j) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-decltype"><a href="#2-3-2-decltype" class="headerlink" title="2.3.2 decltype"></a>2.3.2 decltype</h5><p>decltype 关键字是为了解决 auto 关键字只能对<strong>变量</strong>进行类型推导的缺陷而出现的。它的用法和 typeof 很相似：decltype(表达式)。</p><p>有时候，我们可能需要计算某个表达式的类型，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">auto</span> y = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">decltype</span>(x+y) z;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="2-3-3-尾返回类型推导"><a href="#2-3-3-尾返回类型推导" class="headerlink" title="2.3.3 尾返回类型推导"></a>2.3.3 尾返回类型推导</h5><p>typename 和 class 在模板参数列表中<strong>没有区别</strong>，在 typename 这个关键字出现之前，都 是使用 class 来定义模板参数的。但在模板中定义有==嵌套依赖类型的变量==时，需要用 ==typename消除歧义== 。</p><p>在介绍 auto 时，我们已经提过 auto 不能用于函数形参进行类型推导，那么 auto 能不能用于推导函数的返回类型呢？例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> R, <span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function">R <span class="title">add</span><span class="params">(T x, U y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> x+y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码很差，因为程序员在使用这个模板函数的时候，必须明确指出返回类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++11 中这个问题得到解决。虽然你可能马上会反应出来使用 decltype 推导 x+y 的类型，写出这样的代码：</span></span><br><span class="line"><span class="keyword">decltype</span>(x+y) add(T x, U y)</span><br></pre></td></tr></table></figure><p>但事实上这样的写法并不能通过编译。这是因为在编译器读到 decltype(x+y) 时，x 和 y 尚未被定 义。</p><p>C++11 还引入了一个叫做尾返回类型（trailing return type），利用 auto 关键 字将返回类型后置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line">auto add2(T x, U y) -&gt; decltype(x+y)&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//  C++14 开始是可以直接让普通函数具备返回值推导, 直接写成</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add3</span><span class="params">(T x, U y)</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-4-decltype-auto"><a href="#2-3-4-decltype-auto" class="headerlink" title="2.3.4 decltype(auto)"></a>2.3.4 decltype(auto)</h5><p>decltype(auto) 是 C++14 开始提供的一个略微复杂的用法。</p><p>简单来说，decltype(auto) 主要用于对转发函数或封装的返回类型进行推导，它使我们无需显式的 指定 decltype 的参数表达式。</p><p>学完语言运行时强化  再回头看</p><h4 id="2-4-控制流"><a href="#2-4-控制流" class="headerlink" title="2.4 控制流"></a>2.4 控制流</h4><h5 id="2-4-1-if-constexpr"><a href="#2-4-1-if-constexpr" class="headerlink" title="2.4.1 if constexpr"></a>2.4.1 if constexpr</h5><p>C++11 引入了 constexpr 关键字，它将表达式或函数编译为常量结果。</p><p>一个很自然的想法是，如果我们把这一特性引入到条件判断中去，让代码在编译时就完成分支判断， 岂不是能让程序效率更高？</p><p>C++17 将 constexpr 这个关键字引入到 if 语句中，<strong>允许在代码中声明常量表达式的判断条件。</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="built_in">std</span>::is_integral&lt;T&gt;::value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">5</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; print_type_info(<span class="number">3.14</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//在编译时，实际代码就会表现为如下：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_type_info</span><span class="params">(<span class="keyword">const</span> <span class="keyword">double</span>&amp; t)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t + <span class="number">0.001</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-4-2-区间for循环"><a href="#2-4-2-区间for循环" class="headerlink" title="2.4.2 区间for循环"></a>2.4.2 区间for循环</h5><p>C++11 引入了基于范围的迭代写法，我们拥有了能够写出像 Python 一样简洁的循环语句</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> &amp;element : vec) &#123;</span><br><span class="line">element += <span class="number">1</span>; <span class="comment">// writeable</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> element : vec)&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; element &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// read only</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-模板"><a href="#2-5-模板" class="headerlink" title="2.5 模板"></a>2.5 模板</h4><p>模板的哲学在于将一切能够在编译期处理的问题丢到<strong>编译期</strong>进行处理，仅在运行时处理那些最核心的动 态服务，进而大幅优化运行期的性能。因此模板也被很多人视作 C++ 的黑魔法之一。</p><h5 id="2-5-1-外部模板"><a href="#2-5-1-外部模板" class="headerlink" title="2.5.1 外部模板"></a>2.5.1 外部模板</h5><p>传统 C++ 中，模板只有在使用时才会被编译器实例化。换句话说，只要在每个编译单元（文件）中 编译的代码中遇到了被完整定义的模板，都会实例化。这就产生了重复实例化而导致的编译时间的增加。 并且，我们没有办法通知编译器不要触发模板的实例化。 </p><p>为此，C++11 引入了外部模板，扩充了原来的强制编译器在特定位置实例化模板的语法，使我们能 够显式的通知编译器何时进行模板的实例化：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>; <span class="comment">// 强行实例化 </span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> <span class="class"><span class="keyword">class</span> <span class="title">std</span>:</span>:<span class="built_in">vector</span>; <span class="comment">// 不在该当前编译文件中实例化模板</span></span><br></pre></td></tr></table></figure><h5 id="2-5-2-类型别名模板"><a href="#2-5-2-类型别名模板" class="headerlink" title="2.5.2 类型别名模板"></a>2.5.2 类型别名模板</h5><p>在了解类型别名模板之前，需要理解『模板』和『类型』之间的不同。仔细体会这句话：<strong>模板是用来产生类型的</strong>。在传统 C++ 中，typedef 可以为类型定义一个新的名称，但是却没有办法为模板定义一 个新的名称。因为，模板不是类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicType</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T dark;</span><br><span class="line">U magic;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不合法, 因为模板不是类型, 所以使用typedef 不能定义新的名称</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typedef</span> MagicType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt; FakeDarkMagic;</span><br></pre></td></tr></table></figure><p>C++11 使用 using 引入了下面这种形式的写法，并且同时支持对传统 typedef 相同的功效</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通常我们使用 typedef 定义别名的语法是：typedef 原名称 新名称;，</span></span><br><span class="line"><span class="comment">// 但是对函数指针等别名的定义语法却不相同，这通常给直接阅读造成了一定程度的困难</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*process)</span><span class="params">(<span class="keyword">void</span> *)</span></span>;</span><br><span class="line"><span class="keyword">using</span> NewProcess = <span class="keyword">int</span>(*)(<span class="keyword">void</span> *);</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">using</span> TrueDarkMagic = MagicType&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;T&gt;, <span class="built_in">std</span>::<span class="built_in">string</span>&gt;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">TrueDarkMagic&lt;<span class="keyword">bool</span>&gt; you;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-3-变长参数模板"><a href="#2-5-3-变长参数模板" class="headerlink" title="2.5.3 变长参数模板"></a>2.5.3 变长参数模板</h5><p>在 C++11 之前，无论是类模板 还是函数模板，都只能按其指定的样子，接受一组固定数量的模板参数；而 C++11 加入了新的表示方法，允许任意个数、任意类别的模板参数，同时也不需要在定义时将参数的个数固定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt; <span class="class"><span class="keyword">class</span> <span class="title">Magic</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 模板类 Magic 的对象，能够接受不受限制个数的 typename 作为模板的形式参数, 所以也可以是0个</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;</span><span class="keyword">int</span>,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">map</span>&lt;<span class="built_in">std</span>::<span class="built_in">string</span>,</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&gt; darkMagic;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span>&lt;</span>&gt; nothing;</span><br></pre></td></tr></table></figure><p>定义了变长的模板参数，如何对==参数解包==呢？</p><p>首先，我们可以使用 <strong>sizeof…</strong> 来计算参数的个数，：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">magic</span><span class="params">(Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其次，对参数进行解包，到目前为止还没有一种简单的方法能够处理参数包，但有两种经典的处理 手法：</p><ol><li><p>递归模板函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归是非常容易想到的一种手段，也是最经典的处理方法。这种方法不断递归地向函数传递模板参数，</span></span><br><span class="line"><span class="comment">// 进而达到递归遍历所有模板参数的目的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T0 value)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf1</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">printf1(args...);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">printf1(<span class="number">1</span>, <span class="number">2</span>, <span class="string">&quot;123&quot;</span>, <span class="number">1.1</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>变参模板展开</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在 C++17 中增加了变参模板展开的支持，于是你可以在一个函数中完成 printf 的编写</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T0, <span class="keyword">typename</span>... T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printf2</span><span class="params">(T0 t0, T... t)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; t0 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="function"><span class="keyword">if</span> <span class="title">constexpr</span> <span class="params">(<span class="keyword">sizeof</span>...(t) &gt; <span class="number">0</span>)</span> <span class="title">printf2</span><span class="params">(t...)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>初始化列表展开</p><p>递归模板函数是一种标准的做法，但缺点显而易见的在于必须定义一个终止递归的函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Ts&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">printf3</span><span class="params">(T value, Ts... args)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">(<span class="keyword">void</span>) <span class="built_in">std</span>::<span class="built_in">initializer_list</span>&lt;T&gt;&#123;([&amp;args] &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; args &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;(), value)...&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 通过初始化列表，(lambda 表达式, value)... 将会被展开。由于逗号表达式的出现，首先会执行</span></span><br><span class="line"><span class="comment">//前面的 lambda 表达式，完成参数的输出。为了避免编译器警告，我们可以将 std::initializer_list</span></span><br><span class="line"><span class="comment">//显式的转为 void。</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol><h5 id="2-5-4-非类型模板参数推导"><a href="#2-5-4-非类型模板参数推导" class="headerlink" title="2.5.4 非类型模板参数推导"></a>2.5.4 非类型模板参数推导</h5><p>前面我们主要提及的是模板参数的一种形式：类型模板参数。<strong>其中模板的参数 T 和 U 为具体的类型</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">add</span><span class="params">(T t, U u)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> t+u;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但还有一种常见模板参数形式可以<strong>让不同字面量成为模板参数</strong>，即非类型模板参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">int</span> BufSize&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">buffer_t</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">T&amp; <span class="title">alloc</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">(T&amp; item)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T data[BufSize];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">buffer_t</span>&lt;<span class="keyword">int</span>, <span class="number">100</span>&gt; buf; <span class="comment">// 100 作为模板参数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在 C++11 引入了类型推导这 一特性后，我们会很自然的问，既然此处的模板参数以具体的字面量进行传递，能否让编译器辅助我们 进行类型推导，通过使用占位符 auto 从而不再需要明确指明类型？</p><p>C++17 引入了这一特性， 我们的确可以 auto 关键字，让编译器辅助完成具体类型的推导，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">auto</span> value&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">foo&lt;<span class="number">10</span>&gt;(); <span class="comment">// value 被推导为 int 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-6-面向对象"><a href="#2-6-面向对象" class="headerlink" title="2.6 面向对象"></a>2.6 面向对象</h4><h5 id="2-6-1-委托构造"><a href="#2-6-1-委托构造" class="headerlink" title="2.6.1 委托构造"></a>2.6.1 委托构造</h5><p>C++11 引入了委托构造的概念，这使得<strong>构造函数可以在同一个类中一个构造函数调用另一个构造函数</strong>，从而达到简化代码的目的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value1;</span><br><span class="line"><span class="keyword">int</span> value2;</span><br><span class="line">Base() &#123;</span><br><span class="line">value1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> value) : Base() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">value2 = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Base <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; b.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-2-继承构造"><a href="#2-6-2-继承构造" class="headerlink" title="2.6.2 继承构造"></a>2.6.2 继承构造</h5><p>在传统 C++ 中，<strong>构造函数如果需要继承</strong>是需要将参数一一传递的，这将导致效率低下。C++11 利 用关键字 using 引入了继承构造函数的概念：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> value1;</span><br><span class="line"><span class="keyword">int</span> value2;</span><br><span class="line">Base() &#123;</span><br><span class="line">value1 = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">Base(<span class="keyword">int</span> value) : Base() &#123; <span class="comment">// 委托 Base() 构造函数</span></span><br><span class="line">value2 = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> Base::Base; <span class="comment">// 继承构造</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">Subclass <span class="title">s</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; s.value2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-3-显式虚函数重载"><a href="#2-6-3-显式虚函数重载" class="headerlink" title="2.6.3 显式虚函数重载"></a>2.6.3 显式虚函数重载</h5><p>在传统 C++ 中，经常容易发生意外重载虚函数的事情。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>SubClass::foo 可能并不是程序员尝试重载虚函数，只是恰好加入了一个具有相同名字的函数。</p><p>另 一个可能的情形是，当基类的虚函数被删除后，子类拥有旧的函数就不再重载该虚拟函数并摇身一变成 为了一个普通的类方法，这将造成灾难性的后果。</p><p>C++11 引入了 override 和 final 这两个关键字来防止上述情形的发生。</p><ul><li><p>override 当重载虚函数时，引入 override 关键字将显式的告知编译器进行重载，编译器将检查基函数是否存在这样的虚函数，否则将无法通过编译：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 合法</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">float</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 非法, 父类没有此虚函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>final 则是为了防止类被继续继承以及终止虚函数继续重载引入的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass1</span> <span class="keyword">final</span>:</span> Base &#123;</span><br><span class="line">&#125;; <span class="comment">// 合法</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass2</span> :</span> SubClass1 &#123;</span><br><span class="line">&#125;; <span class="comment">// 非法, SubClass1 已 final</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SubClass3</span>:</span> Base &#123;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span>; <span class="comment">// 非法, foo 已 final</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h5 id="2-6-4-显式禁用默认函数"><a href="#2-6-4-显式禁用默认函数" class="headerlink" title="2.6.4 显式禁用默认函数"></a>2.6.4 显式禁用默认函数</h5><p>在传统 C++ 中，如果程序员没有提供，编译器会默认为对象生成<strong>默认构造函数、复制构造、赋值 算符以及析构函数</strong>。另外，C++ 也为所有类定义了诸如 new delete 这样的运算符。当程序员有需要时， 可以重载这部分函数。</p><p>这就引发了一些需求：无法精确控制默认函数的生成行为。例如禁止类的拷贝时，必须将复制构造 函数与赋值算符声明为 private。尝试使用这些未定义的函数将导致编译或链接错误，则是一种非常不优雅的方式。</p><p>C++11 提供了上述需求的解决方案，允许显式的声明采用或拒绝编译器自带的函数；</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Magic</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Magic() = <span class="keyword">default</span>; <span class="comment">// 显式声明使用编译器生成的构造</span></span><br><span class="line">Magic&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Magic&amp;) = <span class="keyword">delete</span>; <span class="comment">// 显式声明拒绝编译器生成构造</span></span><br><span class="line">Magic(<span class="keyword">int</span> magic_number);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-6-5-强类型枚举"><a href="#2-6-5-强类型枚举" class="headerlink" title="2.6.5 强类型枚举"></a>2.6.5 强类型枚举</h5><p>在传统 C++ 中，枚举类型并非类型安全，枚举类型会被视作整数，则会让两种完全不同的枚举类 型可以进行直接的比较（虽然编译器给出了检查，但并非所有），<strong>甚至同一个命名空间中的不同枚举类型 的枚举值名字不能相同</strong>，这通常不是我们希望看到的结果。</p><p>C++11 引入了枚举类（enumeration class），并使用 enum class 的语法进行声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> &#123;</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3 = <span class="number">100</span>,</span><br><span class="line">value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样定义的枚举实现了类型安全，首先他不能够被隐式的转换为整数，同时也不能够将其与整数数 字进行比较，更不可能对不同的枚举类型的枚举值进行比较。但相同枚举值之间如果指定的值相同，那 么可以进行比较。</p><p>如果我们希望获得枚举值的时候， 将必须显式的进行类型转换，不过我们可以通过重载 &lt;&lt; 这个算符来 进行输出：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="built_in">std</span>::ostream&amp; <span class="keyword">operator</span>&lt;&lt;(<span class="keyword">typename</span> <span class="built_in">std</span>::enable_if&lt;<span class="built_in">std</span>::is_enum&lt;T&gt;::value,</span><br><span class="line"><span class="built_in">std</span>::ostream&gt;::type&amp; stream, <span class="keyword">const</span> T&amp; e)&#123;</span><br><span class="line"><span class="keyword">return</span> stream &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> <span class="built_in">std</span>::underlying_type&lt;T&gt;::type&gt;(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="keyword">class</span> <span class="title">new_enum</span> :</span> <span class="keyword">unsigned</span> <span class="keyword">int</span>&#123;</span><br><span class="line">value1,</span><br><span class="line">value2,</span><br><span class="line">value3 = <span class="number">100</span>,</span><br><span class="line">value4 = <span class="number">100</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (new_enum::value3 == new_enum::value4)&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;new_enum::value3 == new_enum::value4&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; new_enum::value3 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三-语言运行期的强化"><a href="#三-语言运行期的强化" class="headerlink" title="三 语言运行期的强化"></a>三 语言运行期的强化</h3><h4 id="3-1-Lambda-表达式"><a href="#3-1-Lambda-表达式" class="headerlink" title="3.1 Lambda 表达式"></a>3.1 Lambda 表达式</h4><p>Lambda 表达式，实际上就是提供了一个类 似匿名函数的特性，而匿名函数则是在需要一个函数，但是又不想费力去命名一个函数的情况下去使用 的。</p><p>Lambda 表达式的基本语法如下：</p><p><code>[捕获列表](参数列表)</code> mutable(可选) 异常属性 -&gt; 返回类型 { // 函数体 }</p><p> 所谓捕获列表，其实可以理解为参数的一种类型，Lambda 表达式内部函数体在默认情况下<strong>是不能够使用函数体外部的变量</strong>的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列 表也分为以下几种：</p><ol><li><p>值捕获 与参数传值类似，值捕获的前提是变量可以拷贝，不同之处则在于，被捕获的变量在 Lambda 表达式被<strong>创建时拷贝</strong>，而非调用时才拷贝。</p></li><li><p>引用捕获 与引用传参类似，引用捕获保存的是引用，值会发生变化。</p></li><li><p>手动书写捕获列表有时候是非常复杂的，这种机械性的工作可以交给编译器来处理，这时 候可以在捕获列表中写一个 &amp; 或 = 向编译器声明采用引用捕获或者值捕获.</p><p>捕获列表的最常用的四种形式可以是：</p><ul><li>[] 空捕获列表 </li><li>[name1, name2, . . . ] 捕获一系列变量 </li><li>[&amp;] 引用捕获, 让编译器自行推导引用列表 </li><li> [=] 值捕获, 让编译器自行推导值捕获列表</li></ul></li><li><p>表达式捕获</p><p>上面提到的值捕获、引用捕获都是已经在外层作用域声明的变量，因此这些捕获方式捕获的<strong>均为左值</strong>，而不能捕获右值。</p><p>C++14 给与了我们方便，允许捕获的成员用任意的表达式进行初始化，这就允许了右值的捕获，被 声明的捕获变量类型会根据表达式进行判断，判断方式与使用 auto 本质上是相同的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt; // std::make_unique</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt; // std::move</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lambda_expression_capture</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> important = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> add = [v1 = <span class="number">1</span>, v2 = <span class="built_in">std</span>::move(important)](<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> x+y+v1+(*v2);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; add(<span class="number">3</span>,<span class="number">4</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-2-函数对象包装器"><a href="#3-2-函数对象包装器" class="headerlink" title="3.2 函数对象包装器"></a>3.2 函数对象包装器</h4><h5 id="3-2-1-std-function"><a href="#3-2-1-std-function" class="headerlink" title="3.2.1 std::function"></a>3.2.1 std::function</h5><p>Lambda 表达式的本质是一个和<strong>函数对象类型相似的类类型</strong>（称为闭包类型）的对象（称为闭包对象），当 Lambda 表达式的捕获列表为空时，闭包对象还能够转换为函数指针值进行传递，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// void(int), 参考https://stackoverflow.com/questions/34437557/difference-between-voidint-void-int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> foo = <span class="keyword">void</span>(<span class="keyword">int</span>); <span class="comment">// 定义 函数类型, using 的使用见上一节中的别名语法</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">functional</span><span class="params">(foo f)</span> </span>&#123; <span class="comment">// 参数列表中定义的函数类型 foo 被视为退化后的函数指针类型 foo*</span></span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// 通过函数指针调用函数</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//等同于 </span></span><br><span class="line"><span class="comment">//void functional(void(*f)(int) ) &#123; </span></span><br><span class="line"><span class="comment">//f(1); // 通过函数指针调用函数</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> f = [](<span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; value &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line">functional(f); <span class="comment">// 传递闭包对象，隐式转换为 foo* 类型的函数指针值</span></span><br><span class="line">    </span><br><span class="line">f(<span class="number">1</span>); <span class="comment">// lambda 表达式调用</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码给出了两种不同的调用形式，一种是将 Lambda 作为函数类型传递进行调用，而另一种 则是直接调用 Lambda 表达式，在 C++11 中，统一了这些概念，<strong>将能够被调用的对象的类型，统一称之为可调用类型</strong>。而这种类型，便是通过 std::function 引入的。</p><p>C++11 std::function 是一种通用、多态的函数封装，<strong>它的实例可以对任何可以调用的目标实体进行存储、复制和调用操作</strong>，它也是对 C++ 中现有的可调用实体的一种类型安全的包裹（相对来说，函数 指针的调用不是类型安全的），换句话说，就是函数的容器。</p><p>当我们有了函数的容器之后便能够更加方便 的将函数、函数指针作为对象进行处理。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> para)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> para;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// std::function 包装了一个返回值为 int, 参数为 int 的函数</span></span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func = foo;</span><br><span class="line"><span class="keyword">int</span> important = <span class="number">10</span>;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>)&gt; func2 = [&amp;](<span class="keyword">int</span> value) -&gt; <span class="keyword">int</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>+value+important;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; func2(<span class="number">10</span>) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-2-std-bind-和-std-placeholder"><a href="#3-2-2-std-bind-和-std-placeholder" class="headerlink" title="3.2.2 std::bind 和 std::placeholder"></a>3.2.2 std::bind 和 std::placeholder</h5><p>std::bind 则是用来绑定函数调用的参数的，它解决的需求是我们有时候可能并不一定能够一次性获得调用某个函数的全部参数，通过这个函数，我们可以<strong>将部分调用参数提前绑定到函数身上</strong>成为一 个新的对象，然后在参数齐全后，完成调用。例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 将参数 1,2 绑定到函数 foo 上，</span></span><br><span class="line"><span class="comment">// 但使用 std::placeholders::_1 来对第一个参数进行占位</span></span><br><span class="line"><span class="keyword">auto</span> bindFoo = <span class="built_in">std</span>::bind(foo, <span class="built_in">std</span>::placeholders::_1, <span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 这时调用 bindFoo 时，只需要提供第一个参数即可</span></span><br><span class="line">bindFoo(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-右值引用"><a href="#3-3-右值引用" class="headerlink" title="3.3 右值引用"></a>3.3 右值引用</h4><p>右值引用是 C++11 引入的与 Lambda 表达式齐名的重要特性之一。它的引入解决了 C++ 中大 量的历史遗留问题，消除了诸如 std::vector、std::string 之类的额外开销，也才使得函数对象容器 std::function 成为了可能。</p><h5 id="3-3-1-左值、右值、纯右值、将亡值"><a href="#3-3-1-左值、右值、纯右值、将亡值" class="headerlink" title="3.3.1 左值、右值、纯右值、将亡值"></a>3.3.1 左值、右值、纯右值、将亡值</h5><p><strong>左值</strong> (lvalue, left value)，顾名思义就是赋值符号左边的值。准确来说，左值是表达式（不一定是赋 值表达式）后依然存在的持久对象。</p><p><strong>右值</strong> (rvalue, right value)，右边的值，是指表达式结束后就不再存在的临时对象。</p><p>也有人将左值翻译为locator value, 意思是可以在内存中找到地址。右值为read value。而 C++11 中为了引入强大的右值引用，将右值的概念进行了进一步的划分，分为：纯右值、将亡值。</p><p><strong>纯右值</strong> (prvalue, pure rvalue)，纯粹的右值，要么是<strong>纯粹的字面量</strong>，例如 10, true；要么是<strong>求值结果相当于字面量或匿名临时对象</strong>，例如 1+2。非引用返回的临时变量、运算表达式产生的临时变量、原始字面量、Lambda 表达式都属于纯右值。==需要注意的是==，字面量除了字符串字面量以外，均为纯右值。而字符串字面量是一个左值，类型为 const char 数组。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;type_traits&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 正确，&quot;01234&quot; 类型为 const char [6]，因此是左值</span></span><br><span class="line">const char (&amp;left)[6] = &quot;01234&quot;;</span><br><span class="line"><span class="comment">// 断言正确，确实是 const char [6] 类型，注意 decltype(expr) 在 expr 是左值</span></span><br><span class="line"><span class="comment">// 且非无括号包裹的 id 表达式与类成员表达式时，会返回左值引用</span></span><br><span class="line"><span class="keyword">static_assert</span>(<span class="built_in">std</span>::is_same&lt;<span class="keyword">decltype</span>(<span class="string">&quot;01234&quot;</span>), <span class="keyword">const</span> <span class="keyword">char</span>(&amp;)[<span class="number">6</span>]&gt;::value, <span class="string">&quot;&quot;</span>);</span><br><span class="line"><span class="comment">// 错误，&quot;01234&quot; 是左值，不可被右值引用</span></span><br><span class="line"><span class="comment">// const char (&amp;&amp;right)[6] = &quot;01234&quot;;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>将亡值</strong> (xvalue, expiring value)，是 C++11 为了引入右值引用而提出的概念（因此在传统 C++ 中，纯右值和右值是同一个概念），也就是即将被销毁、却能够被移动的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = foo();</span><br></pre></td></tr></table></figure><blockquote><p>在这样的代码中，就传统的理解而言，函数 foo 的返回值 temp 在内部创建然后被赋值给 v，然而 v 获得这个对象时，<strong>会将整个 temp 拷贝一份，然后把 temp 销毁</strong>，如果这个 temp 非常大，这将造成大量 额外的开销（这也就是传统 C++ 一直被诟病的问题）。</p><p>在最后一行中，v 是左值、foo() 返回的值就是 右值（也是纯右值）。但是，v 可以被别的变量捕获到，而 foo() 产生的那个返回值作为一个临时值，一 旦被 v 复制后，将立即被销毁，无法获取、也不能修改。</p><p>而将亡值就定义了这样一种行为：<strong>临时的值能够被识别、同时又能够被移动。</strong></p></blockquote><p>在 C++11 之后，编译器为我们做了一些工作，<strong>此处的左值 temp 会被进行此隐式右值转换</strong>，等价于 static_cast &amp;&amp;&gt;(temp)，进而此处的 v 会将 foo 局部返回的值进行移动。也就是 后面我们将会提到的移动语义。</p><h5 id="3-3-2-右值引用和左值引用"><a href="#3-3-2-右值引用和左值引用" class="headerlink" title="3.3.2 右值引用和左值引用"></a>3.3.2 右值引用和左值引用</h5><p><strong>要拿到一个将亡值，就需要用到右值引用：T &amp;&amp;，其中 T 是类型。</strong>右值引用的声明让这个临时值的 生命周期得以延长、只要变量还活着，那么将亡值将继续存活。</p><p> C++11 提供了 std::move 这个方法将左值参数无条件的转换为右值，有了它我们就能够方便的获得一个右值临时对象，例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; str)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> lv1 = <span class="string">&quot;string,&quot;</span>; <span class="comment">// lv1 是一个左值</span></span><br><span class="line"><span class="comment">// std::string&amp;&amp; r1 = lv1; // 非法, 右值引用不能引用左值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv1 = <span class="built_in">std</span>::move(lv1); <span class="comment">// 合法, std::move 可以将左值转移为右值</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; lv2 = lv1 + lv1; <span class="comment">// 合法, 常量左值引用能够延长临时变量的生命周期</span></span><br><span class="line"><span class="comment">// lv2 += &quot;Test&quot;; // 非法, 常量引用无法被修改</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; lv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span>&amp;&amp; rv2 = lv1 + lv2; <span class="comment">// 合法, 右值引用延长临时对象生命周期</span></span><br><span class="line">rv2 += <span class="string">&quot;Test&quot;</span>; <span class="comment">// 合法, 非常量引用能够修改临时变量</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; rv2 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// string,string,string,Test</span></span><br><span class="line">    </span><br><span class="line">reference(rv2); <span class="comment">// 输出左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>rv2 虽然引用了一个右值，但由于它是一个引用，所以 rv2 依然是一个左值。</p><h5 id="3-3-3-移动语义"><a href="#3-3-3-移动语义" class="headerlink" title="3.3.3 移动语义"></a>3.3.3 移动语义</h5><p>传统 C++ 通过<strong>拷贝构造函数和赋值操作符</strong>为类对象设计了<strong>拷贝/复制</strong>的概念，但为了实现对资源的移动操作，调用者必须使用先复制、再析构的方式，否则就需要自己实现移动对象的接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">int</span> *pointer;</span><br><span class="line"></span><br><span class="line">A() : pointer(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1</span>)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 构造&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A(A &amp;a) : pointer(<span class="keyword">new</span> <span class="keyword">int</span>(*a.pointer)) &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 拷贝&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125; <span class="comment">// 无意义的对象拷贝</span></span><br><span class="line">    </span><br><span class="line">A(A &amp;&amp;a) : pointer(a.pointer) &#123;</span><br><span class="line">a.pointer = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 移动&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 析构&quot;</span> &lt;&lt; pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">delete</span> pointer;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 防止编译器优化</span></span><br><span class="line"><span class="function">A <span class="title">return_rvalue</span><span class="params">(<span class="keyword">bool</span> test)</span> </span>&#123;</span><br><span class="line">A a, b;</span><br><span class="line"><span class="keyword">if</span> (test) <span class="keyword">return</span> a; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(a);</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">return</span> b; <span class="comment">// 等价于 static_cast&lt;A&amp;&amp;&gt;(b);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">A obj = return_rvalue(<span class="literal">false</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;obj:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; obj.pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *obj.pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面的代码中： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 运行结果</span><br><span class="line"></span><br><span class="line">构造 0x2353eb0</span><br><span class="line"> 构造 0x2354ee0</span><br><span class="line"> 移动 0x2354ee0</span><br><span class="line"> 析构 0</span><br><span class="line"> 析构 0x2353eb0</span><br><span class="line">cout obj:</span><br><span class="line">0x2354ee0</span><br><span class="line">1</span><br><span class="line"> 析构 0x2354ee0</span><br></pre></td></tr></table></figure><ol><li>首先会在 return_rvalue 内部构造两个 A 对象，于是获得两个构造函数的输出；</li><li><strong>函数返回后，产生一个将亡值</strong>，被 A 的移动构造（A(A&amp;&amp;)）引用，从而延长生命周期，并将这个右值中的指针拿到，保存到了 obj 中，而将亡值的指针被设置为 nullptr，防止了这块内存区域被销毁。</li></ol><p>从而避免了无意义的拷贝构造，加强了性能。</p></blockquote><h5 id="3-3-4-完美转发"><a href="#3-3-4-完美转发" class="headerlink" title="3.3.4 完美转发"></a>3.3.4 完美转发</h5><p>前面我们提到了(3.3.2 小节)，<strong>一个声明的右值引用其实是一个左值</strong>。这就为我们进行参数转发（传递）造成了 问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 普通传参:&quot;</span>;</span><br><span class="line">reference(v); <span class="comment">// 始终调用 reference(int&amp;)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">pass(<span class="number">1</span>); <span class="comment">// 1 是右值, 但输出是左值</span></span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">pass(l); <span class="comment">// l 是左值, 输出左值</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>对于 pass(1) 来说，虽然传递的是右值，但由于 <strong>v 是一个引用，所以同时也是左值</strong>。因此 reference(v) 会调用 reference(int&amp;)，输出『左值』。而对于 pass(l) 而言，l 是一个左值，为什么 会成功传递给 pass(T&amp;&amp;) 呢？</p><p>这是基于引用坍缩规则的：在传统 C++ 中，我们不能够对一个引用类型继续进行引用，但 C++ 由 于右值引用的出现而放宽了这一做法，从而产生了引用坍缩规则，允许我们对引用进行引用，既能左引 用，又能右引用。但是却遵循如下规则：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118225944987.png" class="" title="image-20221118225944987"><p>准确的讲，无论模板参数是什么类型的引用，当且仅当实参类型为右引用时，模板参数才能被推导为 右引用类型。这才使得 v 作为左值的成功传递。</p><p><strong>完美转发就是基于上述规律产生的。</strong>所谓完美转发，就是为了让我们在传递参数的时候，保持原来的参数类型（左引用保持左引用，右引用保持右引用）。为了解决这个问题，我们应该使用 std::forward 来进行参数的转发（传递）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 左值引用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reference</span><span class="params">(<span class="keyword">int</span> &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 右值引用&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pass</span><span class="params">(T &amp;&amp;v)</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 普通传参: &quot;</span>;</span><br><span class="line">reference(v);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; std::move 传参: &quot;</span>;</span><br><span class="line">reference(<span class="built_in">std</span>::move(v));</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; std::forward 传参: &quot;</span>;</span><br><span class="line">reference(<span class="built_in">std</span>::forward&lt;T&gt;(v));</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;static_cast&lt;T&amp;&amp;&gt; 传参: &quot;</span>;</span><br><span class="line">reference(<span class="keyword">static_cast</span>&lt;T &amp;&amp;&gt;(v));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递右值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">pass(<span class="number">1</span>);</span><br><span class="line">    </span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 传递左值:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> v = <span class="number">1</span>;</span><br><span class="line">    pass(v);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>无论传递参数为左值还是右值，普通传参都会将参数作为左值进行转发，所以 std::move 总会接受到一个左值，从而转发调用了 reference(int&amp;&amp;) 输出右值引用。 </p><p>唯独 std::forward 即没有造成任何多余的拷贝，同时完美转发 (传递) 了函数的实参给了内部调用 的其他函数。</p><p> std::forward 和 std::move 一样，没有做任何事情，std::move 单纯的将左值转化为右值， std::forward 也只是单纯的将参数做了一个类型的转换，从现象上来看，std::forward(v) 和 static_cast(v) 是完全一样的。</p></blockquote><h3 id="四-容器"><a href="#四-容器" class="headerlink" title="四 容器"></a>四 容器</h3><h4 id="4-1-线性容器"><a href="#4-1-线性容器" class="headerlink" title="4.1 线性容器"></a>4.1 线性容器</h4><h5 id="4-1-1-std-array"><a href="#4-1-1-std-array" class="headerlink" title="4.1.1 std::array"></a>4.1.1 std::array</h5><ol><li><p>为什么要引入 std::array 而不是直接使用 std::vector？ </p><blockquote><p>与 std::vector 不同，std::array 对象的大小是固定的，<strong>如果容器大小是固定的，那么可以优先考虑使用 std::array 容器</strong>。另外由于 std::vector 是自动扩容的，当存入大量的 数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候就需要手动 运行 shrink_to_fit() 释放这部分内存。</p></blockquote></li><li><p>已经有了传统数组，为什么要用 std::array?</p><blockquote><p>使用 std::array 能够让代码变得更加 ‘‘现代化’’，而且封装了一些操作函 数，比如获取数组大小以及检查是否非空，同时还能够友好的使用标准库中的容器算法，比如 std::sort。</p></blockquote></li></ol><h5 id="4-1-2-std-forward-list"><a href="#4-1-2-std-forward-list" class="headerlink" title="4.1.2 std::forward_list"></a>4.1.2 std::forward_list</h5><p>std::forward_list 是一个列表容器，使用方法和 std::list 基本类似，因此我们就不花费篇幅进 行介绍了。 需要知道的是，和 std::list 的双向链表的实现不同，std::forward_list 使用单向链表进行实现， 提供了 O(1) 复杂度的元素插入，不支持快速随机访问（这也是链表的特点），也是标准库容器中唯一一 个不提供 size() 方法的容器。当不需要双向迭代时，具有比 std::list 更高的空间利用率。</p><h4 id="4-2-无序容器"><a href="#4-2-无序容器" class="headerlink" title="4.2 无序容器"></a>4.2 无序容器</h4><p>传统 C++ 中的<strong>有序容器 std::map/std::set</strong>，这些元素内部通过红黑树进行实现， 插入和搜索的平均复杂度均为 O(log(size))。在插入元素时候，会根据 &lt; 操作符比较元素大小并判断元素是否相同，并选择合适的位置插入到容器中。当对这个容器中的元素进行遍历时，输出结果会按照 &lt; 操作符的顺序来逐个遍历。</p><p>而无序容器中的元素是不进行排序的，内部通过 Hash 表实现，插入和搜索元素的平均复杂度为 O(constant)，在不关心容器内部元素顺序时，能够获得显著的性能提升。</p><p>C++11 引入了的两组无序容器分别是：std::unordered_map/std::unordered_multimap 和 std::unordered_set/std::unordered_multiset。</p><h4 id="4-3-元组"><a href="#4-3-元组" class="headerlink" title="4.3 元组"></a>4.3 元组</h4><p>关于元组的使用有三个核心的函数： </p><ol><li>std::make_tuple: 构造元组 </li><li>std::get: 获得元组某个位置的值</li><li>std::tie: 元组拆包</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_student</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 返回类型被推断为 std::tuple&lt;double, char, std::string&gt;</span></span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">3.8</span>, ’A’, <span class="string">&quot; 张三&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">2.9</span>, ’C’, <span class="string">&quot; 李四&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (id == <span class="number">2</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">1.7</span>, ’D’, <span class="string">&quot; 王五&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::make_tuple(<span class="number">0.0</span>, ’D’, <span class="string">&quot;null&quot;</span>);</span><br><span class="line"><span class="comment">// 如果只写 0 会出现推断错误, 编译失败</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> student = get_student(<span class="number">0</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: 0, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(student) &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名: &quot;</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(student) &lt;&lt; ’\n’;</span><br><span class="line"><span class="keyword">double</span> gpa;</span><br><span class="line"><span class="keyword">char</span> grade;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> name;</span><br><span class="line"><span class="comment">// 元组进行拆包</span></span><br><span class="line"><span class="built_in">std</span>::tie(gpa, grade, name) = get_student(<span class="number">1</span>);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;ID: 1, &quot;</span> &lt;&lt; <span class="string">&quot;GPA: &quot;</span> &lt;&lt; gpa &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩: &quot;</span> &lt;&lt; grade &lt;&lt; <span class="string">&quot;, &quot;</span></span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名: &quot;</span> &lt;&lt; name &lt;&lt; ’\n’;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::get 除了使用常量获取元组对象外，C++14 增加了<strong>使用类型来获取元组中的对象</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;std::string, double, double, int&gt; t(&quot;123&quot;, 4.5, 6.7, 8);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="keyword">double</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 非法, 引发编译期错误</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::get&lt;<span class="number">3</span>&gt;(t) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="4-3-1-运行期索引"><a href="#4-3-1-运行期索引" class="headerlink" title="4.3.1 运行期索引"></a>4.3.1 运行期索引</h5><p>如果你仔细思考一下可能就会发现上面代码的问题，std::get&lt;&gt; 依赖一个编译期的常量，所以下面 的方式是不合法的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::get&lt;index&gt;(t);</span><br></pre></td></tr></table></figure><p>那么要怎么处理？答案是，使用 std::variant&lt;&gt;（C++ 17 引入），提供给 variant&lt;&gt; 的类型模板参数可以让一个 variant&lt;&gt; 从而容纳提供的几种类型的变量:</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221118232359960.png" class="" title="image-20221118232359960"><p>这样就可以:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; tuple_index(t, i) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h5 id="4-3-2-元组合并与遍历"><a href="#4-3-2-元组合并与遍历" class="headerlink" title="4.3.2 元组合并与遍历"></a>4.3.2 元组合并与遍历</h5><p>还有一个常见的需求就是合并两个元组，这可以通过 std::tuple_cat 来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::tuple&lt;std::string, double, double, int&gt; t(&quot;123&quot;, 4.5, 6.7, 8);</span><br><span class="line"><span class="keyword">auto</span> new_tuple = <span class="built_in">std</span>::tuple_cat(get_student(<span class="number">1</span>), <span class="built_in">std</span>::move(t));</span><br></pre></td></tr></table></figure><h3 id="五-智能指针"><a href="#五-智能指针" class="headerlink" title="五 智能指针"></a>五 智能指针</h3><h4 id="5-1-RALL与引用计数"><a href="#5-1-RALL与引用计数" class="headerlink" title="5.1 RALL与引用计数"></a>5.1 RALL与引用计数</h4><p>引用计数这种计数是为了防止内存泄 露而产生的。基本想法是对于动态分配的对象，进行引用计数，每当增加一次对同一个对象的引用，那 么引用对象的引用计数就会增加一次，每删除一次引用，引用计数就会减一，当一个对象的引用计数减 为零时，就自动删除指向的堆内存。</p><p><strong>『记得』手动释放资源，总不是最佳实践。</strong>因为我们很有可能就忘记了去释放资源 而导致泄露。所以通常的做法是对于一个对象而言，我们在构造函数的时候申请空间，而在析构函数（在 离开作用域时调用）的时候释放空间，也就是我们常说的 RAII 资源获取即初始化技术。</p><p>而 C++11 引入了智能指针的概念，使用了引用计数的想法，让程序 员不再需要关心手动释放内存。这些智能指针包括 std::shared_ptr/std::unique_ptr/std::weak_ptr， 使用它们需要包含头文件 。</p><h4 id="5-2-std-shared-ptr"><a href="#5-2-std-shared-ptr" class="headerlink" title="5.2 std::shared_ptr"></a>5.2 std::shared_ptr</h4><p>std::shared_ptr 是一种智能指针，它能够记录多少个 shared_ptr 共同指向一个对象，从而消除显式的调用 delete，当<strong>引用计数变为零</strong>的时候就会将对象自动删除。</p><p>但还不够，因为使用 std::shared_ptr 仍然需要使用 new 来调用，这使得代码出现了某种程度上的不对称。 </p><p>std::make_shared 就能够用来消除显式的使用 new，所以 std::make_shared 会分配创建传入参 数中的对象，并返回这个对象类型的 std::shared_ptr 指针。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; i)</span> </span>&#123;</span><br><span class="line">(*i)++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// auto pointer = new int(10); // illegal, no direct assignment</span></span><br><span class="line"><span class="comment">// Constructed a std::shared_ptr</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">auto</span> pointer = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line">foo(pointer);</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; *pointer &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 11</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// The shared_ptr will be destructed before leaving the scope</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>std::shared_ptr 可以通过 <strong>get() 方法</strong>来获取原始指针，通过 <strong>reset()</strong> 来减少一个引用计数，并 通过 <strong>use_count()</strong> 来查看一个对象的引用计数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> pointer = <span class="built_in">std</span>::make_shared&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">auto</span> pointer2 = pointer; <span class="comment">// 引用计数 +1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> *p = pointer.get(); <span class="comment">// 这样不会增加引用计数</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer2.use_count() = &quot;</span> &lt;&lt; pointer2.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">//2</span></span><br><span class="line"></span><br><span class="line">pointer2.reset();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;reset pointer2:&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pointer.use_count() = &quot;</span> &lt;&lt; pointer.use_count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><h4 id="5-3-std-unique-ptr"><a href="#5-3-std-unique-ptr" class="headerlink" title="5.3 std::unique_ptr"></a>5.3 std::unique_ptr</h4><p>std::unique_ptr 是一种<strong>独占的智能指针</strong>，它禁止其他智能指针与其共享同一个对象，从而保证代 码的安全：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pointer = <span class="built_in">std</span>::make_unique&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>); <span class="comment">// make_unique 从 C++14 引入</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; pointer2 = pointer; <span class="comment">// 非法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 但是C++ 11 中没有实现make_unique, 据说是忘记了, 可以自己实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ...Args&gt;</span><br><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt; <span class="title">make_unique</span><span class="params">( Args&amp;&amp; ...args )</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;T&gt;( <span class="keyword">new</span> T( <span class="built_in">std</span>::forward&lt;Args&gt;(args)... ) );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然是独占，换句话说就是不可复制。但是，我们可以利用 std::move 将其转移给其他的 unique_ptr。</p><h4 id="5-4-weak-ptr"><a href="#5-4-weak-ptr" class="headerlink" title="5.4 weak_ptr"></a>5.4 weak_ptr</h4><p>如果你仔细思考 std::shared_ptr 就会发现依然存在着资源无法释放的问题。例如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;B&gt; pointer;</span><br><span class="line"></span><br><span class="line">~A() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;A 被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span> &lt;A&gt; pointer;</span><br><span class="line"></span><br><span class="line">~B() &#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;B 被销毁&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> a = <span class="built_in">std</span>::make_shared&lt;A&gt;();</span><br><span class="line"><span class="keyword">auto</span> b = <span class="built_in">std</span>::make_shared&lt;B&gt;();</span><br><span class="line">a-&gt;pointer = b;</span><br><span class="line">b-&gt;pointer = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>运行结果是 A, B 都不会被销毁，这是因为 a,b 内部的 pointer 同时又引用了 a,b，这使得 a,b 的引 用计数均变为了 2，而离开作用域时，a,b 智能指针被析构，却只能造成这块区域的引用计数减一，这样 就导致了 a,b 对象指向的内存区域引用计数不为零，而外部已经没有办法找到这块区域了，也就造成了 内存泄露，如图:</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119152443945.png" class="" title="image-20221119152443945"></blockquote><p>解决这个问题的办法就是使用弱引用指针 std::weak_ptr，std::weak_ptr 是一种弱引用（相比较 而言 std::shared_ptr 就是一种强引用）。弱引用不会引起引用计数增加，当换用弱引用时候，最终的 释放流程如图 5.2 所示：<img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119152600314.png" class="" title="image-20221119152600314"></p><p>在上图中，最后一步只剩下 B，而 B 并没有任何智能指针引用它，因此这块内存资源也会被释放。 </p><p>*<em>std::weak_ptr 没有 * 运算符和 -&gt; 运算符*</em>，所以不能够对资源进行操作，它可以用于检查 std::shared_ptr 是否存在，其 expired() 方法能在资源未被释放时，会返回 false，否则返回 true； 除此之外，它也可以用于获取指向原始对象的 std::shared_ptr 指针，其 lock() 方法在原始对象未 被释放时，返回一个指向原始对象的 std::shared_ptr 指针，进而访问原始对象的资源，否则返回 nullptr。</p><h3 id="六-正则表达式"><a href="#六-正则表达式" class="headerlink" title="六 正则表达式"></a>六 正则表达式</h3><p>正则表达式描述了一种字符串匹配的模式。一般使用正则表达式主要是实现下面三个需求：</p><ul><li>检查一个串是否包含某种形式的子串；</li><li>将匹配的子串替换</li><li>从某个串中取出符合条件的子串。</li></ul><h4 id="6-1-正则表达式简介"><a href="#6-1-正则表达式简介" class="headerlink" title="6.1 正则表达式简介"></a>6.1 正则表达式简介</h4><h5 id="6-1-1-特殊字符"><a href="#6-1-1-特殊字符" class="headerlink" title="6.1.1 特殊字符"></a>6.1.1 特殊字符</h5><p>特殊字符是正则表达式里有特殊含义的字符，也是正则表达式的核心匹配语法。参见下表：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153031490.png" class="" title="image-20221119153031490"><h5 id="6-1-2-限定符"><a href="#6-1-2-限定符" class="headerlink" title="6.1.2 限定符"></a>6.1.2 限定符</h5><p>限定符用来指定正则表达式的一个给定的组件必须要出现多少次才能满足匹配。见下表：</p><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153120714.png" class="" title="image-20221119153120714"><img src="/2022/11/18/%E7%8E%B0%E4%BB%A3C++%E6%95%99%E7%A8%8B/image-20221119153137416.png" class="" title="image-20221119153137416"><h4 id="6-2-std-regex-及其相关"><a href="#6-2-std-regex-及其相关" class="headerlink" title="6.2 std::regex 及其相关"></a>6.2 std::regex 及其相关</h4><p>对字符串内容进行匹配的最常见手段就是使用正则表达式。可惜在传统 C++ 中正则表达式一直没 有得到语言层面的支持，没有纳入标准库，而 C++ 作为一门高性能语言，在后台服务的开发中，对 URL 资源链接进行判断时，使用正则表达式也是工业界最为成熟的普遍做法。</p><p><strong>C++11 提供的正则表达式库操作 std::string 对象，模式 std::regex (本质是 std::basic_regex) 进行初始化，通过 std::regex_match 进行匹配，从而产生 std::smatch（本质是 std::match_results 对象）。</strong></p><p>示例: </p><ul><li><code>[a-z]+\.txt</code>: 在这个正则表达式中, [a-z] 表示匹配一个小写字母, + 可以使前面的表达式匹配多 次，因此 [a-z]+ 能够匹配一个小写字母组成的字符串。在正则表达式中一个 . 表示匹配任意字 符，而 <code>\.</code> 则表示匹配字符 .，最后的 txt 表示严格匹配 txt 则三个字母。因此这个正则表达式的 所要匹配的内容就是由纯小写字母组成的文本文件。</li><li>std::regex_match 用于匹配字符串和正则表达式，有很多不同的重载形式。最简单的一个形式就是 传入 std::string 以及一个 std::regex 进行匹配，当匹配成功时，会返回 true，否则返回 false。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;regex&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> fnames[] = &#123;<span class="string">&quot;foo.txt&quot;</span>, <span class="string">&quot;bar.txt&quot;</span>, <span class="string">&quot;test&quot;</span>, <span class="string">&quot;a0.txt&quot;</span>, <span class="string">&quot;AAA.txt&quot;</span>&#125;;</span><br><span class="line"><span class="comment">// 在 C++ 中 \ 会被作为字符串内的转义符，</span></span><br><span class="line"><span class="comment">// 为使 \. 作为正则表达式传递进去生效，需要对 \ 进行二次转义，从而有 \\.</span></span><br><span class="line"><span class="function"><span class="built_in">std</span>::regex <span class="title">txt_regex</span><span class="params">(<span class="string">&quot;[a-z]+\\.txt&quot;</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;fname: fnames)</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; fname &lt;&lt; <span class="string">&quot;: &quot;</span> &lt;&lt; <span class="built_in">std</span>::regex_match(fname, txt_regex) &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>现代化Cmake</title>
      <link href="/2022/11/06/Modern_CMake/"/>
      <url>/2022/11/06/Modern_CMake/</url>
      
        <content type="html"><![CDATA[<h2 id="Modern-CMake"><a href="#Modern-CMake" class="headerlink" title="Modern CMake"></a>Modern CMake</h2><blockquote><p>现代的 CMake 是指 CMake 3.4+ ，甚至是 CMake 3.21+ ！ 它简洁、强大、优雅，所以你能够花费你的大部分时间在编写代码上，而不是在一个不可读、不可维护的 Make （或 CMake 2） 文件上浪费时间。 并且 CMake 3.11+ 的构建速度应该也会更加的快！！！</p></blockquote><h3 id="一-基础知识简介"><a href="#一-基础知识简介" class="headerlink" title="一 基础知识简介"></a>一 基础知识简介</h3><hr><h4 id="1-1-最低版本要求"><a href="#1-1-最低版本要求" class="headerlink" title="1.1 最低版本要求"></a>1.1 最低版本要求</h4><p>这是每个 <code>CMakeLists.txt</code> 都必须包含的第一行，默认小写</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.16</span>)</span><br></pre></td></tr></table></figure><p><code>CMake</code> 的版本与它的特性（policies）相互关联，这意味着它也定义了 <code>CMake</code> 行为的变化。</p><h4 id="1-2-设置一个项目"><a href="#1-2-设置一个项目" class="headerlink" title="1.2 设置一个项目"></a>1.2 设置一个项目</h4><p>每一个顶层 CMakelists 文件都应该有下面这一行：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">project</span>(MyProject VERSION <span class="number">1.0</span></span><br><span class="line">                  DESCRIPTION <span class="string">&quot;Very nice project&quot;</span></span><br><span class="line">                  LANGUAGES CXX)</span><br></pre></td></tr></table></figure><p>项目名称是这里的第一个参数。所有的关键字参数都可选的。<code>VERSION</code> 设置了一系列变量，例如 <code>MyProject_VERSION</code> 和 <code>PROJECT_VERSION</code>。<code>DESCRIPTION</code>，对项目进行简单介绍。语言最好不写，英文c++中项目中，可能存在个别的C文件。</p><h4 id="1-3-生成可执行文件"><a href="#1-3-生成可执行文件" class="headerlink" title="1.3 生成可执行文件"></a>1.3 生成可执行文件</h4><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(one two.cpp three.h)</span><br></pre></td></tr></table></figure><p><code>one</code> 既是生成的可执行文件的名称，也是创建的 <code>CMake</code> 目标(target)的名称。</p><p>紧接着的是源文件的列表，你想列多少个都可以。CMake 很聪明 ，它根据拓展名只编译源文件。</p><p>在大多数情况下，<strong>头文件将会被忽略</strong>；列出他们的唯一原因是为了让他们在 IDE 中被展示出来，目标文件在许多 IDE 中被显示为文件夹。</p><h4 id="1-4-生成一个库"><a href="#1-4-生成一个库" class="headerlink" title="1.4 生成一个库"></a>1.4 生成一个库</h4><p>制作一个库是通过 <code>add_library</code> 命令完成的，并且非常简单：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(one STATIC two.cpp three.h)</span><br></pre></td></tr></table></figure><p>你可以选择库的类型，可以是 <code>STATIC</code>,<code>SHARED</code>, 或者<code>MODULE</code>. </p><ul><li>STATIC 库是链接其他目标时使用的目标文件档案（archives）。</li><li>SHARED 库是动态链接的，并在运行时加载。</li><li>MODULE 库是未链接到其他目标但可以在运行时使用类似 dlopen 的功能动态加载的插件。</li></ul><p><strong>生成的library名会根据<code>STATIC</code>或<code>SHARED</code>成为<code>name.a</code>或<code>name.lib</code>。</strong></p><p>如果你不选择它，CMake 将会通过 <code>BUILD_SHARED_LIBS</code> 的值来选择构建 STATIC 还是 SHARED 类型的库。</p><h4 id="1-5-目标时常伴随着你"><a href="#1-5-目标时常伴随着你" class="headerlink" title="1.5 目标时常伴随着你"></a>1.5 目标时常伴随着你</h4><p>现在我们已经指定了一个目标，那我们如何添加关于它的信息呢？例如，它可能需要包含一个目录：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">target_include_directories</span>(one PUBLIC <span class="keyword">include</span>)</span><br></pre></td></tr></table></figure><blockquote><p>The <code>INTERFACE</code>, <code>PUBLIC</code> and <code>PRIVATE</code> keywords are required to specify the scope of the following arguments.</p></blockquote><p><code>target_include_directories</code>  指定编译给定目标时要使用的包含目录。命名的 <code>&lt;target&gt;</code> 必须是由 <code>add_executable()</code> 或  <code>add_library()</code>  等命令创建的，并且不能是 ALIAS 目标。</p><p> <code>PUBLIC</code> 对于一个二进制目标没有什么含义；但对于库来说，它让 CMake 知道，任何链接到这个目标的目标也必须包含这个目录。</p><p>其他选项还有 <code>PRIVATE</code>（只影响当前目标，不影响依赖），以及 <code>INTERFACE</code>（只影响依赖）。</p><p>接下来我们可以将目标之间链接起来：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_library</span>(another STATIC another.cpp another.h)</span><br><span class="line"></span><br><span class="line"><span class="comment">#target_link_libraries(&lt;target&gt; ... &lt;item&gt;... ...)</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(another PUBLIC one)</span><br></pre></td></tr></table></figure><p><code>target_link_libraries</code> 指定一个目标，并且在给出目标的情况下添加一个依赖关系。</p><p>如果不存在名称为 <code>one</code> 的目标，那他会添加一个链接到你路径中 <code>one</code> 库（这也是命令叫 <code>target_link_libraries</code> 的原因）。<strong>或者</strong>你可以给定一个库的完整路径，或者是链接器标志。</p><p><em>最后再说一个有些迷惑性的知识：），经典的 CMake 允许你省略 <code>PUBLIC</code> 关键字，但是你在目标链中省略与不省略混用，那么 CMake 会报出错误。</em></p><h4 id="1-6-include-directories"><a href="#1-6-include-directories" class="headerlink" title="1.6 include_directories"></a>1.6 include_directories</h4><blockquote><p><strong><code>include_directories</code> ([<code>AFTER|BEFORE</code>] [<code>SYSTEM</code>] dir1 [dir2 …])</strong><br> 将指定目录添加到编译器的头文件搜索路径之下，指定的目录被解释成当前源码路径的相对路径。</p></blockquote><p>使用 <code>include_directories</code> 后, 不需在 <code>add_executable()</code> 里面添加 <code>test.h</code>, 编译器会自动寻找, 默认顺序是</p><p><strong><code>/usr/include</code></strong> -&gt; <strong><code>/usr/local/include</code></strong> -&gt; <strong><code>dir1</code></strong> -&gt; **<code>dir2</code>**。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">→ tree</span><br><span class="line">.</span><br><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include       </span><br><span class="line">│   ├── test.cpp  </span><br><span class="line">│   └── test.h    </span><br><span class="line">└── main.cpp      </span><br><span class="line"></span><br><span class="line">1 directory, 4 files</span><br></pre></td></tr></table></figure><p>cmakeList.txt写法:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include_directories</span>(<span class="keyword">include</span>)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br></pre></td></tr></table></figure><p>有以下两种方式都可以让main函数运行成功:</p><ol><li>在main函数中, 直接使用<code>#include &quot;test.cpp&quot;</code></li><li>在main函数中, 使用#include “test.h”, 但是test.h 必须实现main调用的函数。</li></ol><h4 id="1-7-设置编译器选项以及编译选项"><a href="#1-7-设置编译器选项以及编译选项" class="headerlink" title="1.7 设置编译器选项以及编译选项"></a>1.7 设置编译器选项以及编译选项</h4><p>CMAKE_C_COMPILER：指定C编译器</p><p>CMAKE_CXX_COMPILER：指定C++编译器</p><p>CMAKE_C_FLAGS：指定编译C文件时编译选项，也可以通过add_definitions命令添加编译选项</p><p>在cmake脚本中，设置编译选项（配置编译器）有如下三种方法：</p><p><code>-Wall选项意思是编译后显示所有警告</code>; <code>-Werror选项意思是所有警告当做错误处理</code>。</p><ul><li><p>add_compile_options命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_compile_options</span>(-Wall -Werror )</span><br></pre></td></tr></table></figure></li><li><p>add_definitions 命令</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ADD_DEFINITIONS</span>(<span class="string">&quot;-Wall -Werror&quot;</span>)</span><br></pre></td></tr></table></figure></li><li><p>set命令修改CMAKE_CXX_FLAGS 或 CMAKE_C_FLAGS</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(CMAKE_C_FLAGS <span class="string">&quot;-Wall -Werror -Wstrict-prototypes -Wmissing-prototypes&quot;</span>)</span><br></pre></td></tr></table></figure></li></ul><p>使用这三种方式在有的情况下效果是一样的，但请注意它们还是有区别的：</p><p>add_compile_options命令和add_definitions添加的编译选项是针对所有编译器的(包括c和c++编译器)，而set命令设置CMAKE_C_FLAGS或CMAKE_CXX_FLAGS变量则是分别只针对c和c++编译器的。</p><h3 id="二-变量与缓存"><a href="#二-变量与缓存" class="headerlink" title="二 变量与缓存"></a>二 变量与缓存</h3><hr><h4 id="2-1-本地变量"><a href="#2-1-本地变量" class="headerlink" title="2.1 本地变量"></a>2.1 本地变量</h4><p>你可以这样声明一个本地 ( local ) 变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_VARIABLE <span class="string">&quot;value&quot;</span>)</span><br></pre></td></tr></table></figure><p>变量名通常全部用大写，变量值跟在其后。你可以通过 <code>$&#123;&#125;</code> 来解析一个变量，例如 <code>$&#123;MY_VARIABLE&#125;</code>.</p><p>列表就是简单地包含一系列变量：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;one&quot;</span> <span class="string">&quot;two&quot;</span>)</span><br></pre></td></tr></table></figure><p>你也可以通过 <code>;</code> 分隔变量，这和空格的作用是一样的：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span>(MY_LIST <span class="string">&quot;one;two&quot;</span>)</span><br></pre></td></tr></table></figure><h4 id="2-2-缓存变量"><a href="#2-2-缓存变量" class="headerlink" title="2.2 缓存变量"></a>2.2 缓存变量</h4><p>CMake 提供了一个缓存变量来允许你从命令行中设置变量。CMake 中已经有一些预置的变量，像 <code>CMAKE_BUILD_TYPE</code>。</p><p>通过 <code>set(&lt;variable&gt; &lt;value&gt;... CACHE &lt;type&gt; &lt;docstring&gt; [FORCE])</code>这个命令来设置的变量就是 Cache Variables。例如 <code>set(MY_CACHE_VAL &quot;666&quot; CACHE STRING INTERNAL)</code>，此时 MY_CACHE_VAL 就是一个 CACHE 变量。相当于一个全局变量，我们在同一个 cmake 工程中都可以使用。</p><ul><li>Cache 变量 CMAKE_INSTALL_PREFIX 默认值是 /usr/local (可以在生成的 CMakeCache.txt 文件中查看)，这时候如果我们 在某个 CMakeLists.txt 中，仍然使用 set(CMAKE_INSTALL_PREFIX “/usr”)，那么此时我们 install 的时候，CMake 以后面的 /usr 作为 CMAKE_INSTALL_PREFIX 的值，这是因为 CMake 规定，有一个与 Cache 变量同名的 Normal 变量出现时，后面使用这个变量的值都是以 Normal 为准，如果没有同名的 Normal 变量，CMake 才会自动使用 Cache 变量。</li><li>所有的 Cache 变量都会出现在 CMakeCache.txt 文件中。这个文件是我们键入 <code>cmake .</code>命令后自动出现的文件。打开这个文件发现，CMake 本身会有一些默认的全局 Cache 变量。例如：CMAKE_INSTALL_PREFIX、CMAKE_BUILD_TYPE、CMAKE_CXX_FLAGSS 等等。可以自行查看。当然，我们自己定义的 Cache 变量也会出现在这个文件中。Cache 变量定义格式为 <code>set(&lt;variable&gt; &lt;value&gt; CACHE STRING INTERNAL)</code>。这里的 <code>STRING</code>可以替换为 <code>BOOL</code> <code>FILEPATH</code> <code>PATH</code> ，但是要根据前面 value 类型来确定。参考。</li><li>修改 Cache 变量。可以通过 <code>set(&lt;variable&gt; &lt;value&gt; CACHE INSTERNAL FORCE)</code>，另一种方式是直接在终端中使用 <code>cmake -D var=value ..</code>来设定默认存在的CMake Cache 变量。</li></ul><h4 id="3-3-环境变量、缓存"><a href="#3-3-环境变量、缓存" class="headerlink" title="3.3 环境变量、缓存"></a>3.3 环境变量、缓存</h4><ul><li>你也可以通过 <code>set(ENV&#123;variable_name&#125; value)</code> 和 <code>$ENV&#123;variable_name&#125;</code> 来设置和获取环境变量，不过一般来说，我们最好避免这么用。</li><li>缓存实际上就是个文本文件，<code>CMakeCache.txt</code> ，当你运行 CMake 构建目录时会创建它。 CMake 可以通过它来记住你设置的所有东西，因此你可以不必在重新运行 CMake 的时候再次列出所有的选项。</li></ul><h3 id="三-寻找其他库"><a href="#三-寻找其他库" class="headerlink" title="三 寻找其他库"></a>三 寻找其他库</h3><h4 id="3-1-OpenMP"><a href="#3-1-OpenMP" class="headerlink" title="3.1 OpenMP"></a>3.1 OpenMP</h4><p><a href="https://cmake.org/cmake/help/latest/module/FindOpenMP.html">OpenMP</a> support was drastically improved in CMake 3.9+. The Modern(TM) way to add OpenMP to a target is:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(OpenMP)</span><br><span class="line"><span class="keyword">if</span>(OpenMP_CXX_FOUND)</span><br><span class="line">    <span class="keyword">target_link_libraries</span>(MyTarget PUBLIC OpenMP::OpenMP_CXX)</span><br><span class="line"><span class="keyword">endif</span>()</span><br></pre></td></tr></table></figure><h4 id="3-2-MPI"><a href="#3-2-MPI" class="headerlink" title="3.2 MPI"></a>3.2 MPI</h4><p>To add MPI, like OpenMP, you’ll be best off with CMake 3.9+.</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(MPI REQUIRED)</span><br><span class="line"><span class="keyword">message</span>(STATUS <span class="string">&quot;Run: $&#123;MPIEXEC&#125; $&#123;MPIEXEC_NUMPROC_FLAG&#125; $&#123;MPIEXEC_MAX_NUMPROCS&#125; $&#123;MPIEXEC_PREFLAGS&#125; EXECUTABLE $&#123;MPIEXEC_POSTFLAGS&#125; ARGS&quot;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(MyTarget PUBLIC MPI::MPI_CXX)</span><br></pre></td></tr></table></figure><h4 id="3-3-添加pthread"><a href="#3-3-添加pthread" class="headerlink" title="3.3 添加pthread"></a>3.3 添加pthread</h4><p>ubuntu 下, 在CmakeList中添加pthread库</p><p>等同于shell中的 <code>g++ -o server main.cpp -lpthread -g</code></p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(Threads REQUIRED)</span><br><span class="line"><span class="keyword">add_executable</span>(main main.cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(main Threads::Threads)</span><br></pre></td></tr></table></figure><h3 id="四-参考链接"><a href="#四-参考链接" class="headerlink" title="四 参考链接"></a>四 参考链接</h3><ol><li><a href="https://modern-cmake-cn.github.io/Modern-CMake-zh_CN/">Modern CMake 简体中文版</a></li><li><a href="https://cliutils.gitlab.io/modern-cmake/">An Introduction to Modern CMake</a></li><li><a href="https://cmake.org/cmake/help/v3.15/manual/cmake-commands.7.html#id2">cmake-commands(7)</a></li><li><a href="https://www.cnblogs.com/lidabo/p/16661713.html">cmake cache变量_反复研究好几遍，我才发现关于 CMake 变量还可以这样理解！ </a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> cmake </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git学习以及配置</title>
      <link href="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="Git学习以及配置"><a href="#Git学习以及配置" class="headerlink" title="Git学习以及配置"></a>Git学习以及配置</h2><h3 id="一-Git学习"><a href="#一-Git学习" class="headerlink" title="一 Git学习"></a>一 Git学习</h3><p>可视化 git 学习网站 <a href="https://learngitbranching.js.org/?locale=zh_CN">Learn Git Branching</a></p><h4 id="1-1-git-checkout"><a href="#1-1-git-checkout" class="headerlink" title="1.1 git checkout"></a>1.1 git checkout</h4><p>用来切换分支,  表明当前所在的分支</p><p><em>在 Git2.23 版本中，引入了一个名为 <code>git switch</code> 的新命令，最终会取代 <code>git checkout</code>，因为 <code>checkout</code> 作为单个命令有点超载（它承载了很多独立的功能）</em></p><h4 id="1-2-git-merge"><a href="#1-2-git-merge" class="headerlink" title="1.2 git merge"></a>1.2 git merge</h4><p>将其他的分支合并到当前的分支,   比如将bugFix 合并到main</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">先切换到main分支</span></span><br><span class="line">git checkout main</span><br><span class="line">git merge bugFix</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105131530367.png" class="" title="image-20221105131530367"><h4 id="1-3-git-rebase"><a href="#1-3-git-rebase" class="headerlink" title="1.3 git rebase"></a>1.3 git rebase</h4><p>第二种合并分支的方法是 <code>git rebase</code>。Rebase 实际上就是取出一系列的提交记录，“复制”它们，然后在另外一个地方逐个的放下去。</p><p>Rebase 的优势就是可以创造更线性的提交历史，这听上去有些难以理解。如果只允许使用 Rebase 的话，代码库的提交历史将会变得异常清晰。</p><p><strong>使用命令 git rebase main 后 发生的变化:</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140803587.png" class="" title="image-20221105140803587"><p>现在 bugFix 分支上的工作在 main 的最顶端，同时我们也得到了一个更线性的提交序列。<strong>注意</strong>，提交记录 C3 依然存在（树上那个半透明的节点），而 C3’ 是我们 Rebase 到 main 分支上的 C3 的副本。</p><p>此时main还未更新, 使用下列操作更新main。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git checkout main</span><br><span class="line">git rebase bugFix</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105131320406.png" class="" title="image-20221105131320406"><p>由于 <code>bugFix</code> 继承自 <code>main</code>，所以 Git只是简单的把 <code>main</code> 分支的引用向前移动了一下而已。</p><h4 id="1-4-HEAD"><a href="#1-4-HEAD" class="headerlink" title="1.4 HEAD"></a>1.4 HEAD</h4><p>HEAD 是一个对当前检出记录的符号引用 —— 也就是指向你正在其基础上进行工作的提交记录。</p><p>HEAD 总是指向当前分支上最近一次提交记录。大多数修改提交树的 Git命令都是从改变 HEAD 的指向开始的。</p><p>HEAD 通常情况下是指向分支名的（如 bugFix）。在你提交时，改变了 bugFix 的状态，这一变化通过 HEAD 变得可见。</p><p><strong>分离的HEAD:</strong> 分离的 HEAD 就是让其指向了某个具体的提交记录而不是分支名。</p><p><strong>举例说明：</strong></p><p><strong>执行以下操作：</strong> 发生的变化</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git checkout c1</span><br><span class="line">git checkout main</span><br><span class="line">git commit</span><br><span class="line">git checkout c2 </span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140632320.png" class="" title="image-20221105140632320"><h4 id="1-5-撤销变更"><a href="#1-5-撤销变更" class="headerlink" title="1.5 撤销变更"></a>1.5 撤销变更</h4><p> Git里撤销变更的方法很多。和提交一样，撤销变更由底层部分（暂存区的独立文件或者片段）和上层部分（变更到底是通过哪种方式被撤销的）组成。我们这个应用主要关注的是后者。</p><p>主要有两种方法用来撤销变更 —— 一是 <code>git reset</code>，还有就是 <code>git revert</code>。</p><h5 id="1-5-1-git-reset"><a href="#1-5-1-git-reset" class="headerlink" title="1.5.1 git reset"></a>1.5.1 git reset</h5><p><code>git reset</code> 通过把分支记录回退几个提交记录来实现撤销改动。你可以将这想象成“改写历史”。<code>git reset</code> 向上移动分支，原来指向的提交记录就跟从来没有提交过一样。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105133031370.png" class="" title="image-20221105133031370"><p>原本的main 是指向c2的, 使用<code>git reset HEAD~1</code>后，main分支有迁回了c1，本地代码库就不知道c2的存在了。</p><h5 id="1-5-2-Git-Revert"><a href="#1-5-2-Git-Revert" class="headerlink" title="1.5.2 Git Revert"></a>1.5.2 Git Revert</h5><p>虽然在你的本地分支中使用 <code>git reset</code> 很方便，但是这种“改写历史”的方法对大家一起使用的远程分支是无效的哦！</p><p>为了撤销更改并<strong>分享</strong>给别人，我们需要使用 <code>git revert</code>。</p><p><strong>使用命令： git revert HEAD</strong> 进行撤销。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140357585.png" class="" title="image-20221105140357585"><p>在我们要撤销的提交记录后面居然多了一个新提交！这是因为新提交记录 <code>C2&#39;</code> 引入了<strong>更改</strong> —— 这些更改刚好是用来撤销 <code>C2</code> 这个提交的。也就是说 <code>C2&#39;</code> 的状态与 <code>C1</code>是相同的。</p><p>revert 之后就可以把你的更改推送到远程仓库与别人分享啦。</p><h4 id="1-6-远程分支"><a href="#1-6-远程分支" class="headerlink" title="1.6 远程分支"></a>1.6 远程分支</h4><p>远程分支反映了远程仓库(在你上次和它通信时)的<strong>状态</strong>。这会有助于你理解本地的工作与公共工作的差别 —— 这是你与别人分享工作成果前至关重要的一步.</p><p>远程分支有一个特别的属性，在你检出时自动进入分离 HEAD 状态。Git这么做是出于不能直接在这些分支上进行操作的原因, 你必须在别的地方完成你的工作, （更新了远程分支之后）再用远程分享你的工作成果。</p><p><strong>远程仓库（在图示中）的样子：</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140500408.png" class="" title="image-20221105140500408"><h4 id="1-7-git-fetch"><a href="#1-7-git-fetch" class="headerlink" title="1.7 git fetch"></a>1.7 git fetch</h4><p>Git远程仓库相当的操作实际可以归纳为两点：</p><p><strong>向远程仓库传输数据以及从远程仓库获取数据</strong>。既然我们能与远程仓库同步，那么就可以分享任何能被 Git管理的更新（因此可以分享代码、文件、想法、情书等等）。</p><p>执行 <strong>git fetch</strong> 的变化：</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105134417699.png" class="" title="image-20221105134417699"><p><code>git fetch</code> 并不会改变你本地仓库的状态。它不会更新你的 <code>main</code> 分支，也不会修改你磁盘上的文件。</p><h4 id="1-8-git-pull"><a href="#1-8-git-pull" class="headerlink" title="1.8 git pull"></a>1.8 git pull</h4><p>然我们已经知道了如何用 <code>git fetch</code> 获取远程的数据, 现在我们学习如何将这些变化更新到我们的工作当中。</p><p>其实有很多方法的 —— 当远程分支中有新的提交时，你可以像合并本地分支那样来合并远程分支。也就是说就是你可以执行以下命令:</p><ul><li><code>git cherry-pick o/main</code></li><li><code>git rebase o/main</code></li><li><code>git merge o/main</code></li><li>等等</li></ul><p>实际上，由于先抓取更新再合并到本地分支这个流程很常用，因此 Git提供了一个专门的命令来完成这两个操作。它就是我们要讲的 <code>git pull</code>。</p><ol><li><p>使用命令 <code>git fetch; git merge o/main</code></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105135236346.png" class="" title="image-20221105135236346"><p>我们用 <code>fetch</code> 下载了 <code>C3</code>, 然后通过 <code>git merge o/main</code> 合并了这一提交记录。现在我们的 <code>main</code> 分支包含了远程仓库中的更新（在本例中远程仓库名为 <code>origin</code>）</p></li><li><p>使用 <code>git pull</code> 可以达到同样的效果</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105135555684.png" class="" title="image-20221105135555684"></li></ol><h4 id="1-9-git-push"><a href="#1-9-git-push" class="headerlink" title="1.9 git push"></a>1.9 git push</h4><p><code>git push</code> 负责将<strong>你的</strong>变更上传到指定的远程仓库，并在远程仓库上合并你的新提交记录。一旦 <code>git push</code> 完成, 你的朋友们就可以从这个远程仓库下载你分享的成果了！</p><p>*注意 —— <code>git push</code> 不带任何参数时的行为与 Git的一个名为 <code>push.default</code> 的配置有关。它的默认值取决于你正使用的 Git的版本，但是在教程中我们使用的是 <code>upstream</code>*。</p><p><strong>使用 git push 后的变化：</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105140045762.png" class="" title="image-20221105140045762"><p>远程仓库接收了 <code>C2</code>，远程仓库中的 <code>main</code> 分支也被更新到指向 <code>C2</code> 了，我们的远程分支 (o/main) 也同样被更新了。所有的分支都同步了！</p><h3 id="二-ssh-key-配置"><a href="#二-ssh-key-配置" class="headerlink" title="二 ssh-key 配置"></a>二 ssh-key 配置</h3><hr><h4 id="2-1-github-使用-token"><a href="#2-1-github-使用-token" class="headerlink" title="2.1 github 使用 token"></a>2.1 github 使用 token</h4><p>为了安全起见，github不再支持密码登录，改为了token，token就相当于一个比较安全的密码，获取到的token是全局的，可以对所有仓库进行操作</p><ol><li><p>获取token，在个人设置下，Developer settings中，新增token</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105112248257.png" class="" title="image-20221105112248257"></li><li><p>拿到token后，有两种使用方式</p><ul><li><p>使用git的时候，每次输入账号密码，这里的密码就是token，但是每次使用都要输入，比较麻烦</p></li><li><p>在git中的远程分支添加token</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 删除原来的分支</span></span><br><span class="line">git remote rm origin</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加由token构成的新分支</span></span><br><span class="line">git remote add origin https://token(这里改为自己的token)/okeyia/gem5_vans.git</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105112958726.png" class="" title="image-20221105112958726"></li><li><p>然后就可以愉快的 <code>git push origin master</code>了</p></li></ul></li></ol><h4 id="2-2-github-添加私钥"><a href="#2-2-github-添加私钥" class="headerlink" title="2.2 github 添加私钥"></a>2.2 github 添加私钥</h4><p>这里的话配置的是 <strong>某个仓库</strong> 的私钥，只允许对某个仓库进行操作。第 <strong>2.1</strong> 章节 配置的全局的私钥，可以对账号下面的所有仓库进行操作。</p><p>建议新建一个demo的仓库，在demo中进行配置</p><ol><li><p>在终端中生成一个 github 的 <code>ssh-key</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C &#x27;xxxxx@qq.com&#x27; -f ~/.ssh/github_id_rsa</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>将私钥对应的公钥,也就是 <strong>github_id_rsa.pub</strong> 的内容copy到github中某个仓库</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221105105215110.png" class="" title="image-20221105105215110"></li><li><p>按照<strong>第2.3章节</strong>，配置 config 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> vim ~/.ssh/config</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">内容如下</span></span><br><span class="line">Host github.com</span><br><span class="line">   HostName github.com</span><br><span class="line">   IdentityFile ~/.ssh/github_id_rsa</span><br><span class="line">   </span><br><span class="line"><span class="meta">$</span><span class="bash"> chmod 600 ~/.ssh/config</span></span><br></pre></td></tr></table></figure></li></ol><ol start="4"><li><p>配置完成后, 测试一下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh -T git@github.com</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 出现一下内容, 则说明配置成功</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">Hi 用户名/仓库名! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span>  </span><br></pre></td></tr></table></figure></li></ol><h4 id="2-3-为主机指定私钥"><a href="#2-3-为主机指定私钥" class="headerlink" title="2.3 为主机指定私钥"></a>2.3 为主机指定私钥</h4><p>主机上可能存在多个私钥, 但是连接的时候默认使用的是<code>id_rsa</code>,  如果不匹配的话, 则连接失败。有三种方法实现为主机指定密钥：</p><ul><li><p>ssh -i xxxx 用户@ip地址，（这里xxx是指密钥文件），这样的话每次都要输入密钥文件，比较麻烦</p></li><li><p>将密钥交给 <strong>ssh-agent</strong> 进行管理，但是ssh-agent在系统中并没有开启自启，每次都需要手动开启，不推荐</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ssh-agent bash   <span class="comment">#启动 ssh-agent</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add Identity_Linux  <span class="comment"># 为 ssh-agent 添加私钥。这里的 Identity_Linux 是我的私钥文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ssh-add -l   <span class="comment">#查看已添加的私钥</span></span></span><br></pre></td></tr></table></figure></li><li><p>配置 <strong>config</strong> 文件，一劳永逸，强烈推荐</p></li></ul><p>SSH的配置文件有两个:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ~/.ssh/config            <span class="comment"># 用户配置文件</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> /etc/ssh/ssh_config      <span class="comment"># 系统配置文件</span></span> </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 个人建议只配置用户配置文件</span></span><br><span class="line">chmod 600 ~/.ssh/config</span><br></pre></td></tr></table></figure><p>常用的配置参数:</p><ul><li><p><strong>Host</strong></p><p>用于我们执行 SSH 命令的时候如何匹配到该配置。</p><ul><li><code>*</code>，匹配所有主机名。</li><li><code>*.example.com</code>，匹配以 .example.com 结尾。</li><li><code>!*.dialup.example.com,*.example.com</code>，以 ! 开头是排除的意思。</li><li><code>192.168.0.?</code>，匹配 192.168.0.[0-9] 的 IP。</li></ul></li><li><p><strong>HostName</strong></p><p>真实的主机名，默认值为命令行输入的值（允许 IP）</p></li><li><p><strong>Port</strong></p><p>默认端口为22, 使用其他端口的话加上 <code>-p xxx</code></p></li><li><p><strong>User</strong></p><p>登录的用户名</p></li><li><p><strong>IdentityFile</strong></p><p>指定连接的私钥</p></li></ul><p><strong>本地配置实例如下:</strong></p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104210515209.png" class="" title="image-20221104210515209"><h3 id="三-gitignore-文件"><a href="#三-gitignore-文件" class="headerlink" title="三 .gitignore 文件"></a>三 .gitignore 文件</h3><p>本地仓库的文件目录结构如下:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">.</span><br><span class="line">├── a.cpp</span><br><span class="line">├── afs</span><br><span class="line">│   └── bfs</span><br><span class="line">├── b.c</span><br><span class="line">├── b.cpp</span><br><span class="line">├── bfs</span><br><span class="line">│   ├── a.cpp</span><br><span class="line">│   └── b.c</span><br><span class="line">├── b.o</span><br><span class="line">└── cfs</span><br><span class="line">    └── fs</span><br><span class="line">        └── bfs</span><br><span class="line">            └── test.txt</span><br></pre></td></tr></table></figure><h4 id="3-1-忽略文件"><a href="#3-1-忽略文件" class="headerlink" title="3.1 忽略文件"></a>3.1 忽略文件</h4><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># this is .gitignore file.</span><br><span class="line"># 以下是忽略的文件</span><br><span class="line">bfs</span><br></pre></td></tr></table></figure><p>只写bfs的话, 忽略同名的文件夹以及文件。</p><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213043599.png" class="" title="image-20221104213043599"><h4 id="3-2-忽略文件而不忽略目录"><a href="#3-2-忽略文件而不忽略目录" class="headerlink" title="3.2 忽略文件而不忽略目录"></a>3.2 忽略文件而不忽略目录</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">bfs</span><br><span class="line">!bfs/</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213424804.png" class="" title="image-20221104213424804"><h4 id="3-3-忽略目录而不忽略文件"><a href="#3-3-忽略目录而不忽略文件" class="headerlink" title="3.3 忽略目录而不忽略文件"></a>3.3 忽略目录而不忽略文件</h4><hr><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">bfs/</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104213251537.png" class="" title="image-20221104213251537"><h4 id="3-4-通配符"><a href="#3-4-通配符" class="headerlink" title="3.4 通配符"></a>3.4 通配符</h4><hr><p>常用的通配符有：</p><p>（1）星号“*” ：匹配多个字符；</p><p>（2）问号“?”：匹配除 ‘/’外的任意一个字符；</p><p>（3）方括号“[xxxx]”：匹配多个列表中的字符；</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> this is .gitignore file.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 以下是忽略的文件</span></span><br><span class="line">*.[co]</span><br></pre></td></tr></table></figure><img src="/2022/11/05/Git%E5%AD%A6%E4%B9%A0%E5%8F%8A%E9%85%8D%E7%BD%AE/image-20221104214535749.png" class="" title="image-20221104214535749"><h4 id="3-5-其他规则"><a href="#3-5-其他规则" class="headerlink" title="3.5 其他规则"></a>3.5 其他规则</h4><ol><li>空行不匹配任何文件；</li><li>git 跟踪文件，而不是目录；</li><li>在 .gitignore 文件中，每行表示一种模式；</li><li>如果本地仓库文件已被跟踪，那么即使在 .gitignore 中设置了忽略，也不起作用。这个时候使用 <code>git rm -rf --cached .</code> 先将git cache中的内容全部删除, 然后再重新添加。</li><li>.gitignore 文件也会被上传的到远程仓库，所以，同一个仓库的人可以使用同一个.gitignore 文件。</li></ol><h3 id="四-参考链接"><a href="#四-参考链接" class="headerlink" title="四 参考链接"></a>四 参考链接</h3><ol><li><a href="https://linux.die.net/man/5/ssh_config">ssh_config(5) - Linux man page</a></li><li><a href="https://blog.csdn.net/senlin1202/article/details/122081089">SSH Config 使用</a></li><li><a href="https://gitee.com/help/articles/4229#article-header0">Gitee git 配置多个SSH-KEY</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工欲善其事, 必先利其器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git配置 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>求职算法总结</title>
      <link href="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<hr><p>还没有总结完!   待续……..</p><hr><h2 id="求职算法总结"><a href="#求职算法总结" class="headerlink" title="求职算法总结"></a>求职算法总结</h2><p>为什么选择c++ 作为主攻语言?   C/C++ 能让我见识到整个计算机体系结构是如何被搭建起来的、程序是如何跑起来的、程序是如何被编译链接在一起的、函数的底层构造是怎样的。</p><h3 id="〇-递归中的时间复杂度"><a href="#〇-递归中的时间复杂度" class="headerlink" title="〇 递归中的时间复杂度"></a>〇 递归中的时间复杂度</h3><p>递归算法的时间复杂度表达式：O(T) = R * O(s)。</p><p>O(T) 表示时间复杂度， R表示递归调用的次数， O(s)每次递归调用计算的时间复杂度。</p><blockquote><p> 斐波那契函数,  它的递归关系是f(n) = f(n-1) + f(n-2),  这里将 n = 5 作为输入,  </p><p>递归过程 抽象成一棵递归树,  在这棵二叉树中每一个节点都是一次递归，那么这棵树有多少个节点呢？  </p><p>一棵深度（按根节点深度为1）为k的二叉树最多可以有 2^k - 1 个节点, 所以该递归算法的时间复杂度为O(2^n)。</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220921_195136.png" class="" title="Clip_20220921_195136"></blockquote><h3 id="一-二分法"><a href="#一-二分法" class="headerlink" title="一 二分法"></a>一 二分法</h3><hr><h4 id="1-1-找下界"><a href="#1-1-找下界" class="headerlink" title="1.1 找下界"></a>1.1 找下界</h4><p><strong>问题定义：</strong>给定一个升序数组，我们将满足  <code>x ≥ target</code> 的第一个元素定义为 <strong>下界</strong> 。</p><p><code>C++ STL</code>中的 <code>lower_bound()</code> 函数就实现了这个功能。</p><h5 id="思路描述"><a href="#思路描述" class="headerlink" title="思路描述"></a>思路描述</h5><p>对于数组 <code>[1,2,3,5,5,5,6,7,9]</code>，令 <code>target=5</code>，则满足 <code>x ≥ target</code> 的下界的下标应该是 <code>3</code>。</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_141823.jpg" class="" title="Clip_20220919_141823"><p>可以看到，从这个位置将数组分为左右两部分，**左侧的元素都「小于」<code>target</code>，右侧的元素都「大于等于」<code>target</code>**。</p><p><strong>定义变量 ：</strong></p><ul><li>区间范围为 <code>[left,right]</code>，<code>left</code>、<code>right</code> 是区间的左右边界的下标</li><li><code>mid</code> 是 <code>[left,right]</code> 的中间位置</li><li>初始时，<code>left</code>、<code>right</code> 分别指向数组的第一个和最后一个元素</li><li><strong>当 <code>left &gt; right</code> 时，表示区间为空</strong></li></ul><p>如果我们在二分查找的过程中，<strong>不断右移 <code>left</code>，左移 <code>right</code>，使得所有「小于」<code>target</code> 的元素都在 <code>left</code> 左侧，所有「大于等于」<code>target</code> 的元素都在 <code>right</code> 右侧，那么当区间为空时，<code>left</code> 就是要查找的下界</strong></p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_142137.jpg" class="" title="Clip_20220919_142137"><h5 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h5><p>根据上述思路，<strong>算法步骤</strong>如下：</p><ul><li>若 <code>nums[mid] &gt;= target</code>，说明 <code>[mid,right]</code> 区间的所有元素均「大于等于」<code>target</code>，因此 <code>right</code> 左移，有 <code>right = mid-1</code></li><li>否则，说明 <code>[left,mid]</code> 区间的所有元素均「小于」<code>target</code>，因此 <code>left</code> 右移，有 <code>left = mid+1</code></li><li>重复上述步骤，直到区间为空，表示找到了下界，**返回 <code>left</code>**。因此循环条件为 <code>left &lt;= right</code>，表示“区间不为空”</li><li>注意，上述两个赋值语句均跳过了中间元素 <code>mid</code></li></ul><p>上述的查找过程如下： </p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_142436.jpg" class="" title="Clip_20220919_142436"><h5 id="模板代码"><a href="#模板代码" class="headerlink" title="模板代码"></a>模板代码</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 查找满足 x ≥ target 的下界的下标</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> search（<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">        <span class="keyword">int</span> middle = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[middle] &gt;= target)&#123;  <span class="comment">// 这里的比较运算符与题目要求一致</span></span><br><span class="line">            right = middle - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;   <span class="comment">// 返回下界的下标</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码中，**<code>if</code> 的判定条件和给定的比较规则是一致的<strong>：要找满足 <code>x &gt;= target</code> 的第一个元素，所以是 <code>if nums[m] &gt;= target</code>。如果要找满足 <code>x &gt; target</code> 的第一个元素，那么只需改为 <code>if nums[m] &gt; target</code>。</strong><code>if</code> 为真时更新 <code>right</code>**。</p><p>最后注意一些细节：</p><ul><li><code>left</code>、<code>right</code> 的初值为 <code>0</code>、<code>n-1</code>，表示「闭区间」</li><li>循环的判定条件是 <code>left &lt;= right</code>，表示区间不为空</li><li>更新 <code>left</code> 和 <code>right</code> 时均跳过了中间元素 <code>mid</code></li></ul><h4 id="1-2-找上界"><a href="#1-2-找上界" class="headerlink" title="1.2 找上界"></a>1.2 找上界</h4><p>定义：满足 <code>x &lt; target</code> 的<strong>最后一个元素</strong>为「上界」。</p><p>给定一个 <code>target</code>，要求返回升序数组中上界的下标。比如：对于数组 <code>[0,1,2,3,4]</code>，当 <code>target=3</code> 时，返回下标 <code>2</code>；当 <code>target=5</code> 时，返回下标 <code>4</code>。</p><p>根据上界和下界的定义，我们可以发现：<strong>上界和「互补的」下界是相邻的，并且 <code>上界 = 下界 - 1</code>**。比如 <code>x ≤ target</code> 的上界和 <code>x &gt; target</code> 的下界相邻。因此，</strong>所有找上界的问题，都可以转换为「互补的」找下界的问题。**</p><p>对于 <code>x &lt; target</code> 而言，要找上界，套用上文的模板，实现 <code>x &gt;= target</code> 的下界, 参考 <a href="#%E6%A8%A1%E6%9D%BF%E4%BB%A3%E7%A0%81">模板代码</a>。</p><p>然后再将下界 减一, 就是我们要找的上界。</p><h4 id="1-3-参考例题"><a href="#1-3-参考例题" class="headerlink" title="1.3 参考例题"></a>1.3 参考例题</h4><p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/">34. 在排序数组中查找元素的第一个和最后一个位置</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchFirst</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="comment">// 寻找下界, 第一个 x &gt;= target的位置</span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt;= target) right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(left &gt;= nums.size() || nums[left] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">searchLast</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 寻找 x == taget 最后一次出现的位置, 只需查找 x &lt;= target的上界 </span></span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">int</span> middle = left + (right - left) /<span class="number">2</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(nums[middle] &gt; target) right = middle <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = middle + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断一下是否越界，或者不相等</span></span><br><span class="line">        <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">searchRange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()) <span class="keyword">return</span> &#123;<span class="number">-1</span>,<span class="number">-1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> &#123;searchFirst(nums,target),searchLast(nums,target)&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="1-4-二分参考链接"><a href="#1-4-二分参考链接" class="headerlink" title="1.4 二分参考链接"></a>1.4 二分参考链接</h4><ol><li></li></ol><h3 id="二-回溯"><a href="#二-回溯" class="headerlink" title="二 回溯"></a>二 回溯</h3><p>回溯法解决的问题</p><ul><li>组合问题：N个数里面按一定规则找出k个数的集合</li><li>切割问题：一个字符串按一定规则有几种切割方式</li><li>子集问题：一个N个数的集合里有多少符合条件的子集</li><li>排列问题：N个数按一定规则全排列，有几种排列方式</li><li>棋盘问题：N皇后，解数独等等</li></ul><p>回溯解决的问题都可以抽象为树形结构，因为回溯解决的都是在集合中查找子集，集合的大小构成了树的宽度，递归的深度。</p><h4 id="2-1-回溯算法模板"><a href="#2-1-回溯算法模板" class="headerlink" title="2.1 回溯算法模板"></a>2.1 回溯算法模板</h4><ol><li>回溯函数模板返回值以及参数</li><li>回归函数终止条件</li><li>回溯搜索的遍历过程</li></ol><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20220919_200402.png" class="" title="Clip_20220919_200402"><p>综上，回溯算法模板如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(参数)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (终止条件) &#123;</span><br><span class="line">        存放结果;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) &#123;</span><br><span class="line">        处理节点;</span><br><span class="line">        backtracking(路径，选择列表); <span class="comment">// 递归</span></span><br><span class="line">        回溯，撤销处理结果</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-2-startIndex-开始位置"><a href="#2-2-startIndex-开始位置" class="headerlink" title="2.2 startIndex 开始位置"></a>2.2 <code>startIndex</code> 开始位置</h4><p>如果是一个集合来求组合的话，就需要<code>startIndex</code>, 例如：<a href="https://programmercarl.com/0077.%E7%BB%84%E5%90%88.html">回溯算法：求组合问题！</a></p><p>如果是多个集合取组合，各个集合之间相互不影响，那么就不用<code>startIndex</code>, 如 <a href="https://programmercarl.com/0017.%E7%94%B5%E8%AF%9D%E5%8F%B7%E7%A0%81%E7%9A%84%E5%AD%97%E6%AF%8D%E7%BB%84%E5%90%88.html">回溯算法：电话号码的字母组合</a></p><h4 id="2-3-去重"><a href="#2-3-去重" class="headerlink" title="2.3 去重"></a>2.3 去重</h4><p>分为:  <strong>“树层去重”和“树枝去重”</strong></p><h3 id="三-哈希表"><a href="#三-哈希表" class="headerlink" title="三 哈希表"></a>三 哈希表</h3><h4 id="3-1-set-集合"><a href="#3-1-set-集合" class="headerlink" title="3.1 set(集合)"></a>3.1 set(集合)</h4><p>在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表所示：</p><table><thead><tr><th>集合</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::set</td><td>红黑树</td><td>有序</td><td>否</td><td>否</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::multiset</td><td>红黑树</td><td>有序</td><td>是</td><td>否</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::unordered_set</td><td>哈希表</td><td>无序</td><td>否</td><td>否</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_set底层实现为哈希表，std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。</p><h4 id="3-2-map-映射"><a href="#3-2-map-映射" class="headerlink" title="3.2 map(映射)"></a>3.2 map(映射)</h4><table><thead><tr><th>映射</th><th>底层实现</th><th>是否有序</th><th>数值是否可以重复</th><th>能否更改数值</th><th>查询效率</th><th>增删效率</th></tr></thead><tbody><tr><td>std::map</td><td>红黑树</td><td>key有序</td><td>key不可重复</td><td>key不可修改</td><td>O(logn)</td><td>O(logn)</td></tr><tr><td>std::multimap</td><td>红黑树</td><td>key有序</td><td>key可重复</td><td>key不可修改</td><td>O(log n)</td><td>O(log n)</td></tr><tr><td>std::unordered_map</td><td>哈希表</td><td>key无序</td><td>key不可重复</td><td>key不可修改</td><td>O(1)</td><td>O(1)</td></tr></tbody></table><p>std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。</p><h3 id="四-动态规划"><a href="#四-动态规划" class="headerlink" title="四 动态规划"></a>四 动态规划</h3><p>模板:</p><ol><li>确定<code>dp</code> 数组 (<code>dp table</code>) 以及下表的含义</li><li>确定递推公式</li><li><code>dp</code> 数组初始化</li><li>确定遍历顺序</li><li>举例推导 数组</li></ol><p><strong>分类解题模板</strong><br>背包问题大体的解题模板是两层循环，分别遍历物品<code>nums</code>和背包容量target，然后写转移方程，<br>根据背包的分类我们确定物品和容量遍历的先后顺序，根据问题的分类我们确定状态转移方程的写法</p><p><strong>首先是背包分类的模板：</strong><br>1、0/1背包：外循环 <code>nums</code> ,内循环 target, target 倒序且 <code>target&gt;=nums[i]</code> ;<br>2、完全背包：外循环 <code>nums</code> ,内循环 target, target 正序且<code>target&gt;=nums[i]</code>;<br>3、组合背包(考虑顺序)：外循环target,内循环 <code>nums</code>, target正序且 <code>target&gt;=nums[i]</code>;<br>4、分组背包：这个比较特殊，需要三重循环：外循环背包bags,内部两层循环根据题目的要求转化为1,2,3三种背包类型的模板</p><p><strong>然后是问题分类的模板：</strong><br>1、最值问题: <code>dp[i] = max/min(dp[i], dp[i-nums]+1)</code>或<code>dp[i] = max/min(dp[i], dp[i-num]+nums)</code>;<br>2、存在问题**<code>(bool)</code>**：<code>dp[i]=dp[i]||dp[i-num]</code>;<br>3、组合问题：<code>dp[i]+=dp[i-num]</code>;</p><p>这样遇到问题将两个模板往上一套大部分问题就可以迎刃而解</p><h4 id="4-1-01-背包问题"><a href="#4-1-01-背包问题" class="headerlink" title="4.1 01 背包问题"></a>4.1 01 背包问题</h4><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20221001190410813.png" class="" title="image-20221001190410813"><p><code>dp[i][j]</code> : <strong>表示从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少</strong>。</p><p>对于<code>物品i</code>来说,  有两种状态,  <strong>放入</strong> 或者 <strong>不放</strong>:</p><ol><li>不放的话, <code>dp[i][j]就是dp[i - 1][j]</code></li><li>放入的话, 由<code>dp[i - 1][j - weight[i]]</code>推出</li></ol><p>所以递推公式为:  <code> dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code> </p><p>初始化数组:</p><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/Clip_20221001_191233.png" class="" title="Clip_20221001_191233"><p>遍历代码:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight数组的大小 就是物品个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= bagweight; j++) &#123; <span class="comment">// 遍历背包容量</span></span><br><span class="line">            <span class="keyword">if</span> (j &lt; weight[i]) dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            <span class="keyword">else</span> dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - weight[i]] + value[i]);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="4-2-滚动数组"><a href="#4-2-滚动数组" class="headerlink" title="4.2 滚动数组"></a>4.2 滚动数组</h4><blockquote><p>在使用二维数组的时候，递推公式：<code>dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);</code></p><p>每一行的 <code>dp[i][∗]</code> 状态值都只与上一行的 <code>dp[i-1][*]</code>状态值有关，因此可基于滚动数组的思想进行对状态空间 <code>dp</code> 进行优化而省去第一维度</p><p><strong>其实可以发现如果把<code>dp[i - 1]</code>那一层拷贝到<code>dp[i]</code>上，表达式完全可以是：<code>dp[i][j] = max(dp[i][j], dp[i][j - weight[i]] + value[i]);</code></strong></p></blockquote><p>滚动数组:  需要满足的条件是上一层可以重复利用，直接拷贝到当前层。</p><p>在一维<code>dp</code>数组中，<code>dp[j]</code>表示：容量为j的背包，所背的物品价值可以最大为<code>dp[j]</code>。</p><p><code>dp[j]</code>可以通过<code>dp[j - weight[i]]</code>推导出来，<code>dp[j - weight[i]]</code>表示容量为<code>j - weight[i]</code>的背包所背的最大价值。</p><p>所以递推公式为:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br></pre></td></tr></table></figure><p>代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weight.size(); i++) &#123; <span class="comment">// 遍历物品</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = bagWeight; j &gt;= weight[i]; j--) &#123; <span class="comment">// 遍历背包容量, 从大到小</span></span><br><span class="line">        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>遍历背包是倒序的</strong>,  仔细想一想为为什么要倒叙 ?</p><blockquote><p>考虑到我我们在更新 <code>dp[j]</code>时，使用的其实是上一行的 <code>dp</code>值；而如果第二层循环从小到大计算的话，那么 <code>dp[j−nums[i-1]]</code> 先于 <code>dp[j]</code> 被更新，因此当我们计算 <code>dp[j]</code>值的时候，<code>dp[j−nums[i-1]]</code>已经是被更新过的状态，而不再是上一行的 <code>dp</code> 值了。</p><p>而在第二层循环中，通过从大到小计算则可巧妙地保证在计算 <code>dp[j]</code> 时所用到的 <code>dp[j]</code>]和 <code>dp[j-nums[i-1]]</code>均来自上一行。</p></blockquote><h4 id="4-3-完全背包"><a href="#4-3-完全背包" class="headerlink" title="4.3 完全背包"></a>4.3 完全背包</h4><h4 id="4-4-典型例题"><a href="#4-4-典型例题" class="headerlink" title="4.4 典型例题"></a>4.4 典型例题</h4><p> <a href="https://leetcode.cn/problems/unique-binary-search-trees/">96. 不同的二叉搜索树</a>    <a href="https://leetcode.cn/problems/unique-binary-search-trees/solution/bu-tong-de-er-cha-sou-suo-shu-by-leetcode-solution/">题解</a></p><p>怎么将数学思维和代码结合起来</p><blockquote><p> 题目要求是计算不同二叉搜索树的个数。定义两个函数：</p><p>G(n): 长度为 n 的序列能构成的不同二叉搜索树的个数。</p><p>F(i, n) 以 ii为根、序列长度为 n 的不同二叉搜索树个数 (1≤i≤n)</p><p>G(n) 可以从 F(i, n) 得到，而 F(i, n) 又会递归地依赖于 G(n)。</p></blockquote><img src="/2022/10/24/%E6%B1%82%E8%81%8C%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/image-20220930214755016.png" class="" title="image-20220930214755016"><h4 id="4-5-参考链接"><a href="#4-5-参考链接" class="headerlink" title="4.5 参考链接"></a>4.5 参考链接</h4><ol><li><a href="https://leetcode.cn/problems/coin-change/solution/yi-pian-wen-zhang-chi-tou-bei-bao-wen-ti-sq9n/">一篇文章吃透背包问题！（细致引入+解题模板+例题分析+代码呈现）</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++常用刷题技巧</title>
      <link href="/2022/09/17/C_C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
      <url>/2022/09/17/C_C++%E5%88%B7%E9%A2%98%E5%B8%B8%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="C-C-常用刷题技巧"><a href="#C-C-常用刷题技巧" class="headerlink" title="C/C++常用刷题技巧"></a>C/C++常用刷题技巧</h2><p><strong>万能头文件</strong></p><blockquote><p>万能头文件</p><p>基本包括了大部分的STL库函数，使用方便快捷</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="一-vector"><a href="#一-vector" class="headerlink" title="一  vector"></a>一  vector</h3><h4 id="1-1-一维vector初始化"><a href="#1-1-一维vector初始化" class="headerlink" title="1.1  一维vector初始化"></a>1.1  一维vector初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; first; <span class="comment">// 空的vector，只是一个列表的头，里面没有元素</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">second</span> <span class="params">(<span class="number">4</span>, <span class="number">100</span>)</span></span>; <span class="comment">// 初始化一个具有4个元素的vector，每个元素的值都是100</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">third</span> <span class="params">(second.begin(), second.end())</span></span>; <span class="comment">// 通过其他vector的迭代器的方式，进行拷贝复制初始化</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fourth</span> <span class="params">(third)</span></span>; <span class="comment">// 直接对其他vector的拷贝复制</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> myints[] = &#123;<span class="number">16</span>, <span class="number">2</span>, <span class="number">77</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fifth</span> <span class="params">(myints, myints+<span class="keyword">sizeof</span>(myints) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>))</span></span>; <span class="comment">// 将数组转化成vector，需要提供的是数组的首地址和地址偏移。</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sixth = &#123;<span class="number">1</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">6</span>&#125;; <span class="comment">// 指定内容进行构造，内容为1,5,4,6的vector</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; vars;</span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test;<span class="comment">//建立一个vector</span></span><br><span class="line"></span><br><span class="line">test.push_back(<span class="number">1</span>);</span><br><span class="line">test.push_back(<span class="number">2</span>);<span class="comment">//把1和2压入vector，这样test[0]就是1,test[1]就是2</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//使用下标访问元素</span></span><br><span class="line"><span class="comment">//使用迭代器访问元素.</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;</span><br><span class="line"><span class="keyword">for</span>(it=vec.begin();it!=vec.end();it++)&#123;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;*it&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">vec.insert(vec.begin()+i,a);<span class="comment">//在第i+1个元素前面插入a;</span></span><br><span class="line">vec.erase(vec.begin()+<span class="number">2</span>);<span class="comment">//删除第3个元素</span></span><br><span class="line">vec.erase(vec.begin()+i,vec.end()+j);<span class="comment">//删除区间[i,j-1];区间从0开始</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;vec.size()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//向量大小</span></span><br><span class="line">vec.clear();<span class="comment">//清空</span></span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">sort(v.begin(),v.end());              <span class="comment">//用sort()函数从小到大进行排序</span></span><br><span class="line">reverse(v.begin(),v.end());          <span class="comment">// 用reverse()函数翻转数组</span></span><br><span class="line">v.size()                             <span class="comment">// 返回容器的大小</span></span><br><span class="line">v.empty()                             <span class="comment">//判断容器是否为空，为空返回0，不为空则为1</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v[<span class="number">0</span>];                          <span class="comment">// 打印第一个元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;v[v.size()]                     <span class="comment">//打印最后一个元素</span></span><br><span class="line">lower_bound(v.begin(),v.end(),a)      <span class="comment">//在有序数组中返回第一个大于等于a的元素的下标,返回值的是地址</span></span><br><span class="line">upper_bound(v.begin(),v.end(),a)-v.begin()  <span class="comment">//在有序数组中返回第一个大于a的元素的下标,这里通过减去首地址，得到了下标位置</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it;  <span class="comment">//定义迭代器方便得到元素值，相当于指针</span></span><br><span class="line">it=upper_bound(v.begin,v.end(),a)    </span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;(*it)                          <span class="comment">//这里返回的是第一个大于a的元素的值</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="1-2-二维数组初始化"><a href="#1-2-二维数组初始化" class="headerlink" title="1.2 二维数组初始化"></a>1.2 二维数组初始化</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二维vector的初始化</span></span><br><span class="line"><span class="keyword">int</span> size = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vars(size, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(size, <span class="number">0</span>)); <span class="comment">// （size,size）的矩阵，元素全部是0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; a(<span class="number">3</span>);<span class="comment">//初始化的是3*3的矩阵,注意我们所申请的矩阵行数和列数默认相等的</span></span><br><span class="line"><span class="comment">//如果我们需要行数和列数不相等的二维数组，那么我们可以对每一行所包含的元素个数加以限制；</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)<span class="comment">//利用resize函数将每一行的元素个数设置为5个，即5列 </span></span><br><span class="line">a[i].resize(<span class="number">5</span>);<span class="comment">//此时我们得到的就是一个3行5列的二维数组</span></span><br></pre></td></tr></table></figure><p>如果我们采用size函数来得到数组规模，那么我们所得到的结果是矩阵的行数，如果需要得到列数可以使用<code>a[0].size()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt; &gt; a(<span class="number">3</span>);<span class="comment">//初始化的是3*3的矩阵 </span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;a.size();i++)<span class="comment">//利用resize函数将每一行的元素个数设置为5个，即5列 </span></span><br><span class="line">a[i].resize(<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;a.size()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//打印的是vector的行数</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>除上述初始化行列数不同的二维数组之外，我们也可以直接定义</strong>，结果也是3行5列的二维数组</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; Array(<span class="number">3</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">5</span>));</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;Array[<span class="number">0</span>].size()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以下也可以</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;num =</span><br><span class="line">&#123; &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;, </span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span> &#125;,</span><br><span class="line">     &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br></pre></td></tr></table></figure><h3 id="二-字符串部分"><a href="#二-字符串部分" class="headerlink" title="二 字符串部分"></a>二 字符串部分</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="built_in">string</span> t=<span class="string">&quot;m&quot;</span>;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s;<span class="comment">//不包括空格</span></span><br><span class="line">getline(<span class="built_in">cin</span>,s);<span class="comment">//读取一行，可以包含空格</span></span><br><span class="line">s.append(t);<span class="comment">//将字符t添加到s  </span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s+t;  <span class="comment">//同上述效果一样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//find(“字符串”) / find(&quot;字符串&quot;,postion)   ---找不到就返回很大很大的数,可以与-1比较</span></span><br><span class="line"><span class="keyword">if</span>(s1.find(s2)==<span class="number">-1</span>)&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;在s1中未找到s2&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.find(t)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//找子序列t在s中出现的首次位置</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s.find(t,<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//从第二个位置开始找，找子序列t在s中出现的首次位置</span></span><br><span class="line"><span class="keyword">int</span> len = s.size();<span class="comment">//字符串s的⻓度</span></span><br><span class="line"><span class="keyword">int</span> len = s.length();<span class="comment">//字符串s的⻓度</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*s1.begin()&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指向字符串的第一个元素</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*(s1.end()<span class="number">-1</span>)&lt;&lt;<span class="built_in">endl</span>;<span class="comment">//指向字符串的最后一个元素</span></span><br><span class="line"></span><br><span class="line">reverse(s.begin(), s.end());<span class="comment">//字符串反转</span></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> sTemp=s1.substr(<span class="number">1</span>);<span class="comment">//下标1开始到结束</span></span><br><span class="line"><span class="comment">//截取substr（pos,num） ----在哪个位置截取，截取多少字符</span></span><br><span class="line"><span class="built_in">string</span> sTemp2 = s1.substr(<span class="number">1</span>,<span class="number">3</span>);<span class="comment">//下标1开始，截取3个字符</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;sTemp&lt;&lt;<span class="string">&quot;----&quot;</span>&lt;&lt;sTemp2&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1[<span class="number">0</span>]&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//访问字符串的0处的位置</span></span><br><span class="line"><span class="built_in">string</span> s1,s2;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;s1&gt;&gt;s2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个字符串之间的大小关系</span></span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1==s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1&gt;s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;(s1&lt;s2)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//插入insert(position,&quot;字符串&quot;)</span></span><br><span class="line">s1.insert(<span class="number">1</span>,<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br><span class="line"><span class="comment">//删除 erase(pos,num)----在哪个位置删除多少字符</span></span><br><span class="line">s1.earse(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line"><span class="comment">//将123456转为字符串</span></span><br><span class="line">s1 = to_string(<span class="number">123456</span>);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s1;</span><br><span class="line"><span class="comment">//将字符型1234转为int类型   ---string to int</span></span><br><span class="line"><span class="keyword">int</span> x=stoi(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line"> <span class="built_in">cout</span>&lt;&lt;x&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三-栈"><a href="#三-栈" class="headerlink" title="三 栈"></a>三 栈</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stack&gt;  //要引入库函数</span></span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">      s.push(i);<span class="comment">//入栈操作</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.top()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问s的栈顶元素</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.size()&lt;&lt;<span class="built_in">endl</span>;  输出s的元素个数</span><br><span class="line">   s.pop(); <span class="comment">// 删除栈顶元素但不返回其值</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;s.empty()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//非空返回0，是空返回1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="四-队列"><a href="#四-队列" class="headerlink" title="四 队列"></a>四 队列</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;//要引入库函数</span></span></span><br><span class="line">   <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; s ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">        s.push(i);<span class="comment">//将i元素接到队列的末端；</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;首元素为：&quot;</span>&lt;&lt;s.front()&lt;&lt;<span class="built_in">endl</span>;  <span class="comment">//访问队首元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">&quot;队尾元素：&quot;</span>&lt;&lt;s.back()&lt;&lt;<span class="built_in">endl</span>;  访问队尾元素</span><br><span class="line">     s.pop(); <span class="comment">// 弹出队列的第一个元素，并不会返回元素的值；</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;s.empty()&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//非空返回0，是空返回1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="五-set"><a href="#五-set" class="headerlink" title="五 set"></a>五 set</h3><blockquote><p>⼀个<code>set</code>⾥⾯的各元素是各不相同的（重复元素自动删除），⽽且<code>set</code>会按照元素进⾏从⼩到⼤排序</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">  s.insert(<span class="number">2</span>);<span class="comment">//插入元素</span></span><br><span class="line"></span><br><span class="line">  s.insert(<span class="number">100</span>);<span class="comment">//插入元素</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">6</span>;i++)&#123;</span><br><span class="line">    s.insert(i);<span class="comment">//插入元素</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//迭代变量set&lt;int&gt;::iterator it</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it=s.begin();it!=s.end();it++)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;<span class="comment">//集合的遍历，it是一个迭代的指针</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//方法二：</span></span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">auto</span> v: s)  <span class="built_in">cout</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="comment">//输入结果：0 1 2 3 4 5 100</span></span><br><span class="line"><span class="comment">//按照从小到大排序，且删除相同元素</span></span><br><span class="line"></span><br><span class="line">s.erase(<span class="number">3</span>);<span class="comment">//删除元素为3的</span></span><br><span class="line">s.clear();<span class="comment">//清空</span></span><br><span class="line">s.size();<span class="comment">//长度</span></span><br><span class="line">s.empty();<span class="comment">//判空</span></span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;*s.find(<span class="number">2</span>)&lt;&lt;<span class="built_in">endl</span>; <span class="comment">//查找某一个num值，返回的是迭代器，因此需要*来输出</span></span><br></pre></td></tr></table></figure><h3 id="六-哈希表"><a href="#六-哈希表" class="headerlink" title="六 哈希表"></a>六 哈希表</h3><h4 id="6-1-map"><a href="#6-1-map" class="headerlink" title="6.1 map"></a>6.1 map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="built_in">cin</span>&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">  <span class="keyword">int</span> x;</span><br><span class="line">  <span class="built_in">cin</span>&gt;&gt;x;</span><br><span class="line">  mp[x] =i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> v: mp) <span class="built_in">cout</span>&lt;&lt;v.first&lt;&lt;<span class="string">&quot; ： &quot;</span>&lt;&lt;v.second&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-2-unordered-map"><a href="#6-2-unordered-map" class="headerlink" title="6.2 unordered_map"></a>6.2 unordered_map</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 头文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="comment">//2. 初始化</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 插入元素</span></span><br><span class="line"><span class="comment">//3.1 数组形式</span></span><br><span class="line"><span class="built_in">map</span>[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="comment">//3.2 直接插入</span></span><br><span class="line"><span class="built_in">map</span>.insert( &#123; &#123;<span class="string">&#x27;b&#x27;</span>,<span class="number">2</span>&#125; , &#123;<span class="string">&#x27;c&#x27;</span>,<span class="number">3</span>&#125; &#125; );</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 修改元素</span></span><br><span class="line"><span class="built_in">map</span>[<span class="string">&#x27;a&#x27;</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 删除元素</span></span><br><span class="line"><span class="comment">//5.1 删除key为&#x27;a&#x27;的元素</span></span><br><span class="line"><span class="built_in">map</span>.erase(<span class="string">&#x27;a&#x27;</span>); </span><br><span class="line"><span class="comment">//5.2删除第一个元素</span></span><br><span class="line"><span class="built_in">map</span>.erase(<span class="built_in">map</span>.begin());</span><br><span class="line"></span><br><span class="line"><span class="comment">//6. 判断元素是否存在</span></span><br><span class="line"><span class="comment">//6.1 如果元素存在</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>.find(<span class="string">&#x27;a&#x27;</span>)!=<span class="built_in">map</span>.end())</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">map</span>.count(<span class="string">&#x27;a&#x27;</span>)!=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//7. 清空所有元素    </span></span><br><span class="line"><span class="built_in">map</span>.clear();</span><br><span class="line"></span><br><span class="line"><span class="comment">//8. 遍历取值并取出键和值</span></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line"><span class="keyword">for</span>( <span class="keyword">auto</span>&amp; a : <span class="built_in">map</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> key= a.first;</span><br><span class="line">    <span class="keyword">int</span>  value= a.second;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = <span class="built_in">map</span>.begin(); it != <span class="built_in">map</span>.end(); it++) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">char</span> key = it-&gt;first;</span><br><span class="line">        <span class="keyword">int</span>  value = it-&gt;second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//9. 判断是否为空</span></span><br><span class="line"><span class="keyword">if</span>( <span class="built_in">map</span>.empty() )</span><br><span class="line">    </span><br><span class="line"><span class="comment">//10. 求元素个数</span></span><br><span class="line"><span class="built_in">map</span>.size();</span><br></pre></td></tr></table></figure><h3 id="七-ACM模式输入输出参考书程序"><a href="#七-ACM模式输入输出参考书程序" class="headerlink" title="七 ACM模式输入输出参考书程序"></a>七 ACM模式输入输出参考书程序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;limits.h&gt;  //INT_MIN 和 INT_MAX的头文件  </span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stu</span> &#123;</span></span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 直接输入一个数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 直接输入一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3. 只读取一个字符 </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="comment">//方式1</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ch) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式2： cin.get(ch) 或者 ch = cin.get() 或者 cin.get()</span></span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch)) &#123;   </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//方式3 ：ch = getchar()  </span></span><br><span class="line"><span class="keyword">while</span> (getchar()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ch &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.1给定一个数，表示有多少组数（可能是数字和字符串的组合），然后读取</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;   <span class="comment">//每次读取1 + n 个数，即一个样例有n+1个数 </span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">nums</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理这组数/字符串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nums[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.2 首先给一个数字，表示需读取n个字符，然后顺序读取n个字符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; n) &#123;  <span class="comment">//输入数量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">string</span> temp;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; temp;</span><br><span class="line">strs.push_back(temp);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//处理这组字符串</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.未给定数据个数，但是每一行代表一组数据，每个数据之间用空格隔开</span></span><br><span class="line"><span class="comment">//4.1使用getchar() 或者 cin.get() 读取判断是否是换行符，若是的话，则表示该组数（样例）结束了，需进行处理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> ele;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; ele) &#123;</span><br><span class="line"><span class="keyword">int</span> sum = ele;</span><br><span class="line"><span class="comment">// getchar()   //读取单个字符</span></span><br><span class="line"><span class="comment">/*while (cin.get() != &#x27;\n&#x27;) &#123;*/</span>   <span class="comment">//判断换行符号</span></span><br><span class="line"><span class="keyword">while</span> (getchar() != <span class="string">&#x27;\n&#x27;</span>) &#123;  <span class="comment">//如果不是换行符号的话，读到的是数字后面的空格或者table</span></span><br><span class="line"><span class="keyword">int</span> num;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.2 给定一行字符串，每个字符串用空格间隔，一个样例为一行</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; str) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line"><span class="keyword">if</span> (getchar() == <span class="string">&#x27;\n&#x27;</span>) &#123;  <span class="comment">//控制测试样例</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">strs.clear();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.3 使用getline 读取一整行数字到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> input;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, input)) &#123;  <span class="comment">//读取一行</span></span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">data</span><span class="params">(input)</span></span>;  <span class="comment">//使用字符串流</span></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>, sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (data &gt;&gt; num) &#123;</span><br><span class="line">sum += num;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4.4 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> words;</span><br><span class="line"><span class="keyword">while</span> (getline(<span class="built_in">cin</span>, words)) &#123;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">data</span><span class="params">(words)</span></span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (data &gt;&gt; str) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.5 使用getline 读取一整行字符串到字符串input中，然后使用字符串流stringstream，读取单个数字或者字符。每个字符中间用&#x27;,&#x27;间隔</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> line;</span><br><span class="line"></span><br><span class="line"><span class="comment">//while (cin &gt;&gt; line) &#123;  //因为加了“，”所以可以看出一个字符串读取</span></span><br><span class="line"><span class="keyword">while</span>(getline(<span class="built_in">cin</span>, line))&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(line)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">while</span> (getline(ss, str, <span class="string">&#x27;,&#x27;</span>)) &#123;</span><br><span class="line">strs.push_back(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//</span></span><br><span class="line">sort(strs.begin(), strs.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//C语言读取字符、数字</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">char</span> c;</span><br><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"></span><br><span class="line">scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;a);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%c&quot;</span>, &amp;c);</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>, &amp;s);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, a);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ch;</span><br><span class="line">ch = getchar();</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span>.get(ch)) &#123; <span class="comment">//获得单个字符</span></span><br><span class="line">;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//读取字符串</span></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; str;  <span class="comment">//遇到空白停止</span></span><br><span class="line">getline(<span class="built_in">cin</span>, str);  <span class="comment">//读入一行字符串</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="八-其他"><a href="#八-其他" class="headerlink" title="八 其他"></a>八 其他</h3><h4 id="自带的宏常量"><a href="#自带的宏常量" class="headerlink" title="自带的宏常量"></a>自带的宏常量</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N = INT_MIN;</span><br><span class="line"><span class="keyword">int</span> N = INT_MAX;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> INF = <span class="number">0x3f3f3f3f</span>; <span class="comment">//通常用来代替最大值，防止运算过程中溢出  0x16进制</span></span><br></pre></td></tr></table></figure><h4 id="字符串判断函数"><a href="#字符串判断函数" class="headerlink" title="字符串判断函数"></a>字符串判断函数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">isdigit</span>(c)  <span class="comment">//判断c字符是不是数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(c)  <span class="comment">//判断c字符是不是字母</span></span><br><span class="line"><span class="built_in">isalnum</span>(c)  <span class="comment">//判断c字符是不是数字或者字母</span></span><br><span class="line"><span class="built_in">tolower</span>(c)  <span class="comment">//转为小写</span></span><br><span class="line"><span class="built_in">toupper</span>(c)  <span class="comment">//转为大写</span></span><br></pre></td></tr></table></figure><h4 id="字符串和数值间的转换"><a href="#字符串和数值间的转换" class="headerlink" title="字符串和数值间的转换"></a>字符串和数值间的转换</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">string</span> str = to_string(num); <span class="comment">//整形转字符串</span></span><br><span class="line"><span class="keyword">int</span> number = stoi(str);  <span class="comment">//字符串转为整形 stol()是字符串转为长整形</span></span><br></pre></td></tr></table></figure><h4 id="迭代器的二分"><a href="#迭代器的二分" class="headerlink" title="迭代器的二分"></a>迭代器的二分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">34</span>,<span class="number">44</span>,<span class="number">99</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> k = lower_bound(nums.begin(), nums.end(), <span class="number">56</span>) - nums.begin(); <span class="comment">//第一个大于等于目标值的迭代器位置</span></span><br><span class="line"><span class="keyword">int</span> k = upper_bound(nums.begin(), nums.end(), <span class="number">56</span>) - nums.begin(); <span class="comment">// 找到第一个大于目标值的迭代器位置</span></span><br></pre></td></tr></table></figure><h4 id="字符串转为小写"><a href="#字符串转为小写" class="headerlink" title="字符串转为小写"></a>字符串转为小写</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**op作用的范围[str1.begin(), str1.end], 作用完成后，存储位置的开头为：str2.begin()，op为toupper/tolower*/</span></span><br><span class="line">transform(str1.begin(), str1.end(), str2.begin(), ::<span class="built_in">toupper</span>);</span><br><span class="line">transform(str1.begin(), str1.end(), str2.begin(), ::<span class="built_in">tolower</span>);</span><br></pre></td></tr></table></figure><h4 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; pq; <span class="comment">//默认是大根堆</span></span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; pq; <span class="comment">//小根堆</span></span><br></pre></td></tr></table></figure><h4 id="快速初始化数组"><a href="#快速初始化数组" class="headerlink" title="快速初始化数组"></a>快速初始化数组</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 注意：这个函数是按字节初始化的</span></span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">-1</span>, <span class="keyword">sizeof</span> nums);</span><br><span class="line"><span class="built_in">memset</span>(nums, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> nums);</span><br></pre></td></tr></table></figure><h4 id="C-11的特性"><a href="#C-11的特性" class="headerlink" title="C++11的特性"></a>C++11的特性</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> p = <span class="keyword">new</span> ListNode(); <span class="comment">// auto 关键字</span></span><br><span class="line">Node* pre = <span class="literal">nullptr</span>   <span class="comment">// nullptr代替NULL</span></span><br><span class="line"><span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; mp; <span class="comment">//哈希表 内部是无序的</span></span><br><span class="line"><span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st; <span class="comment">//无序集合</span></span><br></pre></td></tr></table></figure><h4 id="bitset"><a href="#bitset" class="headerlink" title="bitset"></a>bitset</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">reverseBits</span><span class="params">(<span class="keyword">uint32_t</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(n).to_string();</span><br><span class="line">    reverse(s.begin(), s.end());</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">bitset</span>&lt;<span class="number">32</span>&gt;(s).to_ulong();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字符串分割"><a href="#字符串分割" class="headerlink" title="字符串分割"></a>字符串分割</h4><p>将字符串按照空格分割</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">&quot;hello world my name is yao jun&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">stringstream</span> <span class="title">ss</span><span class="params">(s)</span></span>;</span><br><span class="line"><span class="built_in">string</span> str;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(ss &gt;&gt; str)&#123;</span><br><span class="line">    cnt++;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;str&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;cnt&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>hello</p><p>world</p><p>my</p><p>name</p><p>is</p><p>yao</p><p>jun</p><p>7</p></blockquote><h4 id="四舍五入保留小数"><a href="#四舍五入保留小数" class="headerlink" title="四舍五入保留小数"></a>四舍五入保留小数</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> str[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">double</span> num = <span class="number">22.23434</span>;</span><br><span class="line"><span class="built_in">sprintf</span>(str, <span class="string">&quot;%.2f&quot;</span>, num);</span><br><span class="line"><span class="built_in">string</span> s = str;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h4 id="字符串按格式拆分"><a href="#字符串按格式拆分" class="headerlink" title="字符串按格式拆分"></a>字符串按格式拆分</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> a = <span class="string">&quot;12:59:36&quot;</span>;</span><br><span class="line"><span class="keyword">char</span> str2[<span class="number">100</span>];</span><br><span class="line"><span class="built_in">memcpy</span>(str2, a.c_str(), <span class="built_in">strlen</span>(a.c_str()));</span><br><span class="line"><span class="keyword">int</span> u, v, w;</span><br><span class="line"><span class="built_in">sscanf</span>(str2, <span class="string">&quot;%d:%d:%d&quot;</span>, &amp;u, &amp;v, &amp;w);</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;u&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;v&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;w&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>12 59 36</p></blockquote><h4 id="相同字符的字符串"><a href="#相同字符的字符串" class="headerlink" title="相同字符的字符串"></a>相同字符的字符串</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span>&lt;&lt;s&lt;&lt;<span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果:</p><p>aaaaaaaaaa</p></blockquote><h4 id="结构体排序"><a href="#结构体排序" class="headerlink" title="结构体排序"></a>结构体排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="comment">// 从小到大排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; node_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;node&gt; tt;</span><br><span class="line">    tt.push_back(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    tt.push_back(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    sort(tt.begin(), tt.end());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;node: tt)&#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;node.a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;node.b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果：</p><p>1 5</p><p>2 3</p></blockquote><h4 id="优先队列自定义排序"><a href="#优先队列自定义排序" class="headerlink" title="优先队列自定义排序"></a>优先队列自定义排序</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="comment">// 在优先队列中，跟排序的规则是反的，这里是指a大的排在前面，a相同时，b大的排在前面</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> node&amp; node_)<span class="keyword">const</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a != node_.a) <span class="keyword">return</span> a &lt; node_.a;</span><br><span class="line">        <span class="keyword">return</span> b &lt; node_.b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;node&gt; pq;</span><br><span class="line">    pq.push(&#123;<span class="number">1</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    pq.push(&#123;<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">    pq.push(&#123;<span class="number">2</span>,<span class="number">5</span>&#125;);</span><br><span class="line">    <span class="keyword">while</span>(!pq.empty()) &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;pq.top().a&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;pq.top().b&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        pq.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>执行结果</p><p>2 5</p><p>2 3</p><p>1 5</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>QT学习笔记</title>
      <link href="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="QT学习笔记"><a href="#QT学习笔记" class="headerlink" title="QT学习笔记"></a>QT学习笔记</h2><hr><p>未完待续。。。。。。 预计寒假期间完成</p><hr><h3 id="QWidget"><a href="#QWidget" class="headerlink" title="QWidget"></a>QWidget</h3><h4 id="pro-配置文件"><a href="#pro-配置文件" class="headerlink" title=".pro 配置文件"></a>.pro 配置文件</h4><h4 id="QT注意事项"><a href="#QT注意事项" class="headerlink" title="QT注意事项"></a>QT注意事项</h4><ul><li><p>命名规范</p><ul><li>类名 首字母大写，单词和单词之间首字母大写</li><li>函数名 变量名称 首字母小写,单词和单词之间首字母大写</li></ul></li><li><p>快捷键</p><ul><li>注释 ctrl + /</li><li>运行 ctrl + r</li><li>编译 ctrl + b</li><li>查找 ctrl + f</li><li>帮助文档 F1</li><li>自动对齐 ctrl + i</li><li>同名的.h和.cpp切换 F4</li></ul></li></ul><h4 id="按钮"><a href="#按钮" class="headerlink" title="按钮"></a>按钮</h4><ul><li>按钮常用API</li></ul><ol><li>show() 以顶层方式弹出窗口控件</li><li>setParent() 选择依赖方式</li><li>setText() 设置文本</li><li>resize() 重置窗口大小</li><li>move() 移动</li><li>setWindowTitle() 设置窗口大小</li><li>setFixedSize() 设置固定窗口大小</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">QPushButton *btn = <span class="keyword">new</span> QPushButton;</span><br><span class="line"><span class="comment">// btn-&gt;show();</span></span><br><span class="line"><span class="comment">// 让 btn 对象依赖于myWidget 中</span></span><br><span class="line">btn-&gt;setParent(<span class="keyword">this</span>);</span><br><span class="line">btn-&gt;setText(<span class="string">&quot;第一个按钮&quot;</span>);</span><br></pre></td></tr></table></figure><h4 id="QT中的对象树"><a href="#QT中的对象树" class="headerlink" title="QT中的对象树"></a>QT中的对象树</h4><ol><li>当创建的对象在堆区的时候,如果指定的父亲是QObject 派生下来的类或者子类</li><li>派生下来的类,可以不需要管理释放操作,会将对象放入对象树一定程度上简化了内存回收机制</li></ol><p>这里的话 ,打印顺序是反的, 是先打印了代码, 但是对象还没有释放掉。 正确的理解过程是先释放 我的按钮类 析构， 然后myWidget类析构 调用。</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20220818125200089.png" class="" title="image-20220818125200089"><h4 id="QT的窗口坐标系"><a href="#QT的窗口坐标系" class="headerlink" title="QT的窗口坐标系"></a>QT的窗口坐标系</h4><ol><li>笛卡尔坐标系[左上角为0,0点]</li></ol><h4 id="QT信号和槽"><a href="#QT信号和槽" class="headerlink" title="QT信号和槽"></a>QT信号和槽</h4><p>connect( 信号的发送者 ,信号的具体信息(函数的地址), 信号的接受者,信号的处理(槽)(也是函数的地址))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需求:点击 &quot;我的按钮&quot; 关闭窗口</span></span><br><span class="line">connect(mybtn3,&amp;QPushButton::clicked,<span class="keyword">this</span>,&amp;myWidget::close);</span><br></pre></td></tr></table></figure><ul><li>信号槽的优点 松散耦合,信号发送端 和 接收端本身是没有关联的,通过connectl连接,将两者耦合在一起<ul><li>信号关键字：Signals<ul><li>chlicked(bool) 点击</li><li>pressed() 按下</li><li>released() 释放</li><li>toggled(bool) 切换状态</li></ul></li><li>槽的关键字：Slots</li></ul></li><li>自定义信号和槽位函数<ul><li>自定义信号<ul><li>写在类的signals下,返回值为void,可以有参数,支持重载,不需要实现</li></ul></li><li>自定义槽函数<ul><li>不能写在signals下,public slots[公共的槽函数] 5.4版本以后全局函数或者public都行</li><li>返回值也是void,需要声明,也需要实现,可以有参数,支持重载</li></ul></li><li>然后用connect连接信号和槽</li><li>触发信号 emit</li><li>信号和槽重载，需要函数指针，明确指向函数的地址</li><li>QString 转char * 使用.toUtf8().data()</li><li>信号和槽连接：触发这个信号才能触发槽<ul><li>一个信号可以连接多个槽</li><li>多个信号也可以连接同一个槽函数</li><li>信号和槽的参数和类型必须对应</li><li>信号的参数个数可以多于槽的参数个数</li></ul></li><li>信号和信号连接 触发一个信号也能触发另外一个信号</li><li>断开信号 disconnect(参数一样)</li></ul></li></ul><h4 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h4><ul><li>C++11版本特性 [CONFIG += c++11] 匿名函数对象<ul><li>Lambda表达式函数声明 <code>[]()&#123;&#125;</code><ul><li>[=] 允许使用局部变量</li><li>[&amp;] 允许使用引用传递变量</li><li>[变量] 允许变量使用值传递</li><li>mutable 可修改值传递进来的参数[虽然还是局部变量]<ul><li><code>[m]()mutable&#123;m+=100;打印&#125;;</code> 不加mutable会报错</li></ul></li><li>-&gt;类型 带返回值<ul><li><code>int ret = []()-&gt;int&#123;return 1000&#125;();</code></li></ul></li></ul></li><li>Lambda表达式函数调用 <code>[]()&#123;&#125;()</code></li><li>最常见的<code>[=]()&#123;&#125;</code></li></ul></li></ul><h3 id="MainWindow"><a href="#MainWindow" class="headerlink" title="MainWindow"></a>MainWindow</h3><h4 id="菜单栏-QMenuBar"><a href="#菜单栏-QMenuBar" class="headerlink" title="菜单栏 QMenuBar"></a>菜单栏 QMenuBar</h4><pre><code>* 菜单栏最多只能有一个    + QMenuBar * bar = menuBar(); setMenuBar(bar);    + 创建菜单        * QMenu * fileMenu = bar-&gt;addMenu(&quot;文件&quot;);            + 创建菜单栏目                * QAction * newAction =  fileMenu-&gt;addAction(&quot;新建&quot;);            + 添加分隔符                 * fileMenu-&gt;addSeparator();</code></pre><h4 id="工具栏-QToolBar"><a href="#工具栏-QToolBar" class="headerlink" title="工具栏 QToolBar"></a>工具栏 QToolBar</h4><pre><code>* 工具栏可以有多个    + QToolBar * toolBar = new QToolBar(this);      + addToolBar(toolBar);        * 可选参数 默认停靠范围            + addToolBar(Qt::BottomToolBarArea,toolBar);        * 只允许左右停靠            + toolBar-&gt;setAllowedAreas(Qt::LeftToolBarArea | Qt::RightToolBarArea);        * 取消浮动            + toolBar-&gt;setFloatable(false);        * 设置禁止移动            + toolBar-&gt;setMovable(false);        * 给工具栏设置栏目            + toolBar-&gt;addAction(&quot;绝了&quot;或者QAction);        * 给工具栏添加控件            + toolBar-&gt;addWidget(QPushButton按钮);</code></pre><h4 id="状态栏-QStatusBar"><a href="#状态栏-QStatusBar" class="headerlink" title="状态栏 QStatusBar"></a>状态栏 QStatusBar</h4><pre><code>* 状态栏最多只能有一个    + QStatusBar * stBar = statusBar();    + setStatusBar(stBar);        * 添加标签控件            + QLabel * label = new QLabel(&quot;左侧提示的信息&quot;,this);            + QLabel * label1 = new QLabel(&quot;右侧提示的信息&quot;,this);            + stBar-&gt;addWidget(label);            + stBar-&gt;addPermanentWidget(label1);</code></pre><h4 id="铆接部件-QDockWidget"><a href="#铆接部件-QDockWidget" class="headerlink" title="铆接部件 QDockWidget"></a>铆接部件 QDockWidget</h4><pre><code>* 铆接部件可以有多个    + QDockWidget * dockWidget = new QDockWidget(&quot;浮动&quot;,this);    + addDockWidget(Qt::BottomDockWidgetArea,dockWidget); 放置位置下面 如果没有中心部件默认占满        + 只允许上下                * dockWidget-&gt;setAllowedAreas(Qt::TopDockWidgetArea | Qt::BottomDockWidgetArea);  </code></pre><h4 id="中心部件"><a href="#中心部件" class="headerlink" title="中心部件"></a>中心部件</h4><pre><code>* 中心内容也只能有一个    + 文本窗口 QTextEdit        + QTextEdit * edit = new QTextEdit(this);        + setCentralWidget(edit); //设置中心部件</code></pre><h4 id="资源文件"><a href="#资源文件" class="headerlink" title="资源文件"></a>资源文件</h4><ol><li>将图片文件文件夹拷贝到项目下</li><li>右键项目-&gt;添加新文件-&gt;Qt-&gt;Qt recourse File</li><li>res 生成 res.qrc</li><li>右键res.qrc-&gt;open in editor 编辑资源</li><li>添加前缀 添加文件</li><li>使用 “: + 前缀名 + 文件名”</li></ol><h4 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h4><pre><code>+ 只能有一个的是set 可以允许多个是add</code></pre><h4 id="对话框"><a href="#对话框" class="headerlink" title="对话框"></a>对话框</h4><ul><li>模态对话框 不可以对其他窗口进行操作<ul><li>QDialog dlg(this);</li><li>dlg.exec();</li><li>消息对话框<ul><li>错误对话框 QMessageBox::critical(this,”critical”,”错误”);</li><li>信息对话框 information</li><li>提问对话框 question</li><li>警告对话框warning</li><li>颜色对话框<ul><li>QColor a = QColorDialog::getColor(QColor(255,0,0));</li></ul></li><li>文件对话框 最后一个是过滤<ul><li>QString str = QFileDialog::getOpenFileName(this,”打开文件”,”./“,”(*.cpp)”);</li></ul></li><li>字体对话框<ul><li>bool flag;</li><li>QFont font = QFontDialog::getFont(&amp;flag,QFont(“华文彩云”,12));</li><li>setFont(font);//设置字体</li></ul></li></ul></li></ul></li><li>非模态对话框 可以对其他窗口进行操作<ul><li>QDialog *dlg2 = new QDialog(this); //为了确保不释放,开在堆上</li><li>dlg2-&gt;show();</li><li>dlg2-&gt;setAttribute(Qt::WA_DeleteOnClose);//55号 用于按关闭键自动释放[QWidge的对象树是在关闭总的窗口才会全部释放]</li></ul></li></ul><h4 id="列表控件-listWidget"><a href="#列表控件-listWidget" class="headerlink" title="列表控件 listWidget"></a>列表控件 listWidget</h4><ul><li>QListWidgetItem * item = new QListWidgetItem(“锄禾日当午”);</li><li>ui-&gt;listWidget-&gt;addItem(item); //添加进去</li><li>item-&gt;setTextAlignment(Qt::AlignCenter); //居中</li></ul><h4 id="ui窗口自布局"><a href="#ui窗口自布局" class="headerlink" title="ui窗口自布局"></a>ui窗口自布局</h4><ol><li>Spacers 弹簧 Widget div盒子</li><li>Group Box 分组[适用于Radio Button]</li><li>主窗口设置垂直布局后可以在sizePolicy-&gt;垂直策略-&gt;Fixed来使组件高度合适</li><li>如果找不到某个组件的信号或者槽，找基类</li></ol><h4 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h4><ol><li>add new -&gt; 设计师类</li><li>使用自定义组件<ul><li>查看基类[如widget] 从界面库中拖出来一个widget组件,然后点击提升为,写入类名<ul><li>[设置全局后可以直接在右键中显示]<br>3 自定义组件只有同基类才能被提升</li></ul></li></ul></li></ol><h4 id="QT事件-QEvent"><a href="#QT事件-QEvent" class="headerlink" title="QT事件 QEvent"></a>QT事件 QEvent</h4><ul><li><p>鼠标事件</p><ul><li>事件是虚函数,可以进行重载<br>//鼠标进入事件<br>virtual void enterEvent(QEvent *event);<br>//鼠标离开事件<br>virtual void leaveEvent(QEvent *event);<br>//鼠标按下<br>virtual void mouseReleaseEvent(QMouseEvent *ev);<br>//鼠标释放<br>virtual void mousePressEvent(QMouseEvent *ev);<br>//鼠标移动<br>virtual void mouseMoveEvent(QMouseEvent *ev);  </li></ul></li><li><p>定时器 QTimeEvent</p><ul><li>利用事件实现定时器<ul><li>startTimer(1000); 启动定时器，单位毫秒,返回一个唯一定时器id</li><li>void timerEvent(QTimerEvent * ev)<ul><li>定时器函数,可以通过ev-&gt;timerId()== id1来判断当前是哪个id进来的</li></ul></li></ul></li><li>定时器类QTimer<ul><li>//通过定时器类<br>  QTimer * timer = new QTimer(this);<br>  //启动定时器 每隔500秒发一个信号<br>  timer-&gt;start(500);<br>  //连接信号<br>  connect(timer,&amp;QTimer::timeout,中括号小括号{<br>  static int num = 1;<br>  ui-&gt;label_5-&gt;setText(QString::number(num++));<br>  });  </li></ul></li></ul></li><li><p>event事件分发器</p><ul><li>bool event(QEvent * ev)<ul><li>返回值是bool类型，如果返回true，代表用户要处理这个事件,不向下分发事件了[类似于钩子]</li></ul></li><li>事件枚举QEvent<ul><li>ev.type();</li><li>拦截后使用子类的操作可以使用静态类型转换<ul><li>QMouseEvent *ev = static_cast&lt;QMouseEvent *&gt;(QEvent中行参);</li></ul></li></ul></li><li>但是尽量别拦截</li></ul></li><li><p>事件过滤器</p><ul><li>在app到事件分发器前还能做个过滤</li><li>使用方式<ul><li>给控件安装时间过滤器<ul><li>installEventFilter(this);</li></ul></li><li>重写eventfilter事件</li></ul></li></ul></li></ul><h4 id="绘图-QPainter"><a href="#绘图-QPainter" class="headerlink" title="绘图 QPainter"></a>绘图 QPainter</h4><ul><li>绘图事件 void paintEvent(QPaintEvent *)</li><li>画家类 QPainter(构图的设备)<ul><li>拿起笔 .setPen(笔)</li><li>拿起刷子 .setBrush(刷子)</li></ul></li><li>画笔类 QPen(笔的颜色)</li><li>画刷类 QBrush(笔的颜色)</li><li>高级操作<ul><li>效率降低的抗锯齿<ul><li>painter.setRenderHint()</li></ul></li><li>改变画家位置<ul><li>painter.save();保存当前位置</li><li>painter.restore(); 还原到保存的位置</li><li>painter.translate(); 移动画家</li></ul></li><li>画家绘制图片drawPixmap</li></ul></li></ul><h4 id="绘图设备"><a href="#绘图设备" class="headerlink" title="绘图设备"></a>绘图设备</h4><ul><li>QPixmap 专门对图像显示做了优化</li><li>QBitmap 色深限定为1</li><li>QImage 专门为图像的像素级访问做了优化</li><li>QPicture 可以记录和重视画家的QPainter的各类命令<ul><li>自定义绘图操作 </li></ul></li></ul><h4 id="文件读写-QFile"><a href="#文件读写-QFile" class="headerlink" title="文件读写 QFile"></a>文件读写 QFile</h4><ul><li>file.open(打开方式) QtODevice::readOnly</li><li>全部读取 file.readAll() 按行读 file.readLine() 判断文件末尾atend()</li><li>QFile默认支持的是utf-8 指定格式 QTextCodec<ul><li>QTextCodec *codec = QTextCodec::codecForName(“gbk”);</li><li>ui-&gt;textEdit-&gt;setText(codec-&gt;toUnicode(array)); </li></ul></li><li>关闭文件对象 file.close();</li></ul><h4 id="文件信息-QFileInfo"><a href="#文件信息-QFileInfo" class="headerlink" title="文件信息 QFileInfo"></a>文件信息 QFileInfo</h4><ul><li>QFileInfo info(path);</li><li>后缀名 info.suffix()</li><li>创建日期 info.birthTime().toString(“yyyy/MM/dd hh:mm:ss”);</li><li>修改日期 info.lastModified().toString(“yyyy/MM/dd hh:mm:ss”);</li></ul><h4 id="Qss-前端人狂喜"><a href="#Qss-前端人狂喜" class="headerlink" title="Qss 前端人狂喜"></a>Qss 前端人狂喜</h4><ul><li>#myButton 这里的id实际上就是objectName指定的值</li><li>伪状态<ul><li>:active 当小部件驻留在活动窗口中时，将设置此状态</li><li>:checked    该控件被选中时候的状态</li><li>:hover    鼠标在控件上方</li><li>:pressed    该控件被按下时的状态</li><li>:disabled    该控件禁用时的状态</li><li>:first    该控件是第一个（列表中）</li><li>:focus    该控件有输入焦点时</li></ul></li></ul><h4 id="动画-QPropertyAnimation"><a href="#动画-QPropertyAnimation" class="headerlink" title="动画 QPropertyAnimation"></a>动画 QPropertyAnimation</h4><p>//winLabel 你要对那个组件使用动画  geometry几何结构<br>QPropertyAnimation * an = new QPropertyAnimation(winLabel,”geometry”);<br>//动画时间<br>an-&gt;setDuration(1000);<br>//动画开始<br>an-&gt;setStartValue(QRect(winLabel-&gt;x(),winLabel-&gt;y(),winLabel-&gt;width(),winLabel-&gt;height()));<br>//动画结束<br>an-&gt;setEndValue(QRect(winLabel-&gt;x(),winLabel-&gt;y() + 300,winLabel-&gt;width(),winLabel-&gt;height()));<br>//动画方式<br>an-&gt;setEasingCurve(QEasingCurve::OutBounce);<br>an-&gt;start();  </p><h4 id="背景音乐-QSound"><a href="#背景音乐-QSound" class="headerlink" title="背景音乐 QSound"></a>背景音乐 QSound</h4><ul><li>qmake: QT += multimedia</li><li>QSound * startSound = new QSound(“:/res/TapButtonSound.wav”,this); 载入音效</li><li>startSound-&gt;play(); 播放</li><li>startSound-&gt;setLoops(-1); -1循环次数无限</li></ul><h4 id="打包发布"><a href="#打包发布" class="headerlink" title="打包发布"></a>打包发布</h4><ul><li>debug-&gt;release</li><li>运行 运行失败添加环境变量D:\QT\5.12.3\mingw73_64\lib</li><li>把 Goldreverse.exe 单独丢到一个文件夹下</li><li>cmd中路径后windeployqt .\Goldreverse.exe 运行</li><li>此时已经可以使用了</li><li>深入打包[hm nis edit][<a href="https://www.bilibili.com/video/BV1g4411H78N?p=63&amp;spm_id_from=pageDriver%5D">https://www.bilibili.com/video/BV1g4411H78N?p=63&amp;spm_id_from=pageDriver]</a></li><li>HM NIS Edit 和 NSIS</li></ul><h3 id="Qt-amp-Clion-配置"><a href="#Qt-amp-Clion-配置" class="headerlink" title="Qt &amp; Clion 配置"></a>Qt &amp; Clion 配置</h3><h4 id="工具链的配置"><a href="#工具链的配置" class="headerlink" title="工具链的配置"></a>工具链的配置</h4><p>主要是配置工具链中的工具集，注意选中qt安装路径中的mingw</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221105202452526.png" class="" title="image-20221105202452526"><h4 id="CmakeList中的设置"><a href="#CmakeList中的设置" class="headerlink" title="CmakeList中的设置"></a>CmakeList中的设置</h4><p>在CmakeList中设置CMAKE_PREFIX_PATH 为 Qt安装路径中的cmake</p><img src="/2022/08/16/QT_%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/image-20221105202714141.png" class="" title="image-20221105202714141"><h4 id="关于乱码问题"><a href="#关于乱码问题" class="headerlink" title="关于乱码问题"></a>关于乱码问题</h4><p>写入到student.text中的数据, 打开是乱码, 暂时还没有解决</p><h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><ol><li><a href="https://blog.csdn.net/qq_41622214/article/details/124776481?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_utm_term~default-0-124776481-blog-115482634.pc_relevant_multi_platform_whitelistv3&spm=1001.2101.3001.4242.1&utm_relevant_index=3">CLion配置Qt环境</a></li></ol><h3 id="案例一-翻金币"><a href="#案例一-翻金币" class="headerlink" title="案例一: 翻金币"></a>案例一: 翻金币</h3><hr><p><a href="https://www.bilibili.com/video/BV1g4411H78N?p=52&vd_source=d4177fc7398a75956465a504f7fd3259">视频链接</a></p><ul><li>收获<ol><li>删除资源文件后需要删除debug文件,不然会报错</li><li>界面的切换可以使用信号和槽 即其它界面emit发送一个信号,主界面接收<ul><li>当然也可以选择记录父类指针,但是必须要在构造函数中多传个参数，而不是使用默认的parent</li></ul></li><li>在按钮上方有其他组件，可以使用label-&gt;setAttribute(Qt::WA_TransparentForMouseEvents);让其可以点到按钮[51号属性]</li><li>界面翻转金币 本质上是个按钮 <ul><li>人点击后 </li><li>金币触发翻转</li><li>定时器每隔30ms发送一次信号给金币</li><li>金币触发图片重新放置,到最大值或者最小值的时候关闭定时器</li><li>金币中有坐标i 和 j 以及一个flag 来确定该金币在页面中的位置</li></ul></li><li>锁定窗口 m_chooseScence-&gt;setGeometry(this-&gt;geometry()); 每次进入或者退出都锁定他的位置</li></ol></li><li>延时器<br>QTimer::singleShot(毫秒,拉姆达表达式);</li></ul><h3 id="案例二-学生管理"><a href="#案例二-学生管理" class="headerlink" title="案例二: 学生管理"></a>案例二: 学生管理</h3><hr><p>参考大佬的代码, 建议连接上数据库</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Processor Counter Monitor</title>
      <link href="/2022/07/27/Processor_Counter_Monitor/"/>
      <url>/2022/07/27/Processor_Counter_Monitor/</url>
      
        <content type="html"><![CDATA[<h2 id="Processor-Counter-Monitor测量cache及带宽"><a href="#Processor-Counter-Monitor测量cache及带宽" class="headerlink" title="Processor-Counter-Monitor测量cache及带宽"></a>Processor-Counter-Monitor测量cache及带宽</h2><p>Performance Counter Monitor（PCM）是一个由英特尔开发的，也是基于PMU(performance monitoring unit)一个性能检测工具。</p><p>它是运行在msr 内核模块(perf是内核系统调用吧？)上的，提供了C++ API。</p><ul><li>pcm：CPU、cache</li><li>pcm-memory：内存带宽（每频道及每个DRAM DIMM槽）</li><li>pcm-latency：L1 cahce</li><li>pcm-pcie：PCIe</li><li>pcm-numa：NUMA架构</li><li>pcm-power：能耗</li></ul><p><a href="https://github.com/opcm/pcm">最新版</a> , 复现论文[Saga-Bench: Software and Hardware Characterization of Streaming Graph Analytics Workloads] 的过程中, <a href="https://github.com/opcm/pcm/tree/91dbfaaf1a956c669de6cb705e033bd28e313ef7">用到的历史版本</a> 。 </p><h3 id="一-编译PCM"><a href="#一-编译PCM" class="headerlink" title="一 编译PCM"></a>一 编译PCM</h3><p>从 <code>github</code> 下载好源码, 进行编译,  编译完成后, 测试实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">0.1秒监测一次，结果输出为test.csv文件</span></span><br><span class="line">sudo ./pcm.x 0.1 -csv=test.csv --external-program Test</span><br></pre></td></tr></table></figure><p>第一次运行可能会出现如下错误:</p><blockquote><p>PCM Error: can’t open MSR handle for core 0<br>Can not access CPUs Model Specific Registers (MSRs).<br>Try to execute ‘modprobe msr’ as root user and then<br>you also must have read and write permissions for /dev/cpu/<em>/msr devices (/dev/msr</em> for Android). The ‘chown’ command can help.<br>Access to Processor Counter Monitor has denied (no MSR or PCI CFG space access).</p></blockquote><p>解决方法, 切换到 root 用户, 执行 modprobe msr 。</p><h3 id="二-测量L2-L3-cache的缺失率"><a href="#二-测量L2-L3-cache的缺失率" class="headerlink" title="二 测量L2 L3 cache的缺失率"></a>二 测量L2 L3 cache的缺失率</h3><h4 id="2-1-pcmBasic-h"><a href="#2-1-pcmBasic-h" class="headerlink" title="2.1 pcmBasic.h"></a>2.1 pcmBasic.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCMBasic_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCMBasic_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/cpucounters.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cassert&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">CounterStateType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_processor_level_stats</span><span class="params">(<span class="built_in">std</span>::ofstream&amp; out, <span class="keyword">const</span> PCM * m, <span class="keyword">const</span> CounterStateType &amp; state1, <span class="keyword">const</span> CounterStateType &amp; state2)</span></span>&#123;</span><br><span class="line">    assert(out.is_open());</span><br><span class="line">    <span class="comment">/* Output format/order: L2 MPKI, L3 MPKI, L2 hit rate, LLC hit rate, TLP (active cycles method), TLP (C state method = BigBench paper&#x27;s method)</span></span><br><span class="line"><span class="comment">     incoming QPI link utilization, outgoing QPI link utilization */</span></span><br><span class="line">    assert(m-&gt;isL2CacheMissesAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL3CacheMissesAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL2CacheHitRatioAvailable() &amp;&amp; </span><br><span class="line">           m-&gt;isL3CacheHitRatioAvailable());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> uint32 qpiLinks = (uint32)m-&gt;getQPILinksPerSocket();    </span><br><span class="line">    <span class="keyword">double</span> incoming = <span class="number">0.0</span>; <span class="keyword">double</span> outgoing = <span class="number">0.0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 i = <span class="number">0</span>; i &lt; m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        <span class="keyword">for</span> (uint32 l = <span class="number">0</span>; l &lt; qpiLinks; ++l)&#123;</span><br><span class="line">            incoming += <span class="number">100.</span> * getIncomingQPILinkUtilization(i, l, state1, state2);</span><br><span class="line">            outgoing += <span class="number">100.</span> * getOutgoingQPILinkUtilization(i, l, state1, state2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> overallIncomingQPILinkUitlization = incoming / (m-&gt;getNumSockets() * qpiLinks);</span><br><span class="line">    <span class="keyword">double</span> overallOutgoingQPILinkUitlization = outgoing / (m-&gt;getNumSockets() * qpiLinks);</span><br><span class="line"></span><br><span class="line">    out &lt;&lt; (<span class="keyword">double</span>(getL2CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2)) * <span class="number">1000</span> &lt;&lt; <span class="string">&quot;,&quot;</span> </span><br><span class="line">    <span class="comment">// L3 MPKI</span></span><br><span class="line">    &lt;&lt; (<span class="keyword">double</span>(getL3CacheMisses(state1, state2)) / getInstructionsRetired(state1, state2)) * <span class="number">1000</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getL2CacheHitRatio(state1, state2) &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getL3CacheHitRatio(state1, state2) &lt;&lt; <span class="string">&quot;,&quot;</span>   </span><br><span class="line">    &lt;&lt; (<span class="keyword">double</span>(getCycles(state1, state2))/getInvariantTSC(state1, state2)) * <span class="number">100</span>  &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; getCoreCStateResidency(<span class="number">0</span>, state1, state2)*<span class="number">100.</span> &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; overallIncomingQPILinkUitlization &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">    &lt;&lt; overallOutgoingQPILinkUitlization &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">CounterStateType</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_processor</span><span class="params">(<span class="keyword">const</span> PCM * m, <span class="keyword">const</span> CounterStateType &amp; state1, <span class="keyword">const</span> CounterStateType &amp; state2, <span class="keyword">bool</span> update)</span></span>&#123;</span><br><span class="line">    ofstream out;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(update)&#123;</span><br><span class="line">        out.open(<span class="string">&quot;UpdateProcLevel.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app); </span><br><span class="line">        display_processor_level_stats(out, m, state1, state2); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        out.open(<span class="string">&quot;AlgProcLevel.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app); </span><br><span class="line">        display_processor_level_stats(out, m, state1, state2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    out.close();   </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCMBasic_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="2-2-调用实现"><a href="#2-2-调用实现" class="headerlink" title="2.2 调用实现"></a>2.2 调用实现</h4><p>注意: 调用程序的源码中使用 <code>#include pcmBasic.h</code> 包含头文件 。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// ######################### PCM Memory initialization Start ########################</span></span><br><span class="line">    PCM* m = PCM::getInstance();    </span><br><span class="line">    <span class="keyword">bool</span> PMM = <span class="literal">false</span>, update = <span class="literal">false</span>; <span class="keyword">int</span> rankA = <span class="number">-1</span>, rankB = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (!m-&gt;hasPCICFGUncore())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;Unsupported processor model (&quot;</span> &lt;&lt; m-&gt;getCPUModel() &lt;&lt; <span class="string">&quot;).&quot;</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (m-&gt;memoryTrafficMetricsAvailable())</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;For processor-level memory bandwidth statistics please use pcm.x&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">    &#125; </span><br><span class="line">   </span><br><span class="line">    ServerUncorePowerState * BeforeState = <span class="keyword">new</span> ServerUncorePowerState[m-&gt;getNumSockets()];</span><br><span class="line">    ServerUncorePowerState * AfterState = <span class="keyword">new</span> ServerUncorePowerState[m-&gt;getNumSockets()];</span><br><span class="line">    uint64 BeforeTime = <span class="number">0</span>, AfterTime = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before counter states     </span></span><br><span class="line">    <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i&lt;m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        BeforeState[i] = m-&gt;getServerUncorePowerState(i); </span><br><span class="line">    &#125;</span><br><span class="line">    BeforeTime = m-&gt;getTickCount();        </span><br><span class="line">    <span class="comment">// ####################### PCM Memory initialization Done #######################</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">// ######################### PCM Memory finalization Start ########################</span></span><br><span class="line">    AfterTime = m-&gt;getTickCount();</span><br><span class="line">    <span class="comment">// after counter states     </span></span><br><span class="line">    <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i&lt;m-&gt;getNumSockets(); ++i)&#123;</span><br><span class="line">        AfterState[i] = m-&gt;getServerUncorePowerState(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    calculate_bandwidth(m, BeforeState, AfterState, AfterTime-BeforeTime, update, PMM);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span>[] BeforeState;</span><br><span class="line">    <span class="keyword">delete</span>[] AfterState;</span><br><span class="line">    m-&gt;cleanup();</span><br><span class="line">    <span class="comment">// ###################### PCM Memory finalization Done #################</span></span><br></pre></td></tr></table></figure><h3 id="三-测量内存带宽"><a href="#三-测量内存带宽" class="headerlink" title="三 测量内存带宽"></a>三 测量内存带宽</h3><h4 id="3-1-pcmMemory-h"><a href="#3-1-pcmMemory-h" class="headerlink" title="3.1 pcmMemory.h"></a>3.1 pcmMemory.h</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> PCMMemory_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCMMemory_H_</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 此处更改为pcm的路径</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/utils.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;/home/server2/pcm/cpucounters.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Programmable iMC counter</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_RANK_A 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_RANK_A 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> READ_RANK_B 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> WRITE_RANK_B 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PARTIAL 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMM_READ 2</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PMM_WRITE 3</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NM_HIT 0  <span class="comment">// NM :  Near Memory (DRAM cache) in Memory Mode</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_DELAY_DEFAULT 1.0 <span class="comment">// in seconds</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_DELAY_MIN 0.015 <span class="comment">// 15 milliseconds is practical on most modern CPUs</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PCM_CALIBRATION_INTERVAL 50 <span class="comment">// calibrate clock only every 50th iteration</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> uint32 max_sockets = <span class="number">256</span>;</span><br><span class="line"><span class="keyword">const</span> uint32 max_imc_channels = ServerUncorePowerState::maxChannels;</span><br><span class="line"><span class="keyword">const</span> uint32 max_edc_channels = ServerUncorePowerState::maxChannels;</span><br><span class="line"><span class="keyword">const</span> uint32 max_imc_controllers = ServerUncorePowerState::maxControllers;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">memdata</span> &#123;</span></span><br><span class="line">    <span class="keyword">float</span> iMC_Rd_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_Wr_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Rd_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Wr_socket_chan[max_sockets][max_imc_channels];</span><br><span class="line">    <span class="keyword">float</span> iMC_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_Wr_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> iMC_PMM_Wr_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> M2M_NM_read_hit_rate[max_sockets][max_imc_controllers];</span><br><span class="line">    <span class="keyword">float</span> EDC_Rd_socket_chan[max_sockets][max_edc_channels];</span><br><span class="line">    <span class="keyword">float</span> EDC_Wr_socket_chan[max_sockets][max_edc_channels];</span><br><span class="line">    <span class="keyword">float</span> EDC_Rd_socket[max_sockets];</span><br><span class="line">    <span class="keyword">float</span> EDC_Wr_socket[max_sockets];</span><br><span class="line">    uint64 partial_write[max_sockets];</span><br><span class="line">    <span class="keyword">bool</span> PMM;</span><br><span class="line">&#125; <span class="keyword">memdata_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Output format: </span></span><br><span class="line"><span class="comment">socket(i) read bW, socket(i) write BW for all i; system read BW; system write BW; system total BW</span></span><br><span class="line"><span class="comment">*/</span> </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_bandwidth_alg</span><span class="params">(PCM *m, <span class="keyword">memdata_t</span> *md)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sysReadDRAM = <span class="number">0.0</span>, sysWriteDRAM = <span class="number">0.0</span>, total = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;AlgMem.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app)</span></span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)&#123;</span><br><span class="line">        out &lt;&lt; md-&gt;iMC_Rd_socket[skt] <span class="comment">/* socket read BW (MB/s) */</span> &lt;&lt;  <span class="string">&quot;,&quot;</span> &lt;&lt; md-&gt;iMC_Wr_socket[skt] <span class="comment">/* socket write BW (MB/s) */</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;       </span><br><span class="line">        sysReadDRAM += md-&gt;iMC_Rd_socket[skt];   <span class="comment">// system read BW (MB/s)</span></span><br><span class="line">        sysWriteDRAM += md-&gt;iMC_Wr_socket[skt];  <span class="comment">// system write BW (MB/s)      </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total = sysReadDRAM + sysWriteDRAM;</span><br><span class="line">    out &lt;&lt; sysReadDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sysWriteDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_bandwidth_update</span><span class="params">(PCM *m, <span class="keyword">memdata_t</span> *md)</span></span>&#123;</span><br><span class="line">    <span class="keyword">float</span> sysReadDRAM = <span class="number">0.0</span>, sysWriteDRAM = <span class="number">0.0</span>, total = <span class="number">0.0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function">ofstream <span class="title">out</span><span class="params">(<span class="string">&quot;UpdateMem.csv&quot;</span>, <span class="built_in">std</span>::ios_base::app)</span></span>; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)&#123;</span><br><span class="line">        out &lt;&lt; md-&gt;iMC_Rd_socket[skt] <span class="comment">/* socket read BW (MB/s) */</span> &lt;&lt;  <span class="string">&quot;,&quot;</span> &lt;&lt; md-&gt;iMC_Wr_socket[skt] <span class="comment">/* socket write BW (MB/s) */</span> &lt;&lt; <span class="string">&quot;,&quot;</span>;        </span><br><span class="line">        sysReadDRAM += md-&gt;iMC_Rd_socket[skt];   <span class="comment">// system read BW (MB/s)</span></span><br><span class="line">        sysWriteDRAM += md-&gt;iMC_Wr_socket[skt];  <span class="comment">// system write BW (MB/s)      </span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    total = sysReadDRAM + sysWriteDRAM;</span><br><span class="line">    out &lt;&lt; sysReadDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; sysWriteDRAM &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; total &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">    out.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate_bandwidth</span><span class="params">(PCM *m, <span class="keyword">const</span> ServerUncorePowerState uncState1[], <span class="keyword">const</span> ServerUncorePowerState uncState2[], uint64 elapsedTime, <span class="keyword">bool</span> update, <span class="keyword">bool</span> PMM)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//const uint32 num_imc_channels = m-&gt;getMCChannelsPerSocket();</span></span><br><span class="line">    <span class="comment">//const uint32 num_edc_channels = m-&gt;getEDCChannelsPerSocket();</span></span><br><span class="line">    <span class="keyword">memdata_t</span> md;</span><br><span class="line">    md.PMM = PMM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(uint32 skt = <span class="number">0</span>; skt &lt; m-&gt;getNumSockets(); ++skt)</span><br><span class="line">    &#123;</span><br><span class="line">        md.iMC_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_PMM_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.iMC_PMM_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.EDC_Rd_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.EDC_Wr_socket[skt] = <span class="number">0.0</span>;</span><br><span class="line">        md.partial_write[skt] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(uint32 i=<span class="number">0</span>; i &lt; max_imc_controllers; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            md.M2M_NM_read_hit_rate[skt][i] = <span class="number">0.</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">const</span> uint32 numChannels1 = m-&gt;getMCChannels(skt, <span class="number">0</span>); <span class="comment">// number of channels in the first controller</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span>(m-&gt;getCPUModel()) &#123;</span><br><span class="line"><span class="keyword">case</span> PCM::KNL:</span><br><span class="line">            <span class="keyword">for</span>(uint32 channel = <span class="number">0</span>; channel &lt; max_edc_channels; ++channel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getEDCCounter(channel,READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getEDCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.EDC_Rd_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                    md.EDC_Wr_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                md.EDC_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getEDCCounter(channel,READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                md.EDC_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getEDCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                md.EDC_Rd_socket[skt] += md.EDC_Rd_socket_chan[skt][channel];</span><br><span class="line">                md.EDC_Wr_socket[skt] += md.EDC_Wr_socket_chan[skt][channel];</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">for</span>(uint32 channel = <span class="number">0</span>; channel &lt; max_imc_channels; ++channel)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(getMCCounter(channel,READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getMCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>) <span class="comment">//In case of JKT-EN, there are only three channels. Skip one and continue.</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!PMM || (getMCCounter(channel,PMM_READ,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span> &amp;&amp; getMCCounter(channel,PMM_WRITE,uncState1[skt],uncState2[skt]) == <span class="number">0.0</span>))</span><br><span class="line">                    &#123;</span><br><span class="line">                        md.iMC_Rd_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                        md.iMC_Wr_socket_chan[skt][channel] = <span class="number">-1.0</span>;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                md.iMC_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                md.iMC_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                md.iMC_Rd_socket[skt] += md.iMC_Rd_socket_chan[skt][channel];</span><br><span class="line">                md.iMC_Wr_socket[skt] += md.iMC_Wr_socket_chan[skt][channel];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span>(PMM)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.iMC_PMM_Rd_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,PMM_READ,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                    md.iMC_PMM_Wr_socket_chan[skt][channel] = (<span class="keyword">float</span>) (getMCCounter(channel,PMM_WRITE,uncState1[skt],uncState2[skt]) * <span class="number">64</span> / <span class="number">1000000.0</span> / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line"></span><br><span class="line">                    md.iMC_PMM_Rd_socket[skt] += md.iMC_PMM_Rd_socket_chan[skt][channel];</span><br><span class="line">                    md.iMC_PMM_Wr_socket[skt] += md.iMC_PMM_Wr_socket_chan[skt][channel];</span><br><span class="line"></span><br><span class="line">                    md.M2M_NM_read_hit_rate[skt][(channel &lt; numChannels1)?<span class="number">0</span>:<span class="number">1</span>] += (<span class="keyword">float</span>)getMCCounter(channel,READ,uncState1[skt],uncState2[skt]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    md.partial_write[skt] += (uint64) (getMCCounter(channel,PARTIAL,uncState1[skt],uncState2[skt]) / (elapsedTime/<span class="number">1000.0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">if</span> (PMM)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(uint32 c = <span class="number">0</span>; c &lt; max_imc_controllers; ++c)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(md.M2M_NM_read_hit_rate[skt][c] != <span class="number">0.0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    md.M2M_NM_read_hit_rate[skt][c] = ((<span class="keyword">float</span>)getM2MCounter(c, NM_HIT, uncState1[skt],uncState2[skt]))/ md.M2M_NM_read_hit_rate[skt][c];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(update) display_bandwidth_update(m, &amp;md);</span><br><span class="line">    <span class="keyword">else</span> display_bandwidth_alg(m, &amp;md);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">//PCMMemory_H_</span></span></span><br></pre></td></tr></table></figure><h4 id="3-2-调用实现"><a href="#3-2-调用实现" class="headerlink" title="3.2 调用实现"></a>3.2 调用实现</h4><p>注意: 调用程序的源码中使用 <code>#include pcmMemory.h</code> 包含头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    <span class="comment">// #################### PCM Processor Level Stats initialization Start #######################</span></span><br><span class="line">    PCM* m = PCM::getInstance();    </span><br><span class="line">    <span class="keyword">bool</span> update = <span class="literal">false</span>; </span><br><span class="line">    </span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;CoreCounterState&gt; cstates1, cstates2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;SocketCounterState&gt; sktstate1, sktstate2;</span><br><span class="line">    SystemCounterState sstate1, sstate2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// before counter states     </span></span><br><span class="line">    m-&gt;getAllCounterStates(sstate1, sktstate1, cstates1);        </span><br><span class="line">    <span class="comment">// #################### PCM Processor Level Stats initialization Done ###################</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段</span></span><br><span class="line"><span class="comment">// 需要测量的代码段    </span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ################### PCM Processor Level Stats finalization Start ####################</span></span><br><span class="line">    <span class="comment">// after counter states     </span></span><br><span class="line">    m-&gt;getAllCounterStates(sstate2, sktstate2, cstates2);</span><br><span class="line"></span><br><span class="line">    display_processor(m, sstate1, sstate2, update);    </span><br><span class="line">    </span><br><span class="line">    m-&gt;cleanup();</span><br><span class="line">    <span class="comment">// ######################## PCM Processor Level Stats finalization Done ###################</span></span><br></pre></td></tr></table></figure><h3 id="四-编译连接"><a href="#四-编译连接" class="headerlink" title="四 编译连接"></a>四 编译连接</h3><p>makefile 的编写</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">PCM_DIR := /home/server2/pcm</span><br><span class="line"></span><br><span class="line">PCM_HDR := $(wildcard $(PCM_DIR)/*.h)</span><br><span class="line">PCM_SRC := $(wildcard $(PCM_DIR)/*.cpp)</span><br><span class="line"><span class="meta">#</span><span class="bash">PCM_OBJ := $(patsubst %.cpp,%.o,$(wildcard $(PCM_DIR)/*.cpp))</span></span><br><span class="line">PCM_OBJ := msr.o cpucounters.o pci.o mmio.o client_bw.o utils.o</span><br><span class="line">PCM_OBJ := $(addprefix $(PCM_DIR)/,$(PCM_OBJ))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ALL= memory_footprint run_static_algorithm run_batch_updates run_simultaneous_updates_queries</span><br><span class="line">all: $(ALL)</span><br><span class="line"></span><br><span class="line"><span class="meta">%</span><span class="bash"> : tools/%.cpp $(PCM_OBJ)</span></span><br><span class="line">        $(CC) $(CFLAGS) $(PFLAGS) -o $@ $^ $(JEMALLOC)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(PCM_OBJ) : $(PCM_SRC)</span></span><br><span class="line">cd $(PCM_DIR) &amp;&amp; make -f $(PCM_DIR)/Makefile</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">        rm -f *.o $(ALL)</span><br></pre></td></tr></table></figure><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ol><li><a href="https://github.com/abasak24/SAGA-Bench/tree/master/pcmResource">saga-Bench pcmResource</a> 的代码实现</li><li><a href="https://chhzh123.github.io/blogs/2019-02-19-pcm/">CPU/内存监视器</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> Bandwidth </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图处理相关论文</title>
      <link href="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
      <url>/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/</url>
      
        <content type="html"><![CDATA[<h2 id="图处理的相关论文"><a href="#图处理的相关论文" class="headerlink" title="图处理的相关论文"></a>图处理的相关论文</h2><blockquote><p>Benchmark：主要是对比别人的方法，这个方法不一定是最好的，但一定是最具有代表性且被广泛认可的（一种标准和规范）。其所用的数据就是benchmark data，其方法就是benchmark method，你提出的方法在benchmark data上得出的结果与benchmark method 的结果对比才知道你的方法是否足够好。</p><p>baseline:  主要关注自己提出的方法，比最原始最简单的方法出来的结果（参照物）。然后在这个基础上改进，增加各种组件，可以看出提升多少，通过baseline我们可以知道这个方法能不能work, 有多少提升。</p></blockquote><h3 id="STINGER-流图的高性能数据结构"><a href="#STINGER-流图的高性能数据结构" class="headerlink" title="STINGER: 流图的高性能数据结构"></a>STINGER: 流图的高性能数据结构</h3><hr><blockquote><p> Stinger的关键属性是具有偏斜度分布的语义图上的快速插入，删除和更新。提出了一种新的数据结构，能够达到比较快的更新速度。</p></blockquote><p>正是由于在偏斜度分布的图上面进行的，所有才会使用batch 更新的方法，在batch 中  STINGER 的后续实现首先对批次进行排序（通常一次 100,000 条边更新），以便将发生在特定顶点上的所有边更新与插入分开的删除分组在一起。</p><p><strong>为什么会有batch</strong>        </p><blockquote><p>在具有许多线程上下文和内存库的系统上，数据结构中的工作量或并行性通常不足以一次处理单个更新。为了解决这个问题，我们开始批量处理边缘更新。一个批次摊销了进入数据结构的成本，并提供了大量的独立工作要做。</p></blockquote><p><strong>实验：</strong> 为什么采用batch 更新的方式，当batch 的大小发生变化的时候，每秒更新的变数会提高？ 每秒更新的边的个数是怎么计算的？</p><blockquote><p>我们测量处理数据结构中每个边缘更新所花费的时间。我们测量了几个批次，并以每秒更新的形式报告了性能。</p></blockquote><p><strong>进一步的优化:</strong>  </p><blockquote><p>然而，在无标度图中，少数顶点将面临多次更新，而大多数顶点只有一次更新或根本没有更新。这种工作负载不平衡限制了我们可以利用的并行量，并迫使大多数线程等待少数线程完成。</p></blockquote><p>为了解决这个问题，跳过了对边进行分类，并行的处理每条边的插入。但是，处理同一顶点上的两个边更新事件会引入竞争条件，必须通过适当的同步来处理。 并没有在软件商提出解决办法，而是使用Cray XMT 是这个场景的完美系统。（Cray XMT（Cray eXtreme MultiThreading，[1] 代号 Eldorado[2]）是 Cray 公司基于第三代 Tera MTA 架构的可扩展多线程共享内存超级计算机架构，针对大型图问题），但是这个系统近10年没有消息。</p><p><strong>缺点:</strong>  在整篇论文中只提到了更新，没有考虑查询的情况。</p><h3 id="图处理工作负载内存层次结构的分析与优化"><a href="#图处理工作负载内存层次结构的分析与优化" class="headerlink" title="图处理工作负载内存层次结构的分析与优化"></a>图处理工作负载内存层次结构的分析与优化</h3><p align = "right" > ——2019年发表在 `HPCA` 上面的一篇论文<p/><hr><p>Analysis and Optimization of the Memory Hierarchy for Graph Processing Workloads。</p><p><strong>提出问题:</strong> 在微架构级别，性能受到单机内存图分析的内存子系统效率低下的限制。本文的目标是解决单机内存图分析的内存效率低下问题。</p><ol><li>首先，我们在模拟的多核架构上对图形处理工作负载进行深入的数据类型感知表征。我们分析 1) 乱序内核中的内存级并行性和 2) 缓存层次结构中的请求重用距离。我们发现，涉及不同应用程序数据类型的加载-加载依赖链构成了实现高内存级并行性的主要瓶颈。我们还观察到不同的图数据类型表现出异构的重用距离。因此，私有 L2 缓存对性能的贡献可以忽略不计，而共享 L3 缓存表现出更高的性能敏感度。</li><li>基于他们的观察结构，提出了 DROPLET，这是一种用于图应用程序的数据感知解耦 预取器。 DROPLET 根据其固有的重用距离以不同的方式预取不同的图形数据类型。</li></ol><p>这里通过 <code>Using Cycle Stacks to Understand Scaling Bottlenecks in Multi-Threaded Workloads</code> 介绍的方法，使用pagerank 在 orkut上面 得到了 ==Cycle stack==。  45% 的周期是 DRAM 绑定的停顿周期，而内核被充分利用而仅在 15% 的周期内没有停顿。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221114164748773.png" class="" title="image-20221114164748773"><h4 id="一-借鉴的方向"><a href="#一-借鉴的方向" class="headerlink" title="一 借鉴的方向"></a>一 <strong>借鉴的方向</strong></h4><blockquote><p>现代 CPU 中使用的三种关键延迟容忍技术是 OoO 执行产生的 MLP、片上缓存(常说的三级cache)和预取。</p><p>OoO 执行依赖于重新排序缓冲区 (ROB) 向前看指令流，它可以在加载/存储队列、非阻塞缓存和 DRAM 中的并行性的帮助下支持多个正在运行的内存请求。</p></blockquote><p>这里主要参考优化的第一个方向,  通过两个特征来深入了解fig 1中的内存受限行为</p><ol><li>乱序执行中的内存级并行性（MLP）</li><li>cache层次结构中的重用距离</li></ol><blockquote><p>参考知乎: <a href="https://www.zhihu.com/question/28611947">https://www.zhihu.com/question/28611947</a></p><p><strong>instruction size 的概念:</strong>  标量乱序执行的核心就是不断的检查未来的指令，并从中发掘可以并行执行的指令，从而最终提升IPC。这个可以乱序执行的指令窗口叫做instruction window，这是衡量现代CPU性能的一个重要指标（举个不太恰当的例子，以前参加智能车比赛，摄像头看得越远理论上可以跑的越快）。</p><p>有两个关键因素影响着不断增加的instruction window size，一个是<strong>分支预测</strong>（branch prediction），准确的分支预测（目前的指标可以做到小于10MPKI，MPKI是没1000条指令中预测错误数目）可以保证绝大多数情况下instruction window 中的指令都是在正确的 程序路径 上。否则总是错误的预测执行（speculative execution）反而会降低IPC。 另外一个关键就是<strong>寄存器重命名和 reorder buffer 的大小</strong>。reorder buffer是实现乱序执行同时保持程序正确性和精确异常的关键，每条指令在译码之后会分配一个reorder buffer的entry，reorder buffer后面会按照指令顺序commit保证程序正确性。通常指令窗口大小（instruction window size）就是reorder buffer entry size，intel的几个关键节点的微架构的instruction window大小如下，Nehalem（45nm）128， Haswell（22nm）192，Sunny Cove（10nm）352。苹果的M1目前达到了~600（一部分原因是ARM不需要micro-ops译码，从而可以实现更高的instruction译码带宽8-wide）。</p></blockquote><h4 id="二-特征描述"><a href="#二-特征描述" class="headerlink" title="二 特征描述"></a>二 特征描述</h4><h4 id="2-1-指令窗口大小不是阻碍-MLP-的因素"><a href="#2-1-指令窗口大小不是阻碍-MLP-的因素" class="headerlink" title="2.1 指令窗口大小不是阻碍 MLP 的因素"></a>2.1 指令窗口大小不是阻碍 MLP 的因素</h4><ol><li>之前有论文说 ROB是影响MLP的主要因素，他们通过扩大指令窗口的大小，发现==带宽==并没有明显的增加。</li><li>第二个是发现加速比也没有明显的增加。</li></ol><h4 id="2-1-2-负载依赖链阻止实现高-MLP"><a href="#2-1-2-负载依赖链阻止实现高-MLP" class="headerlink" title="2.1.2 负载依赖链阻止实现高 MLP"></a>2.1.2 负载依赖链阻止实现高 MLP</h4><blockquote><p>laod-load dependency chains prevent achieving high MLP</p></blockquote><p>为了理解为什么大的ROB不能提升内存间的并行, 我们跟踪 ROB 中加载指令的依赖关系, MLP 受固有的应用程序级依赖特性的限制。</p><h4 id="2-1-3-图属性数据是依赖链中的消费者"><a href="#2-1-3-图属性数据是依赖链中的消费者" class="headerlink" title="2.1.3 图属性数据是依赖链中的消费者"></a>2.1.3 图属性数据是依赖链中的消费者</h4><p>平均而言，我们发现图形属性数据主要是消费者（53.6%）而不是生产者（5.9%）。发布(issuing)图形属性数据加载被延迟并且不能并行化，因为它必须依赖生产者加载来计算地址。</p><h4 id="2-1-4-私有-L2-缓存表现出可忽略的性能敏感性，而共享-LLC-表现出更高的性能敏感性"><a href="#2-1-4-私有-L2-缓存表现出可忽略的性能敏感性，而共享-LLC-表现出更高的性能敏感性" class="headerlink" title="2.1.4 私有 L2 缓存表现出可忽略的性能敏感性，而共享 LLC 表现出更高的性能敏感性"></a>2.1.4 私有 L2 缓存表现出可忽略的性能敏感性，而共享 LLC 表现出更高的性能敏感性</h4><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221116195030491.png" class="" title="image-20221116195030491"><p>如图 4a 所示，我们将 LLC 大小从 8MB 更改为 64MB，并找到 17.4%（最大 3.25X）性能改进的最佳点，LLC 容量增加 4 倍。平均 LLC MPKI（每千克指令缺失）从基线中的 20 减少到 16 (16MB) 到 12 (32MB) 到 10 (64MB)。相应的加速比分别为 7%、17.4% 和 7.6%。最佳点是在降低的未命中率和更大的 LLC 访问延迟之间取得平衡。</p><p>图 4b(i) 显示 L2 命中率（在基线中已经非常低，为 10.6%）在容量增加 2 倍后增加到仅 15.3%，而集关联性增加 4 倍没有影响（命中率升至仅 10.9%）。</p><p>图 4b(ii) 显示系统性能对不同的 L2 缓存配置（容量和集合关联性）表现出很小的敏感性。最左边的条表示没有私有 L2 缓存的架构，与 256KB 缓存相比没有减速。因此，没有私有 L2 缓存的架构同样适用于图形处理。</p><h4 id="2-1-5-属性数据是-LLC-容量的主要受益者"><a href="#2-1-5-属性数据是-LLC-容量的主要受益者" class="headerlink" title="2.1.5 属性数据是 LLC 容量的主要受益者"></a>2.1.5 属性数据是 LLC 容量的主要受益者</h4><p>为了了解哪种数据类型受益于更大的 LLC，图 4c 显示了对于每种数据类型，最终从 DRAM 获取数据的内存引用的百分比。属性数据下降最为明显.</p><h4 id="2-1-6-图结构缓存行在所有数据类型中具有最大的重用距离。-Graph-property-cacheline-具有比-L2-缓存服务更大的重用距离"><a href="#2-1-6-图结构缓存行在所有数据类型中具有最大的重用距离。-Graph-property-cacheline-具有比-L2-缓存服务更大的重用距离" class="headerlink" title="2.1.6 图结构缓存行在所有数据类型中具有最大的重用距离。 Graph property cacheline 具有比 L2 缓存服务更大的重用距离"></a>2.1.6 图结构缓存行在所有数据类型中具有最大的重用距离。 Graph property cacheline 具有比 L2 缓存服务更大的重用距离</h4><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221116195837647.png" class="" title="image-20221116195837647"><blockquote><p>Graph structure cacheline has the largest reuse distance among all the data types. Graph property cacheline has a larger reuse distance than that serviced by the L2 cache.</p></blockquote><p>为了进一步了解 L2 和 L3 缓存的不同性能敏感性，我们按应用程序数据类型分解内存层次结构使用情况，如图 7 所示。</p><ol><li>在大多数基准测试中，对结构数据的访问由 L1 缓存和 DRAM 提供服务，这表明 L1 中丢失的缓存行是在遥远的过去引用的缓存行，因此它已从 L2 和 L3 缓存中被逐出。 重用距离超出 LLC 的服务能力这一事实解释了为什么更大的 LLC 无法显着降低图 4c 中片外结构访问的比例。</li><li>另一方面，L1 缓存中丢失的大部分属性数据加载不能由 L2 缓存提供服务，但可以由 LLC 和 DRAM 提供服务。总的来说，LLC 在服务属性访问方面比结构访问更有用。因此，property cacheline 的重用距离相对较小，但仍大于 L2 缓存捕获的重用距离</li><li>最后，图 7 提供的证据表明，对中间(顶点)数据的访问主要是 L1 缓存和 LLC 中的片上缓存命中。</li></ol><p>**最终: ** 三种数据类型的重用距离解释了为什么私有 L2 缓存无法为内存请求提供服务并且显示出微不足道的好处。</p><h4 id="三-总结与机遇"><a href="#三-总结与机遇" class="headerlink" title="三 总结与机遇"></a>三 总结与机遇</h4><p>图形分析中内存限制的停顿行为是由两个问题引起的：</p><ol><li>不同数据类型的异构重用距离导致密集的 DRAM 访问以检索结构和属性数据。</li><li>由于负载依赖链导致的低 MLP，限制了重叠 DRAM 访问的可能性</li></ol><hr><h3 id="Graphfire：为图处理协同获取、插入和替换策略"><a href="#Graphfire：为图处理协同获取、插入和替换策略" class="headerlink" title="Graphfire：为图处理协同获取、插入和替换策略"></a>Graphfire：为图处理协同获取、插入和替换策略</h3><blockquote><p>已经开发了专门的图形定制预取机制、处理器设计和内存层次结构引擎，以容忍此类访问的长时间延迟. ==但是==这些方法要么过于占用带宽，要么需要进行侵入性硬件更改，从而抑制通用计算的灵活性，要么依赖于限制真正加速的软件预处理。</p></blockquote><p>这项工作引入了 Graphfire，这是一种灵活的内存层次结构方法，可以学习图形处理中的不同访问模式，并利用专门的获取、插入和替换优化的协同作用来解决有问题的间接访问，而无需依赖软件或 ISA 支持。</p><h4 id="一-已有工作的问题"><a href="#一-已有工作的问题" class="headerlink" title="一 已有工作的问题"></a>一 已有工作的问题</h4><ul><li>大量工作涉及缓存管理技术 这些技术都没有考虑图形应用程序的特定访问模式，而是专注于那些在更常规的工作负载中众所周知和常见的模式，例如streaming、strided、thrashing、mixed 等。因此，当这些技术应用于图形分析时，这些技术产生的任何硬件开销都被浪费了。</li><li>GRASP [15] 提出了针对图分析的领域专业化 LLC 管理的第一步，但会产生基于度的图重新排序的软件预处理成本 [14]。软件预处理使得该技术对于大图不太实用，例如在许多应用场景中，输入图只被处理一次 [5]，或者甚至没有完全遍历图，例如在搜索算法中。</li></ul><p>据我们所知，对于图形应用程序<strong>，不存在可以在没有软件支持的情况下学习和优化其访问模式的内存层次结构方法</strong>。</p><h4 id="二-我们的工作"><a href="#二-我们的工作" class="headerlink" title="二 我们的工作"></a>二 我们的工作</h4><p>以优化图形应用程序的缓存性能为目标，我们的工作做出以下==关键观察==：</p><ol><li>内存层次结构必须专门针对有问题的间接访问（ problematic indirect accesses）来缓解它们的瓶颈。</li><li>要与软件无关，==轻量级机制==必须自动识别 PIA，这可以在每个指令的基础上实现。</li><li>虽然 PIA 是不规则的，但其中的一个子集具有很高的重用性，因此 LLC 必须保留它们。</li></ol><p><strong>所用的方法：</strong></p><p>鉴于这些观察结果，本文提出了 Graphfire，这是一种灵活的、基于硬件的内存层次结构方法</p><ul><li>了解图形应用程序中何时出现 PIA</li><li>通过定制的获取、插入和替换策略优化它们的性能。</li></ul><h4 id="三-MOTIVATION"><a href="#三-MOTIVATION" class="headerlink" title="三 MOTIVATION"></a>三 MOTIVATION</h4><h5 id="3-1-内存访问模式"><a href="#3-1-内存访问模式" class="headerlink" title="3.1 内存访问模式"></a>3.1 内存访问模式</h5><p>图形应用程序因数据遍历引起的不规则内存访问而臭名昭著。最先进、高效的算法实现通过两个嵌套的内核循环迭代地执行图形遍历，并利用压缩稀疏行 (CSR) 格式将输入数据集有效地存储为一维密集数组 [45]。</p><p>指针间接访问发生在顶点属性数组中，该数组存储每个顶点的结果，例如距离或等级 [6]。 CSR 数组存储图形信息，例如顶点和边缘位置，但经常和/或不经常访问。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117103412358.png" class="" title="image-20221117103412358"><p><strong>上图是图处理内核的伪代码</strong>， 外部循环（第 2-5 行）遍历顶点工作列表（针对当前算法迭代），而内部循环（第 6-13 行）分析当前顶点的邻居以潜在地更新它们的数据，具体取决于算法的目标。如果更新了邻居，则将其添加到下一次算法迭代的工作列表中（第 12-13 行）。该算法在工作列表为空（第 1 行）时终止，即图已遍历且更新已稳定。</p><p>==外循环中的指令==相对于内循环中的指令很少出现，特别是对于具有高边顶点比的图。访问是流式的或间接的（这里的访问是流失的是什么意思? 一直访问吗?） </p><h6 id="3-1-1-Infrequent-Streaming"><a href="#3-1-1-Infrequent-Streaming" class="headerlink" title="3.1.1 Infrequent, Streaming"></a>3.1.1 Infrequent, Streaming</h6><p>这些访问出现在外部 for 循环或内部循环的条件内部，并具有流式行为。如图 1 的第 2 行所示，该算法遍历顶点工作列表并以流方式加载每个顶点索引。然而，这种访问并没有表现出良好的局部性，因为在内核的内部循环中，每次访问都可以被多次内存访问分开。</p><h6 id="3-1-2-Infrequent-Indirect"><a href="#3-1-2-Infrequent-Indirect" class="headerlink" title="3.1.2 Infrequent, Indirect"></a>3.1.2 Infrequent, Indirect</h6><p>这些指针间接访问出现在外部 for 循环或内部循环中的条件。当前顶点 v 索引到 vertex_ptr 数组以加载其邻居列表索引（第 4-5 行）并确定内循环迭代次数。对起始索引的第一个加载（第 4 行）是指针间接的，而第二个（第 5 行）具有局部性。另一个间接访问来自有条件地更新顶点属性数据（第 10 行）。但是，这些不规则访问不会对性能产生重大影响，因为它们很少发生。</p><h6 id="3-1-3-Primary-Streaming-Accesses-PSAs"><a href="#3-1-3-Primary-Streaming-Accesses-PSAs" class="headerlink" title="3.1.3 Primary Streaming Accesses (PSAs)"></a>3.1.3 Primary Streaming Accesses (PSAs)</h6><p>这些访问发生在内部 for 循环的关键路径中，并执行流式加载或存储到相邻索引（第 6 行）。这些是真正的流式访问，同时展示了时间和空间局部性，并且它们经常且定期发生。因此，它们是缓存友好的，不会造成数据供应瓶颈。我们将这些访问称为主要流访问 (PSA) 来描述这些特征。</p><h6 id="3-1-4-Primary-Indirect-Accesses"><a href="#3-1-4-Primary-Indirect-Accesses" class="headerlink" title="3.1.4 Primary Indirect Accesses"></a>3.1.4 Primary Indirect Accesses</h6><p>这些访问也发生在内部 for 循环的关键路径中，并执行指针间接加载（在第 8 行中突出显示）到顶点属性数组，以便为给定的邻居加载数据。由于这些间接访问发生在每个循环迭代中，并且具有导致性能成本的较长延迟，因此它们是图应用程序的数据供应瓶颈的原因。我们将它们称为主要间接访问 (PIA)，并在下一节中详细介绍它们的特性。</p><h5 id="3-2-The-Problems-with-PIAs"><a href="#3-2-The-Problems-with-PIAs" class="headerlink" title="3.2 The Problems with PIAs"></a>3.2 The Problems with PIAs</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117112612220.png" class="" title="image-20221117112612220"><p>顶点属性数组是 PIA 的主要来源，但是分析footprint, 发现只占应用程序总内存占用量的很小一部分。（这里的内存占用是指什么？）然后做实验发现了<strong>尽管 PIA 的数据占用空间相对较小，但它们本身占应用程序访问总数的很大一部分。</strong> 当应用程序遍历图形时，必须对顶点属性数组进行频繁更新。将不规则性与频率相结合会产生==内存延迟性能瓶颈==。</p><p>图 3 将总内存延迟分解为 PIA 与其他内存访问。在所有应用程序和输入中，PIA 的延迟平均占总内存延迟的 88%，构成了主要的应用程序性能瓶颈。因此，必须在内存层次结构中进行创新，以解决这些引用所表现出的缺乏规律性和局部性的问题。</p><h6 id="3-2-1-Lack-of-Locality"><a href="#3-2-1-Lack-of-Locality" class="headerlink" title="3.2.1 Lack of Locality"></a>3.2.1 Lack of Locality</h6><p>不幸的是，PIA 的不规则性导致它们表现出较差的局部性。对于上述应用程序/输入组合，平均而言，在 64B 逐出缓存行中有 54.1 (L1)、59.9 (L2) 和 59.5 (L3) 字节未使用。因此，为 PIA 获取整个缓存行的数据是一种浪费。这个没有具体的数据来表示？ 是怎么计算出来的？</p><h6 id="3-2-2-访问模式之间的干扰"><a href="#3-2-2-访问模式之间的干扰" class="headerlink" title="3.2.2 访问模式之间的干扰"></a>3.2.2 访问模式之间的干扰</h6><p>同一缓存集中不同内存访问模式的共存会损害性能。 PIA 可能会被 PSA 或其他不频繁访问逐出，从而导致多次冲突未命中，尤其是具有高重用性的 PIA 应保留在 LLC [6] 中。由于其不规则性和频率，PIA 是 LLC 中的主要驱逐对象。平均而言，21% 的驱逐是由其他类型的访问造成的。消除这种干扰可以提高 PIA 的缓存性能。</p><h6 id="3-2-3-变量-PIA-重用"><a href="#3-2-3-变量-PIA-重用" class="headerlink" title="3.2.3 变量 PIA 重用"></a>3.2.3 变量 PIA 重用</h6><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221117112845107.png" class="" title="image-20221117112845107"><p>图 4 展示了 BFS 在 Kronecker 网络上运行时的 PIA 访问和重用直方图。这捕捉了许多现实世界数据集的幂律趋势。图 4a 显示很少有顶点被频繁访问，而大多数顶点很少被访问。具有高重用性的顶点不应被低重用性 PIA 逐出。图 4b 说明了 PIA 重用距离的可变性。许多被重用，但大多数重用距离太长（相对于缓存关联性）以防止 PIA 被逐出。因此，PIA 的替换策略应适应顶点特征。</p><h3 id="用于图形分析的领域专用缓存管理"><a href="#用于图形分析的领域专用缓存管理" class="headerlink" title="用于图形分析的领域专用缓存管理"></a>用于图形分析的领域专用缓存管理</h3><p>Domain-Specialized Cache Management for Graph Analytics                                              ——HPCA 20</p><hr><h3 id="多核系统中处理内存干扰的技术-17-浙大"><a href="#多核系统中处理内存干扰的技术-17-浙大" class="headerlink" title="多核系统中处理内存干扰的技术 17 浙大"></a>多核系统中处理内存干扰的技术 17 浙大</h3><p>在多核系统中，同时运行的多个应用程序相互竞争访问共享的资源，如互连、高速缓 存和内存等。如果对可用的共享高速缓存容量和内存带宽的管理不恰当的话，不同应用程 序相互干扰，严重影响对方的运行。</p><blockquote><p>例如，在内存处，应用程序原有的行缓冲命中率和阵列级并行度会受到破坏，同时请求在读写队列中等待的时间也会因竞争激烈程度的加剧而 大幅增加；在高速缓存处，不同应用程序可能相互驱逐对方在高速缓存中的块，导致原有 命中率的破坏。</p></blockquote><p>请求在内存处的时延主要包含在队列中的等待时间和在DRAM中执行时间，这两 个部分受内存调度算法的影响特别大。</p><h4 id="创新-基于动态多层次优-先级的内存访问调度算法-DMPS"><a href="#创新-基于动态多层次优-先级的内存访问调度算法-DMPS" class="headerlink" title="创新: 基于动态多层次优 先级的内存访问调度算法 DMPS"></a>创新: 基于动态多层次优 先级的内存访问调度算法 DMPS</h4><p>识别应用程序的内存访问调度算法一般 由三部分组成：</p><ol><li>检测应用程序的内存访问特征；</li><li>基于内存访问特征来将应用程序分 类，以至于易受干扰的应用程序拥有更高的优先级；</li><li>选择优先级最高的就绪命令来执 行。</li></ol><h4 id="一-DRAM-访问过程"><a href="#一-DRAM-访问过程" class="headerlink" title="一 DRAM 访问过程"></a>一 DRAM 访问过程</h4><p>行缓冲是阵列中感应放大器单元的集合，是DRAM和内存控制器交互的接口。一般来说，行缓冲的大小为 <code>2-16KB</code>。</p><p>在行缓冲的行没有被关掉之前，行缓冲类似于高速缓存， 命中的话可减小访问延迟。到DRAM的访问可分为三步：</p><ol><li>激活命令，在目标阵列中打 开目标行，将其内容转移到行缓冲中</li><li>读写命令，在行缓冲中访问目标列；</li><li>预充电 命令，将行缓冲中的内容写回阵列的数组，关闭行缓冲的行。</li></ol><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220727095026744.png" class=""><h4 id="二-页管理策略"><a href="#二-页管理策略" class="headerlink" title="二 页管理策略"></a>二 页管理策略</h4><p>页管理策略管理行缓冲中感应放大器的操作，基本的策略有两种：开页策略和关页策 略</p><p>在开页策略中，<strong>行缓冲只在没 有到打开行的访问且有到其他行的访问时才关闭。</strong>开页策略的重要假设是一旦某一行数 据移到行缓冲中，那么在不久的将来该行的其他列会被访问，即偏爱到同一行的访问，适 合于空间局部性好的应用程序。访问类型主要是行命中和行冲突，对于行命中率高的程 序，开页策略能大幅提高性能。</p><p>在关页策略中，行缓冲在每个访问结束后都会关闭，访问 类型只有行关闭。关页策略适合到不同行的随机访问，同时每个访问的时延一样，有利于 带宽分配和实时控制</p><h4 id="三-地址映射机制"><a href="#三-地址映射机制" class="headerlink" title="三 地址映射机制"></a>三 地址映射机制</h4><p>地址映射机制负责将系统的内存地址空间映射到DRAM的逻辑结构中，具体来说，地 址映射机制将访问的物理地址转换成通道、排、阵列、行、列等值，具体化数据的放置位 置，对于性能有巨大的影响。当某块放置在某阵列中，下一块可以放置在同一行中、或者 同一阵列的下一行中、或者同一排的下一阵列中、或者同一通道的下一排中、又或者下一 通道中，所以地址映射机制决定了内存系统中可利用的并行度。</p><p>常见的地址映射机制有两 种：块交叉(Cacheline Interleaving)和行交叉(Row Interleaving)，如图2．3所示。行交叉将 连续的块放置在同一行中，试图最大化行缓冲命中率，适用于开页策略；而块交叉将连续 的块分散到不同的通道、排和阵列中，从而最大化内存访问并行度，适用于关页策略。最 小化开页(Minimalist Open Page) 则在两者之间做了权衡，通过少量的行命中实现开页 的增益，同时提高并行度来防止访问饥饿的现象和保证公平性。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220727103932041.png" class="" title="image-20220727103932041"><hr><h3 id="基于依赖感知的动态有向图处理加速器-20-华科"><a href="#基于依赖感知的动态有向图处理加速器-20-华科" class="headerlink" title="基于依赖感知的动态有向图处理加速器 20 华科"></a>基于依赖感知的动态有向图处理加速器 20 华科</h3><p>图算法通常需要对整个图进行反复迭代处理，不断地更新图顶点状态值，最终使 得所有图顶点状态值都不再发生改变，才停止迭代处理过程。因此，现有动态图处理 系统通常采用图迭代模型对最新图镜像执行增量计算。</p><p>目前的图迭代模型通常包括 批量同步迭代方法（Bulk Synchronous Parallel，BSP）模型和异步迭代模型。</p><h4 id="1-同步迭代模型"><a href="#1-同步迭代模型" class="headerlink" title="1 同步迭代模型"></a>1 同步迭代模型</h4><p>如图 1.3 所示，同步 BSP 迭代模型使用同步屏障机制将整个执行流程划分为数 个迭代周期。在每轮迭代中，基本并行处理单元被分配给各线程并行处理，通过对图 顶点及其相连的边执行运算以获得图顶点状态值（即，算法结果）。然而，由于同步 屏障的限制，各个图顶点都只能使用其前序图顶点在前一轮迭代中的旧状态值来计 算各自的新状态值，所有图顶点都完成各自的计算才能开始新的一轮迭代。迭代周期 交错进行，直到达到收敛状态。当 图处理系统并行处理图数据时，图数据被划分为并 行块并且分配给不同的处理单元。不同并行块之间通过共享内存或者消息通信机制 进行数据交换。</p><p>近年来，软件图处理系统和图加速器提出许多图划分方法，运行时负 载均衡策略和访存优化策略以提高每一轮迭代中图处理系统的吞吐率，并且已经达 到很好的效果。然而，受限于同步 BSP 迭代模型，图顶点的状态值在每轮迭代中只 能到达其直接后代图顶点，造成图顶点状态值的缓慢传播。因此，现有的同步 BSP 迭代模型不能有效支持动态图增量计算对低延迟和实时性的要求。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801201253986.png" class="" title="image-20220801201253986"><h4 id="2-异步迭代模型"><a href="#2-异步迭代模型" class="headerlink" title="2 异步迭代模型"></a>2 异步迭代模型</h4><p>不同于同步 BSP 迭代模型，如图 1.4 所示，异步迭代模型消除了同步屏障，当 前迭代计算得到的结果可以立即用于同一迭代中其它图顶点的状态值更新。因此，在 采用异步迭代模型的情况下，动态图中的图顶点的状态值传递速度通常快于同步 BSP 迭代模型，能够加快迭代收敛速度。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801201340527.png" class="" title="image-20220801201340527"><p>然而在异步迭代中，同时处理相邻图顶点会导致共享内存的读写冲突。为保证 异步迭代的顺序一致性，一些工作[20]对共享数据加锁以避免相邻图顶点的同时处 理。这导致大量锁开销，严重影响了大度图顶点的执行效率，对异步迭代处理性能 产生影响。为了减少原子开销，一些子图中心的异步迭代方法针对系统资源数 量，将有向图划分为图数据块并且分配图数据块给各个并行处理单元。不同图数据 块被并行地处理，通过消息通信机制同步不同图数据块之间的图顶点状态值。在各 个数据块内部，图顶点被串行地，异步地执行以快速传递图顶点状态值。</p><h4 id="3-设计动机"><a href="#3-设计动机" class="headerlink" title="3 设计动机"></a>3 设计动机</h4><blockquote><p>现有的同步 BSP 迭代模型和异步迭代模型能够提升有向图算法的并行度， 广泛应用于多种图处理系统和图加速器中。然而，由于动态有向图增量计算对实时性 要求极高，现有的迭代模型仍然面临着收敛速度缓慢和冗余数据计算和访问等问题， 无法满足用户对动态有向图处理的实时性需求。</p></blockquote><p>在动态有向图增量计算中，受到动态图变化影响的图顶点会沿着有向路径不断 地传递各自的状态值，因此，动态有向图处理的实时性直接受到图顶点的状态值传递 速度的影响。对于迭代有向图算法，每个图顶点都需要读取其前序图顶点的状态值以 重复更新自身的最新状态值，直到迭代收敛为止。但是，当在现有平台上并行执行图 算法时，大多数图顶点和它的前序图顶点被多个并行处理单元同时处理，在每轮迭代 中根据其前序图顶点的过时状态值更新以更新自身的状态值。结果，当使用现有的同 步/异步迭代模型时，活跃图顶点的最新状态值只能够缓慢地沿着有向路径传播到其 他的图顶点，并且根据其它图顶点的陈旧状态值来重复进行计算以更新自身。这不仅 浪费了大量时间用于处理冗余图顶点，还需要高额访存开销以反复加载这些图数据。</p><h5 id="3-1-同步BSP迭代过程"><a href="#3-1-同步BSP迭代过程" class="headerlink" title="3.1 同步BSP迭代过程"></a>3.1 同步BSP迭代过程</h5><p>如图 2.1 所示，动态图处理系统采用同步 BSP 迭代模型执行增量计算。在初始 状态时，动态有向图中所有的图顶点都达到收敛状态，并且相应的计算结果被维护。 当动态有向图结构发生变化时，例如，新增加了指向𝑣&amp;、𝑣’和𝑣(的边，需要重新进行 增量计算以获得最新图镜像的计算结果。图处理系统将激活图顶点，并且按照同步 BSP 迭代方式处理这些图顶点。在第一轮同步迭代中，𝑣&amp;的状态值首先被传递给其 后代图顶点𝑣’。然而，由于同步屏障，活跃图顶点的新状态值不能够立即被同一轮同 步迭代中的其它图顶点使用，因此，𝑣’不能够立即使用𝑣&amp;的状态值，也无法将𝑣&amp;的状态值立即传递给其后代图顶点𝑣(。当新的一轮迭代开始后，𝑣’才将自己接收到的𝑣&amp;传 递来的状态值后得到的结果传递给𝑣(。按照这种方式，在图数据块 P2 中的图顶点需 要至少三轮同步迭代才能将状态值传递给其它图数据块，造成了大量的冗余图数据 计算和访问，导致图顶点状态值缓慢地在有向图中传播。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801204827566.png" class="" title="image-20220801204827566"><h5 id="3-2-异步迭代模型"><a href="#3-2-异步迭代模型" class="headerlink" title="3.2 异步迭代模型"></a>3.2 异步迭代模型</h5><blockquote><p>由于传统的 round-robin 异步迭代模型[21]通常按照图顶点索引次序依次异步串行地处理活跃图顶 点，这忽略了有向图结构本身的更新依赖关系，导致低拓扑顺序的图顶点比高拓扑顺 序的图顶点先被处理。已经处理过的图顶点的状态值只能在下一轮异步迭代中才能 再次被处理，因此，在传统的异步迭代模型下，图顶点状态值仍然缓慢地在有向图中 传播，造成冗余图顶点更新。</p></blockquote><p>如图 2.2 所示，当动态图处理系统采用 round-robin 异步迭代模型执行增量计算 时，在其中一轮异步迭代过程中，一条已经被动态图改变量激活的有向路径（即， 𝑣&amp; → 𝑣’ → 𝑣(）上的图顶点可能被分配任意的图顶点索引次序，当图数据块 P2 被调 度处理时，其中的图顶点被按照图顶点索引次序依次异步串行地更新图顶点状态值。 然而，在每一轮异步迭代中，图顶点按照𝑣(，𝑣’，𝑣&amp;的顺序依次向后代图顶点传递各 自的图顶点状态值。由于已经处理过的图顶点的状态值只能在下一轮异步迭代中才 能再次被更新，因此在本轮异步迭代中，尽管图顶点可以立即使用并传递其前序图顶 点的状态值，但是其后代图顶点只能在下一轮迭代才能被重新更新。由于有向路径 (𝑣&amp; → 𝑣’ → 𝑣( → 𝑣))中包含 3 条边，因此至少需要进行三轮异步迭代（包含线程间同 步），图数据块 P2 才能将图顶点状态值完全传递给其它图数据块。因此，无论是同 步迭代模型，还是传统异步迭代模型，都 无法有效感知动态有向图的更新依赖关系，无法利用拓扑结构来加速动态有向图增量计算中的图顶点状态值传递。</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220801204945409.png" class="" title="image-20220801204945409"><h4 id="二-实验部分"><a href="#二-实验部分" class="headerlink" title="二 实验部分"></a>二 实验部分</h4><blockquote><p>The Aspen interface is an extension of Ligra’s interface. It includes the full Ligra interface-vertexSubsets, edgeMap, and various other functionality on a fixed graph. </p><p>On top of Ligra, we add a set of functions for updating the graph - in particular, for inserting or deleting sets of edges or sets of vertices. We also add a flat-snapshot function.  所有处理和更新的函数都是工作在固定大小的、不变的图镜像版本上面.</p></blockquote><h3 id="四-RisGraph-A-Real-Time-Streaming-System-for-Evolving-Graphs-to-Support-Sub-millisecond-Per-update-Analysis-at-Millions-Ops-s"><a href="#四-RisGraph-A-Real-Time-Streaming-System-for-Evolving-Graphs-to-Support-Sub-millisecond-Per-update-Analysis-at-Millions-Ops-s" class="headerlink" title="四 RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s"></a>四 RisGraph: A Real-Time Streaming System for Evolving Graphs to Support Sub-millisecond Per-update Analysis at Millions Ops/s</h3><blockquote><p>单调算法（例如可达性和最短路径）在实时分析中广泛使用，以获得 both static and temporal insights(见解)，并且可以通过增量计算加速。现有的 streaming system 采用增量计算模型，并实现低潜伏期或高吞吐量，但不能两者兼而有之。</p><p>RisGraph 通过局部数据访问和更新的并行性解决挑战.</p><p>单调算法在不断 evolving graph 中经常使用,  其中包括可及性，广度搜索，最短路径，连接的组件（和最小/最大标签传播(Connected Components, and Min/Max Label Propagation)。它需要扫描大量数据甚至整个图表，以重新计算不断发展的图的每个快照上的单调算法。增量计算的想法可以通过利用先前的结果来减少冗余计算来加速单调算法。</p></blockquote><p>RisGraph 单边更新， 与批处理相比，Per-Update分析对延迟友好，产生最新结果，并提供最准确，最详细的信息。它只留下一个开放的问题：如何在per-update analysis 中提供高吞吐量。</p><h4 id="一-motivation"><a href="#一-motivation" class="headerlink" title="一 motivation"></a>一 motivation</h4><p>已有的解决方案：<code>Kickstarter</code> 和 <code>Differential Dataflow</code> 是最先进的代表, <code>Kickstarter</code> 提出了单调算法的增量图计算模型，而<code>Differential Dataflow</code>则呈现了无图形意识的广义增量模型。</p><p><strong>不足:</strong>  如果<code>Kickstarter</code> 和 <code>Differential Dataflow</code> 每次更改图形时都（Per Update Analysis）进行分析，则每秒只能处理大约1000个更新。they rely on batching to trade latency for higher throughput(以延迟换吞吐量), benefiting from larger concurrency and lower overheads.  此外，它们提供了批处理模式以进一步优化吞吐量，从而降低了分析的频率，并仅对每批批次产生一个汇总的最终结果。</p><p><strong>不足举例:</strong>  我们以2010年Twitter-2010 [48]的范围进行广度优先搜索（<code>BFS</code>）。为了满足20 ms延迟需求（实时分析[65]），这些系统的吞吐量仅为1K OPS/s。为了提供 100K OPS/s的吞吐量，它们需要批量超过 <code>20k</code> 的更新，并且平均处理时间增长到150毫秒以上。因此，现有的流图系统不能同时通过批处理满足延迟和吞吐量要求。尽管如此，批处理模式还是整个更新，跳过了中间状态，这些状态在某些情况下可能有用，例如财务欺诈检测和交易综合性。</p><p><strong>单边更新的挑战：</strong> </p><ol><li>无法像 batch 更新那样，均摊开销</li><li>高吞吐量和低延迟 的目标要求系统有效地进行两种工作负载。修改图表时，它需要将每个更新应用于数据结构，并提供更新的图表，以便在短时间内进行分析。为了启用每个更新的实时分析，系统需要一个图形感知的设计，以利用单个更新的局部性，而不是利用整个图形扫描的典型技术。此外，它需要一种新的机制才能使平行性进行PerDate Processing，这对于在不批处理的情况下实现高吞吐量也很重要。</li></ol><p><strong>guiding idea：</strong></p><ol><li>局部数据访问的想法来自以下观察结果：图形流系统的常用图形感知技术仍然需要不必要的整个图形扫描[43，54，68，77]。如果我们仅通过访问受更新影响的必要顶点来避免这些扫描，我们将获得更好的性能，因此我们建议使用称为索引的邻接列表和稀疏阵列的数据结构来启用本地化访问。</li><li>我们通过并行处理更新（跨越并行性），同时维护应用程序的每个语义，进一步改善了吞吐量。我们提出了一种算法，以识别可以并行执行的更新，并一个一个更新以保持低延迟，以及原子能，隔离和Per Update分析的正确性。</li></ol><h4 id="二-实验结果"><a href="#二-实验结果" class="headerlink" title="二 实验结果"></a>二 实验结果</h4><p>四种算法： BFS、SSSP、SSWP、WCC</p><p>我们首先加载90％的边缘，选择10％的边缘作为从加载边缘的删除更新，然后将其余（10％）边缘视为插入更新。删除和更新占比1:1。</p><p>与<code>Kickstarter</code>相比，<code>Risgraph</code>的性能改进主要是我们本地化数据访问的信用（第3节）。 <code>Risgraph</code>的表现优于差异数据流，这主要是由于专门的图形感知引擎和增量模型。例如，与<code>Risgraph</code>相比，在Twitter-2010上重新计算<code>BFS</code>的处理时间为78倍。</p><h4 id="三-相关工作"><a href="#三-相关工作" class="headerlink" title="三 相关工作"></a>三 相关工作</h4><ol><li><code>Kickstarter</code> 通过追踪依赖关系和修剪近似值，为单调算法提供了正确的增量计算。 </li><li><code>Grapu</code>  by components-based classification and in-buffer <code>precomputation</code> 加速批处理单调算法。</li><li><code>Graphin</code> 结合了一个I-GAS模型，该模型会逐步处理固定尺寸的更新。</li><li><code>GraphBolt</code> 提出了一个通用的增量模型来 处理 non-monotonic algorithms like Belief Propagation,，但比单调算法的 <code>kickstarter</code> 涉及更多的开销。</li></ol><h3 id="五-GraphPulse-An-Event-Driven-Hardware-Accelerator-for-Asynchronous-Graph-Processing"><a href="#五-GraphPulse-An-Event-Driven-Hardware-Accelerator-for-Asynchronous-Graph-Processing" class="headerlink" title="五 GraphPulse: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing"></a>五 <code>GraphPulse</code>: An Event-Driven Hardware Accelerator for Asynchronous Graph Processing</h3><p>​                                                                                                                                                                                                ——2020 MICRO</p><blockquote><p>大规模的图处理带来了一些问题:</p><ol><li>首先，内存密集型处理会给内存系统带来压力, 和计算型系统相比, 内存占用更大, 频率更高. 大型内存占用还会导致内存带宽瓶颈并加剧长期访问延迟.</li><li>其次，由于顶点的并发更新，大多数计算模型中访问共享图状态的同步开销很高.</li><li>跟踪活动顶点或者边缘的开销很大, 这种跟踪是必不可少的，因为计算是不规则的，而在每次迭代中都有不同的顶点和边缘的子集。</li></ol><p>综上, 我们认为，现代处理体系结构不太适合按大规模进行图形处理应用程序</p></blockquote><p><code>GraphPulse</code> 围绕事件驱动计算的想法, 它表示计算为event， when the value of a  vertex changes to update vertices on all outgoing edges(当顶点的值更改为更新所有传出边上的顶点时)通常生成.</p><h3 id="六-JetStream-Graph-Analytics-on-Streaming-Data-with-Event-Driven-Hardware-Accelerator"><a href="#六-JetStream-Graph-Analytics-on-Streaming-Data-with-Event-Driven-Hardware-Accelerator" class="headerlink" title="六 JetStream: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator"></a>六 <code>JetStream</code>: Graph Analytics on Streaming Data with Event-Driven Hardware Accelerator</h3><blockquote><p><code>Jetstream</code> 扩展了最近提出的基于事件的加速器，用于图形工作负载，以支持流更新。它通过事件驱动的计算模型来处理累积和单调图算法，该模型限制了访问图形顶点的较小子集，有效地重用以前的查询结果以消除冗余，并优化了增强内存存储器带宽利用率的内存访问模式。</p></blockquote><p><code>Jetstream在Kickstarter和GraphBolt</code> 软件框架上达到了约18倍的速度，这些系统在较小的批次尺寸下具有明显较高的加速度。</p><p>更新的 batch 大小只占原始图大小的很小一部分, 如果重头计算的话势必会带来一些不必要的冗余。逐步支持删除的问题更具挑战性，只有Kickstarter [45]，GraphBolt [26]和DZIG [25]支持它。</p><p>支持的算法：supports all algorithms compatible with delta-accumulative computation。</p><p>相对于增加，删除操作更加麻烦，我们在两个阶段中支持删除：</p><ol><li>将图形的上一个版本的逐步转换为更新图的可恢复状态</li><li>bringing the results to convergence again.</li></ol><h3 id="七-图处理相关论文"><a href="#七-图处理相关论文" class="headerlink" title="七 图处理相关论文"></a>七 图处理相关论文</h3><h4 id="三-how怎么解决这个问题"><a href="#三-how怎么解决这个问题" class="headerlink" title="三 how怎么解决这个问题"></a>三 how怎么解决这个问题</h4><p>GRASP augments existing cache policies to maximize reuse of hot vertices by protecting them against cache thrashing, while maintaining sufficient flexibility to capture the reuse of other vertices as needed.</p><ul><li><h4 id="论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别"><a href="#论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别" class="headerlink" title="论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别"></a>论文中提出的图重排序方法的作用对象和机制以及与其他重排序方法的区别</h4></li></ul><blockquote><p>这并未提出新的重排序方法, 而是使用已有的重排序方法,  引用下面两篇论文.</p><ul><li> [A Closer Look at Lightweight Graph Reordering](# A Closer Look at Lightweight Graph Reordering)</li><li>[Making caches work for graph analytics](# Making caches work for graph analytics)</li></ul></blockquote><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220511164905637.png" class="" title="image-20220511164905637"><center>(a) Software applies vertex reordering, which segregates hot vertices at the beginning of the array. (b) GRASP interface exposes an ABR pair per Property Array to be configured with the bounds of the array. (c) GRASP identifies regions exhibiting different reuse based on an LLC size. </center><ul><li>Page5  论文中是如何识别热数据顶点，如何pinpoint(准确找到)热数据区域以及如何对访问进行归类；</li></ul><blockquote><ul><li><p>Conveniently, the hottest vertices are located at the beginning of the Property Array in a contiguous region thanks to the application of skew-aware reordering as seen in Fig. 3(a).  <strong>也就是说, 热顶点是通过排序得到的</strong>。</p></li><li><p>会在属性数组起始地址抓两个LLC-sized 的子区域， 一个 HIgh Reuse Region, 另一个Moderate Reuse Region.</p></li><li><p>GRASP determines this by comparing the address with the bounds of the High Reuse Region of each Property Array. </p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220511165057988.png" class="" title="image-20220511165057988"><p>GRASP encodes the classification result (High-Reuse, Moderate-Reuse, Low-Reuse or Default) as a 2-bit Reuse Hint, and forwards it to the LLC along with each cache request, as shown in Fig. 4, to guide specialized insertion and hit-promotion policies as described next.</p></li></ul></blockquote><h4 id="四-what-解决之后得到什么结论"><a href="#四-what-解决之后得到什么结论" class="headerlink" title="四 what 解决之后得到什么结论"></a>四 what 解决之后得到什么结论</h4><h5 id="4-1-Graph-process-framework"><a href="#4-1-Graph-process-framework" class="headerlink" title="4.1 Graph process framework"></a>4.1 Graph process framework</h5><blockquote><p>ligra, a widely used graph processing framework that supports both pull- and push-based computations, including switching from pull to push (and vice versa) at the start of every iteration. </p></blockquote><h5 id="4-2-Software-evaluation"><a href="#4-2-Software-evaluation" class="headerlink" title="4.2  Software evaluation"></a>4.2  Software evaluation</h5><p>论文中涉及的重排序技术</p><blockquote><p><strong>Sort</strong>  reorders vertices in the memory space by sorting them in the descending order of their degree.</p></blockquote><blockquote><p><strong>HubSort</strong>  segregates(隔离) hot vertices in a contiguous region by assigning them a continuous range of vertex IDs in their descending order of degree. In doing so, Hub Sorting essentially sorts all hot vertices, while largely preserving structure for the cold vertices.</p></blockquote><blockquote><p><strong>DBG</strong> , unlike Sort and HubSort, does not rely on sorting to segregate hot vertices. Instead, DBG coarsely(粗略的) partitions all vertices into a small number of groups based on their degree. Similar to Sort and HubSort, DBG is effective at improving spatial locality; however, unlike the other two techniques, DBG is able to largely preserve the existing graph structure.</p></blockquote><blockquote><p><strong>Gorder</strong> is evaluated as a representative of complex techniques. As Gorder is only available in a single-thread implementation, while reporting the net runtime of Gorder for a given dataset, we optimistically divide the reordering time by 40 (maximum number of threads supported on the server) to provide a fair comparison with skew-aware techniques whose reordering implementation is fully parallelized.</p></blockquote><h3 id="八-A-Closer-Look-at-Lightweight-Graph-Reordering"><a href="#八-A-Closer-Look-at-Lightweight-Graph-Reordering" class="headerlink" title="八 A Closer Look at Lightweight Graph Reordering"></a>八 A Closer Look at Lightweight Graph Reordering</h3><h4 id="二-why"><a href="#二-why" class="headerlink" title="二 why"></a>二 why</h4><p>To address the limitations of existing skew-aware reordering techniques, </p><ul><li> Sort achieves the maximum reduction in the cache footprint of hot vertices. However, in doing so, Sort completely decimates existing graph structure</li><li>Hub Sorting and Hub Clustering both classify vertices as hot or cold based on their degree and preserve the structure for cold vertices. However, in dealing with hot vertices, they resort to inefficient extremes. </li><li>At one extreme, Hub Sorting employs fine-grain reordering that sorts all hot vertices, destroying existing graph structure. At the other extreme, Hub Clustering does not apply any kind of reordering among hot vertices, sacrificing significant opportunity in improving cache efficiency</li></ul><p>we propose Degree-Based Grouping <a href="https://github.com/faldupriyank/dbg">DBG</a>。</p><h4 id="三-how"><a href="#三-how" class="headerlink" title="三 how"></a>三 how</h4><h5 id="3-1-the-dbg-algorithm"><a href="#3-1-the-dbg-algorithm" class="headerlink" title="3.1 the dbg algorithm"></a>3.1 the dbg algorithm</h5><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220512161706297.png" class="" title="image-20220512161706297"><center>  DBG algorithm. Degree can be in-degree or out-degreeor sum of both.</center><h5 id="3-2-the-dbg-example"><a href="#3-2-the-dbg-example" class="headerlink" title="3.2 the dbg example"></a>3.2 the dbg example</h5><p> Vertex degree is shown inside the box while original vertex ID is shown below the box.</p><p>Vertex ordering in memory after DBG. In this example, DBG partitions vertices into three groups with degree ranges [0, 20), [20, 40) and [40, 80). DBG maintains a relative order of vertices within a group. As a result, many vertices are placed nearby the same vertices as before the reordering such as vertex sets (P4, P5, P6), (P0, P1) and (P10, P11).</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220512162204354.png" class="" title="image-20220512162204354"><center>Vertex ordering in memory after DBG. </center><h5 id="3-3-运行作者实验"><a href="#3-3-运行作者实验" class="headerlink" title="3.3 运行作者实验"></a>3.3 运行作者实验</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">1. 编译 这一步注意设置DBG_ROOT, 要不然下面第二部会出现错误</span></span><br><span class="line">export DBG_ROOT=&#x27;/home/server2/dbg&#x27;</span><br><span class="line">cd ~/dbg/apps</span><br><span class="line">make -j </span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">2. 下载数据集</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//el --&gt; edge list of the form (src, dst) <span class="keyword">in</span> text file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//bel --&gt; edge list of the form (src, dst) <span class="keyword">in</span> binary file</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//vgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//cvgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges (no self or redundant edges)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//csvgr --&gt; binary csr format with no weight <span class="keyword">for</span> edges (no self or redundant edges)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//         graph is symmetric -- so <span class="keyword">for</span> every edge (u, v) there also exist (v, u)</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//cintgr --&gt; binary csr format with int weight <span class="keyword">for</span> edges (no slef or redundant edges)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">//edges are assumed to take 8 bytes and vertices (and edge weights) are assumed to take 4 bytes <span class="keyword">in</span> binary file</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">//all *gr files contain a header of 24 bytes as follows:</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//number of vertices</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//number of edges</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//major number</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//minor number</span></span><br><span class="line"><span class="meta">#</span><span class="bash">//gr files are implemented based on the implementation from Galois.</span></span><br><span class="line"></span><br><span class="line">wget http://snap.stanford.edu/data/web-Google.txt.gz</span><br><span class="line">gunzip web-Google.txt.gz</span><br><span class="line">../graph-convert-utils/clean_edgelist.py web-Google.txt web-Google.el</span><br><span class="line">../graph-convert-utils/convert.sh web-Google</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">3. Run individual application， 运行之前安装numactl，否则会出现错误。 安装命令 sudo apt install numactl</span></span><br><span class="line">make REORDERING_ALGO=5 DEGREE_USED_FOR_REORDERING=0 DATASET=web-Google run-PageRank</span><br></pre></td></tr></table></figure><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20220513152610369.png" class="" title="image-20220513152610369"><h3 id="九-Making-caches-work-for-graph-analytics"><a href="#九-Making-caches-work-for-graph-analytics" class="headerlink" title="九 Making caches work for graph analytics"></a>九 Making caches work for graph analytics</h3><p>Hub sorting was proposed as a variant of Sort that aims to preserve some structure while reducing the cache footprint of hot vertices.</p><h3 id="十-Speedup-Graph-Processing-by-Graph-Ordering"><a href="#十-Speedup-Graph-Processing-by-Graph-Ordering" class="headerlink" title="十 Speedup Graph Processing by Graph Ordering"></a>十 Speedup Graph Processing by Graph Ordering</h3><p>Gorder—— the state-of-the-art structure-aware reordering technique.</p><h3 id="十一-如何直接对属性数组进行冷热数据分离"><a href="#十一-如何直接对属性数组进行冷热数据分离" class="headerlink" title="十一 如何直接对属性数组进行冷热数据分离"></a>十一 如何直接对属性数组进行冷热数据分离</h3><blockquote><p>这里对冷热数据分离是什么意思?  </p><p>是划分出high reuse region、Moderate （适度）Reuse Region， 不常用数据？</p></blockquote><h4 id="1-1-DBG-实验"><a href="#1-1-DBG-实验" class="headerlink" title="1.1 DBG 实验"></a>1.1 DBG 实验</h4><p>在dbg的实验中, 将el格式的图转为了cvgr –&gt; binary csr format with no weight for edges (no self or redundant edges), cintgr –&gt; binary csr format with int weight for edges (no slef or redundant edges)。pagerank算法应该是借助 ligra 使用了 cvgr格式的图。这里的话没有cache，还需要自己配置才能获取到冷热数据，因此还要看以前的grasp这个仓库。</p><h4 id="1-2-grasp实验"><a href="#1-2-grasp实验" class="headerlink" title="1.2 grasp实验"></a>1.2 grasp实验</h4><p>在[Domain-Specialized Cache Management for Graph Analytics ](# 图处理相关论文) 这篇论文中,  通过dbg重排序后，作者直接定义了两个cache大小的区域, 分别获取high、 moderate 区域。</p><h3 id="十二-Proceedings-of-the-ACM-on-Measurement-and-Analysis-of-Computing-Systems-Vol-3-No-3-Article-60"><a href="#十二-Proceedings-of-the-ACM-on-Measurement-and-Analysis-of-Computing-Systems-Vol-3-No-3-Article-60" class="headerlink" title="十二  Proceedings of the ACM on Measurement and Analysis of Computing Systems Vol. 3, No. 3, Article 60"></a>十二  Proceedings of the ACM on Measurement and Analysis of Computing Systems Vol. 3, No. 3, Article 60</h3><p>CHARACTERIZATION METRICS</p><h4 id="1-1-Performance-Metrics"><a href="#1-1-Performance-Metrics" class="headerlink" title="1.1 Performance Metrics"></a>1.1 Performance Metrics</h4><ol><li>We measure single-threaded application performance using instructions per cycle (IPC)</li><li>For multithreaded applications, we show parallel speedup (i.e., the single-threaded execution time divided by the parallel execution time), which accounts for synchronization overheads.</li><li>To quantify the memory intensity of an application, we use the number of misses per kilo-instruction (MPKI) issued by the last-level cache for that application to DRAM.</li></ol><h4 id="1-2-Parallelism-Metrics"><a href="#1-2-Parallelism-Metrics" class="headerlink" title="1.2 Parallelism Metrics"></a>1.2 Parallelism Metrics</h4><p>Prior works have used either memory-level parallelism (MLP) [26, 47, 137, 152, 181] or bank-level parallelism (BLP) to quantify the amount of parallelism across memory requests</p><p>MLP measures the average number of outstanding memory requests for an application, but this does not capture the amount of parallelism offered by the underlying hardware.</p><p>BLP measures the average number of memory requests that are actively being serviced for a single thread during a given time interval.</p><img src="/2022/05/15/%E5%9B%BE%E5%A4%84%E7%90%86%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/image-20221004152901298.png" class="" title="image-20221004152901298"><h4 id="1-3-Contention-Metrics"><a href="#1-3-Contention-Metrics" class="headerlink" title="1.3 Contention Metrics"></a>1.3 Contention Metrics</h4><p>An important measure of spatial and temporal locality in memory is the row buffer hit rate, also known as row buffer locality.</p><p>To quantify the row hit rate, prior works count the number of row buffer hits and the number of row buffer misses, which they define as any request that does not hit in the currently-open row.</p><blockquote><p>To accurately capture row buffer locality, we introduce a new characterization methodology where we break down memory requests into: (1) row buffer hits; (2) row buffer misses, which only include misses for a DRAM request where the bank does not have any row open; and (3) row buffer conflicts, which consist of misses where another row is currently open in the bank and must be closed (<code>i.e., precharged</code>) first. Row buffer conflicts provide us with important information about how the amount of parallelism exposed by a DRAM type can limit opportunities to concurrently serve multiple memory requests, which in turn hurts performance.</p></blockquote><p>为了准确捕获行缓冲区局部性，我们引入了一种新的特征方法，将内存请求分解为：</p><p>（1）行缓冲区命中；</p><p>（2）行缓冲区错过，其中仅包括银行没有任何行打开的DRAM请求的错过； </p><p>（3）行缓冲冲突，其中包括当前在银行中打开另一排，必须首先关闭（即预处理）的失误。行缓冲冲突为我们提供了有关DRAM类型暴露的并行量如何限制同时服务多个内存请求的机会，这反过来又损害了性能。</p><h3 id="十三-Graphfire-Synergizing-Fetch-Insertion-and-Replacement-Policies-for-Graph-Analytics"><a href="#十三-Graphfire-Synergizing-Fetch-Insertion-and-Replacement-Policies-for-Graph-Analytics" class="headerlink" title="十三 Graphfire: Synergizing Fetch, Insertion, and Replacement Policies for Graph Analytics"></a>十三 Graphfire: Synergizing Fetch, Insertion, and Replacement Policies for Graph Analytics</h3><blockquote><p> With the goal of optimizing cache performance for graph applications, our work makes the following key observations: (i) The memory hierarchy must specialize for the problematic indirect accesses (PIAs) to alleviate their bottlenecks. (ii) To be software-agnostic, a lightweight mechanism must automatically identify PIAs, which can be achieved on a perinstruction basis. (iii) While PIAs are irregular, a subset of them have high reuse, so the LLC must retain them.</p></blockquote><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2>]]></content>
      
      
      <categories>
          
          <category> 学术论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图重排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OpenMP并行编程</title>
      <link href="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="OpenMP并行编程"><a href="#OpenMP并行编程" class="headerlink" title="OpenMP并行编程"></a>OpenMP并行编程</h2><h3 id="一-编程模型"><a href="#一-编程模型" class="headerlink" title="一 编程模型"></a>一 编程模型</h3><p>OpenMP是共享存储体系结构上的一个并行编程模型。 适合于SMP共享内存多处理系统和多核处理器体系结构。</p><ul><li><p>OpenMP是基于线程的并行编程模型。 </p></li><li><p>OpenMP采用Fork-Join并行执行方式： </p><ul><li>OpenMP程序开始于一个单独的主线程（Master  Thread），然后主线程一直串行执行，直到遇见第 一个并行域(Parallel Region)，然后开始并行执行并行 区域。</li><li>其过程如下： Fork:主线程创建一个并行线程队列，然后，并行域中的代 码在不同的线程上并行执行； Join:当并行域执行完之后，它们或被同步或被中断，最后 只有主线程在</li></ul></li></ul><img src="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/image-20220422102521910.png" class="" title="image-20220422102521910"><hr><h3 id="二-Clion中-Cmake-文件"><a href="#二-Clion中-Cmake-文件" class="headerlink" title="二 Clion中 Cmake 文件"></a>二 Clion中 Cmake 文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">FIND_PACKAGE(OpenMP REQUIRED)</span><br><span class="line">if (OPENMP_FOUND)</span><br><span class="line">    message(&quot;OPENMP FOUND&quot;)</span><br><span class="line">    set(CMAKE_C_FLAGS &quot;$&#123;CMAKE_C_FLAGS&#125; $&#123;OpenMP_C_FLAGS&#125;&quot;)</span><br><span class="line">    set(CMAKE_CXX_FLAGS &quot;$&#123;CMAKE_CXX_FLAGS&#125; $&#123;OpenMP_CXX_FLAGS&#125;&quot;)</span><br><span class="line">endif () </span><br></pre></td></tr></table></figure><h3 id="三-代码实例"><a href="#三-代码实例" class="headerlink" title="三 代码实例"></a>三 代码实例</h3><h4 id="3-1-pragma-omp-parallel"><a href="#3-1-pragma-omp-parallel" class="headerlink" title="3.1 #pragma omp parallel"></a>3.1 #pragma omp parallel</h4><p>parallel制导命令表示接下来由花括号括起来的区域将创建多个线程并行执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Hello, world!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-制导指令-for"><a href="#3-2-制导指令-for" class="headerlink" title="3.2  制导指令 for"></a>3.2  制导指令 for</h4><p>在并行域里面用 <code>#pragma omp for</code>，在这条语句之后的一个for循环语句中每一个要循环的任务将被分配给不同的线程去执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果没有这行代码, 2个线程每一个都将运行一次for循环, 加完这条代码, 2个线程共同运行一次for循环</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面的代码和下面的代码, 结果是相同的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-schdule指令"><a href="#3-3-schdule指令" class="headerlink" title="3.3 schdule指令"></a>3.3 schdule指令</h4><p>在以上的任务中，各个线程自动分配到要执行的任务标号，没有对任务做一些进一步的调度，接下来介绍的字句将会对for循环任务的调度做更细致一些的规定。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">schedule(type, size);</span><br><span class="line"><span class="comment">// type参数有四种：1.static, 2.dynamic, 3.guided, 4.runtime</span></span><br><span class="line"><span class="comment">// size参数是整形数据：表示循环迭代次数划分的单位。</span></span><br></pre></td></tr></table></figure><h5 id="3-3-1-静态调度"><a href="#3-3-1-静态调度" class="headerlink" title="3.3.1 静态调度"></a>3.3.1 静态调度</h5><p>静态调度，不用size参数时分配给每个程序的都是 <code>n/t</code> 次连续迭代，n 为迭代次数，t为并行的线程数目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(static)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-3-2-动态调度"><a href="#3-3-2-动态调度" class="headerlink" title="3.3.2 动态调度"></a>3.3.2 动态调度</h5><p>动态调度模式是先到先得的方式进行任务分配，不用size参数的时候，先把任务干完的线程先取下一个任务，以此类推，而不是一开始就分配固定的任务数。</p><p>使用size参数的时候，分配的任务以size为单位，一次性分配size个。虽然很智能，在任务难度不均衡的时候适合用dynamic，否则会引起过多的任务动态申请的开销。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">2</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for schedule(dynamic,3)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-4-section-指令"><a href="#3-4-section-指令" class="headerlink" title="3.4 section 指令"></a>3.4 section 指令</h4><p>sections 把不同的区域 交给不同的线程去执行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">3</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel sections</span></span><br><span class="line">   &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt;omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp section</span></span><br><span class="line">      &#123;</span><br><span class="line">         <span class="built_in">cout</span> &lt;&lt; omp_get_thread_num();</span><br><span class="line">      &#125;</span><br><span class="line">       </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-single指令"><a href="#3-5-single指令" class="headerlink" title="3.5 single指令"></a>3.5 single指令</h4><p>single制导指令所包含的代码段只有一个线程执行，别的线程跳过该代码，如果没有nowait子句，那么其他线程将会在single制导指令结束的隐式同步点等待。有 <code>nowait</code> 子句其他线程将跳过等待往下执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">omp_set_num_threads(<span class="number">4</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp single</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;single thread=&quot;</span> &lt;&lt; omp_get_thread_num()&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; ++i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-5-注意点-pargma-omp-for"><a href="#3-5-注意点-pargma-omp-for" class="headerlink" title="3.5  注意点 #pargma omp for"></a>3.5  注意点 #pargma omp for</h4><p>单独使用 <code>#pargma omp for</code>, 相当于没有并行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; ++i)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;rank:&quot;</span> &lt;&lt; omp_get_thread_num() &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="comment">// 有序输出100行, 全是进程0 相当于没有并行</span></span><br></pre></td></tr></table></figure><h3 id="四-使用OpenMp-实现-std-accumulate"><a href="#四-使用OpenMp-实现-std-accumulate" class="headerlink" title="四 使用OpenMp 实现 std:: accumulate"></a>四 使用OpenMp 实现 std:: accumulate</h3><blockquote><p>最近刚好在学习C++ 并行编程，学习到了怎么使用多线程实现 <code>std::accumulate</code> , 比较一下两者的差异。</p></blockquote><p>下面是直接运行的代码:  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">sum += dp[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>在上面这个程序中，试图用sum来累加变量和。#pragma omp parallel for告诉编译器要把这个for语句拆开来并行执行。</p><p>注意 sum 定义在并行块外面，所以在并行块中会共享这个变量。也就是说在四个核中用的是同一个变量，对于sum + = i 语句，是先把sum的值取出来和 i 相加后再把结果赋给sum变量。</p><p>既然四个线程用的是同一个sum，那么如果sum在线程0中取出来了，另一个线程中也同时取出来了同样值的sum，加完后值在两个线程中都会被送就回到sum，那么就会造成有一次操作被重写了（数据碰撞），也就是说最后的结果很可能小于正确的结果。</p></blockquote><h4 id="4-1-pragma-omp-critical"><a href="#4-1-pragma-omp-critical" class="headerlink" title="4.1 #pragma omp critical"></a>4.1 #pragma omp critical</h4><p>这条语句是告诉编译器下面的代码块很关键，任何时刻都只能有一个线程执行该代码块。不过这样的话<strong>代码会在多个核中的运行会相互影响</strong>，对性能有一定影响，最好的解决方法是用规约reduction。</p><blockquote></blockquote><h4 id="4-2-reducation-规约"><a href="#4-2-reducation-规约" class="headerlink" title="4.2 reducation(规约)"></a>4.2 reducation(规约)</h4><blockquote><p>reduction (+:sum) 告诉编译器，这并行块要用规约，+表示求和操作，sum是目标变量名。这样的话，编译器就会给每个线程一个sum的拷贝并正确初始化为0，然后<strong>每个线程执行完之后再合并</strong>。规约只适用于固定的操作符。</p><img src="/2022/05/13/OPenMP%E5%B9%B6%E8%A1%8C%E7%BC%96%E7%A8%8B/image-20221121112738508.png" class="" title="image-20221121112738508"></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by sen on 2022/11/21.</span></span><br><span class="line"><span class="comment">// 使用规约求和</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp=&#123;<span class="number">100</span>&#125;;</span><br><span class="line">srand(time(<span class="literal">nullptr</span>));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 随机生成1千万个数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">dp.push_back(rand() % <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">auto</span> start = <span class="built_in">std</span>::chrono::system_clock::now();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> omp parallel for reducation(+:sum)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; ++i) &#123;</span><br><span class="line">sum += dp[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; sum &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;使用openmp所花费的时间为: &quot;</span> </span><br><span class="line">        &lt;&lt; (<span class="built_in">std</span>::chrono::system_clock::now() - start).count() &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-firstprivte和lastprivate"><a href="#4-3-firstprivte和lastprivate" class="headerlink" title="4.3 firstprivte和lastprivate"></a>4.3 firstprivte和lastprivate</h4><blockquote><p>如果我们不想要已经定义了的变量在多个线程中共享，想要让每个线程有自己的拷贝怎么办呢？</p><p>下面就简单介绍一个private从句，以及firstprivate和lastprivate。通过使用#pragma omp parallel private（variable list），告诉编译器在下面的并行块中每个线程都对variable list列出的变量进行拷贝。不过值得注意的时，每个线程中拷贝的变量的初始值是不确定的，执行完并行块后该变量的值也不确定。</p><p>所以就有了firstprivate和lastprivate，firstprivate 是说<strong>变量的初始值就是按照该变量进入并行块之前的值初始化</strong>；lastprivate 是说退出并行块后，按照串行情况最后的一个值给到主线程中的变量。如果同时使用firstprivate和lastprivate，那么该变量就会有和串行是一样的初始值和结束值。</p></blockquote><h3 id="五-参考链接"><a href="#五-参考链接" class="headerlink" title="五 参考链接"></a>五 参考链接</h3><ol><li><p><a href="https://www.jianshu.com/p/796d531c08ed">并行计算工具OpenMP 二</a></p></li><li><p><a href="https://cloud.tencent.com/developer/ask/sof/491657">使用clang-12时，CMake的find_package( OpenMP )找不到OpenMP</a> 保持clang版本与libomp版本一致,  如 clang版本为10, 安装对应的libomp版本.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install libomp-10-dev</span><br></pre></td></tr></table></figure></li><li><p><a href="https://www.ibm.com/docs/en/xl-c-aix/13.1.2?topic=processing-pragma-omp-parallel">pragma omp parallel</a></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How-to-read-papers</title>
      <link href="/2022/05/09/How-to-read-papers/"/>
      <url>/2022/05/09/How-to-read-papers/</url>
      
        <content type="html"><![CDATA[<h2 id="如何阅读论文"><a href="#如何阅读论文" class="headerlink" title="如何阅读论文"></a>如何阅读论文</h2><blockquote><p>研一萌新, 最近在读论文的时候, 读到后半部分，前面讲的什么东西都已经忘完了, 不得不重新回顾。这样读起来有种深陷泥潭、举步维艰的感觉，然后觉得可能是自己读论文的方法有问题——没有从整体上把握整篇论文，只陷于个细节里面去了。感觉自己是时候该学习一下读论文的方法,  提高自己效率。</p></blockquote><p>通常来说，读论文一般有以下四个要素：</p><ul><li>What 这篇论文要解决什么问题？</li><li>Why 这篇文章为什么要解决这个问题, 解决这个问题有什么意义?<ul><li>Importance, implication, relevance</li><li>切入点：现有文献、研究方法</li></ul></li><li>how 这篇文章如何解决了这个问题?<ul><li>Problem formulation, research methods, data, experiments, etc</li></ul></li><li>what 解决这篇文章之后得到怎么样的结论<ul><li>Conclusions, perspectives, outlook, etc.</li></ul></li></ul><h3 id="一-论文各部分的重要性"><a href="#一-论文各部分的重要性" class="headerlink" title="一 论文各部分的重要性"></a>一 论文各部分的重要性</h3><ol><li>摘要 abstract: 论文最重要的部分，一般由导师直接把关</li><li>引言 introduction: 重要性仅次于摘要，内容更加易懂</li><li>相关工作 related work: 对领域内工作的分类和总结</li><li>其他章节: 论文细节，对于理解本论文非常重要。</li><li>总结 conclusion: 全文总结和展望</li><li>参考文献 reference: 论文引用的文献列表</li><li>附录 Appendix: 部分无法放到正文中的内容，如过分细节的证明和算法</li></ol><h3 id="二-快速阅读（泛读）"><a href="#二-快速阅读（泛读）" class="headerlink" title="二 快速阅读（泛读）"></a>二 快速阅读（泛读）</h3><p><strong>观点：</strong></p><ul><li><strong>快速阅读其实是一种技巧，一个捷径。</strong>你可能从这些图片中以及标题中获取大约70%，80%甚至90%的论文信息。</li><li>对于<strong>作者</strong>来说，他会思考论文的任务是什么？研究发现是什么？是什么内容让这篇文章重要且有吸引力？一个论文需要帮助大家明白究竟是想表达什么。站在读者的视角，你需要理解文章的观点。写论文的准则：你必须要让论文易于阅读。你必须要让每个读者都可以轻松阅读。</li><li>对于<strong>读者</strong>来说，我需要学习这篇文章嘛？我有多需要从这篇文章中学习？ 我能学到什么？当我一定程度上理解了文章，对我有什么影响？</li><li><strong>一篇论文包含四个部分，标题，摘要，引言和剩下的部分。</strong>作者应该花等长的时间写这4个部分。 但对于学生来说，大家真的需要大部分精力在实验，公式上。</li></ul><p><strong>如何进行快速阅读：</strong></p><ol><li> <strong>整篇论文都是在概括浓缩（abstraction）的过程中</strong>，引言是文章的浓缩，摘要是引言的浓缩，标题是摘要的浓缩。</li><li><strong>引言：论文是关于什么的？解决什么问题？为什么论文有意思？有什么新的发现？文章为什么是好的？</strong></li><li>摘要：我们可以有层次地阅读论文。我们可以将论文分解并加上一些有趣的亮点，这有利于阅读。<strong>论文中摘要部分说了什么？之后你需要看看这篇论文真正的发现是什么？我为什么需要在意这些东西？</strong></li></ol><p>如果时间有限，直接读abstract是最高效的方法。如果时间还很充裕，那么就把introduction也读一遍。读完这两部分，就应该能基本理解论文的核心思想。</p><p><strong>WARNING</strong>:读得速度越快，对论文的理解越差，甚至会出现误解。因此，想要好好理解一篇论文，精读是非常必要的。</p><h3 id="三-精读"><a href="#三-精读" class="headerlink" title="三 精读"></a>三 精读</h3><p>通过泛读（快速）阅读筛选完论文之后，需要精读部分的重要论文。我个人建议将精读分为几个阶段进行:</p><ol><li>理解论文基本原理: motivation，所用的理论？</li><li>理解论文详细内容: 深入理解论文细节，包括定义、假设和相关公式等</li><li><del>能够重现实验</del>（未必需要）: 能否重现整个实验，并得到相同结果？</li><li>组织讨论: 与其他人进行讨论，可能有没有疏忽的地方？或者理解不到位的地方？</li><li>设计更好的方案: 能不能更进一步，设计更好的方法？</li></ol><p><strong>每个阶段可以对应一次或者多次阅读，通过多次阅读来加深对论文的理解</strong>。不要指望一口气能够理解整篇论文。很多原因会造成理解不够深入甚至理解错误，例如现阶段的知识面不够，或者对于某些概念理解错误等。所以需要多次阅读（如果有必要，多次讨论）来避免这类问题。</p><p><strong>WARNING</strong>:讨论是非常必要的（最好由阅读论文的人主讲），当其他人从他的角度提出疑问时，很可能会给意想不到的惊喜。</p><h3 id="四-沈向洋-经读论文的方法"><a href="#四-沈向洋-经读论文的方法" class="headerlink" title="四 沈向洋: 经读论文的方法"></a>四 沈向洋: 经读论文的方法</h3><ol><li><p>批判性阅读</p><ul><li><strong>批判性阅读的核心就是不断否定，不断质问，不断怀疑。</strong></li><li><strong>由于批判性阅读会花费很多时间，你可能时不时卡住。我建议你，不要惊慌失措！批判性阅读确实很难，但你要坚持下去，定能度过难关。</strong></li><li><strong>搞明白你可以到哪里获取帮助，可以求助谁。但要站在对方角度进行思考，不能过多占用对方的时间。</strong></li></ul></li><li><p>创造性阅读</p><ul><li>简单地说，如果我要根据这篇论文做一些研究，有什么新的东西我可以做？最终，你<strong>需要根据你所学的论文以及相关的论文思考，你是否有足够棒的想法能够让你在未来三到五月里进行相关研究？</strong></li><li><strong>真正理解论文是能够根据论文提出问题并回答问题。</strong></li></ul></li><li><p>问题列表</p><ul><li>客观性问题：论文是关于什么的？核心观点是什么？有什么局限性？作者有没有公开代码？数据是否可用？这个想法是否真的不错？论文中想法是否有违直觉？论文的贡献是否重要？实验做的如何？</li><li>主观性问题：关于这篇论文我有没有遗漏的地方？这篇论文对我有没有帮助？我是否可以直接用文中的方法解决问题？这篇论文是否值得持续研究下去？别人对这篇论文有什么想法呢？谁是这个领域的专家？<strong>如果我有机会见到论文的作者，我会问什么问题？</strong></li></ul></li></ol><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ol><li><a href="https://github.com/Richardyu114/How-to-Read-and-Write-Research-Paper">How-to-Read-and-Write-Research-Paper</a></li><li><a href="https://github.com/qiyuangong/How_to_Search_and_Read_a_Paper">How_to_Search_and_Read_a_Paper</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学术论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 怎么读论文 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pinatrace</title>
      <link href="/2022/05/03/Pintool/"/>
      <url>/2022/05/03/Pintool/</url>
      
        <content type="html"><![CDATA[<h4 id="一-Inter-pin-使用简介"><a href="#一-Inter-pin-使用简介" class="headerlink" title="一 Inter pin 使用简介"></a>一 Inter pin 使用简介</h4><blockquote><p>其实在研一上学期，就接触pin了，但仅仅只停留在理论上，没有实践。本次主要使用pin来获取某一个段代码访问内存的trace。官网给出的examples中有一个pinatrace.cpp, 只能获取到<strong>整个代码的访问trace</strong>, 因此需要对pintrace.cpp做出一个更改。</p></blockquote><blockquote><p>现在pin版本已经更新到了pin 3.22, 下载链接:  <a href="https://www.intel.com/content/www/us/en/developer/articles/tool/pin-a-binary-instrumentation-tool-downloads.html">Pin - A Binary Instrumentation Tool - Downloads</a></p></blockquote><blockquote><p>由于网上可以搜到的大多pintools工具都是几年前的,  因此提供一个旧版本的pin下载链接:  <a href="https://github.com/wangziqi2013/wangziqi2013.github.io/blob/master/static/pin-2.14.tar.gz">Pin 2.14 下载链接</a> <a href="http://software.intel.com/sites/landingpage/pintool/downloads/pin-3.5-97503-gac534ca30-gcc-linux.tar.gz">pin 3.5 下载链接</a> <a href="https://software.intel.com/sites/landingpage/pintool/downloads/pin-3.7-97619-g0d0c92f4f-gcc-linux.tar.gz">pin 3.7 下载链接</a></p></blockquote><blockquote><p>用户手册: <a href="https://software.intel.com/sites/landingpage/pintool/docs/98547/Pin/html/index.html#BuildingInsideKit">Pin 3.22 User Guide</a></p></blockquote><h4 id="二-代码示例"><a href="#二-代码示例" class="headerlink" title="二 代码示例"></a>二 代码示例</h4><h5 id="2-1-pinatrace-cpp"><a href="#2-1-pinatrace-cpp" class="headerlink" title="2.1 pinatrace.cpp"></a>2.1 pinatrace.cpp</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;pin.H&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> CHAR * ROI_BEGIN = <span class="string">&quot;__app_roi_begin&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> CHAR * ROI_END = <span class="string">&quot;__app_roi_end&quot;</span>;</span><br><span class="line"></span><br><span class="line">FILE * trace;</span><br><span class="line"><span class="keyword">bool</span> isROI = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a memory read record</span></span><br><span class="line"><span class="function">VOID <span class="title">RecordMemRead</span><span class="params">(VOID * ip, VOID * addr, CHAR * rtn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return if not in ROI</span></span><br><span class="line">    <span class="keyword">if</span>(!isROI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Log memory access in CSV</span></span><br><span class="line">    <span class="comment">//fprintf(trace,&quot;%p,R,%p\n&quot;, ip, addr);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;%p\n&quot;</span>,addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Print a memory write record</span></span><br><span class="line"><span class="function">VOID <span class="title">RecordMemWrite</span><span class="params">(VOID * ip, VOID * addr, CHAR * rtn)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Return if not in ROI</span></span><br><span class="line">    <span class="keyword">if</span>(!isROI)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Log memory access in CSV</span></span><br><span class="line">    <span class="comment">//fprintf(trace,&quot;%p,W,%p\n&quot;, ip, addr);</span></span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;%p\n&quot;</span>, addr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set ROI flag</span></span><br><span class="line"><span class="function">VOID <span class="title">StartROI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isROI = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Set ROI flag</span></span><br><span class="line"><span class="function">VOID <span class="title">StopROI</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    isROI = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Is called for every instruction and instruments reads and writes</span></span><br><span class="line"><span class="function">VOID <span class="title">Instruction</span><span class="params">(INS ins, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Instruments memory accesses using a predicated call, i.e.</span></span><br><span class="line">    <span class="comment">// the instrumentation is called iff the instruction will actually be executed.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// On the IA-32 and Intel(R) 64 architectures conditional moves and REP</span></span><br><span class="line">    <span class="comment">// prefixed instructions appear as predicated instructions in Pin.</span></span><br><span class="line">    UINT32 memOperands = INS_MemoryOperandCount(ins);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Iterate over each memory operand of the instruction.</span></span><br><span class="line">    <span class="keyword">for</span> (UINT32 memOp = <span class="number">0</span>; memOp &lt; memOperands; memOp++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Get routine name if valid</span></span><br><span class="line">        <span class="keyword">const</span> CHAR * name = <span class="string">&quot;invalid&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(RTN_Valid(INS_Rtn(ins)))</span><br><span class="line">        &#123;</span><br><span class="line">            name = RTN_Name(INS_Rtn(ins)).c_str();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (INS_MemoryOperandIsRead(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            INS_InsertPredicatedCall(</span><br><span class="line">                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemRead,</span><br><span class="line">                IARG_INST_PTR,</span><br><span class="line">                IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                IARG_ADDRINT, name,</span><br><span class="line">                IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// Note that in some architectures a single memory operand can be</span></span><br><span class="line">        <span class="comment">// both read and written (for instance incl (%eax) on IA-32)</span></span><br><span class="line">        <span class="comment">// In that case we instrument it once for read and once for write.</span></span><br><span class="line">        <span class="keyword">if</span> (INS_MemoryOperandIsWritten(ins, memOp))</span><br><span class="line">        &#123;</span><br><span class="line">            INS_InsertPredicatedCall(</span><br><span class="line">                ins, IPOINT_BEFORE, (AFUNPTR)RecordMemWrite,</span><br><span class="line">                IARG_INST_PTR,</span><br><span class="line">                IARG_MEMORYOP_EA, memOp,</span><br><span class="line">                IARG_ADDRINT, name,</span><br><span class="line">                IARG_END);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pin calls this function every time a new rtn is executed</span></span><br><span class="line"><span class="function">VOID <span class="title">Routine</span><span class="params">(RTN rtn, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Get routine name</span></span><br><span class="line">    <span class="keyword">const</span> CHAR * name = RTN_Name(rtn).c_str();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">strcmp</span>(name,ROI_BEGIN) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Start tracing after ROI begin exec</span></span><br><span class="line">        RTN_Open(rtn);</span><br><span class="line">        RTN_InsertCall(rtn, IPOINT_AFTER, (AFUNPTR)StartROI, IARG_END);</span><br><span class="line">        RTN_Close(rtn);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="built_in">strcmp</span>(name,ROI_END) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Stop tracing before ROI end exec</span></span><br><span class="line">        RTN_Open(rtn);</span><br><span class="line">        RTN_InsertCall(rtn, IPOINT_BEFORE, (AFUNPTR)StopROI, IARG_END);</span><br><span class="line">        RTN_Close(rtn);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pin calls this function at the end</span></span><br><span class="line"><span class="function">VOID <span class="title">Fini</span><span class="params">(INT32 code, VOID *v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fclose(trace);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Print Help Message                                                    */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="function">INT32 <span class="title">Usage</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PIN_ERROR( <span class="string">&quot;This Pintool prints a trace of memory addresses\n&quot;</span></span><br><span class="line">              + KNOB_BASE::StringKnobSummary() + <span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"><span class="comment">/* Main                                                                  */</span></span><br><span class="line"><span class="comment">/* ===================================================================== */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// Initialize symbol table code, needed for rtn instrumentation</span></span><br><span class="line">    PIN_InitSymbols();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Usage</span></span><br><span class="line">    <span class="keyword">if</span> (PIN_Init(argc, argv)) <span class="keyword">return</span> Usage();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open trace file and write header</span></span><br><span class="line">    trace = fopen(<span class="string">&quot;roitrace.csv&quot;</span>, <span class="string">&quot;w&quot;</span>);</span><br><span class="line">    <span class="built_in">fprintf</span>(trace,<span class="string">&quot;pc,rw,addr,rtn\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add instrument functions</span></span><br><span class="line">    RTN_AddInstrumentFunction(Routine, <span class="number">0</span>);</span><br><span class="line">    INS_AddInstrumentFunction(Instruction, <span class="number">0</span>);</span><br><span class="line">    PIN_AddFiniFunction(Fini, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Never returns</span></span><br><span class="line">    PIN_StartProgram();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>修改完pinatrace.cpp 后, 重新make, 生成pinatrace.so文件。</p></blockquote><h5 id="2-2-roi-h"><a href="#2-2-roi-h" class="headerlink" title="2.2 roi.h"></a>2.2 roi.h</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _ROI_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  _ROI_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* General Markers */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noinline)) __app_roi_begin()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __attribute__ ((noinline)) __app_roi_end()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">asm</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h5 id="2-3-hello-world-cpp"><a href="#2-3-hello-world-cpp" class="headerlink" title="2.3 hello_world.cpp"></a>2.3 hello_world.cpp</h5><p><strong>注意</strong>: hello_world.cpp 中必须包含 <code>extern &quot;C&quot; &#123; #include &lt;roi.h&gt; &#125;</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;roi.h&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">    __app_roi_begin();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt;<span class="string">&quot;hello,world!\n&quot;</span>;</span><br><span class="line">    __app_roi_end();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;second line!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    hello();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 对hello_world 进行编译, 此处-I.表示从当前目录寻找extern <span class="string">&quot;C&quot;</span> &#123;<span class="comment">#include &lt;roi.h&gt;&#125;中的roi.h。</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> -I 头文件 例如xx.h， 寻找的顺序是：-I&#123;path&#125;–&gt;/usr/include–&gt;/usr/<span class="built_in">local</span>/include</span></span><br><span class="line">g++ -o hello_world hello_world.cpp -I.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 运行</span></span><br><span class="line">~/pin-3.21-bak/pin -t ~/pin-3.21-bak/source/tools/ManualExamples/obj-intel64/pinatrace.so -- ./hello_world</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">结果生成 roitrace.csv</span></span><br></pre></td></tr></table></figure><p>参考链接：</p><ol><li><p><a href="https://github.com/vnaveen0/pin_tools">pin_tools</a></p></li><li><p><a href="https://stackoverflow.com/questions/32026456/how-can-i-specify-an-area-of-code-to-instrument-it-by-pintool/32029564#32029564">How can i specify an area of code to instrument it by pintool?</a></p></li><li><p><a href="https://bbs.pediy.com/thread-269711.htm">有毒的学Pin记录（一）</a></p></li><li><p><a href="http://brieflyx.me/2017/binary-analysis/intel-pin-intro/">Intel Pin 基本用法</a></p></li><li><p><a href="https://anhkgg.com/pin-use-note-function-analysis/">pin使用小记-函数分析</a></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
            <tag> pintools </tag>
            
            <tag> memtoryTrace </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颈肩操</title>
      <link href="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/"/>
      <url>/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/</url>
      
        <content type="html"><![CDATA[<h4 id="放松颈肩-环节疲劳"><a href="#放松颈肩-环节疲劳" class="headerlink" title="放松颈肩, 环节疲劳"></a>放松颈肩, 环节疲劳</h4><p>珍爱生命, 远离ICU, 经过本人测试, 本套颈肩操可以有效缓解颈部疲劳, 放在博客提醒自己。</p><h4 id="第一节-颈部捏按"><a href="#第一节-颈部捏按" class="headerlink" title="第一节 颈部捏按"></a>第一节 颈部捏按</h4><blockquote><p>3次为一组，连续捏按8组。</p><p>左右各8组，交替进行。</p><p>保持轻柔和缓，捏按力度，持续渗透。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153521407.png" class="" title="image-20220417153521407"><h4 id="第二节-左顾右盼"><a href="#第二节-左顾右盼" class="headerlink" title="第二节 左顾右盼"></a>第二节 左顾右盼</h4><blockquote><p>缓慢转向一侧，保持3秒钟。</p><p>左右各8组。</p><p>注意旋转要匀速和缓，切忌猛烈地转动</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153637390.png" class="" title="image-20220417153637390"><h4 id="第三节-前俯后仰"><a href="#第三节-前俯后仰" class="headerlink" title="第三节 前俯后仰"></a>第三节 前俯后仰</h4><blockquote><p>前后各自保持3秒钟。<br>重复做8次。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153737110.png" class="" title="image-20220417153737110"><h4 id="第四节-左右侧曲"><a href="#第四节-左右侧曲" class="headerlink" title="第四节 左右侧曲"></a>第四节 左右侧曲</h4><blockquote><p>左右到位后，各自坚持3秒。左右各8次.</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153845908.png" class="" title="image-20220417153845908"><h4 id="第五节-悬肩舒颈"><a href="#第五节-悬肩舒颈" class="headerlink" title="第五节 悬肩舒颈"></a>第五节 悬肩舒颈</h4><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417153937510.png" class="" title="image-20220417153937510"><h4 id="第六节-头颈相抗"><a href="#第六节-头颈相抗" class="headerlink" title="第六节 头颈相抗"></a>第六节 头颈相抗</h4><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154028268.png" class="" title="image-20220417154028268"><h4 id="第七节-颈项争力"><a href="#第七节-颈项争力" class="headerlink" title="第七节 颈项争力"></a>第七节 颈项争力</h4><blockquote><p>左手置于胸前, 右手置于背后, 手掌向右平行推出, 颈部向左转动, 保持三秒钟.</p><p>再换右手, 重复八次。 </p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154105726.png" class="" title="image-20220417154105726"><h4 id="第八节-仰头忘掌"><a href="#第八节-仰头忘掌" class="headerlink" title="第八节 仰头忘掌"></a>第八节 仰头忘掌</h4><blockquote><p>仰视手背, 配合深呼吸, 重复八次。</p></blockquote><img src="/2022/04/17/%E9%A2%88%E8%82%A9%E6%93%8D/image-20220417154614780.png" class="" title="image-20220417154614780"><h4 id="视频链接"><a href="#视频链接" class="headerlink" title="视频链接:"></a>视频链接:</h4><p><a href="https://www.bilibili.com/video/BV1ci4y1S7en?spm_id_from=333.999.0.0">北汽颈肩操</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 放松自己 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>正则表达式</title>
      <link href="/2022/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/2022/04/15/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是正则表达式-？"><a href="#什么是正则表达式-？" class="headerlink" title="什么是正则表达式 ？"></a>什么是正则表达式 ？</h2><blockquote><p>正则表达式是一种被用于从文本中检索符合某些特定模式的文本。</p></blockquote><p>正则表达式是从左到右来匹配一个字符串的。“Regular Expression”这个词太长了，我们通常使用它的缩写“regex”或者“regexp”。<br>正则表达式可以被用来替换字符串中的文本、验证表单、基于模式匹配从一个字符串中提取字符串等等。</p><p>想象一下，您正在编写应用程序，并且您希望在用户选择用户名时设置规则。我们希望用户名可以包含字母，数字，下划线和连字符。<br>为了让它看起来不丑，我们还想限制用户名中的字符数量。这时我们可以使用以下正则表达式来验证用户名：</p><p align="center"><img src="https://i.imgur.com/UrDb9qc.png" alt="Regular expression"></p><p>上面这个正则表达式可以匹配 <code>john_doe</code>，<code>jo-hn_doe</code> 和 <code>john12_as</code>。但是它不能匹配 <code>Jo</code>，因为该字符串里面包含大写字符，并且它太短了。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#1-%E5%9F%BA%E6%9C%AC%E5%8C%B9%E9%85%8D">基本匹配</a></li><li><a href="#2-%E5%85%83%E5%AD%97%E7%AC%A6">元字符</a><ul><li><a href="#21-%E8%8B%B1%E6%96%87%E5%8F%A5%E5%8F%B7">英文句号</a></li><li><a href="#22-%E5%AD%97%E7%AC%A6%E9%9B%86">字符集</a><ul><li><a href="#221-%E5%90%A6%E5%AE%9A%E5%AD%97%E7%AC%A6%E9%9B%86">否定字符集</a></li></ul></li><li><a href="#23-%E9%87%8D%E5%A4%8D">重复</a><ul><li><a href="#231-%E6%98%9F%E5%8F%B7">星号</a></li><li><a href="#232-%E5%8A%A0%E5%8F%B7">加号</a></li><li><a href="#233-%E9%97%AE%E5%8F%B7">问号</a></li></ul></li><li><a href="#24-%E8%8A%B1%E6%8B%AC%E5%8F%B7">花括号</a></li><li><a href="#25-%E5%AD%97%E7%AC%A6%E7%BB%84">字符组</a></li><li><a href="#26-%E5%88%86%E6%94%AF%E7%BB%93%E6%9E%84">分支结构</a></li><li><a href="#27-%E8%BD%AC%E4%B9%89%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6">转义特殊字符</a></li><li><a href="#28-%E5%AE%9A%E4%BD%8D%E7%AC%A6">定位符</a><ul><li><a href="#281-%E6%8F%92%E5%85%A5%E7%AC%A6%E5%8F%B7">插入符号</a></li><li><a href="#282-%E7%BE%8E%E5%85%83%E7%AC%A6%E5%8F%B7">美元符号</a></li></ul></li></ul></li><li><a href="#3-%E7%AE%80%E5%86%99%E5%AD%97%E7%AC%A6%E9%9B%86">简写字符集</a></li><li><a href="#4-%E6%96%AD%E8%A8%80">断言</a><ul><li><a href="#41-%E6%AD%A3%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">正向先行断言</a></li><li><a href="#42-%E8%B4%9F%E5%90%91%E5%85%88%E8%A1%8C%E6%96%AD%E8%A8%80">负向先行断言</a></li><li><a href="#43-%E6%AD%A3%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">正向后行断言</a></li><li><a href="#44-%E8%B4%9F%E5%90%91%E5%90%8E%E8%A1%8C%E6%96%AD%E8%A8%80">负向后行断言</a></li></ul></li><li><a href="#5-%E6%A0%87%E8%AE%B0">标记</a><ul><li><a href="#51-%E4%B8%8D%E5%8C%BA%E5%88%86%E5%A4%A7%E5%B0%8F%E5%86%99">不区分大小写</a></li><li><a href="#52-%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2">全局搜索</a></li><li><a href="#53-%E5%A4%9A%E8%A1%8C%E5%8C%B9%E9%85%8D">多行匹配</a></li></ul></li><li><a href="#%E5%B8%B8%E7%94%A8%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F">常用正则表达式</a></li></ul><h2 id="1-基本匹配"><a href="#1-基本匹配" class="headerlink" title="1. 基本匹配"></a>1. 基本匹配</h2><p>正则表达式只是我们用于在文本中检索字符串的模式。例如正则表达式 <code>cat</code>，表示：字母 <code>c</code> 后面跟着一个字母 <code>a</code>，再后面跟着一个字母 <code>t</code>。</p><pre>"cat" => The <a href="#learn-regex"><strong>cat</strong></a> sat on the mat</pre><p>正则表达式 <code>123</code> 会匹配字符串“123”。通过将正则表达式中的每个字符逐个与要匹配的字符串中的每个字符进行比较，来完成正则匹配。<br>正则表达式通常区分大小写，因此正则表达式 <code>Cat</code> 与字符串“cat”不匹配。</p><pre>"Cat" => The cat sat on the <a href="#learn-regex"><strong>Cat</strong></a></pre><h2 id="2-元字符"><a href="#2-元字符" class="headerlink" title="2. 元字符"></a>2. 元字符</h2><p>元字符是正则表达式的基本组成元素。元字符在这里跟它通常表达的意思不一样，而是以某种特殊的含义去解释。有些元字符在写在方括号内时有特殊含义。<br>元字符如下：</p><table><thead><tr><th align="center">元字符</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配除换行符以外的任意字符。</td></tr><tr><td align="center">[ ]</td><td>字符类，匹配方括号中包含的任意字符。</td></tr><tr><td align="center">[^ ]</td><td>否定字符类。匹配方括号中不包含的任意字符</td></tr><tr><td align="center">*</td><td>匹配前面的子表达式零次或多次</td></tr><tr><td align="center">+</td><td>匹配前面的子表达式一次或多次</td></tr><tr><td align="center">?</td><td>匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。</td></tr><tr><td align="center">{n,m}</td><td>花括号，匹配前面字符至少 n 次，但是不超过 m 次。</td></tr><tr><td align="center">(xyz)</td><td>字符组，按照确切的顺序匹配字符 xyz。</td></tr><tr><td align="center">&#124;</td><td>分支结构，匹配符号之前的字符或后面的字符。</td></tr><tr><td align="center">&#92;</td><td>转义符，它可以还原元字符原来的含义，允许你匹配保留字符 <code>[ ] ( ) &#123; &#125; . * + ? ^ $ \ &#124;</code></td></tr><tr><td align="center">^</td><td>匹配行的开始</td></tr><tr><td align="center">$</td><td>匹配行的结束</td></tr></tbody></table><h2 id="2-1-英文句号"><a href="#2-1-英文句号" class="headerlink" title="2.1 英文句号"></a>2.1 英文句号</h2><p>英文句号 <code>.</code> 是元字符的最简单的例子。元字符 <code>.</code> 可以匹配任意单个字符。它不会匹配换行符和新行的字符。例如正则表达式 <code>.ar</code>，表示：任意字符后面跟着一个字母 <code>a</code>，<br>再后面跟着一个字母 <code>r</code>。</p><pre>".ar" => The <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-2-字符集"><a href="#2-2-字符集" class="headerlink" title="2.2 字符集"></a>2.2 字符集</h2><p>字符集也称为字符类。方括号被用于指定字符集。使用字符集内的连字符来指定字符范围。方括号内的字符范围的顺序并不重要。<br>例如正则表达式 <code>[Tt]he</code>，表示：大写 <code>T</code> 或小写 <code>t</code> ，后跟字母 <code>h</code>，再后跟字母 <code>e</code>。</p><pre>"[Tt]he" => <a href="#learn-regex"><strong>The</strong></a> car parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><p>然而，字符集中的英文句号表示它字面的含义。正则表达式 <code>ar[.]</code>，表示小写字母 <code>a</code>，后面跟着一个字母 <code>r</code>，再后面跟着一个英文句号 <code>.</code> 字符。</p><pre>"ar[.]" => A garage is a good place to park a c<a href="#learn-regex"><strong>ar.</strong></a></pre><h3 id="2-2-1-否定字符集"><a href="#2-2-1-否定字符集" class="headerlink" title="2.2.1 否定字符集"></a>2.2.1 否定字符集</h3><p>一般来说插入字符 <code>^</code> 表示一个字符串的开始，但是当它在方括号内出现时，它会取消字符集。例如正则表达式 <code>[^c]ar</code>，表示：除了字母 <code>c</code> 以外的任意字符，后面跟着字符 <code>a</code>，<br>再后面跟着一个字母 <code>r</code>。</p><pre>"[^c]ar" => The car <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-3-重复"><a href="#2-3-重复" class="headerlink" title="2.3 重复"></a>2.3 重复</h2><p>以下元字符 <code>+</code>，<code>*</code> 或 <code>?</code> 用于指定子模式可以出现多少次。这些元字符在不同情况下的作用不同。</p><h3 id="2-3-1-星号"><a href="#2-3-1-星号" class="headerlink" title="2.3.1 星号"></a>2.3.1 星号</h3><p>星号 <code>*</code> 表示匹配上一个匹配规则零次或多次。正则表达式 <code>a*</code> 表示小写字母 <code>a</code> 可以重复零次或者多次。但是它如果出现在字符集或者字符类之后，它表示整个字符集的重复。<br>例如正则表达式 <code>[a-z]*</code>，表示：一行中可以包含任意数量的小写字母。</p><pre>"[a-z]*" => T<a href="#learn-regex"><strong>he</strong></a> <a href="#learn-regex"><strong>car</strong></a> <a href="#learn-regex"><strong>parked</strong></a> <a href="#learn-regex"><strong>in</strong></a> <a href="#learn-regex"><strong>the</strong></a> <a href="#learn-regex"><strong>garage</strong></a> #21.</pre><p>星号 <code>*</code> 可以与元符号 <code>.</code> 用在一起，用来匹配任意字符串 <code>.*</code>。星号 <code>*</code> 可以与空格符 <code>\s</code> 一起使用，用来匹配一串空格字符。<br>例如正则表达式 <code>\s*cat\s*</code>，表示：零个或多个空格，后面跟小写字母 <code>c</code>，再后面跟小写字母 <code>a</code>，再在后面跟小写字母 <code>t</code>，后面再跟零个或多个空格。</p><pre>"\s*cat\s*" => The fat<a href="#learn-regex"><strong> cat </strong></a>sat on the <a href="#learn-regex"><strong>cat</strong></a>.</pre><h3 id="2-3-2-加号"><a href="#2-3-2-加号" class="headerlink" title="2.3.2 加号"></a>2.3.2 加号</h3><p>加号 <code>+</code> 表示匹配上一个字符一次或多次。例如正则表达式 <code>c.+t</code>，表示：一个小写字母 <code>c</code>，后跟任意数量的字符，后跟小写字母 <code>t</code>。</p><pre>"c.+t" => The fat <a href="#learn-regex"><strong>cat sat on the mat</strong></a>.</pre><h3 id="2-3-3-问号"><a href="#2-3-3-问号" class="headerlink" title="2.3.3 问号"></a>2.3.3 问号</h3><p>在正则表达式中，元字符 <code>?</code> 用来表示前一个字符是可选的。该符号匹配前一个字符零次或一次。<br>例如正则表达式 <code>[T]?he</code>，表示：可选的大写字母 <code>T</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p><pre>"[T]he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><pre>"[T]?he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in t<a href="#learn-regex"><strong>he</strong></a> garage.</pre><h2 id="2-4-花括号"><a href="#2-4-花括号" class="headerlink" title="2.4 花括号"></a>2.4 花括号</h2><p>在正则表达式中花括号（也被称为量词？）用于指定字符或一组字符可以重复的次数。例如正则表达式 <code>[0-9]&#123;2,3&#125;</code>，表示：匹配至少 2 位数字但不超过 3 位（0 到 9 范围内的字符）。</p><pre>"[0-9]{2,3}" => The number was 9.<a href="#learn-regex"><strong>999</strong></a>7 but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><p>我们可以省略第二个数字。例如正则表达式 <code>[0-9]&#123;2,&#125;</code>，表示：匹配 2 个或更多个数字。如果我们也删除逗号，则正则表达式 <code>[0-9]&#123;2&#125;</code>，表示：匹配正好为 2 位数的数字。</p><pre>"[0-9]{2,}" => The number was 9.<a href="#learn-regex"><strong>9997</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><pre>"[0-9]{2}" => The number was 9.<a href="#learn-regex"><strong>99</strong></a><a href="#learn-regex"><strong>97</strong></a> but we rounded it off to <a href="#learn-regex"><strong>10</strong></a>.0.</pre><h2 id="2-5-字符组"><a href="#2-5-字符组" class="headerlink" title="2.5 字符组"></a>2.5 字符组</h2><p>字符组是一组写在圆括号内的子模式 <code>(...)</code>。正如我们在正则表达式中讨论的那样，如果我们把一个量词放在一个字符之后，它会重复前一个字符。<br>但是，如果我们把量词放在一个字符组之后，它会重复整个字符组。<br>例如正则表达式 <code>(ab)*</code> 表示匹配零个或多个的字符串“ab”。我们还可以在字符组中使用元字符 <code>|</code>。例如正则表达式 <code>(c|g|p)ar</code>，表示：小写字母 <code>c</code>、<code>g</code> 或 <code>p</code> 后面跟字母 <code>a</code>，后跟字母 <code>r</code>。</p><pre>"(c|g|p)ar" => The <a href="#learn-regex"><strong>car</strong></a> is <a href="#learn-regex"><strong>par</strong></a>ked in the <a href="#learn-regex"><strong>gar</strong></a>age.</pre><h2 id="2-6-分支结构"><a href="#2-6-分支结构" class="headerlink" title="2.6 分支结构"></a>2.6 分支结构</h2><p>在正则表达式中垂直条 <code>|</code> 用来定义分支结构，分支结构就像多个表达式之间的条件。现在你可能认为这个字符集和分支结构的工作方式一样。<br>但是字符集和分支结构巨大的区别是字符集只在字符级别上有作用，然而分支结构在表达式级别上依然可以使用。<br>例如正则表达式 <code>(T|t)he|car</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟小写字母 <code>h</code>，后跟小写字母 <code>e</code>，或匹配小写字母 <code>c</code>，后跟小写字母 <code>a</code>，后跟小写字母 <code>r</code>。</p><pre>"(T|t)he|car" => <a href="#learn-regex"><strong>The</strong></a> <a href="#learn-regex"><strong>car</strong></a> is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><h2 id="2-7-转义特殊字符"><a href="#2-7-转义特殊字符" class="headerlink" title="2.7 转义特殊字符"></a>2.7 转义特殊字符</h2><p>正则表达式中使用反斜杠 <code>\</code> 来转义下一个字符。这将允许你使用保留字符来作为匹配字符 <code>&#123; &#125; [ ] / \ + * . $ ^ | ?</code>。在特殊字符前面加 <code>\</code>，就可以使用它来做匹配字符。<br>例如正则表达式 <code>.</code> 是用来匹配除了换行符以外的任意字符。现在要在输入字符串中匹配 <code>.</code> 字符，正则表达式 <code>(f|c|m)at\.?</code>，表示：小写字母 <code>f</code>、<code>c</code> 或者 <code>m</code> 后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟可选的 <code>.</code> 字符。</p><pre>"(f|c|m)at\.?" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> sat on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h2 id="2-8-定位符"><a href="#2-8-定位符" class="headerlink" title="2.8 定位符"></a>2.8 定位符</h2><p>在正则表达式中，为了检查匹配符号是否是起始符号或结尾符号，我们使用定位符。<br>定位符有两种类型：第一种类型是 <code>^</code> 检查匹配字符是否是起始字符，第二种类型是 <code>$</code>，它检查匹配字符是否是输入字符串的最后一个字符。</p><h3 id="2-8-1-插入符号"><a href="#2-8-1-插入符号" class="headerlink" title="2.8.1 插入符号"></a>2.8.1 插入符号</h3><p>插入符号 <code>^</code> 符号用于检查匹配字符是否是输入字符串的第一个字符。如果我们使用正则表达式 <code>^a</code>（如果 a 是起始符号）匹配字符串 <code>abc</code>，它会匹配到 <code>a</code>。<br>但是如果我们使用正则表达式 <code>^b</code>，它是匹配不到任何东西的，因为在字符串 <code>abc</code> 中“b”不是起始字符。<br>让我们来看看另一个正则表达式 <code>^(T|t)he</code>，这表示：大写字母 <code>T</code> 或小写字母 <code>t</code> 是输入字符串的起始符号，后面跟着小写字母 <code>h</code>，后跟小写字母 <code>e</code>。</p><pre>"(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in <a href="#learn-regex"><strong>the</strong></a> garage.</pre><pre>"^(T|t)he" => <a href="#learn-regex"><strong>The</strong></a> car is parked in the garage.</pre><h3 id="2-8-2-美元符号"><a href="#2-8-2-美元符号" class="headerlink" title="2.8.2 美元符号"></a>2.8.2 美元符号</h3><p>美元 <code>$</code> 符号用于检查匹配字符是否是输入字符串的最后一个字符。例如正则表达式 <code>(at\.)$</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，后跟一个 <code>.</code> 字符，且这个匹配器必须是字符串的结尾。</p><pre>"(at\.)" => The fat c<a href="#learn-regex"><strong>at.</strong></a> s<a href="#learn-regex"><strong>at.</strong></a> on the m<a href="#learn-regex"><strong>at.</strong></a></pre><pre>"(at\.)$" => The fat cat sat on the m<a href="#learn-regex"><strong>at.</strong></a></pre><h2 id="3-简写字符集"><a href="#3-简写字符集" class="headerlink" title="3. 简写字符集"></a>3. 简写字符集</h2><p>正则表达式为常用的字符集和常用的正则表达式提供了简写。简写字符集如下：</p><table><thead><tr><th align="center">简写</th><th>描述</th></tr></thead><tbody><tr><td align="center">.</td><td>匹配除换行符以外的任意字符</td></tr><tr><td align="center">\w</td><td>匹配所有字母和数字的字符：<code>[a-zA-Z0-9_]</code></td></tr><tr><td align="center">\W</td><td>匹配非字母和数字的字符：<code>[^\w]</code></td></tr><tr><td align="center">\d</td><td>匹配数字：<code>[0-9]</code></td></tr><tr><td align="center">\D</td><td>匹配非数字：<code>[^\d]</code></td></tr><tr><td align="center">\s</td><td>匹配空格符：<code>[\t\n\f\r\p&#123;Z&#125;]</code></td></tr><tr><td align="center">\S</td><td>匹配非空格符：<code>[^\s]</code></td></tr></tbody></table><h2 id="4-断言"><a href="#4-断言" class="headerlink" title="4. 断言"></a>4. 断言</h2><p>后行断言和先行断言有时候被称为断言，它们是特殊类型的 <strong><em>非捕获组</em></strong>（用于匹配模式，但不包括在匹配列表中）。当我们在一种特定模式之前或者之后有这种模式时，会优先使用断言。<br>例如我们想获取输入字符串 <code>$4.44 and $10.88</code> 中带有前缀 <code>$</code> 的所有数字。我们可以使用这个正则表达式 <code>(?&lt;=\$)[0-9\.]*</code>，表示：获取包含 <code>.</code> 字符且前缀为 <code>$</code> 的所有数字。<br>以下是正则表达式中使用的断言：</p><table><thead><tr><th align="center">符号</th><th>描述</th></tr></thead><tbody><tr><td align="center">?=</td><td>正向先行断言</td></tr><tr><td align="center">?!</td><td>负向先行断言</td></tr><tr><td align="center">?&lt;=</td><td>正向后行断言</td></tr><tr><td align="center">?&lt;!</td><td>负向后行断言</td></tr></tbody></table><h3 id="4-1-正向先行断言"><a href="#4-1-正向先行断言" class="headerlink" title="4.1 正向先行断言"></a>4.1 正向先行断言</h3><p>正向先行断言认为第一部分的表达式的后面必须是先行断言表达式。返回的匹配结果仅包含与第一部分表达式匹配的文本。<br>要在一个括号内定义一个正向先行断言，在括号中问号和等号是这样使用的 <code>(?=...)</code>。先行断言表达式写在括号中的等号后面。<br>例如正则表达式 <code>(T|t)he(?=\sfat)</code>，表示：匹配大写字母 <code>T</code> 或小写字母 <code>t</code>，后面跟字母 <code>h</code>，后跟字母 <code>e</code>。<br>在括号中，我们定义了正向先行断言，它会引导正则表达式引擎匹配后面跟着 <code>fat</code> 的 <code>The</code> 或 <code>the</code>。</p><pre>"(T|t)he(?=\sfat)" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><h3 id="4-2-负向先行断言"><a href="#4-2-负向先行断言" class="headerlink" title="4.2 负向先行断言"></a>4.2 负向先行断言</h3><p>当我们需要指定第一部分表达式的后面不跟随某一内容时，使用负向先行断言。负向先行断言的定义跟我们定义的正向先行断言一样，<br>唯一的区别在于我们使用否定符号 <code>!</code> 而不是等号 <code>=</code>，例如 <code>(?!...)</code>。<br>我们来看看下面的正则表达式 <code>(T|t)he(?!\sfat)</code>，表示：从输入字符串中获取全部 <code>The</code> 或者 <code>the</code> 且不匹配 <code>fat</code> 前面加上一个空格字符。</p><pre>"(T|t)he(?!\sfat)" => The fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h3 id="4-3-正向后行断言"><a href="#4-3-正向后行断言" class="headerlink" title="4.3 正向后行断言"></a>4.3 正向后行断言</h3><p>正向后行断言用于获取跟随在特定模式之后的所有匹配内容。正向后行断言表示为 <code>(?&lt;=...)</code>。例如正则表达式 <code>(?&lt;=(T|t)he\s)(fat|mat)</code>，表示：从输入字符串中获取在单词 <code>The</code> 或 <code>the</code> 之后的所有 <code>fat</code> 和 <code>mat</code> 单词。</p><pre>"(?<=(T|t)he\s)(fat|mat)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h3 id="4-4-负向后行断言"><a href="#4-4-负向后行断言" class="headerlink" title="4.4 负向后行断言"></a>4.4 负向后行断言</h3><p>负向后行断言是用于获取不跟随在特定模式之后的所有匹配的内容。负向后行断言表示为 <code>(?&lt;!...)</code>。例如正则表达式 <code>(?&lt;!(T|t)he\s)(cat)</code>，表示：在输入字符中获取所有不在 <code>The</code> 或 <code>the</code> 之后的所有单词 <code>cat</code>。</p><pre>"(?&lt;!(T|t)he\s)(cat)" => The cat sat on <a href="#learn-regex"><strong>cat</strong></a>.</pre><h2 id="5-标记"><a href="#5-标记" class="headerlink" title="5. 标记"></a>5. 标记</h2><p>标记也称为修饰符，因为它会修改正则表达式的输出。这些标志可以以任意顺序或组合使用，并且是正则表达式的一部分。</p><table><thead><tr><th align="center">标记</th><th>描述</th></tr></thead><tbody><tr><td align="center">i</td><td>不区分大小写：将匹配设置为不区分大小写。</td></tr><tr><td align="center">g</td><td>全局搜索：搜索整个输入字符串中的所有匹配。</td></tr><tr><td align="center">m</td><td>多行匹配：会匹配输入字符串每一行。</td></tr></tbody></table><h3 id="5-1-不区分大小写"><a href="#5-1-不区分大小写" class="headerlink" title="5.1 不区分大小写"></a>5.1 不区分大小写</h3><p><code>i</code> 修饰符用于执行不区分大小写匹配。例如正则表达式 <code>/The/gi</code>，表示：大写字母 <code>T</code>，后跟小写字母 <code>h</code>，后跟字母 <code>e</code>。<br>但是在正则匹配结束时 <code>i</code> 标记会告诉正则表达式引擎忽略这种情况。正如你所看到的，我们还使用了 <code>g</code> 标记，因为我们要在整个输入字符串中搜索匹配。</p><pre>"The" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on the mat.</pre><pre>"/The/gi" => <a href="#learn-regex"><strong>The</strong></a> fat cat sat on <a href="#learn-regex"><strong>the</strong></a> mat.</pre><h3 id="5-2-全局搜索"><a href="#5-2-全局搜索" class="headerlink" title="5.2 全局搜索"></a>5.2 全局搜索</h3><p><code>g</code> 修饰符用于执行全局匹配（会查找所有匹配，不会在查找到第一个匹配时就停止）。<br>例如正则表达式 <code>/.(at)/g</code>，表示：除换行符之外的任意字符，后跟小写字母 <code>a</code>，后跟小写字母 <code>t</code>。<br>因为我们在正则表达式的末尾使用了 <code>g</code> 标记，它会从整个输入字符串中找到每个匹配项。</p><pre>".(at)" => The <a href="#learn-regex"><strong>fat</strong></a> cat sat on the mat.</pre><pre>"/.(at)/g" => The <a href="#learn-regex"><strong>fat</strong></a> <a href="#learn-regex"><strong>cat</strong></a> <a href="#learn-regex"><strong>sat</strong></a> on the <a href="#learn-regex"><strong>mat</strong></a>.</pre><h3 id="5-3-多行匹配"><a href="#5-3-多行匹配" class="headerlink" title="5.3 多行匹配"></a>5.3 多行匹配</h3><p><code>m</code> 修饰符被用来执行多行的匹配。正如我们前面讨论过的 <code>(^, $)</code>，使用定位符来检查匹配字符是输入字符串开始或者结束。但是我们希望每一行都使用定位符，所以我们就使用 <code>m</code> 修饰符。<br>例如正则表达式 <code>/at(.)?$/gm</code>，表示：小写字母 <code>a</code>，后跟小写字母 <code>t</code>，匹配除了换行符以外任意字符零次或一次。而且因为 <code>m</code> 标记，现在正则表达式引擎匹配字符串中每一行的末尾。</p><pre>"/.at(.)?$/" => The fat                cat sat                on the <a href="#learn-regex"><strong>mat.</strong></a></pre><pre>"/.at(.)?$/gm" => The <a href="#learn-regex"><strong>fat</strong></a>                  cat <a href="#learn-regex"><strong>sat</strong></a>                  on the <a href="#learn-regex"><strong>mat.</strong></a></pre><h2 id="常用正则表达式"><a href="#常用正则表达式" class="headerlink" title="常用正则表达式"></a>常用正则表达式</h2><ul><li><strong>正整数</strong>：<code>^\d+$</code></li><li><strong>负整数</strong>：<code>^-\d+$</code></li><li><strong>电话号码</strong>：<code>^+?[\d\s]&#123;3,&#125;$</code></li><li><strong>电话代码</strong>：<code>^+?[\d\s]+(?[\d\s]&#123;10,&#125;$</code></li><li><strong>整数</strong>：<code>^-?\d+$</code></li><li><strong>用户名</strong>：<code>^[\w\d_.]&#123;4,16&#125;$</code></li><li><strong>字母数字字符</strong>：<code>^[a-zA-Z0-9]*$</code></li><li><strong>带空格的字母数字字符</strong>：<code>^[a-zA-Z0-9 ]*$</code></li><li><strong>密码</strong>：<code>^(?=^.&#123;6,&#125;$)((?=.*[A-Za-z0-9])(?=.*[A-Z])(?=.*[a-z]))^.*$</code></li><li><strong>电子邮件</strong>：<code>^([a-zA-Z0-9._%-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]&#123;2,4&#125;)*$</code></li><li><strong>IPv4 地址</strong>：<code>^((?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.)&#123;3&#125;(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?))*$</code></li><li><strong>小写字母</strong>：<code>^([a-z])*$</code></li><li><strong>大写字母</strong>：<code>^([A-Z])*$</code></li><li><strong>网址</strong>：<code>^(((http|https|ftp):\/\/)?([[a-zA-Z0-9]\-\.])+(\.)([[a-zA-Z0-9]])&#123;2,4&#125;([[a-zA-Z0-9]\/+=%&amp;_\.~?\-]*))*$</code></li><li><strong>VISA 信用卡号码</strong>：<code>^(4[0-9]&#123;12&#125;(?:[0-9]&#123;3&#125;)?)*$</code></li><li><strong>日期（MM/DD/YYYY）</strong>：<code>^(0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])[- /.](19|20)?[0-9]&#123;2&#125;$</code></li><li><strong>日期（YYYY/MM/DD）</strong>：<code>^(19|20)?[0-9]&#123;2&#125;[- /.](0?[1-9]|1[012])[- /.](0?[1-9]|[12][0-9]|3[01])$</code></li><li><strong>万事达信用卡号码</strong>：<code>^(5[1-5][0-9]&#123;14&#125;)*$</code></li></ul><h2 id="Contribution"><a href="#Contribution" class="headerlink" title="Contribution"></a>Contribution</h2><ul><li>Report issues</li><li>Open pull request with improvements</li><li>Spread the word </li></ul><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p>MIT © <a href="mailto:ziishaned@gmail.com">Zeeshan Ahmed</a></p><hr><p><strong><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F-">⬆ top</a></strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Overview of DRAMs</title>
      <link href="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/"/>
      <url>/2022/04/15/DRAM%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h3 id="Overview-of-DRAMs"><a href="#Overview-of-DRAMs" class="headerlink" title="Overview of DRAMs"></a><strong>Overview of DRAMs</strong></h3><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415150456153.png" class="" title="image-20220415150456153"><blockquote><p>DRAM子系统是一个相对复杂的整体的一部分。此图显示了一个双向多处理器，每个处理器都有自己的专用辅助缓存。与本章最相关的部分以深灰色阴影显示：CPU、内存控制器和单个DRAM</p></blockquote><h3 id="DRAM-Basics-Internals-Operation"><a href="#DRAM-Basics-Internals-Operation" class="headerlink" title="DRAM Basics: Internals, Operation"></a>DRAM Basics: Internals, Operation</h3><p>  <strong>DRAM</strong>: A random-access memory (RAM) that uses  a single transistor-capacitor(晶体管电容器) pair for each bit .  下图显示了DRAM内部存储单元的电路: </p><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415151328606.png" class="" title="image-20220415151328606"><p>DRAM内部的组织。DRAM内存阵列是一个由存储单元组成的网格，其中一行和一列的每个交叉点存储一位数据. </p><blockquote><p>This circuit is  dynamic because the capacitors storing electrons  are not perfect devices, and their eventual leakage  requires that, to retain information stored there, each  capacitor in the DRAM must be periodically refreshed (i.e. , read and rewritten)</p></blockquote><blockquote><p>Each DRAM die(芯片) contains one or more memory arrays, rectangular grids of storage cells with each cell  holding one bit of data.  By identifying the intersection of a row  and a column (by specifying a row address and a column address to the DRAM), a memory controller can  access an individual storage cell inside a DRAM chip  so as to read or write the data held there</p></blockquote><blockquote><p>the capacitor lies at the intersection  of a wordline and a bitline; <strong>it is connected to the bitline through a transistor controlled by the wordline</strong>.  A transistor is, among other things, a switch, and  when the voltage on a wordline goes high, all of the  transistors attached to that wordline become closed  switches (turned on), connecting their respective  capacitors to the associated bitlines. The capacitors at each intersection of wordline and bitline are  extremely small and hold a number of electrons that  are miniuscule relative(相对较小的) to the physical characteristics  of those bitlines.  </p></blockquote><blockquote><p>The capacitors at each intersection of wordline and bitline are  extremely small and hold a number of electrons that  are miniuscule relative to the physical characteristics  of those bitlines. Therefore, special circuits called  sense amplifiers are used to detect the values stored  on the capacitors when those capacitors become  connected to their associated bitlines. </p><p><strong>The sense  amplifiers first precharge the bitlines to a voltage level  that is halfway between logic level 0 and logic level 1.</strong>  When the capacitors are later connected to the bitlines through the transistors, the capacitors <strong>change  the voltage levels on those bitlines</strong> very slightly(轻微地). The  sense amplifiers detect the minute changes and pull the bitline voltages all the way to logic level 0 or 1.  Bringing the voltage on the bitlines to fully high or  fully low, as opposed to the precharged state between  high and low, actually recharges the capacitors as  long as the transistors remain on(连通). </p></blockquote><h4 id="Multiple-Memory-Arrays"><a href="#Multiple-Memory-Arrays" class="headerlink" title="Multiple Memory Arrays"></a>Multiple Memory Arrays</h4><blockquote><p> If the memory arrays  are designed to act in unison, they operate as a unit,  and the memory chip typically transmits or receives  a number of bits <strong>equal to</strong> the number of arrays each time the memory controller accesses the DRAM.</p></blockquote><p>For  example, in a simple organization, a x4 DRAM (pronounced “by four”) indicates that the DRAM has at  least <strong>four memory arrays</strong> and that a column width is  4 bits (each column read or write transmits 4 bits of  data). In a x4 DRAM part, four arrays each read 1 data  bit in unison, and the part sends out 4 bits of data  each time the memory controller makes a column  read request.</p><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415153809797.png" class="" title="image-20220415153809797"><p>NOTICE:   <strong>each of the DRAM illustrations in Figure  represents multiple arrays but a single bank. Each set of memory arrays that operates independently of other  sets is referred to as a bank, not an array .</strong></p><h4 id="RANK"><a href="#RANK" class="headerlink" title="RANK"></a>RANK</h4><blockquote><p>Because a system can have multiple DIMMs, each  of which can be thought of as an independent bank,  and the DRAM devices(内存颗粒) on each DIMM can implement internally multiple independent banks, the  word “rank” was introduced to distinguish DIMM-level independent operation versus(和) internal-bank-level independent operation. </p></blockquote><blockquote><p>A system is composed of potentially many  independent DIMMs. <strong>Each DIMM may contain one  or more independent ranks</strong>. Each rank is a set of  DRAM devices that operate in unison, and internally  each of these DRAM devices implements one or more  independent banks. Finally, <strong>each bank is composed  of slaved memory arrays</strong>, where the number of arrays  is equal to the data width of the DRAM part (i.e., a x4  part has four slaved arrays per bank)</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415155638103.png" class="" title="image-20220415155638103"><center>DIMMs, ranks, banks, and arrays </center><hr><h4 id="Memory-controller-and-Memory-modules"><a href="#Memory-controller-and-Memory-modules" class="headerlink" title="Memory controller and Memory modules"></a>Memory controller and Memory modules</h4><blockquote><p>The busses in a JEDEC-style organization are classified by their function and organization into data,  address, control, and chip-select busses. </p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415161510722.png" class="" title="image-20220415161510722"><center>a memory controller and two memory modules with a 16-bit data bus and an 8-bit address and command bus</center><blockquote><p>The data bus that transmits data to and from  the DRAMs is relatively wide. It is often 64 bits wide,  and it can be much wider in high-performance systems. A dedicated address bus carries row and column addresses to the DRAMs, and its width grows  with the physical storage on a DRAM device (typical  widths today are about 15 bits). A control bus is composed of the row and column strobes(选通), output enable,  clock, clock enable, and other related signals. These  signals are similar to the address-bus signals in that  they all connect from the memory controller to every  DRAM in the system. Finally, there is a chip-select  network that connects from the memory controller  to every DRAM in a rank (a separately addressable  set of DRAMs). </p></blockquote><h4 id="the-chip-select-bus"><a href="#the-chip-select-bus" class="headerlink" title="the chip-select bus"></a>the chip-select bus</h4><blockquote><p>The chip-select bus contains a separate wire(线路) for every rank of DRAM in  the system.  The chip-select signal passes over a wire  unique to each small set of DRAMs and enables or  disables the DRAMs in that rank so that they, respectively, either handle the request currently on the bus  or ignore the request currently on the bus. Thus, <strong>only  the DRAMs to which the request is directed handle  the request</strong>. Even though all DRAMs in the system  are connected to the same address and control busses and could, in theory, all respond to the same  request at the same time, the chip-select bus prevents this from happening. </p></blockquote><h4 id="the-Steps-of-a-DRAM-Read"><a href="#the-Steps-of-a-DRAM-Read" class="headerlink" title="the Steps of a DRAM  Read"></a>the Steps of a DRAM  Read</h4><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415164647716.png" class="" title="image-20220415164647716"><center> System organization and the steps of a DRAM  read </center><blockquote><p>As mentioned previously, a DRAM device connects indirectly to a microprocessor through a  memory controller; the microprocessor connects  to the memory controller through some form of  network (bus, point-to-point, crossbar, etc.); and  the memory controller connects to the DRAM  through another network (bus, point-to-point, etc.).  </p></blockquote><blockquote><p>Figure also illustrates the steps of a typical  DRAM read operation. After ordering and queueing  requests, the microprocessor sends a given request  to the memory controller. Once the request arrives at  the memory controller, it is queued until the DRAM is  ready and all previous and/or higher priority requests  have been handled. The memory controller’s interface to the DRAM is relatively complex (compared  to that of an SRAM, for instance); the row-address  strobe (RAS) and column-address strobe (CAS) components are shown in detail in next Figure. </p></blockquote><blockquote><p>The memory controller must decompose the provided data address into components that identify the  appropriate rank within the memory system, the bank  within that rank, and the row and column inside the  identified bank. The components identifying the row  and column are called the row address and the column address. <strong>The bank identifier is typically one or  more address bits</strong>. The rank number ends up causing  a chip-select signal to be sent out over a single one of  the separate chip-select lines. </p></blockquote><h4 id="the-Bitlines-Be-Precharged"><a href="#the-Bitlines-Be-Precharged" class="headerlink" title="the Bitlines Be Precharged"></a>the Bitlines Be Precharged</h4><blockquote><p>Once the rank, bank, and row are identified, the  bitlines in the appropriate bank must be precharged (set to a logic level halfway between 0 and 1). Once  the appropriate bank has been precharged, <strong>the second step</strong> is to activate the appropriate row inside the  identified rank and bank by setting the chip-select  signal to activate the set of DRAMs comprising the desired bank, sending the row address and bank  identifier over the address bus, and signaling the  DRAM’s  RAS pin (row-address strobe—the bar indicates that the signal is active when it is low). </p><p>This tells  the DRAM to <strong>send an entire row of data (thousands  of bits) into the DRAM’s sense amplifiers</strong> (circuits  that detect and amplify the tiny logic signals represented by the electric charges in the row’s storage  cells). This typically takes a few tens of nanoseconds,  and the step may have already been done (the row  or page could already be open or activated, meaning  that the sense amps might already have valid data in  them). </p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415165940565.png" class="" title="image-20220415165940565"><center> The multi-phase DRAM-access protocol. The row access drives a DRAM page onto the bitlines to be sensed by the  sense amps. The column address drives a subset of the DRAM page onto the bus (e.g., 4 bits).</center><p>NOTICE: separately transmitted row and  column addresses</p><blockquote><p>Once the sense amps have recovered the values,  and the bitlines are pulled to the appropriate logic  levels, the memory controller <strong>performs the last step</strong>,  which is to read the column (column being the name  given to the data subset of the row that is desired),  by setting the chip-select signal to activate the set of  DRAMs comprising the desired bank, sending the  column address and bank identifier over the address  bus, and signaling the DRAM’s  CAS pin (column address strobe—like  RAS , the bar indicates that it is active when low).  </p><p>This causes only a few select bits in the sense amplifiers to be connected to the output  drivers, where they will be driven onto the data bus.  Reading the column data takes on the order of tens of  nanoseconds. When the memory controller receives  the data, it forwards the data to the microprocessor. </p></blockquote><h4 id="Clock"><a href="#Clock" class="headerlink" title="Clock"></a>Clock</h4><blockquote><p>A clock transmits a continuous signal with regular  intervals of “high” and “low” values. It is usually illustrated as a square wave or semi-square wave with each  period identical to the next, as shown in Figure 7.9. The  upward portion of the square wave is called the positive  or rising edge of the clock, and the downward portion  of the square wave is called the negative or falling edge of the clock. The primary clock in a computer system is  called the system clock or global clock, and it typically  resides on the motherboard (the PCB that contains the  microprocessor and memory bus). The system clock  drives the microprocessor and memory controller and  many of the associated peripheral devices directly. If  the clock drives the DRAMs directly, the DRAMs are  called synchronous DRAMs. If the clock does not drive  the DRAMs directly, the DRAMs are called asynchronous DRAMs. In a synchronous DRAM, steps internal  to the DRAM happen in time with one or more edges  of this clock. In an asynchronous DRAM, operative  steps internal to the DRAM happen when the memory controller commands the DRAM to act, and those  commands typically happen in time with one or more  edges of the system clock.</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220415190728890.png" class="" title="image-20220415190728890"><center> Example clock signals</center><blockquote><p>Clocks are typically shown as square waves (bottom) or sort of square waves (top). They  repeat ad infinitum, and the repeating shape is called a clock cycle. The two clocks pictured above have the same frequency—the  number of cycles in a given time period</p></blockquote><h3 id="DRAM-中文"><a href="#DRAM-中文" class="headerlink" title="DRAM 中文"></a>DRAM 中文</h3><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/Simplified-topology-of-DRAM-organization.png" class="" title="Simplified-topology-of-DRAM-organization"><p>影响DRAM的性能:</p><ul><li>内存容量</li><li>内存的延时周期</li><li>内存的带宽</li></ul><h4 id="内存带宽"><a href="#内存带宽" class="headerlink" title="内存带宽"></a>内存带宽</h4><p>内存带宽的影响是内存中现存的非常严重的问题，而影响内存带宽的主要因素是 行冲突</p><p>地址层级如下:</p><ol><li>通道（Channel） 通道是 DRAM 内存系统结构中最高的级别。独立内存控制器之间不同通道的运 行是没限制的。为了更优化的性能设计，连续的存取指令在缓存层已经被映射到不同 的通道了。</li><li>排（Rank） 排是通道的下一层，DRAM 的存取是在同一个通道的不同排之间也是可以并行 运行的</li><li>体（Bank）类似于连续的存取指令作用在不同的排上，当连续的指令作用在同一个排的不同 体时，DRAM 的内存系统仍然会有并行运行的存在。对于现在的 DRAM 设备而言， 将连续的存取指令通过调度方式分配到同一个排的不同体上，要比分配到同一个通道 的不同排上更加高效，因为这样不需要多余的周期来进行数据总线上的转换。</li><li>行（Row）在通用 DRAM 内存系统中，每个体在执行时，仅能激活（Active）一个行，当 有连续的指令通过调度映射到同一个体的不同行时，需要将第一个行进行预充电操作 （Precharge），再对第二个行进行激活操作，才能顺利进行连续指令的运行。这样做 便会造成大量的延迟，同时伴随的还有行冲突的数量会增加。想要降低行冲突出现的 概率，需要通过地址映射将连续的指令映射到同一个体的同一个行上面，这样行命中 的比例变化提升很多。从而能够有效的提升 DRAM 的性能</li><li>列（Column）当连续的指令作用在同一个体的同一个行时，此时不需要预充电操作，在获取数 据时，根据时间局部性和空间局部性 ，内存控制器会把整个行的数据都取出来放在 敏感放大器上。所以，第二个指令所映射的列也会以极高的效率获得。</li></ol><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410095244676.png" class="" title="image-20220410095244676"><p>地址映射不单单是内存中的地址翻译，它是连接着处理器、内存控制器和内存的 重要桥梁。因为地址在计算机系统中不同模块传输的状态不同，有物理地址和逻辑地 址，所以，需要地址映射来进行合理的转化。</p><h4 id="虚拟地址与物理地址"><a href="#虚拟地址与物理地址" class="headerlink" title="虚拟地址与物理地址"></a>虚拟地址与物理地址</h4><blockquote><p>虚拟地址（Virtual Address） 如果 CPU 启用了内存管理单元（Memory Management Unit，又称 MMU），CPU 核发出的地址将被内存管理单元截获，从 CPU 传输到内存管理单元的地址称为虚拟 地址(Virtual Address，简称 VA</p></blockquote><blockquote><p>物理地址（Physical Address）： 如果中央处理器不存在内存管理单元，或者未启用，则其核在获取指令或者访存 时发出的地址将被直接传到 CPU 的外部地址引脚上，被内存芯片接受，则称为物理 地址（Physical Address）。 内存管理单元将该地址译成另外地址发到 CPU 的外部地址引脚上，便意味着将 虚拟地址转化成了物理地址。内存管理单元是以页（Page）为单位的，对于 32 位 CPU 而言，通常一页为 4K。例如，虚拟地址 0xb700 1000<del>0xb700 1fff 是一个页，可能被 MMU 映射到物理地址 0x2000</del>0x2fff，物理内存中的一个物理页面也称为一个页框 (Page Frame)。 当内存控制器将虚拟地址转化成能够索引到具体 DRAM 每个数据模块的物理地 址后，DRAM 便会通过物理地址而索引到内存中具体的数据，再通过数据总线反馈 给 CPU[8]</p></blockquote><h4 id="内存带宽-1"><a href="#内存带宽-1" class="headerlink" title="内存带宽"></a>内存带宽</h4><h5 id="ROW-行"><a href="#ROW-行" class="headerlink" title="ROW 行"></a>ROW 行</h5><blockquote><p>在通用 DRAM 内存系统中，每个体在执行时，仅能激活（Active）一个行，当 有连续的指令通过调度映射到同一个体的不同行时，需要将第一个行进行预充电操作 （Precharge），再对第二个行进行激活操作，才能顺利进行连续指令的运行。这样做 便会造成大量的延迟，同时伴随的还有行冲突的数量会增加。想要降低行冲突出现的 概率，需要通过地址映射将连续的指令映射到同一个体的同一个行上面，这样行命中 的比例变化提升很多。从而能够有效的提升 DRAM 的性能</p></blockquote><h5 id="Column-列"><a href="#Column-列" class="headerlink" title="Column 列"></a>Column 列</h5><blockquote><p>当连续的指令作用在同一个体的同一个行时，此时不需要预充电操作，在获取数 据时，根据时间局部性和空间局部性 ，内存控制器会把整个行的数据都取出来放在 敏感放大器上。所以，第二个指令所映射的列也会以极高的效率获得</p></blockquote><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410174402971.png" class="" title="image-20220410174402971"><h5 id="连续存取指令"><a href="#连续存取指令" class="headerlink" title="连续存取指令"></a>连续存取指令</h5><img src="/2022/04/15/DRAM%E6%80%BB%E7%BB%93/image-20220410183659726.png" class="" title="image-20220410183659726"><h5 id="开页模式策略"><a href="#开页模式策略" class="headerlink" title="开页模式策略"></a>开页模式策略</h5><blockquote><p>开页的策略其 适用的环境是，如果有连续的指令到来，那么在执行完第一个指令后，并不会通过预 充电命令关掉该行。当内存控制器使用开页模式策略时，某行数据被取出存放在一个 DRAM 体的敏感放大器中的同一行的不同列，它可以快速的直接执行，此时会有最 小的延迟称为 Tcas。这种情况下，当另外一个读取指令指向了同一个行，因为该行已 经激活在敏感放大器中，所以它仅仅需要列命令，便可将数据从敏感放大器传递到内 存控制器中 ，这样的延迟是最小的。当然，另一方面，当连续的指令作用的是同一 个体的不同行时，内存控制器在执行第二个访问操作时，必须将第一个行通过预充电 指令关掉，同时再打开另外一个指令所指向的那个行，这样才可以执行第二个的列选取.  </p></blockquote><h5 id="关页策略"><a href="#关页策略" class="headerlink" title="关页策略"></a>关页策略</h5><p>关 页策略适用的环境是，当连续的指令到来以后，在执行完第一个指令，紧接着发布一 个预充电的指令来关掉该行，所以它适用于行冲突很多的情况下</p><h4 id="行冲突现象"><a href="#行冲突现象" class="headerlink" title="行冲突现象:"></a>行冲突现象:</h4><p>如果连续的地址存取指令，它们通过地址映射的算法后，指向的是同一个体的不同行，这会产生大量的延迟，因为上述第一个行需要激活的指令，才能执行第一个存取的请求，因为第二个不同于第一个行，因为同一个体一次仅能激活一个行，所以，需要将第一个行进行预充电的操作， 来使第一个行的状态变为关闭，紧接着再发布第二个指令来激活第二个请求所指向的行，在此两个行为以后，才可以执行第二个请求， 获取第二个行的数据，存放在行缓冲区中。因为这样的操作比第一种情况多出了一个 预充电与一个激活的指令延迟，所以效率是非常低的。这样的情况我们称之为行冲突现象. </p>]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Computer Architecture </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu下实用工具配置</title>
      <link href="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/"/>
      <url>/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="一-shell配置"><a href="#一-shell配置" class="headerlink" title="一 shell配置"></a>一 shell配置</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">安装插件的脚本</span></span><br><span class="line">sudo apt install wget curl git zsh vim tldr -y</span><br><span class="line">sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</span><br><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br><span class="line">sed -i &#x27;s/plugins=(git)/plugins=(git zsh-autosuggestions zsh-syntax-highlighting z)/&#x27; ~/.zshrc</span><br><span class="line"></span><br><span class="line">git clone https://github.com/okeyia/honukai-iterm-zsh.git ~/.oh-my-zsh/custom/themes</span><br><span class="line"></span><br><span class="line">sed -i &#x27;s/robbyrussell/honukai&#x27; ~/.zshrc</span><br><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><p>好用的shell有很多, 如fish、zsh、Oh-my-zsh ，本教程以Oh-my-zsh为例，配置教程如下：</p><h3 id="1-安装zsh"><a href="#1-安装zsh" class="headerlink" title="1 安装zsh"></a>1 安装zsh</h3><p>以ubuntu为例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install zsh</span><br></pre></td></tr></table></figure><h3 id="2-下载oh-my-zsh-源码"><a href="#2-下载oh-my-zsh-源码" class="headerlink" title="2 下载oh-my-zsh 源码"></a>2 下载oh-my-zsh 源码</h3><h4 id="2-1-脚本安装方式"><a href="#2-1-脚本安装方式" class="headerlink" title="2.1 脚本安装方式"></a>2.1 脚本安装方式</h4><p>使用curl或者wget</p><table><thead><tr><th>Method</th><th>Command</th></tr></thead><tbody><tr><td>curl</td><td><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr><tr><td>wget</td><td><code>sh -c &quot;$(wget -O- https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;</code></td></tr></tbody></table><h4 id="2-2-手动安装"><a href="#2-2-手动安装" class="headerlink" title="2.2 手动安装"></a>2.2 手动安装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">wget https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;ohmyzsh&#x2F;ohmyzsh&#x2F;master&#x2F;tools&#x2F;install.sh</span><br><span class="line">sudo sh install.sh</span><br></pre></td></tr></table></figure><h3 id="3-安装-oh-my-zsh插件及主题"><a href="#3-安装-oh-my-zsh插件及主题" class="headerlink" title="3 安装 oh-my-zsh插件及主题"></a>3 安装 oh-my-zsh插件及主题</h3><h4 id="3-1-插件—代码高亮"><a href="#3-1-插件—代码高亮" class="headerlink" title="3.1 插件—代码高亮"></a>3.1 插件—代码高亮</h4><ol><li>克隆源码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-syntax-highlighting.git $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure><ol start="2"><li>修改配置文件 <code>~/.zshrc</code></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( [plugins...] zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure><ol start="3"><li>是配置文件生效</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure><h4 id="3-2-插件—自动补全"><a href="#3-2-插件—自动补全" class="headerlink" title="3.2 插件—自动补全"></a>3.2 插件—自动补全</h4><ol><li><p>克隆源码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/zsh-users/zsh-autosuggestions $&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">plugins=( # other plugins... zsh-autosuggestions)</span><br></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h4 id="3-3-主题—honukai"><a href="#3-3-主题—honukai" class="headerlink" title="3.3 主题—honukai"></a>3.3 主题—honukai</h4><ol><li><p>主题配置文件一般存放于  <code>~/.oh-my-zsh/custom/themes</code> 文件夹, 进入到该文件夹, 执行该命令, 将下面的内容(复制内容如下)复制进去.  </p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim honukai.zsh-theme </span><br></pre></td></tr></table></figure><p><strong>复制内容如下:</strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Based on the great ys theme (http://ysmood.org/wp/2013/03/my-ys-terminal-theme/)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Machine name.</span></span><br><span class="line"><span class="keyword">function</span> box_name &#123;</span><br><span class="line">    [ -f ~/.box-name ] &amp;&amp; cat ~/.box-name || <span class="built_in">echo</span> <span class="variable">$HOST</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Directory info.</span></span><br><span class="line"><span class="built_in">local</span> current_dir=<span class="string">&#x27;$&#123;PWD/#$HOME/~&#125;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># VCS</span></span><br><span class="line">YS_VCS_PROMPT_PREFIX1=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[white]%&#125;on%&#123;<span class="variable">$reset_color</span>%&#125; &quot;</span></span><br><span class="line">YS_VCS_PROMPT_PREFIX2=<span class="string">&quot;:%&#123;<span class="variable">$fg</span>[cyan]%&#125;&quot;</span></span><br><span class="line">YS_VCS_PROMPT_SUFFIX=<span class="string">&quot;%&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line">YS_VCS_PROMPT_DIRTY=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[red]%&#125;✖︎&quot;</span></span><br><span class="line">YS_VCS_PROMPT_CLEAN=<span class="string">&quot; %&#123;<span class="variable">$fg</span>[green]%&#125;●&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Git info.</span></span><br><span class="line"><span class="built_in">local</span> git_info=<span class="string">&#x27;$(git_prompt_info)&#x27;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_PREFIX=<span class="string">&quot;<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX1&#125;</span>git<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX2&#125;</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_SUFFIX=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_SUFFIX</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_DIRTY=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_DIRTY</span>&quot;</span></span><br><span class="line">ZSH_THEME_GIT_PROMPT_CLEAN=<span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_CLEAN</span>&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># HG info</span></span><br><span class="line"><span class="built_in">local</span> hg_info=<span class="string">&#x27;$(ys_hg_prompt_info)&#x27;</span></span><br><span class="line"><span class="function"><span class="title">ys_hg_prompt_info</span></span>() &#123;</span><br><span class="line"><span class="comment"># make sure this is a hg dir</span></span><br><span class="line"><span class="keyword">if</span> [ -d <span class="string">&#x27;.hg&#x27;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX1&#125;</span>hg<span class="variable">$&#123;YS_VCS_PROMPT_PREFIX2&#125;</span>&quot;</span></span><br><span class="line"><span class="built_in">echo</span> -n $(hg branch 2&gt;/dev/null)</span><br><span class="line"><span class="keyword">if</span> [ -n <span class="string">&quot;<span class="subst">$(hg status 2&gt;/dev/null)</span>&quot;</span> ]; <span class="keyword">then</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_DIRTY</span>&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_CLEAN</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"><span class="built_in">echo</span> -n <span class="string">&quot;<span class="variable">$YS_VCS_PROMPT_SUFFIX</span>&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># Prompt format: \n # USER at MACHINE in DIRECTORY on git:BRANCH STATE [TIME] \n $</span></span><br><span class="line">PROMPT=<span class="string">&quot;</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[blue]%&#125;#%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[cyan]%&#125;%n \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;at \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[green]%&#125;<span class="subst">$(box_name)</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;in \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;<span class="variable">$&#123;current_dir&#125;</span>%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;git_info&#125;</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;[%*]</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125;→ %&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [[ <span class="string">&quot;<span class="variable">$USER</span>&quot;</span> == <span class="string">&quot;root&quot;</span> ]]; <span class="keyword">then</span></span><br><span class="line">PROMPT=<span class="string">&quot;</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[blue]%&#125;#%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$bg</span>[yellow]%&#125;%&#123;<span class="variable">$fg</span>[cyan]%&#125;%n%&#123;<span class="variable">$reset_color</span>%&#125; \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;at \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[green]%&#125;<span class="subst">$(box_name)</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;in \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[yellow]%&#125;<span class="variable">$&#123;current_dir&#125;</span>%&#123;<span class="variable">$reset_color</span>%&#125;\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;hg_info&#125;</span>\</span></span><br><span class="line"><span class="string"><span class="variable">$&#123;git_info&#125;</span> \</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$fg</span>[white]%&#125;[%*]</span></span><br><span class="line"><span class="string">%&#123;<span class="variable">$terminfo</span>[bold]<span class="variable">$fg</span>[red]%&#125;→ %&#123;<span class="variable">$reset_color</span>%&#125;&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>修改配置文件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;honukai&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>使配置文件生效</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ol><h3 id="4-用户默认使用zsh"><a href="#4-用户默认使用zsh" class="headerlink" title="4 用户默认使用zsh"></a>4 用户默认使用zsh</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">which zsh                #查看zsh的路径</span><br><span class="line">sudo vi /etc/passwd      #以用户sen为例, 将/bin/bash 改为/usr/bin/zsh</span><br></pre></td></tr></table></figure><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220924155931302.png" class="" title="image-20220924155931302"><h2 id="二-sudo-免密码"><a href="#二-sudo-免密码" class="headerlink" title="二 sudo 免密码"></a>二 sudo 免密码</h2><p>个别情况下，sudo 免密设置的特别麻烦，这里可对某个管理员用户设置sudo 免输入免密。本教程以<code>ubuntu 18.04</code> 为例。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sudo visudo</span><br><span class="line"><span class="meta">#</span><span class="bash">在%sudo ALL=(ALL:ALL) ALL下面添加如下一行</span></span><br><span class="line">username  ALL=(ALL) NOPASSWD: ALL, 这里的username就是你自己的用户名</span><br><span class="line"><span class="meta">#</span><span class="bash">添加完成 如下图所示, 之后按Ctrl+O，接着按回车确定保存文件。最后Ctrl+X退出编辑</span></span><br></pre></td></tr></table></figure><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409220215145.png" class="" title="image-20220409220215145"><h2 id="三-vmware-配置git代理"><a href="#三-vmware-配置git代理" class="headerlink" title="三 vmware 配置git代理"></a>三 vmware 配置git代理</h2><h3 id="1-主机ip及虚拟机ip设置"><a href="#1-主机ip及虚拟机ip设置" class="headerlink" title="1 主机ip及虚拟机ip设置"></a>1 主机ip及虚拟机ip设置</h3><h4 id="1-1-VMware网络编辑器配置"><a href="#1-1-VMware网络编辑器配置" class="headerlink" title="1.1 VMware网络编辑器配置"></a>1.1 VMware网络编辑器配置</h4><p>如图所示: </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221141249.png" class="" title="网络编辑器配置"><h4 id="1-2-本机VMnet8-设置"><a href="#1-2-本机VMnet8-设置" class="headerlink" title="1.2 本机VMnet8 设置"></a>1.2 本机VMnet8 设置</h4><p>请确保本机VMnet8的本机ip地址和虚拟机IP地址处于同一网段, 如图中所示, 配置为: 192.168.1.1</p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221513434.png" class="" title="image-20220409221513434"><h4 id="1-3-测试与主机连接"><a href="#1-3-测试与主机连接" class="headerlink" title="1.3 测试与主机连接"></a>1.3 测试与主机连接</h4><p>在虚拟机中<code>ping</code>主机, 如果能<code>ping</code>通, 就代表连接无问题. </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409221853038.png" class="" title="image-20220409221853038"><h3 id="2-gitconfig设置"><a href="#2-gitconfig设置" class="headerlink" title="2 .gitconfig设置"></a>2 .gitconfig设置</h3><h4 id="2-1-本机中运行代理软件"><a href="#2-1-本机中运行代理软件" class="headerlink" title="2.1 本机中运行代理软件"></a>2.1 本机中运行代理软件</h4><p>本次以v2rayN为例, 代理开启pac模式, 设置中打开允许局域网连接,</p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409222218684.png" class="" title="image-20220409222218684"><h4 id="2-2-查看所用协议"><a href="#2-2-查看所用协议" class="headerlink" title="2.2 查看所用协议"></a>2.2 查看所用协议</h4><p>在代理页面查看配置的协议及端口号。v2rayN中一般都是http协议和socks5协议, 记下配置的端口号. </p><img src="/2022/04/09/ubuntu%E4%B8%8B%E5%AE%9E%E7%94%A8%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/image-20220409222519626.png" class="" title="image-20220409222519626"><h4 id="2-3-编辑-gitconfig文件"><a href="#2-3-编辑-gitconfig文件" class="headerlink" title="2.3 编辑 .gitconfig文件"></a>2.3 编辑 <code>.gitconfig</code>文件</h4><p>使用命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global socks5://userName:userPwd@127.0.0.1:10809</span><br><span class="line">git config --global socks5://userName:userPwd@127.0.0.1:10809</span><br></pre></td></tr></table></figure><p><strong>或者</strong> 在用户目录下，编辑.gitconfig文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">vim ~/.gitconfig</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">添加以下内容, 这里的ip的值就是1.2节中配置的主机ip, 端口号就是2.2中的端口号, 注意端口号和协议保持一致, 可以配置socks5协议, 也可以配置http协议, 这里配置的是http协议。</span></span><br><span class="line">[http]</span><br><span class="line">    sslVerify = false</span><br><span class="line">    proxy = http://192.168.10.1:10809</span><br><span class="line">    </span><br><span class="line"><span class="meta">#</span><span class="bash">注意：如果使用socks5协议的话，可能需要用户名和密码（默认是不需要的），socks5配置格式如下：</span></span><br><span class="line">[http]                                                                               </span><br><span class="line">    proxy = socks5://userName:userPwd@127.0.0.1:10809</span><br></pre></td></tr></table></figure><h2 id="四-github-clone-加速"><a href="#四-github-clone-加速" class="headerlink" title="四 github clone 加速"></a>四 github clone 加速</h2><p>如果自己本机没有配置代理,   可使用国内的某些代理网站.   <a href="https://gitclone.com/docs/howto/howto_github">github clone 加速</a></p>]]></content>
      
      
      <categories>
          
          <category> 工欲善其事, 必先利其器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复现师兄论文实验</title>
      <link href="/2022/03/13/%E5%A4%8D%E7%8E%B0%E5%B8%88%E5%85%84%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/"/>
      <url>/2022/03/13/%E5%A4%8D%E7%8E%B0%E5%B8%88%E5%85%84%E8%AE%BA%E6%96%87%E5%AE%9E%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="b963e430fdcd63331ecf8da00e85b68c2ddcda7788cf3885fe52308ad479ae60">e8ddf16f6a907c53c402f597f0c2281f2d7aac72253b3449ac2f4958d425e4708939b0421678b058df7b574f2a20007e61d25057c51aa67913fabc023c3d73494eccaa335c69a5dde71800ac33dc951944d77760c7bf01b6c31af0a16f1c0952bdd51f36a4ccf7ea2417f35a9c1293b6f23ab88fb618b8f94f8262a7cffe802fa67bebb1363a3f78c305ee32db600db354663cf276924d653f0b0185099545d14218dfb81d4f984a974436e28157f892e2847dacac013ccb245d3f7c5eee159f2808230a0710b6ee3eadf884d48fd15d10a8ad70d968ad152e9bdc70be171c2ed49e643bf6e132330221de45d9f8f6dc2a23c9e5f7d19a1453bbc601184be48db3800769b6d0edacd0b2f3ecf4fbb0644ef825c1ba340ce05712b613cf75ca29b20f09c0eeb3013ac874b676f5a8fcb0e39edc4dfbcae1551afbe43d2181f3b115b90a4673c9144cd00bbe622bbb0e855c9473e8d09fa741bea29ed840cb993a30f3806313c4363664025393c92721161cdd95c970d9f786a5ef4a6287e20b90ee1035a209791a559be4f33b3ff26c4ca5aa4d261efd40e67829cb12242c6a40b6c64fa00a4395ae8d1887e08653d8e7a799dadd259b4cd81a66cd6b6c82985b73340c9dcda35b49e9bacaf52fd7adae534d3e46388c77168c2a7f581ab2f063e1c4b646d27fc0800878f289925db5a0fff67bf96219d5d62d525f2f885e41addb2a27944d78e22124ed657904f7956ce13234bdb72e59d4f7dded6d696be7c769138df8f190ca4fc496f3407cf0951ddcefe87f239e149a3848f26c55570d3218658669174c41f3d81e47227662d98d3e85965ee29072fd8d8362020456ca8cf5899c39911cc509f65f26347f8de36a9d82d9202c091ed3ece57c25c62e09316ed91ce0f547ba992a39e6dd0ee76f8d3c3fa89e83df5fed2a541b266c5c2733deb6dad5ece37498413fdb77d650b00ac70a532e8a1ad443c1c24e836714bfe56d30ab659bf737c3a3b6d9896386a84777d61d0db1cfb70f6b28736e832dc216fca658eda012a1cf29122170254aaa1da2b34a218a9c00f7b0463504707b0990a11534435524ab044ecae0ffdb373944ddcefe9b70d3a73b980e34688c3d5a237b066036d94a776fc340f04330cb5fd76f04da8a4d1e64eb87343b5932880c1e088df72dbe1635189a38ddb9fd12060dfeae4d4109e8bbf44b252976308b9e12d22843b8566295385fa90bdf0f5cc0833506877332b16a5d6eb9b7c799969ebd8f8752095f99db1110890ddfd9fef0b356c6cd5e1e0671415e25317286497ecfde35c2e87658008e62a5b2cc6b1c7567d6793af600d5f90800832311d0fb26e86322f3fde999461f771845b797e11c2831929d7b8a2886ca6208b2712a7c95b550a4469cbe05050f430e32ceb62161645b34cf2fbd79927e9979af17531b42e81cbf4666a660defbe68b977326b67779982355ab640a061823aa7e09bee1694bb3760d7782ecc88cb0492078e7c1c603afa883ae8bf3fe9e040c9d6d5ab1bd1976e7eb24e75bb29ac0abdf3e741232c27e3a2ee54513927e0cb848951a77226280bc197961e9c8bb66acbed8870e00d7f517138f3c5d6c3169f880b664dda71cc6d1a5c314ed41d88dd9a96af24770b5847a09ba23355d5616da7a10660382cfa7b74b20f060e000bee9a5bcebbc378857c0022795cdcaffb18093d200201bbb25096db5d62b6e55b219651f59922ed3906de41c23496f73bb20f6a8050ef31a29989649cbe598d42ee91ebbddb6fdcdfa8eb42f2ed78aa1384904e7c859bd6712c5f8f4e04e5eb32ef11a897c4cf78b4a6826d8b8d295d4e808831c72dbe8c55c69c9f893a266a83d63f9356e19594c6f1ef44d9894e9e1f3ed46e439c152b3d777936fa8c43686d2cd8565aff7178632eac82f3fea5faf4e523c0dd093393855f631bf0c075e5ac4cb5f26b3350c73ed361cdd7cfd6f4c4e8a53116dcfc7b61647edc8656b81b42d2dec7529aec6751360c528f21e517db6cb39d7b0f3eeec183df1acef9d30587e56bd0c4ea3187de7d28b2e02cadbeb825d54619749823b1e5c907506cb709865a78bacf3e451ca8d0cbfb76e8e00c0dbd12793b85b3a2e2521795f3073329dcbb1b81000eed2c0be72d0af6176cb581cd3ac418af70f7ca507fe3781684639e5e0a2411d2c6985aa63e8721bd90df5e1db19914f0b4a7dfe3b3edf17e51ed8fff28e78771350241270d39a231427c8b9945c015fbf2a8e673eea0b7cd78f210b8f776be3825acc73de19e22b6bd24b1754b05eb24d92855bfdaebc63918e5452132d68f77b9cfd70dd6d839f34f1d4e1a2eecc11e489dd4e07e178ec8fcd25e6f942137f82b9e5e4a056958b146d0d0e4aa42bef70c0140eabcc4bdbbc0eba37acf0d0a85c9062b1000a9745b66c1c81ade6432566a4081ad2ea1ade22f70fca34423cca8638891a3368a9aab512c54e1f29eec118823c37a6aae6298ba52641225ade348efb28323fe7daa2a5ef9b2fba669f1354bc5ab3d3feb4b2932845c9b13f990a53e88b71ac812d68c553ec7d914553b11355aaa6ecfdb3228b6a0802426c59644a75052383e924682ac2d5cf380b448a5ca4ab8d8e98e35302ffc6498cd2aca17f1852fba7eda150612d2bcc9ab73f3d1fd081a053a77bf885ae62b1a77557799818a08d1636ecf761c162fc6b327d762785c0b0740f6044a8dc5a7a792f41e236e665058bc32096ce9e9398cdbe1318da5ba22aa9757b6565d8662e022d3ec1a7d5a278444c648c5fa3d699d6db073899b15ef4b29dc3c009207066a157a850868ac033ad32896df2b12d05c53441a8849aefd92f1c9adebc5b909c2788dd87e841e8c959724161d4a31ab0b9936ded7d48bf13ae03e8b8569ccf30c484249ffe8ebd99586927594cacdbf20defc80dbbb4586a5853768e4af7ff5176c095b6e6ff29b0a27fc94a789ace86ed99b7cac984d8a9fda276f458772294022cee5c9254ebbc74c53359ec73bc37233901d06865e9679e69c625f93738e8d25fbc5b37774b40cfdd2f2a7fcf317f3ae79b5d094e12166bd3b25958efce69a97dfad930218c61a60490e80c54bbf17f6b6dab11fdc8fecbfe20e02acd62959b394adfffaaa975c011eb2292252e829026ab7d86c361eea9971346f789c6ab86496aa0e25d585c1fdd2866a6cf19ed62abb7a981882e14b7afd894dff7bd6d42b9919973ac7385a81241172903237e779b48a9c24360376599bd86dc42dc99eb0613f0ec3e2f1c099dd5fcbfa362bd2bba64b058dc462fefb0305315d7479d566c67b144fed1835a0493473dfdbdcc043dbb102825f1fbc88c9f5a4d811eee89679a758b1fbe726d1ea56ad4df740e49e1a4e72c2623b9b5a52fffec46bd1658afd665a40aa55ba8aefc066c159c0fa124cc83fa7e8626eb9162f3bc3871bcf3364bacb7cf45a0a17b8fd1e48511f0b89173e33e781e8117afb42f6e1e800265f7bb9acf4c60fadadbe0a3711908df423f8ca2c9ccb787018a09a0c881ba2e702580510adc3727cb6d9da265a25a92ab617a110e6b09f02a7d2048a6d093f6a7a9736bf82b02481224c114a4cdc99b8171b9c2cafd678475ac30530f02da05defee7744869512e357224e1bfdeb0f007dd5ce8780b6fcea45342023278fa7f12c2676d1799a5f3e792a7a3c621db20b69f198b6301f4f403a52f29de3d1546e529d071414a01f0edf0114914319100a3f35af32020ad29c446ac1b79165d9162eb616da885569da001792bec512fa5e59656a64ad6041eac88694433e3dd15ae48d8a18dd0c1ce10086e9eecbcb37108313d0e99d01bf723f6c7d6d1902bbf373fb34ec8fefc8941a5b74721116c7f2a68fd14241e977adeaac8d3b284cbf4a3b3d7d20f66f6ade81d706c0d892f7b8a67665f8cfa86c6719cecadbf1e6de65a31d5384aa87d79cafd58c70483ac83d190645f7edcb68b1ebb7d1782d8640e071ed17f1911f033eba7ac9ad8e6629b4c701b44495816c00cb078e0a9280e38654dec734ffe02300562bb49aa9168347c6d7a67510452d6e50187254623f0491d7f7c760904b8cbbe597b8d5158de4e5582acca1402115c5fdf6a6cc14a34c962832b5b78d0ad0b5232561c7c320e9a5eb3b665683121c6978190f702f1c28424c00907d401ba74d915a4ecbe7cf2c87841176c1d1ba9fec92850c4ccc5ee776db056eb33dbaaf4ddde72b0bc84cd8c36af9792ef0f452974c83bfa8ab440817e72214de36b6738a192421b151b2119d47078325a6708e612c347caa151d7e9da9e269bf646ad0ae76d55cf885880f3a5c8ebb18279cd9afaf2f2315a7812735f181b5bbf9ff194e9909bebe266118f67e5f5765afac06b818714c2682120aecaabaf7eac24ec141d7a3f5960edb1d7e1fe31558bb9877485f74bddf57df08fae690f8f6fb26eacae95411e598402ff5bb98dbf973233fac8c740d697f0856dcf00ffc16570f9b025061da423891c7b0cfdeb746e1f20bd2d8f9098e038631f13d63ad493fcba41e6a558efa454e72ac11c9e1dde166ce82f7783ee6749a29497f884ee4579059d063fea384e37327396dfb3cf73b921e3a43b3094c82877071ccbb4719d36e6c9970e874abccf8f33d1e5e07243b5b759de325341a45d33fd861bbe6a77f7bd73506912f6a8362e6b564f18f1e0457a60ab0a922df3831b66cd68e80f93510d67e3014e9f23123a68b7a6d2e60920355f34abbf6dc7ec25c62cf16f55b99ee59ba1a9a75239b49ec34b08e2de21726199ba60a4e3225c675274825caae79e97676ae6e3b21ae445e55f737576c733903ec58a10c1c6c731c375031795023d2434167cdcaedad6305c72e9772604edb0ab2d5dfb2da48d7794f2281cce52426fc9c597a92ad029ab27e62e0a938582ac325b1b28049c62fe11441bf7d12c85be35138dc40b3cce5b74311513aefc4c6f3344e438270fe26aec0c265531b9d710671e35b131241ffb92eee1a60d173c8cfed75bdbf54ac695939e4a1453ab573a2bca8eb0ce77ff6b43e0918ae97634966d9264fe5eb0eab9ccf6c07a1a7b10a145d4d89000198d40fd91ccc2a3b340d76969e88a6cfcf8e3fd8b40ba9936c8c37eb0a7cac5d1b57f91d179dbe63e9423ab2dcfb777f415c873dbcfe7b1e95218b7711c244e178a3b9064123f3035fbee0b185023dbe844168c96736d91b81d08ac9e229a90508b0e5a4cb83b4f68e6a33f1862947971c5b232cd66ba3300142bc8114ee7319aa5d66784a1ed6b34e744d4dbfebeebe81feb040ce644077f815cda40eb737cca4ea419966b1341901ee00a886993f93a12aed56e272b4dccc77ce2f83999f55976cecc7aed6ae6cc711a50ed8e66d75e27498f1ee94ad0a9aac6a0dd5ccd64973d0aef2d40e10b22c4cad5ab5423963372f516cf29bb3001b65cd46c2e8b4d1b85f05cbc6477163eef4128b01ab228d04cd65a292cffb772b252c30dceb6cc508971398ca720bcb36e5225e477c7e055dc1d342985961a224b89bb29500b5c22c8212e85cceb0ad8758418f8f5d8e9183100d9a9fe0598eedf8e9132122dca3cfe722988372b625b3b7766185899d1a73ea6347c15dd98721c51ae513be2e2992014cc30968f9ef66727dec2af91d42e27720a4367f77ff282cdd62dcc4d2a8f34b2a1adc27705c52cce8bbbcf8464e82ce03336ac02ab9286743f9a9596ce12bf669c4e9049c9646bb8e41c13e7b9425f8b1af275b64aa5dd5722b200d13050a35e1e2a263144fafba5360cbf3bfe751f77757f708a2f2427546b99c08df11f4d6968ae243475c182b785fdc0c9232ba854eed6bad070ee98c104dae5e66300cfe1ffeb96be2d3c9d08b50105313ff6c5c79470e0f6edb5a48327ac6fd78ea9400fff52427dbd892d589dcd26869c3c02a58399e08b6a0c2c77ce0b9bf2247914a150bfe0639593cdd7ba6dfa3986546ad229526471aff3f3073f799d72ce54408bbd18d2493afe11b34dab8f3c92262e1f104bc4d52aa8a6af98e5b221b5785f3e83cc9789e10fec61f0003c596186d54fa7c696c593ee3204cf16e577878ab8929b32feb428746c37caa68a01630019a41ac3d51f1d5696801cca303953ac0ff12b30d29a474a80aa3f75ddb3b791d6dd8b5264c71696d1fbe7cceebc961670d1c63f038f9a999a4bd913d7792b1c5fd60a079dcf278e69fbd5ee627b12ac75ce5e86db52b4a284d110638f9123afc96c881217970bbb60c60410c174dc01f472fa61c26169d67d007565ae6bd5c22791cbcf9a7e6c0d95d88772c5262361c416ee30c9abb74f86a39abebb3b7c792e01caf8bb94b6f54245c154c1052f0a04c3fd52ef148bab70d2b4a46ea7f175f339132660db70ac2ae1efe5ec8b252a1df803c929b23d00c8c1a7a7e6be6b99e28af39b58c288d7970b995e603cb2846ee6944b55dbf0f9761b694682473918443dc908ef61e80e44d865f9e5fd19b072e1efd5718e73c0546099ae50203d6563a86cb6690804fe4950dc88e3834119bee24f4de4c280afa512f941c6c7704fc4f3b805d12c3c870094a950144c511710b2a723c7efe4779f146a372b5354004934eb4615b83825106aede8f9de958f424566c72853d9ca426680d881d94bc75284c1fec4fc0d536c829ed0b5e8568419efb0dbae0544b22dd7e0ec593620fb10c39a44a72f496c5ae82f6999b500cbf691a69b86fb428d3e693164f38da8f4bd34e16722dd822c678edfcf6509d14b1b6d6f41b7b0ab12194a6df27563d4eece9560e18e1ac4352ab8193f7c06bb247cb6670afea8ff0190a8f91c07c281a7166d187048ca2639c769089669bef3525b3001704694b40e8d2a225f841b35738bf2dcd600f7fcc4af9f775815808b3d6b3be7a9b2b6235dce59ca4a55691cce032bc9fba4ae7d68e76cef9e11c5d963d8ff992a0a61b128b485ca448c733af21a10f673b0bca67facbad4e9b19080f00801cf67bfe0aff5e3a4bbe20d285c99f1a28158ab27827d7e04bbbf27d1da613e091c0c568954f524cee89d190245a6426e091072ec6ff82dbb1d39d6b5409b6e77e81f54ffc705f173c6a5ec31ab47173356a506feff22f7c41a9bc62df0c27520608c46ac18c72ef5c0392289ad0d0a8fc689d7a0c372b8699407135524754a5169b6e3eb7f313bcf2cf93017a0acb054e86c38c28375470770cfe412083a7bf5aeb253faf0c7902fb8a25a2ab11079fe66ae0f868f7aa06c7186cd8941610bb3e903ce1f8e0222edf0045fad8a854af8e2a401e9e55e37050ef1387f2875b6737cde972a202b41aa23aa00217dfddc9929d9ef5099808acc20c07e3089847aa65aa07cfd9d685bf43bd2d077f3b2cf463d9782ceb28eefa6419260cedda1c023766174d0e62af52b41f0275d93a1595d9b44015b11c5908f1f51aa8190d203c47cd6c6bf85035d03707e9c864d3b9ce9fa4d147bf7008048e975a4cb232613e660019362e3bb674c318ef14c613a74d4aa37e83a135047e3fef5d4d136511d56b7e11b1de16563c8c074db22c1a0d4e583880638a844021182233258023e21739f98369710803de95d586ff9b96761349e44309851f0a7ea77afacd4bed5798f408324aa7988e37daec989570334ec04b7b8447f22b9cabbbfdf18c3340109dcaef1e6b49a238b0901527c7e57edd39d042a93799cd10d11fa47943ccfdb38270278121408a020552daceec2e07d4899520e1f64444d109393e399d399b7c3bcd51c222f4b27048d8dbf4a1811564efe3b95d8dc96bd9e79b300c47944e93488605fdedc72e2b6d2be74e679cefccb7283c42cdf4740a1d74d693fd8d94b11e360e1d6cfa5d29b904e2364aba5705a656e4ac9d961dfa881cc44612d5ec5aeb804e3c6ca56a6d6ef1db24f04fc70ed558baa652d7544a4e3b840ad51dfc6ebbbf6150d20fc1e36e1d25f32e853c144eb42a80dffbf0d80c74908ad759d78bb4557ae10578d799a1b5ee1387c05dd55af6d0cd56f3cf4f2cc1b909e2d1a542677b263c686fbec48c481f40e651ad9c0703906632f69bd12fc6e8d1a4e8586acde0c118bed687c898ef132076167cedd660a71b3a3ce270ac67a05e4e1b7fd7f6fc13433f60c1253cec338edfe4e44c85dc6c1c2edd9b735e63a23b2be93af9f0f9e95ae0b078008cf050dcf3883bda4f9fd8920d44a59b927b7c4bb7d414cd955120b45bcd38926fa8270e3b65f5327854dd973af9b165c022d03a288ae5610f5d12286cc73a4d2a96b32a1d1dc11a57316e6ad8356a493381b2cdf6342573fa66e05cf0c385d853f8eaee73bb031641932c129f36b0415109c0f74af288ef3c5af26cf50376b005addfc8da6148ee8890168e711f593640a24b099d627bb3e2ddb634d53a37834d847a50b63e701a418214a186089119cb1deacc30c696e209bc325f37f57623773d6159c6f235535c6b8e1157812e7d244c57e2754c7c6c9d961b0ef97ab403172d580cb61baf8a1b9372c105ab4fc379b147e5d1723c2e126edc4ef624c20ed56384853b683bc6c67b71ba25dcd2f18976d0c046d9da453ab425679c0a84a33f71e0987f470b97a48829b2cd3772c6d0c606676bf884b6aea916ac863c007a66cf2f6a363bba04d3d78b4387611bd49d7fd1ebc4d8c775b0f695fd7d35a30f39b886f6ce61a0de33c7d122fe84efe24bd91e69e4a335a32723c6f679858ad659207b2ce3a889d76dc7054a1f49de1f3422dc70224ec11ed8ffcf5f6cc8e0e55987d742c7258ddb6e44ac00ebaad6e306c2b2690e64b95e2b2fc106379b48b71201b7e86fd70b31c59abad73f7828a75b945279dafee8d84367e05ad9e65b99ec1a80eafb260550db8f4edb4c119a24a65f3a794339a26ef9e186a2aa872b65f620cb1ea4d9e76022788fb33baf8d9aaed892d6dba4b62f9b2bfaa65cf653feef49e8a136b6f8f7ab8babdc6573ba8b69d2dda1a1a8bafcac3800067ef74d1e2cdbeb591f2ef2acb09d1d2c6565984e5b1d993a680c0e0d177de37c07c4882db952859cb9c849d45d799b01e02fcf26045a5783bd188c1d102adb8e4a2adcb90853f65caf88ea884c1014c6977097aec037d54511e62069bb18a4a87d903bb24bec77a9243a34ea52567ca8c820f56df000bd704b52b31e6d46f64019f88dc5cbd133bbfdc90017ba5118462d0b9eb4f56ccbbf52414b2fba370249e879062118cdc92faeee778aff75144e2f5cf1ca7e90c0a85c17a2198ac770fa54d4c7d056fecbacf916687d939e38d311355c233fd74420406d7b8adca5b01352928a549c386b31f360d5a01c22724b9fafd1ec76bee19db36fbc3dddae49c8736a70c0d400eeeeb3bd0b82f07f2834773c10bd314f406fda98142260c1900ea85f7450c34dbdd3db84b12b7290ceb50eda5b200ca0b080a422302b93e2a7ed63b8c9ecf924ca61ea19a853777c593fb7d1eab71663c84e8ac4b21943c2d76ab9513b9768d14014e9a18fc7693838133e82f320951e7807d875953898c21174ff867cbe7dddeb03fd4c5cc14119eb6db9118448cc42463978db177a7973ae165d8df0e581c63f3fd726ff245be148adda5794b88e66ea289dd1222a2a812a1fe8d96273b01b4208daea5cdf8d623e7c20f185456356fa75f77ef8f2973143b532b91e3ff030503c3cda18a9eb70031b7174fa18fd3244571da5e2840b03c02266136cd8c0a3004eea812fb1b0014078efaa37bae1fea6804a85d51af01d7532f778057af89b3f14342e6a328ed9cd439bf9e93e5749b550d22c38fbe24b87ebfde0d842da8bd2811dd9c431d3b6fdf4305d6b54f9ec96d8b0bee18ff44e6abbd11f42255a070f8eb5aaa66a11a81b133d30f84a01802210878eecc4ac2b357e64fe6cb6d9965a49490a081717221297b5b86e70171a9b6c88c1330a90de192581206a4d997cae724e813898fcbe60d98dcb2de04061cad75b315f4048cdbc2c87949da7fae6a6950b98f2d91760e341e290f3870af97ca0a829987333386795a0c9f9c8a4de77c57544ca311447c203e71a7a97201fe34d586e346eea35b3502e79c2e36e8c16eee776268422e5656840ccd8976b034d20c4259a7f7c2abdb293ef99298e9b064d336de85703eb53fe45c7397a3bf108cbaa80dd360e96a6197540bb521ec3b60b0170a4f9f231bfefd416a6adc9cc7ccc1f7004aa9a800fa92697c5a03d5211d05323f3fe54055d23017ee711ba2717db6ef87a83940b0125865350d665c8fd8154e73791084adc29dd34ef455b9a22bec607bd7d283a95ead44709915e2c0e47eb1164a8b74ae37b010627e51aa52799460bad8d24c43c5ddc821faf9a7f2b75cea34b7f8b7fe11a208c7acf1ccdf7c874582ffc89e36450c7a505e13af1078eb23b32ded0e67fd682da643b61fca7bbd831a09f82510f2137b17bf55517cfebdb3aefa16875fa871bb9ea85d1cdef61f03923f9825b4e60f782c73fb956fa09f8d2f15455ab05f07cb7cdcc3d61b395a79887b09cad9faaf197d35c176bbddcd4888c8eb5730bd7d489ece7ed631c09de238a07d5561c5ff002d3fc5599b7de20dad4f6e90cde32663b86d85953b3b5bfb2d76e7d1aeb83a9bab07b10d38728871d4a974da902b83a834595ba8c8c16ac178cc5e8c03527d7647607c458d79d48fe27f0d973042a0b16da5d3b2b50615a18bc1cac9c167b891c2cf34cbd3418df4e4dc5f0f30babfa8e48003d3f9aab0ac84e8dafebcd223913947f4d7ffaf35a5b6c91d2937c47871b2cbb2e73042ff4a5e709e70ab1b4bf32fa27aedca63ef2837c1717bb2064bd181ac9f58797734493566965d53367c09f25d192a9d6b20e85867d805cdd57a2b4884ed081749b967bbb4c26313938f261f89a9b20f0269889156a0d9de7fd5d517c5b177a6ddc30d78c7705804816eb0bc7c96d236d2a324a5415577f56061506269200d922c466d05c295189f496d60e820acdcd118fbd8839c4d03b47d92204d62f031d9dbe222120f224093359ab9161675cbe1ec8bcd30ae817f753b6a9c4b18c3c2962468946f1e78e83c7d7bf7da6a32080bbf360459e39030400682b788409e22fa87ae881650c7fcfd9baed461ae543e1ce5585aab51e4aab16a09c23da9535233a06349ad4fc383da1e1e11d659fbcf6cbfd43b2ee8428951679997ebb065892b11b1719283d8fa781eff2aed60a39d1d06d6ecf8a0dafe68e402286ec2b753a2a84465598718774a6f4f80a3cbbff3229c85882628ee1e5b95c417ea352823f6cf4d4361ff521b0a55073783e8f224641794f2035be7f6ad90889c24a94b04681dceec43916ad64ba1516c09b1a6f3ddd183bfc44eeeed118264699a627b1ae7cadd58ea9fb524c666b6f56051791a629823faca55f184f36ede83b738febc9422cf4ba06a24881e6907e3ccc1987e805ed1c1229308f809e070da6893e44a990d1e27ae71edf2cf33bcf55ec85c19ef112beae9314640c3b560c2940e8d26777f636103087b4e63b7b79786f4fbd2187d29db16dfef2f0e1a6ee5d3b3054a67c45042695c57ce475df28fc3211336d73a3242779041cfa2e8392c5abbc6189c36573a1e346c8295ec63c4fffbff9093864de014fb12f363d5b94aaa0213dcef025017063e78cc8065083c931d303d13c9463ba3be2073b6c795cf319e82f26181694de78aff6a4a77eb017d3906bf41f195f5234ec6d80145b4a29d76c6d719e80fea12f09d1f26e1fcbbadc461cefd61cb04e2059184b5dd00f02be2c8a649df0e6d0958d5fd4eacdd648ea7ca04ec0e8ba142ebd94aee03d72c733ac4fa24e20fa6b6f89b9b4bb4fbadb6bc61e06c52b74fb2ab9a2ea9115827997bc5b29ba4537b4a32398a55aba7ec2df3cff1c619bfbf5672ea3bcb98cede3cd3f88bd9b3fe689258d1c2f322c628db6a5b106d40fb8122596c0e203a3bebaebdd48d859c5797e6b15744de429c6b32d56677101f3f6597a2dc461c37473904023a58011d600c65a5b2caca41bb4e8448371a761ac59d99bc16c74d10d4ec7d1cdbd4ad7818a15f0288dc09519aa0cdf986cb2af2224feac0c7203f83678b39edceccb9d1b859a1571c53099ffc262967732f1cb255c42e7a630499ddc26c60a6c962db51f797cf7f4710b4c837b12f34439187247b356c3a010e1ce9ad04e76df8ff9732b8c106a49d17fd51d2a82a98bbb6fb6d2613b6659b57802f53d6f57bed7f3f7615c915785942da9a318c8e46001116665bd6741be2ed5ebca0262c4da22f2b6eef968b87afd9de7ee5a23034fc5d69b40d63a8229ca1a9926f1a9e883d60f89919f619411b81039b9310865db034f926bc0efe3827ac5931127167aa861b68ddc6d3562d6bcb01280a7839b453d290f9d91852ec420287fd93c516577e9d872c8233d64f3fcc43c9f80b3ce2b149db382da69bb9a68747c7486408b7da61f0e3130495b3f19149933b3f88c9ac09140b53c703def7991ec3e5f53b6bd0ec42ac174d3c3a674117c0131600ede7cf26d1fb78da78e0e1383459a8f35227d3561077fb1e5cb4e3bdda1fb3e2893c02437a53883d930e0a90c55638c49e39d3369b03f047792cdbc94a1629f272447560afd62516a912e93f5b53bf5f70fb937db74f56eadc8de655ab3903304e47a764dcb584a3e1df2fa57b5acaa3a322e2dfbb88750a47ce7523d3dd1bb512953b375d0b8cc9af565f02d031bf544ae9f74fe2c18af1785dd3e13161a60168117066000f95ad45028e64313a897bf71fea3c0cb068f052a3d1544df5bdc26074b8d28bfe550f67e1ae149fadd32a98b4640e455df4927e5b92f57afc38ddf0e8bf6aa2102ba8d47c16656c44e79abb1cb6bed0cbd2fadf8de4cb0c00cfcedde3e7847f692ae1e7028e6490b8063cdd7bf699d0558d7d3f75d6d993a97bdc00f832e0b36a3e7e73d50ed5386cd56ff37fde108d333f658448933e5816ab8359c7faa8ffb0a6880daf0239766a1f0af783fbe60204dfdc0cb6fa34845b6ec2a846b3c8ea93b572c4384a4bd07ed47d584cee93d5baf697ba051f0d0dcebae81508a6a3939bd7fa152c21829648c848b6e56d60f5c9c18784939062cc35714f4e0f8cb6e2f8fe0d88894dc846dfd7ce21c6ac2626925b38d20d913c901bf89e59a78f6663c172ae418af94e335111b0d14ccd22f6be82bd31891a9d5bd7183ddfb80810116232b5175a5151fba645748a1f13b3a883f10a4b70f0b5f2949b10b5cfea1113eaf71f0e0bd39fa7f8d141ad8bdeceaaa2aa48c05c4518cdded5b4c5e75b2b8a2c0a3487fb6d3ce2edd751413eabb597649669a9461dd844e3b5e4fe5927e03b6bd1386d3ed42b5d7450c37c90ffc7ba3013c1831e279ef96d04544437ecd8e82ec5e7cdc81cf41ace4f28fe936eee1dd45f84255259975323d0e20d455fe0a220c9cfa86a26b95b42c1ec3895d5bf7247c9a1cd4bac4f5fa225907d2303e8a73f9ee78884735bf85e0048335bd75a9d3f90c5315b95b9711c29101f7057265ef12d883056e9acf21e2bdf92d41b25d2fe49d05a9f47c4400d1567a2c28eb14e482c8c06c85090ba3633aa017c775f47c4eec6f62807de86ee63db672d9f08fb8cc8d2b1c5b4546b51c263e4736ef9c2661d5c22d601bc96cbb0d728952e761f03829eef002eec9b43f409569cc88a9a14c513fc8d7fa9834ef0ff2cd1baefc5f0622946b75427d50f3c9dae07adb160647ac167827732ec730d83882879f85409aa113b93bc091660ce9e553e54971fa21c5b3226b6fe0ef269a4233ea8bf109f6f5f14912002fae323ff340306498c9b3ab9c683fcb048af620ece334237be795bed86ee246685f6426ceb66196d3ec6065e59dea8c900a71f387b1b73ff55bcb549cbe9e504129b37f9667db2a9616c31c1c76c84c96b3d5b048dcdaa4a1f5cc9e4883b37bfac34e5bf67e3d081d259a95e418d0f0654767a6aeaf2407564a69ca7ec6fae527af334706affbb163bed349bc0bbdcb2f4d9a732e5089db5745b37a2ff5689afc634a4db06ea09fc51b51ecf8d4fd0a65e0ea0a61fec2e6f7c886d1da912ca31b317fede8167cd5b0271cc5dad3856a67621806e6ea52b6efddbc3221fdc24692bbe40d48405601fa430f76bad80cfbb08c2f3d98d7444438801a20170826363aea1588f947e12cfc4c5185f5c3abc8dac288f59673c201563dfde3240d279eef24677b614cc2c45bab6d5237d383d6a96140ef1e659277ad0fe7be32ab6925f56c76e01d739d3b4a9e01aafdae17cf87f0ee900ebeafaf0a2eb8670bbf56fe5ea63a9cf419e53fb3a371c2890f39b229f21a1d26849df4841281c0d293a5c62d4179f2605c92cd6c211a936f2d0519fbd646259f6e5ff0465b1764b9d0ade9ed76b039574cc49b691c5099646c067dc02859e4e3c96e4f751f65e71a119e7e6f2ca7f268239aa705e8e0b6d3660c7724bf3884a035de60f3540d71c407c2261afa5fe3c877082ea21456000afb1ca022dd4a16b7d9b5f3ac97dcf2796b70c36e88b5a5fb4b74b771f06ff7db636e31fef3389e6cfd755a55e74f5800ff4a06d2506f4ca9d5db52c0f9eb91514ec189528304b2e88f2c573181f73a498b2250046626814021ead25741810fbb7077e3652b920365186649b992626aa3df47948efcb30b08c4c7f6fc412db6ec7f67fa01d115cd4be5e62bf8007974e0410c8127e07a112787dac6a5d8c8a5b81648978521ee8213152c5339606328291422d43cc4f61636d9cd1a7850352378f7fb749c8b5083faea30b4de31fe7bebee87ecff23d7597ee7bf92587458058d59fad8b7e514d9841952ab35e60ea16423914d2a8d8fadcd536f0db36d642ac6dd36cfa98ef661c84bea2560280c06f875208de1b8c6d717b28845ecbf7f2b9c7b5a44fda4eb86485642eb4a64be04d8a378b8a13b977d4f3d95527f3cb4cc621d4cbe96f994b547ccf5e6b385ce7d46b3090ce7c8f62e548ec1aeb0ed1eb0dd5574d68132c722cff8b2200836a8d76136c35f36e08d97e251c4160ddb7acef91f1daab5b1b8f5490d9e04e7fdbabb7bc3c3cb08b3bb444259dd3ad47e7235629adb7c7127662346f5064662dd20003bd84c9a2daa363d260fe0bc54bb34d83ff74d93a28a795e73f0cc534b57c2288487a409355ef91d5fa5958ce90183c25a3fa71c49f466cd3c9679443ac419f1f22d6fd8bb759cb96d25c9c586e9ec887fc26c5476a903d327df09d0ea51a9eb49a95ebaac17c7263dccdfe57fac26fe4617e40a73ac93f2d4f458c95f50681dc9c429ed6be06a2b36d2f850140878e842bac899ff79ac22d662ffd75276f7678190e7081373f56c8e360da32093c31b6e93a55c52f01370c6155285a4db14a73fd296bbd722dde011eaf4c7bab0bcdc7615f75e1a83f002e5a3434ff113866fc8967f249a982904144532149e647a0618d0d7a0169680fd2776d82c188ec9dbfab8e3539bfbafd0a116c587dea77fc0592ef98755c0df201ec6a9280ca9e48fd880e1b45cc892f1a335b6b7589fabf38bcb923c7b06fe5a995c4964d1bb3565320e6cfd1e97e96df4bc396b6ae0d2efb55e2ef365dc5770be9f7d94dde3e60b118931493d23764a99d83f7269408fe2dcc8e40bbe8ef3e8de35e7df587fea165c3cb306f9663b0e3de4f5e982b73949ccf88127b90a9f60439bac6ee1d90d754afc8a3fd2105b4f1f1455638dc9b92ed312b1e3d3fa890e83b7508b0d45dae004606648c09b57aa8ec5d4736820835ba17a1c4278fc6ea5f26c66eb79904115e830ee3e4b5d726aaee41d61c23d02371a1283a7c553d3dec1c7e7b4a94e01fe24e4ab7023afbe7bebef49fe4188c6ea1dcdd0575b75dc07ee584a8d7124108bcbfdbdb40b67d6a149495f0aebffd60f3e28f6ae68975cfbbe643a45578f37cbc855dc22d24a5c6496c9f982378d555e2ed404c10ebe9a57a3fdd08eaccc9665a36956452ee2554f51848a6afeec5d91927e0560a563fb3c6f1ddbb39da61b15ac26d51f179f74148c15ec7ed31907e61c0204dd6e8d219e1e2e04b8be4cb38afacf447eb76c0bc623222aea1c6e870c48b9dfc5f19fe4c404eb1decd9f2fa952446395ecffd5492b2b1ae7ffbb01a1bbcdb5814c132c02876bb5a1543c42c1b7acf4c499bd225ada2e7be1905d7f6b1ab12e59140f2cab2c2a02455ff51fc49426dc7f148372360b43d1e6c427bde5a08e32c1096310af77bb6e3a36595ba70f2a5308bb7b5f6f194cee038870048d2be5a69497065d0d6ef0be8519b6ae6d9710aed46839c9303e99fcd43779411da79fa7031e418cdb4e3b38375ada5cf8aee23a642f54c0777d88061aa1142498a3b106d02d4f7cff48d64c998de0111283fad5cce482dc80180bad71d290792237c3c46a55dd839358a63a86c206719daecca746fc123ee35531e6f00bdce168a1046afc21b3d989418162a7061d2387e774ecb8d53e53fdb2b3665914239cf24e4d4e8ecdccc5f3c20ba6c23351a2c0cb67750c7c31e0d2fcebc7227caf30bd2baf7eede864bebe806b1681bcd51ce87a2ffd69f282e5e90d316f70aa1ed9f1635ba06ebcb8e90ad56d21419382e684fbf9f4589d879507f244fd156e98f2af3e045219c2df5201432f9f91172280f87af1d63e0e98e2f58218db52e8e373109114059cfc242a8807340f03f5e479e2836ea5a6be8131ab7ae8aaac0ceb92f128f9f9832a8c314469a14cc65252d012302d9fd41746f94258981f800404ec333503f83cb3dd748b555b9892f300533134f1775faf1c70ada8811b9771587c23bb00d084964edad6c95bffb1c38774a746f5305fc8002b229d5cf6c4d23005dd66c55fa95d6b17a4660f7580add4a3896c116edfe97ad58b250ac3d993606a8a901405cf92802cffd06e1977cd73d549dba786eba3c93696a5ccbb04e27599c4925ec8624a950b250a247dadea4784aabf86422c68cec93531609a2a6d03e6de69032f62885a8c8ccf9c50c7a5dcdfd1e4724bd51eabf030afc201fb33b5191d2ac716ba52d52169da0fde6f95861c5e2d1a965bfb27740ab28dba1e56924e5d16a3c14ece0bbd38f4537a337f2bb91d94090c72b69b414f71ee1efd8e4bf0b772af999b479d802d185e328bf999eb2c5d884bc9a0d4a22ee3db36c706790dd21814fd1619eb1c17ed788c2140957c61283f7fb7b212df086095249c5caaabc37f3bfd68edf91ca9718a332f976db0e1e300a33a36d8220da285fd389c762c40647a77d535c585fd52f665cee1148b5e2dc2385b54d3c238cb25bbc9572e85888580a21b70efba7e94e30919e9fd013028421f2bafea114dd35258e0448bf28c11b2b9de3ad041b1616654ef0fc7b3081216b6bb8512faf90b8ce20fc41d541b2bb8e5361128be241a9786f29b03eaf58aa747588b62f4bb15f9566199a8e6bdbd786df74923f66162c663e1a4c5825dd4d1158e928a48f0968293ef6d2f137759a847b5b0c4d22339d594c49fd78ec24f85f8ff9192fa806fc0848b6c79d12ee2bbdf4d018341af0244004251a9e138e2a536681279d3a4e71022e7be8c0ce73ecd9a729c8727cb4dedcc69bc7ee03449fa6c165cb17aa4b1e352b72a0971664f6734b0c6fdbce38fc8b58d23e437be22e1d826d7650db4ec24422934b5ae3a6bdc76645a2cb7a7c4ecfde014a36b99df897eef95c25bebe1b6bd46dd2daf03229b7eadf38bd79ddc1ee424b4050662d0665443dea924dfd43ca54762dd857da2e8376c40b2fbc06e334fb4021a321731017af247bb56476508dfb6292b15e575c7ad0b5ff6d61fbf31b01ce21ca0e21520176be75c4a8f496c07a96b8215c44aa3c7bc75abbbb3be4eecd721a81eb261ef40e3bcd867f638d6b85fc72085f3e9143c98391b579ea6cebac2cb65415f73be2a4106cab880597cabff2f39b073f7c014b530f12e1ea844fae689b2202038e18fc4e3e0c866cc26870780a8a41faeb64ed56654c0082a927b07db60b72ddf6dfd7d04bda395b1d79fbbdfd860df18fea38db10902bee9cdc31bb6f66b7f49bcbac442444318d38377720086b91957f9eb9a1807fc5d5c20cf352382653571fcecb322186e66399802b69d012875ceb470de2830f780d3d1c221d155a19a75ccb6f96b1bbe9133c0c334e99b56b57c4bc8ae915b0f7d660b932a50b79e68925c4309b2966bfd0908896023ec483741e2bffca95015ff4aaa6cb464be0b28a15656c5d66f01cb84e79d6d171b69d0b9f79fba33c52ca82f8d1fc6ab9b7935f35b0839efed9ea17c1bea77e750a6a67f655b6ece7ac56fee877a707568d82f9ccb6460d514abe72e4768d93caf9306417724e5318809092bf59a289ce015d90159e762a9457e66a0a6a37356171e049342466553ac30cf5e541ae1abfad54cb2b3b188140f8281f64d2a32ba34d8e1bad2b452aa701fa2aedde8059ae4b097c34156d4a66a60ad712302a0b06053ed558d5894d59346f72f15caef092ba3e1b350d463cd7ed35da8e808c2d7da54e9e7251a8011ea96f33d52652d2cbfb5856bb168c006ae9a5a53f67ab90dfc4b8085b4731ceddf9c7ac1aa956bedaf6aea070f2493d67cfab0858a9f7d8bae89b272aae0abf5f4cb739554f676be6b7c330ed40ababf1325241e47390ac56042ada7ac01868b355dc94f09759bcc3a97bd3b026a5490f51f8b73ff9a2400a6184c96fe9c204333ea5c2bf1df77f9c9e4928286e6f75398fdf7f9794148bf839e7c378a161e75c462de2f011573f99c990e22e04add92f96497158f9fdab63aa7e8bbd84c284f1aca53cf9fa3a7c946327b3390ad1218ede796b4ed0695da0f1cf008ebb424711553c8101f16e7374845f12404c034e110301ae5c735a8b2ce7a5a189b296004e27af602a1cd83319a3de6eb05f133e7bbb1f649f467abf69c769207e73de2eea9f3f304345326e6a6d6f0df0961e9075ea3cc06df4ef6250e06cddf0f557da3c549465f5ecc62213e407aa7a541f66a9cb161257e96950cce447401271e62a7fa5d7f958b324cabda6c78ee9de0feeb5c9cefa95d05a516f97e83948ddcff45d0389b6d421f5858d465965fb60c782fad56dd1f8a335d2cde24733d2ffc57fdfe5438b734955618af1f44c72d7a5a77a3f24e54614042e1d4968ab4397f39dfa9b8a62e647a250f8d1b0e6a6c87bcaa2aa3df9dfd5ff33c88291e2163842189c4c57d49a5af0f37868ae9855323968272b0201d25b5a6899299deee2c10c12066f5070fb710e7a36380d2df1aff1bd9233a648f51ec86c0874cb1dbb1265d941fbf3a2656c8462bf6b98c4a2e8198d8660331230e53073875f10b1d8a375f0547ef010b505af9a513741a42e171d1be557d01ce875d075e84c534d6d1f607a5f01251f7453ece5938b3f739c6fe181021b491387900058abfb9258faae3614e827cb1da364522a0f14fbc7fcafe5fa1796a4cf7eb9bca7877ffe4381dc6411ee8eaceda41106cc27a1a23943b11d3d6385b39cc1a724696e5a2d06ea5e189df675bffe6d1caff7dfd2ebf3351a05f5e5d59aefe0192df058ce1239e52fd44cc71285c3d3d3fcdccffb7148e9f2b9631cec6a2289b92ac9481ec89d4fb2a9fd1e05fd658fe9cee4ef0a51eda1f83290e0b5078d74674f12b5d3fe80bda83ed48dd4f6d44083be349526605b18a1d8160030d12af64146ea63781b3436abcd1b58f5527c6fd6325f4e24156b69077f64de3924e7613870d8256d048358cadec836ed85713870d64b37c7f69f6a3ba8e5ec6c8d74c53aed3ee28a3c4f081800411cbbb7195d52a46960d6df968d53f0c0db5581a048790e37d79e080e795ef488119e2a13debb833d690747cc89d302bcd281b19887452cef23742f9729b687211d2fd5885887704fbecc241232a35e6b4f9d8f69c67dd5b312a6d3eb67cd5036ac96709f52c0664b17a6cb88076360b5c8ab47d4449e0990fec584d73d8f6b676e540ef593a38165ef0b283f9b5557a37387689e03c0af0ebcb4878087a89d26e0ad89e74dc325643e3c87e832bfe38e63780a65cdd776c1ef5f87287305bd1ba74941b2a080006ec1954a16358823cc7030b52200871df533cd038129057450bcb0a2a6abbcce522315aabeb54256e4e23df638ab77ab815884494e90f587cf4bf81b0266edf51c24adb1576a23617696e495510e74e04eb7ba23256ff896477d62fb2e99c90051bedfb52248e050a1627d39933389c7c2327d97ff8a0d13ca12d7ce0c3bc14e4185cbf8ed3d55826de6ba470f8cf5b61a1b5bd531f098f9d5cd6b4a2b1b499cee879e12c20c5e6e24cf0e975f62be4a7b40efdf8c422a282b6719022b4ec7cd15b73a3ee78c112b1e16b818125eb191b1033e0cb163f3ab163c70e197c7a6a7460f49b34746da2495f913da96a59908eb1720569aee4d4ee307c6a95cf0f93a27b108d066f308fca9615d5e45380a7bc305c3937d05084f741ff9996e1f504f5b25572d6636fe226444b3a8ce812e76565e153a0275c3f5846510003e3efee24390df6157843cec8ccb381c89c2360bfa687b4306d1c4d43f0cc99a4881328ade97f94a4d858c254bb1c335b4f7ba11239d209dddcc379dda07d3a7972636cb7ed5a0f87bb29a0aca08749ff4e51471b224e7fb26abd8a426bdaa8623aced4583f4bda7e642a6a83405c86923e6688a2518f89bcfe108a8876a2c2fea7b8c192d19dd66ef5f59a11451751b182c67c6092c09b0b19766fd52cf1b7de02eb50754485b00bacb798280f7cf6181adb771da4e39211dff54b032f9fb9cef6049a5485a4a00a79059a3f44bb307727f57ad794d4731f306b274af2675fdb0a2a583cc50ddf28153f249517f6362315b3177a67b96b8b786ca1719d79ad1868fc06e796acdf807e2330999416597207cde3440cb3227fe923f1678c264bb5927cc6b1cd203e986514ac02c8baddcb86e07009372e88db6eb217cafcdba8cb6f6ac3944ad41f8f90001f72704c243e3a0965dcaa8d28915d0b54c014fdf9a155e803086c5b3e36410e9153d5dd3aa9aa828e16ba9338ad5785929af04e0e8aa3104cce7cf4f7289063c29228b9530a95143b57aa1656e06a1ab3d24b7203d0f346022189980d9dca89c16664751cc7408047cc1364d9c05f9b2fa4ba51687ea4dffc4f9b60afdde1d5500986a24190b6c82928b47933de08687828a2481d8b3846ba5c9f235bd2b1310b4d3366538d13917a40a3ef76b85b49781df3055390be52f3abad46bcef1df9abe38ae8fc0563586428cb4653aa1511415a7e27feb9c04ff45bd272cbef13747e1e8ff7a28b8c735ed75a076ca28431c8069061b9c286ccea6290ee950c604108f881e9b6eda1a72b14a4582ce8ca0ffe5e5bfa0ecb30a0a0302edfbd911fa21e57a1ec0a8bc8913abe6f06526a214186ff51f8d44ba2572fb78cb21824673bb9184bf8616ce5de703182ce5958fa1dd0239c6f8df8cf59b0599ef04300c9b264f0bef9b7185bf636b05a65225b367958ea50ae5e749951d7a66e375d01e7bc45fab0ccdba8b8b1a5ece3f08d7c0a261988e1c05a980061fa8a3512d9b8511e0489812f86b39569e250fbf12ac572e8f8074a324efec134a8f529f4a461e1bcf8121caea700386d893f4096348a2c1ee292ea2d5d79e9a560851ec601224ea2c26d655a8617999fe59c1179d70948120388f25639d85acc60cbd8d513e0a94a83621c8d8a3603bfde40236e4c375983da1a8ceda36e60cfad839fa26ac84e91683c86e33d6c02863eb4cb92e37983c54688d5497e7344e4cbfdb202c7bea23a011c7608503396086d16ea2a9e0860912caa16e0730e59e636bcc9d2cbd70d1a10ced3cdde21eb0523555737efddbfb43c5d43df62b1d3945ba77fc76a532e4fb84f1f8e4a5efc8a6ad4c842d50e8d2f999837f9e12cd815ecda9150151abfe638ead53d813ba6b275e302af21bf689e9a863a10578c4fa82370a5782fc1bafe1e99bab9e10202e045b23400f321295948d14d5ce0fec1324683194e0a37166c95ba25fe9eda9c8f513f257c3eb2d786cf69adc4c33f5ec595e47ff2f8ceb2101935f3159dff604013295e884642c38bf625390deb154656b6545354f35906aaa34c78d984a9df41e13058108ebcc12d509894f55ab5af998008e3845b9e8a156f4cee77992963c0a981bd226f7ef6f7b5e2c3cf2dd9222a54672b0c80fc857fa564c3b0b5634037e3d59bcf48221ac0fedfd1abf5204dbfbb073c7d11c955734ef09eddabf89066f12aaf1dd1fb5482b9ea16d889a84664d52bf40b15f60ef212c3f133e2e6018f0d1cf185471ce6ad372b8ef4abcfc946ab9ea424b649ee18c20e897b90a3a24a32a6111d314b0ecf8d5453b3a600c5b2c6d70cf72695b435353ccd3a1db05d1d04a4b927fbc1c2870875da7fdbf8651ee3b508c4557d8510a261a47995236dd15506705f33d035f2196c1412559e2f9a456721bfa7eedd2134a81273cba6bbff7a5fe0c130e772f0a50427f6ae65f4da92a2d25bdbc6b151babaa0689c4c5af8266d140750a89077cd3660ec54a2509ed9ae5b44b5d8b58b2eb8075b8cd362905916d2a3dd4411701c7b23f74bf40f47873e2631953d8631aeed1675b7df380f32704479877ffb64006de454c15453a03eaa481cc93f7b2d6ee19361bbb24b7e3c452278bb0d0a4ffeecda936274cba800e132937b0397a521303ef98c482347a4139120e65c8a3ccd9d0d1ec97e62be684e5a8882b922a405c0b790950958070ed5db47adf8795b40b5f55a146eaa0fd136f545f414ea6c07fb020308d01a760e40fe3cdb6b0fc060af1edaf42e19bbac18e4c9be39842c63229c2de3df2b7fa3178d223947141c98cbff5b5d2c2e7c376c96721d70d2e61f9691065d3774a6d4ddf2184844ef33342cb8c207c24b5db768bb780e7ef064a499091b84f9f0144fbe4bf559eb973ed0aee7597eb08d7b1d7bf5cfa9adf36e0321955834473548c251b55cef93469aa086be08eecb39af61a8f05750ef6b3c0d2902175600f5c32da49328883d573d18ce6b54ad2f8e331ae1f9ed1f382ab1b673a1e81db1bcc0ec8e332f1aef8a18b577dc22de0899027df1d87cc3bf310cb7a4fd01b4d377860bc193bea84e6126b33d9abfd3b5e8b351b147626d36be853c6c52763a5a922b23ce7770277477f1ab43ed2911b307b57454df935bc15349163c95669ae1142df312344b1f9fe9d7489db19afb18ff28e595d010e6410cf99e7cdd18b65c6d703a0d49c57d3170469e9c001d9444d0a76ea3f8dfde58736e6b00be15f4a20487818a1acbcae9d2242173a432fed119768b66bc8c4e9bf4b45edb53a474cf7da6f496e1406c547b521fb56a1d7d4af26aeee07c93ad0ba9a4f3bc208a5eee002fa090163cc4e832981beff52a2295a994db9d9c349295a98a2783429491d389eb6dc83907b88f0d4284a8049dcdaa9ef5f564ee3abc7dcc37301290b9b4be33c2260b932f7c0a6d41e49fafad291ca3a3f75959c0ce0aca1990b1464bbbe859d19f031fe01e4745161fd08a4ef9b7d2aac3bf1462e7da521ecc969e21eac441d21d5f2b37d6c5aa1bfe7b168328297544c6dfd46bc2236f0df06beb725c3b1939ced10d4e589da032b3819c1a65f26570e250c2915d0783425b0f8b29c25a2d9405963a4054d6c0f44d59a56bb5a072c1f42f05d9bb2e7e9bc91aeffc0475434eca4adbb902273d0843785d087a3494e67a98758a3ffc5f05d0b515dad2c94de44879d3bee8bc4b76e5f089775f0b6ddf1e3653bc4669094d9f57c1436b85676f4a238327b1380ef2e9fc93478944ce58d4c89b1b3b35f1194d2cb1b2e0c3f02c76fc320773c8bd0315d6f7783ca2862d88a73c3cd8bd3a4093806b23648f0c69331e1c52a1ec6ea50c44840bff1b27e4385438ecd309510c21cd251ac89e2e0c97423149bbbbf80ea77f0019c25459d6aa851e3e18ef6bd180de8461887cae68126fef91d0991c128812be9f0fa8ca0e8106bcbfa0a23812855cd2f9b13819dc7a6caff354ba8dea0c99ecd427a47fdc8bfb18583ceca319aad03b1ce09b9076ed98ee5504031b483a50d0b521184b676f6bf8fe71628ef9b77b6d2c56379695799c5017c4102e0e2326ffce27c9f8264c829126e9a021b6a24e386b00289742d1a310666399456b451b861161b37c12faace3db833f33d6d794bcfb1bffe27d1253b239bf34fac4549bd3aa75bfd72ddd29b7768f81a56c31532e8d85f2ddb87c6cda3c03a018e1ba2211401afee076ca415501c51fcc85109ecbf3989cb500f5132e456197cd229b106d31f547a823d70946843d5f76214b6bef5c8a91c92c35dc140511b2a135980e3060657e025792bb00a58ce66c2e4efad7183d55b86f503d3300c0d4d93c7860074aa385cacac33411cd07f069d4909b82ef17e9ad7dba0be85287dfd5b864028559eb603835c114d621bff5154e469b30f742da0957a25d72e12e2e05e013b44d59fb83c42ed285b109d46d11d01119621d516d011de809714d3473affee32abb04b56f3ac5f9de38faa84b80302ccb84004044128a5629e2210a56ff730bd8f75c11e0dac6443db69be6efd076874479cf07a09d5e9a2d6e974d9b5adf2a38777fa1ab5b38ea323d31e6d3eabd4314f2c0f9be07e5af0a230b88be47d4da105e067545810a72b98a46b3585a59f6998f8a2cdf34a0d66adbf90719788e3d8323f4b74a39a03d37929ca625a8aa8d12345fb95e9bc956f4f84ac4b622bdd79ab80f2dade542c155ae8629981902ab8732617704eb2172d23f1bc1df5cb25b359766fc7bb2edf179bb04016cab12330958ab42da9eedf3bf4e2bcdaa1daa9c1ba54bb0f10fd032a97ee874c46c731916df52e1f1e6ee96546d82c575514f0d3defb6f5516b6636163eb078bf8ebcd6d9fe5d7c2665001f7bd5663d7ffa88b8f2020e2f4fdbcbf0c2162613e638769660fd64da98d165ab061c4dd681f3eca0734663bc856d13e334c6d733bcabfec3b62728688473de89ad3aa6e5d51371d00d732ada0c14b3445c9c76c58a912440373bfcbbfc7bee0c17123a8a2daf8369fee31e31c85f23e3456cee14e84e64a86f185e5198c9469e55344a8bda3de4863e38e9f6ad00a5d18cbafde6edc831f0c6dd2db61c9792956917d1e340237c91a8d37fded2412e329b8522449e63bdb9dfb4bdfba65acd926ff5947891d99a43465a5d5aacb3cb73f579312dba1050fb35e06f68d4d8e457d65289deb17eaf32205c4e7170e05bac38f054c426f8c6d56dbc0525dddb839c2cf68eac257b0a103c094b65689412774fd02fda71d8de98843862c243cf8fa3d2c226b6766907355b2bfb090540870f220b6af9b5c6ae0833eb255c626d0f21cf330fda55bf8fa03e545a5d7f61c773a6c54bf9cc1ad9556d7c028e2de2a4ebc7cea829090cbdf5340a2c8978a68705305136c9831ae42c59ec55ef118be6f19f06c52bd547808dbbe7cb36ad3fb730aa6a461d7a212430b4fe4eed9faa91eb4aea9c47e728f31d4bcbc8747bc53d21d0d0f965ae9b969db8acdaeb0334b6f859ed1348617c592feac4b0b8dba95faa179d7ec017446f974d6bdf828260ad0f8b496d78773b2a401a2a933bf8f2599b66a71bc0f150ee2dd34642fd8f1b5c87b83d99ef307541f24c6ac6c7e64925ef5400889c2876639850a4fb9ab1b75df64614f0611ecb171681b563b45429e5828d4f7b504a2b16f8e3e48513bc8e8b05fa4407d75becb6e5cdc2b81394e9f819a1aae7ddd0e2357a6da281b31da692dab4e84f8bdb7363cbd6998a1478deec57ad70f183316597c8c0fa76d7e92fe539f125e6b7102322ac2856bb9b9bfb71476c5cc507c66ea1a4cd82c13c9637bb6e5682ebc22f921847d0c28c6aba3d1565742668a76eb38de5071ebb074785e9672b1e731562dbef224092bd67ac2777f1824f73dc0b21769c964c2ff1c86f458a55d9813ae8aca91daf5e05f7c146e4a0599a76b4e3c62d90dd47c9572cd2297a11c3c89623736f5972a714ae9c33e2dbd383c2ef706389dd20f2a05f5b39c395112057b7f825a80612556ebde8972d0b754fb547f4027a7ebdeff44a932230bc8b4a739b7412a7dec89f7a3c4e6fc202ffa5de2e5c066a77d56b87ffd35349f1f6e07a38dd1b5f012ed61725fa56f173610a0e1fae612c1cbc6b70005ce0d6e7f639a5bcf7f13a406f5bd20e3028da89f526a1b96805576f6cb18e44ce2ef68c35356c1eb901062b930f7de311879cf8434468d21429dab01ec46a6367635e0571a61c5f606e5792e00def0206427e7cfce6b88cb35ce9d08098b4729af2294408cbaefa9e19aee587aaf2f161246d0197fbdeba64eb5598e14920128c2ef3c7efdc0b375c16af2e7a795d04a3e158f2850e0537ec2c0db59773e664735e000012413ea4d024ac97c77ae966c70090dc1667500da784cd14357a7067135be34673dd70c9cf51848ec4df1a1d04d14e3719f857a05ccf62afb51b6bc3d6a480191770e24833fc2199f61b69d8ca4d6190e1f0f7e9c7d1dc64e4134cc5befd8e7c1afd5313308b3db951ee871bba48660a933bd7da0b4e47b56ea541007df11f266f69475916f7469e6608a1714c854ad7f611c8f774a4a2f5decde2df977ee6dc2feda89cb7806d45d610187d0b3bfe7702af29985f17963ddab08394504869b0d07a78d9c4073150ca4822ab65dc2668b2c6ac5fc239ea13371aff8aea54967afbeb50a6434d42670013e38c3c69755545ae3197954d140faf815c5c801f1d5d131464fb95e83fe45f3487fbd0fc249f425a1f73934beffbd0095d46a416286300c30b5cce8b8c6fe96e737294fd799573f1efc7b71c67afa61fdd7f4a4d1e8aa5d271da6a3d8882f2bec9cf50d6f58226168be98d099ca158b5691cd24e6714565c52c2f248950598d1c3113f881c92f5c15382373e6c32b18705a52ff5cb39c886e93f6625a3fd35e2cac0c083af6d3445b12de0366a42cee915b178214198c14b5eaed94fa356686506f0fee36ea86d4c3b58c7681c8b0cf0ca2e08057a39ecc48413b45926fd5ad7c405c4ed4dbdcadb32882ece8ee69c9af4e123fc3026ee30ea0c7d1a637c95b7a34a484f33539af4d8f8e19e7e39f8c54d59f4864748570a8d7379f7ab870342c2032998a31d2d5eb6e42e06578db6478a74638f5c9a700d06d5fd3bfa2d70654b8b2ee2f8919278cc81500c013be9c04d18450a4efec50ab8627e975ccbd7d43dddee81d3c89d1f9d838d894c7fcb57885d617966533cecc1a0c4bffd80380e7e736abfd6f67b470cbd46936027462e61688d877de341b98e191af7d09f0445b0393fab2f8ad00efa13fff127e4eb5e718eb76b87dbe0405dbd162a776b7249ff233fc4dfeab6fbe29eecce9739d43236152f83b542385b815c47cce7c82b3c6fca26a504b33afea9cfb6fc5a8df86638ff95b4d134f2983c04ca86cfac3975be70e443428f569f95f0253191db3608ea03d669e3b1f5d298b5fd35f33c73e590919528faf405ca93cf937ca53c5616929c8a72d157c7d33a7179384b8642c34b97f6ea2e5e3b234c9734e50fa88d13d052b9b30821c46c174fc9d2b8ce4d123b58dec26b34a0f3832c998b2b700deed8d524f52852bebf9beeb283c4a0d6e07f2d3a9372ccdfa5203c24af90ecb16eef91d739ed5bd8e53f9876873403a83150fcc6d5c0e61df2be3b9f2a78bd8be030ad63947b62acff05d2c19c066bbe5b111036619a35eb4b75bcbbfd6b44c7223ec26b86846120bdce8d73245a730f2f356e9b1ff5523212eb02d00d4308b24236d48f50304b5cc2d7b8269cf2263c48edd5b7671482f056ba6d2223c0a99593c55a81ef88c465c62906f28f956e837ae2509000e0215db6adaad66d5f5bab82834b09ae274111b814c10032734e3ffd2d1a4979f01ea7d232545fc738004abe944c8047bbd7d9b882ebe3983795a281b587d9dfdf485d776019cb0842659469152bdfee0e1adb01042d379683c5309c757a65a64db989bd4b087374aafc6139ea680d88d06776f7dd6e0e01328ff603fcf7c81a588fb316e580ce746011c3b83c69deff1e5b4a9cbd22c4cc50ecc1c25d7658392ab1aab243b3b4e20171d73aea98d13444088ce21bd47dc77461ad9804bb3cc1181818032a8a0bc1f71456bea772b33213164b9b864f8d45107d82dfb0b71b1ddc80b0a418868833581e92b4a74c2ce68084cced24e1ba873d459e506801128150980e0853fa747e29190b6c3e197d7cfa0328648c1cf3ddd010b5ea5569581bf763eeb20784b7c7324b95c8a9d44f6d3c9b55ac252c5c67ebc7b8c59f55dc92fabae39573c1653d154c7c54be27a94d193b31bb4d4269419cefed68c7c835bdfddb6bb2348ab3491b48e8fa97317c87aebbfc9555fad4eafc090da1524e90e566b6eb502398e60d9b4fd74e7fdc32e1de8effa67f071daa94caf70fe09e79d31d1c390a02e3f3fd80db72db97f40949a648ca983421b57ba816b07ba46f7695c4746ae4af9f60d22a9b1712cb37f29b2e8892550e0e5517cdb5095330e1e01f29150691239a524d921ea74ccd8f7fb660005cfd5f94604a82610f81fc1262ab059911f75e59e4d4270b96f8e1ba8efc366ca9b04b307ad9cd140dc4fd9dbb41ad6e12ea9cc03b31f7cead860dbbf2dd2b2a8d6dc6e5247c79d5bec5f5bff494b6d65c92764b08fab1ab93fc29b109c364e6dcea8dc74bdbc0dc756710d9910093c5cb804e693ba659c32f314cfcb43b071a0eda53f05872982493ea3dd43af19f556ea31df47ca3623e13b4488daa4246ec6e8691394f1f24da6ab7a10a0a3b37f498ed64b5df1913244c573cb7be297bc4055b40119e573a18c5fe3f0701037da1ee15eb4ff65b1606583debf186b4dddf3b645e3d957b028b3ea805b9333413df45ceaa2222ffb3b7d9a20035734dc846129c945799147de181e5ba707fe070bd6f5a3166ebf2933ebfd294e8dc3b9726c939e228b783023938e176e7b83c2c2a9fa68f6eb7d00a5453970a955294284ff7c494d470966b7b5b3c9f46aafa3b1458ef6055bb62fc2bb58a04ea3061bc1f870cd50afab63377aaf50d57536d8bab10f29bc9eb60098276e8fbf47de44528b721a3baf243678d56ddfef67330118146836917333f6db9b6f6e9572edfa10fbca002d112544846018f65380053c4dabd3d69f3956d6bc0863b7f816b34fbd284a0eee07f991d7f8f08bc3ed61116e09a3f08e44b5ac02a7fa951ec9e389315cb43bc78295069e4adc6707a62fedd692fbce8d52226cc03d8708278b7fca25a91c9e354daa98997f9e09f7283571cb089bbd4429eb92f342e95ed95dabdf47d575c27e6fdb8d750d13c4584ab786ff86e031e9202f61be1bd714232e9fac0e0ab8e1b886007e94a3bc40c1e64caeb32c744cf00bc4a1b045dc93ded6217ba0cbb0c74f45f748604f14acb79b01dcd938a4adb65bfae0afc81941e2f02e5604a7150692cf70e496b3a645a5b707dff27182a489dabb2995622e9725760c1aa34054e397480ace3714d39e3c9b1864e6b769ae8104d62e1e601bd15a6427fe7310e08801932438f1a101f54d07f596b1a9ebf44659d37dfc3e870528bab1df2ca251c07c4400ea1b445fc7879a00e52fa675a9264314a9153c862971c3f956e2b5b03b4a92b451eb241f01e0ed24bfd2dec274a7420ac87105f66072e380f489b7ebe83a05076db0d0a2db589f60225e2273034c3f0f2731222c146ab406cc4bce83f338f93f39269586f6b6a52a96eed1918927cb4ed5cc70b15f95d70d56fe2b58927c385755877d98debc448625f4b8931b334b4c396cdd48bbdf0f71a4e10e116be07e6c97d0ed49f858cda1e36b84407df08ccbe117e7ffd969d890a746ce060ef9b45e3c797a96a2ff666044649ee718142649e3997fec104faf4cc722d0e3792601ecdb79b7b59596ed2bf6d8d2571e81e56384b9fb0f94964c7ab9cfb45abcf6ce0d23df0ef5d72617906594ae28a53a3ba4af8dedd5d253a203e632973dc72d542f446b7bef31efa65b3657c4ef0a49cdc47118a6653c884e23e333dfe728b73cdabc2b97d01422637554dd954d1a7c08bf343f636289365c773e0be0956a0cd2e438bae199eea8620545a46f01a191a20159abaaf0464d645333b2d65dec651281564936a78eda88ab8cfc28762cd47e0876cd886d6e53a951ff455ee46deb80eaa3783d915500ae539d5ed1765f166f953722ebc633ae64879859ce6a94709c8984766a71491e3eec6df0991b3b00aeda023c8ecd23b66b1371c0a8684d5a1962558eb0f5eb4c68874319a91ad14eef8f0cb6281d12f6e17fa11c17ebc2f648844fc297f10176c5af84caab679edd100ce31bbfac5b6b806e2b2293da94b8e78bd5ca90a0edf43d2f913852d28709aa1fd7240cfcf97727831c73e07a2b9bcab16f57edafcc57d0fd543ac5489ea39e3f06efcc18fb42bbdf281754be275e4d37a6ce5ccecff7fd62ba2ef671f826b1db296aac8634f7cf0e0c55eb76e5d9f5c8dcb8b6393cee032b4298b7407cdb8191554dac3588ee646a501eef32e97ff78746e311a47117bfdffa8c056c55a2c2e82db67f8439ef758e9126474e7942f13603dc02bf8cd2112d2410f4771449796307aa6aa1fb3ce7317901d17c69b9e31d772dbabed21bd8dac4879f5503818d7974398a1a03ef4c2724f9e658ab8463a9a92bf5082df50f52672d29a8291e15fb3e5ea91b3d68c56eaf9a6ac4f3efb9412fb8a5e0e266991ebaa1962835bf2d4e483dbdd38672d85cf0d3b25533a3541c570b86a884a4c70dc726d1489d188efa090bff228643ac7e095bb7462544e434a9841f8c528d8891482edee1805e4e43764002d56c874e372a7d9ff013dd02b438f15af7cfe3d78ecdfbec1cfbb9101f3a0419470230e9cf51e3ecdb9d020c267e40e53cc6dd4e4404920f9c0633ff2a2b278314221eb69c33fc3ee5a5aacd0c30146a023ae666b69d898d535eeb71956408387e2fe037880fae9ddccd2ebd120cef5c4702ee837da1636f263196ac5fe09b8aab6e0ede4c5d4be2f8d3e4c76db45c07d4312572ec301ca662edbaa164ed54d8da0e276b7b96cf616302186c4fc35171097975e373df3cb4271b4b7eddb0218a5c6e4efdbf7a29f0b7d67326f2707c141ac730854669c13cc07e3918fd65cf45543dd4f5411dd99d9d98451e49302b980813bd00376c5807b4c596b4b92ecfbfdf583efd8a1aec451a666e86ce0ba0b206c7c5b4504ec80373b1f2d34c7883e86d473813b641bbae8ff71f99cb2d800ff9f7319514544b57507019c19d00223f8f8b215acbedf17816c13a244a6bb4c0e916bfdc699e01c8ffa7473f828802c097a3cf62defc2c6ed829ecd2d6023acc247468ead5874bb737fb1913f606e8733ede62b73e1c303b6261eb0282bd5fe047b114ece279fff5538f585e598bc3a8b80a3370d5507c6daaa196b50269bb7cebc35429ad65675144f9819788ad0df732858230ba080ec64810c47b797c66d9f9a02974b5e1d5de3d9ed656106d872736e7e9c0edde89c2cc5015782eaa39b925ac43d7d412b77ae076da1f8e5913df826eefbbd20a50c8ee8c86aef16ba0d41b227acadce5fe497a3079f4f0a848cf975a7e81c8846ef1a91fd5b6f154e83c90ca667e5d6768ffca7c2569cbfb9f10257bba9da1dec74009007f9771b6174fd390a37e632d0ab9c4613ad10029fb6a65e90893974d4875cde21948b36fedeb818090bd77cb4a1b2d96f6b76886a8f03bd1b76bd43b35b7db296a3cd91900b318db97be61d8d53d01c1847acdaec7678f89ccd33c2ae4814c574100164b5ce30041ef84d146182636270184acbc36b9176f080819a56a2c47635179652f7c6fafa13755b2a8091af20514363c7588e8fe9e21b3cab96768b2bda73c5006cb0c1b1e0d9a35199e197afc66077e99402e2ff37dee2939c9f207933113c0eea5b22b25ac06a0323c3cb8d928277dffbb80c943c1a092c55d59ebe456b1448f285be3b7f9ad96f18c1f94f73f8629b8bb1f234c6e33e46e9e783afba20547ba2443ae0832845de20517c4e098d5a08e17b4a8e95387d507e7dbc29fdab9187068145932871cd2a05e021e60142dbbe567930ae2ca9d45c2d34637ab9479dbfafef0f30b371ed888d4672ae47aa9000e0cefe5b51241e7857e12d2bc6187c35a4baa9fa887d1b13373fea22a0c0680577bcaeed783e19bee19bda35099f231ed6c9511016a3558d9464f447d8d89b1b67358d654a193d3c5de04de18ae6acf710dd2bf044f97969e809f02e6548fcf3ac8a79f0ca3615610a3d7d1f8ad905b37571cdd40e5d0cce386820bdcdf71f70460a83217bc910afd7cb917325b98c9018b311ef34f5993625869b1fcf238a4932a91b72a03ead136e9b8e32996a1a4c5795d2a60c55da4bdbc78625dbe829ad2a52f518f02b9a50483c0bb34ac96adb80fb91296f56cc750d8e7f77e41c2c7f9fe5cbe2cd8dabb7f8235f825d4795284dce4862e1152e2e4cad1ed5511de8f4e924c292e8824a78fdabb3500c022a8e7991232acc235bf28a47b8bca88c1a0a743b70be042266622d35d07166719f99da77348039d8d67c3d58f8fa32ff73ff90d5f422f6c787f8cc2fde3328b37cc314daf9642472569dea7288309ddba9c5554e3092d4d002e3b7ce77273b4636cfdd44acd206e780ef62739227814295e6a256c69ea85326fba210bdc7687e595dd36045f7914afd3bb85c12c2f7730c55473d5ff470a266963a100816bc80a93f1f2ddca141fc2edb8c29011a06300e33919aa5a4f723f7a36af51624aa28b15349177f7bb4c40ff8c82d8eb4fe8b28c02696678b8127151d301fb543eda0a6eddd6ffcc740a2c9066f119ff1c77a3f7af4ce007a89cce1a48cca1c925d63776c0b4ae3036ab08abdeed27c4bd90abdd527db98f4f48401c4e3478847f781215a150dfe14645c0406a64995595aba96597f4b09f0310c116c96c554c779308017723b16b9a33552c60599c66ab31e6504ef285dc79d5294e55c85e28420cfd189e472b485d91329de2fd5b8dc1c808359182980c381fc91dcbfa003f7e442d68da27b7d9e2f85a457c069e6f79265893fb7276e9433bd9952f72718e7f4b5f108c5bed7b771fbb2ef77becfb9f9510d449734379e803302a1f0bfdca1c134a4aef5b2bc711c279a11751d9bc381f9f06581f2e9bb20b2ffca55c1ad000005baa9224e6f7e0a83e1ede8f581104c19b028b1cd7907bb755a701e196dbfcdc7a8f1d6c9a638d54cc821561c41ea3669293401e9dc81a6e59f2c50822f3751168be933379cf3fecc1258c216165dee29dd4b1853c4dd4744d2afcd9b45522fd86b2e2600628334b5ba61383bb4eb59568b0cfd1e7676fbe2fbf803117027383f65625294515d64be1b8878a435497e4d3a0b179bc1c66dbba1d159312ed899ccdd3e7bdb04eb03a659bd10132c773a168bb87d90803ebbfe34886d518456bcfe6edd6d03ba728cb2d272bed5e0984fe1ce0f06303e3797603b8352728e0c6e6a1d932747c5d5eb537fb3108b74f6b6ee2e0007474f032280e23563308c6a43cf09ca05305759ba629486ba108ef85120cb9f0f7d2428382279788785619f9fc730a1c50249dd68ebdc899bda233f48d1f1fe989f7e60a88595ffe7ff9d6472eee02d3fd771123b69c968d25ab28deb82696249ec06ce74670e046b47c8ae089a01301a1014507a3c8fc786be79f8e1a989296a969fc87e9091646d4eabd32d24a9433c939cf8cc0a235c94f95b3b0ed198195d0cb5501745ced1a6424d2ca3c0f9dd272e77501d95e9e8bc1433705e50ace5f7aea735c944f027e6b094e86852b657e4864e41724f4fc0692c0e3e7bd6353d107eb5a44afa511937d1c3186c6e103a093f1826549352187dbc5af73746d607a0b5bca5c253bdc2a6a03220924002424755ca8dc5bf5e8b92e0a4fd52a6829b6d5ad2e4ca99ea57183d5041c6af8e35d03690611f9aa423869ab8d2041ab4bbba3e4999cc0dee89834033334183c425365eb81e949ce9dafde3f106665882529da0365e772ad0386145a18f896d0ebd6cf8b025db35860695729d2dd31ba45ec9dbe6865cc14097d4a1f618ecf6e8d1f98a56fc837b40c541031495ae865327e16fcf6e2bdeeefce53415336387d77410f35d7ff74e5ae86133acf9b54da33dcb942fc5cf87611334ba8e6a2e779f52eb2cefa73e16e610f848cf32cff42c048d9d293900665b8651f121b7e731eb49d91dcd8ba63fdfbfde775c5d907ed2ec4de747ec0e09a72bedc04a911d158be1aee32167f6f12be164569d3efbaaf45f30e3379543778b95a621eed9a016b2a6d50f992442133db18d7da859525ecfde554ae5b0bab5aa76b2bc7c69d1e7c93b9e044eecbd0c7f8b403d9f9f23d59a5db6a007b9beca44e5534d4a7f8a8af70dda2c9dae9cb031ceef399179b1e878646b6b0651b5858e1735aa3e4877360cb0b451d9a5cc27fb1136cf905cd2063008cd10adfe3957a91cce1c6df284a1ca5c262cc884c8dad03cde6c4e568008fbc1c4e6570dc49a3c3e5cb4f4da7a89d540b51d81dfd22c6b54c50ab469a9f5fd9f19ed4ca77652c7ee7b75185af0134b88950d5cfd02f05f52989d20f326b9aa866b5052ed3fba17fef2b1fad957304ebf213887b561f1cd7d0cacb9d55d01eda6a434b1f55f1e73a5be225c6b17a4de68a5792a8e4ce3d5110124b7a68253fd09f38e738e7233c40ef7c93e6dbab18b9f35d52135da899310bd621b917b22d245ef5ed0066c1be10707a9c9e6644d07e65fe52e603da3f2da55a92ed318a9d611d1454f361518e6ad7e98201cb2dd4c832dd45a2c3e75e423c881a0cabc91a2006c46208b4bf0a619dfb39c049c400471b2663c1a8daaafa6438f26dcaf4d969571b4415b17a0ac3cba786710b7c77ef22a77defd1d195f095adaeafd6ae43db0d96dcff86c9b5d9c6a82b70ead0a4552d1f300b06fc498bf85434042fb99d499beb5e1d2a78bac3f6ff62f392acfbf3912f56784d41e372a345f1df6840988743bc94448c7bb33c747f522bc3985df3edc2ac57b5f7efa2d5f05cfcd18efb34765ca1f099b38c294d1a2c686ac6b9fec116cf0344e6b1949fa98f0389d1c36978962877ef84d305b1f334c9bf490c96cd82169f4245d54f5535f22ed74e3f9e3c0625ce3c0e48e88a73389a73978f8d8643bdf27bf0af397857f16bdfc6eaa02954a1b9ebdf66a4cb35b906e8d551241b2ec58ee4b3d94b0b8880fe008311f6ecad2eeced7ca34a38ff3304635cf35dd68e7009f1749c978ace261c84f1a7c461ed492261a3415cb30c92290caf51e46c59cfe4ab2974dcb42fc641a168251cd6d2dc2d2a9d90451dc767a955e7ae83c8b239a14a69f740d992a85a1c8aeda3dc916127a854e9898438d47829fc3498c2e321ed7b17e15551a8639005b61cc0c8a92e33bd9e265d1fccf0d814b8d33fcef4d69bb018656dd3d5522a222d729dba8e5f14979b0a0547b73defdf1c392c51b814ac68465697031ada5fe6d19f932cd6f487fd117e14e7aff4a6d0341eba7fc09208187a6dd31bebd49202b1ec24dae93dfb79f945b1bf693ccfffb3b595f8aa506694ad4f17846a105f250606473e1bffa356b24887289d9a50dec167169f126cd7f8836a48789eebc6a71a31148177c2f70d5343b3ce2794a35f6500e632d815cc0c5b414a9f1c245a575a8423429acd0b2206b05c8ba391e3aab30b58332d455c49bcb80e34d1b16a09d71751e77aac82b1922e7a3e0212f5ebe87a27ff168901a65c4a93880c5d91559d21a1119bfcec6895224612cfe972caf462264d59317862194d32664e35093c9c140ef3d189df56a263fb673d1e303392816eb73f89b3f01b1221e982a3fc31529ae3cee0a4d6a91699b987d1cc3cab769c716ed395d0ad0562b725ac6e0d5fa9a305ede1ce5e2b21992d3c71f56bad1ec1b89fca244dbd739aee8985758ca3e8216de887a5ba210ba567738ba905667b83b2e6af7278cb8d628680af80590cac728e3e007ef2ba07e331f4f9c5ae345da328e9559b317340bf3bb6b0538947326df88a8f6adff2e8da390cfa493634b1db95f004655e038a164d14fa17a7b2b095ae19b37546ca2a6ce3d0a77377451c85dc87477e008f9a05cd20ba79edbe64a8bc1ff8c9460c5b87bb2e5df681a10218c7662263c5e35176fd23e65a34a24aae235ff6d387797906538151440385f1c180155d9e3d139e8ca248fa815202036c6a2c4c65dad9d1b896f7bc475fcf7f2cc0038be68bd18a29da6f9f1ea7e8fa2ccf2e43b188da936f236630ec3c6fd08fb890d44eafce8e5c5c6d2b4bee7c24fe73e1c88b6ba3706d3cafbfb97b57e6b61175da49616b7625109e5a034999f595e3b26959baa2b1eee52d7570d98ad8369a7d1b999720122ac287e05289ac02da4ad480168b6f1146fda532bf94d2588e37d72506c88eb0f613f50e0a9e1e93c31ea00a6e615775750e8f9793817e17e9fe3aa7501822d69f758f705c0b4556c115e8654f5d86e6f0da43eb0a5eff0c6b18ba9dd10b9785265fc703511279dae7c2d9d23e02c452cf862a5d2293521266926ea79864cc5f7ba5c35f7131eaf69b186c0f640f32bfb96c48b20ffd6ac6fe451f1b0d92aa32ef59dfc51bd9455897c9f3feb1ca3bf7ecc35516501934e300fc5972aa663eb4498d55990cb8a2e34d3055f833f6cd5bd3e7eb68cb85d3d1a3989c813922205bcc39de46a7af0e7e156748ebb6c70c0e7cfb4c6b74496e609a4241a347659ac14c4bf972d70b38bc70b4d74b15232c50a4e48f4d389f757fd718f3d86ef45b9938af6320b3be870685f289da056b760f8a629911ecc2d5a05d13da3625dbf88686af8cc4334acd4ec2f37ea0b848076c5b3aa7e8da0c283da713d4f222d8d0a87d18096bde6efbc036e5274dd975ad63352a1a5eab7846c3b732874a581f074da3d01dfbee4e9a3a6242470e81c8af2f249aecef0df286bc46c874f6c3be4976ddbca071137c578948a3c8234a5dc4f7214486fefa85e0be919a37f360fd4247c77f7b276a5fa8ec4d90cc6e9c30f5ffb73c291dd4511024b44efa4b9919e80404730cfce5838d31b2ad675ce77b79800443cac522829d3377909aa195543c815f562c147b030a0aad19122e0ef10e219433ef44fd4820d39d9793aea26f58813e058f2d80dd3cbd95754e720bcf814b87b71f8e9c28144d4354f5316db9067130f414acbf98cbd8d4a0b07519a4336fb118f1c823e5af1fec19faed94868e0c1de028c59306744ab7a1c941e218f47f830d94ec5f9dce18f9f560110381ea5a5e24000df24ce4c2df7b149153373790d11eead11443c0a882a95d94e0f62d083a7b283e96c5700ff758dbdcfd874f92269bf04dcb7bf55eefd01993f7735450d6549174f0a9b267a6278e364430fd24d02c40187b718a834f305cee065b708a34a2609ab0eb90e856a8092301e0ad5aecb7b9f7ac71f119b83a15e0d6a576225e1b6984ab50ba36f3eafb16853f821249a6d5ac6a990670eab6f0bfc902dc216ac6c7b8fb791cefc9259ee62eb93244a00e794fa749dd85c834b206bc9a84db8492202aa29d3d1d5cc2484b058a955d3c69a074687bfbf52b41ecbc2eaf2ae727a6947c8a258d1088b69bacad3693051456262529fb8f5ecacb3f997770d3ebdf5439f289a347bd24ff48d02fbf72a8fb9f994eddcfc68cb6af26a092fb4cbe4f8c7ea1ef13bd5e6ab037737834a089759561373c89bf8874553526f4f42369c387bebf64804d062827cdd1e6220ce54b3f8384d42940659b293bef3a2b6067c8bedeafc9fc8ba00579c335fe63f450530292d086d3fae2521a93decd3ad51b269d0da0adf6816fb713601f555caadea50c05c8a15384153daa153ea21d096cde0b8143ec2897ed2bd6f274597489d1d159fd1c33cdee690f3d6f0c52ffc42c2f0181a08ff258fc8313914654f3da9136608e57032499c871d9043fc7e776e96c5ec12bbf890fa8692f3cadcc1ed58e339a91f53c3f477b78d849dc8c3a04bb37dd23f6a8d7ca5d665c6d79129a85c8784bb3fae89268800b8ebdea31deefd16e6a311a0f34f862aec38ef7f1043b61eb6ec490e848968bd6721d7373013197d6bb6e50b760727a7a561e2f0b8693db513991c94ffdaae61eaa15c44293b81e1f8470f4e5bead9659ce497e1a972f4bb3bd08ae91af02edd4c83714308d6ce0a92cb8b2ce6d798f4485238550547c5bb4d36563d988f0174052607264b07fa27f507450292da2bea59f2b174e7b1d8b53915c7ff8bc6429ccc6f3db0253026c9a86e7a4b1b45fa72c1b1448ff16c4bfa2563800a6f7baec3de5a8b0c4b8c69612ad99b97b3770cbfa52f7927b4efd251ed7d52d2ddd339627b82dc8718dace6519346812df46934da81e5c65af4a9e49e21f328085125d75bf0fad9844e3e2f5d4893ce50d9fcb6bbefc42e7a5e46839c94f41788535a90a5ecb57bd4bab0a78fc5e5ce0e2fcfc75d6cbcb2d2ccd52bed5777779c68277bdd4d099fdc0dd45cd838ad331378b62d271ba90db8239c9aa7dc1702ac19a7d821e80c8aa08afdf4beee1c45d5e2629eedde5760edcf8f7e43419ab1642a67c586f0e72ba92335cc730e47e61e1126ff13097afd8594ffa66004e73384f5adc59784a22a9deaf2cfaae7511c2d8dd55b5e8e621c491c0a3310986b7c780dc6f2fe53175418840d34ccaf7dddb6a14741ba5c0302f43a3cc86ac9979cac9b634c725a8776eb2d0601be20c9fbd71fff0f9847c01a8d624db80e050212b4a92274af2cbdedacdd6d3cf59494cacc9e99841791a9321f9a3977d9885da97b95c102df895c9f42a047e5e3e0c6bc1ebc201b28a1544535077b554733509841cc796337ce78cbcddb56e11204c1d2cb3a89109c68b6ecdd560168d6c8c6509ea589347c4cc6093c87c872f02cdbd3f4c0bd99ed83d28c7c1b742c34707f26fd233cbe75a12428c5c602eff844083de040674f9faf69d6f8fee1a08b5b92b59ff781d8cedf2e7fe7f18308289d24ff079992078e691a0f1a24a1b88f10c5818d7431f2b6e4380654f3e5241044f87347ca2b09f08b0b9536d451b0edb3b2ebfcddb948b610cf689eceee2279322d72320a6d432b44e0efe5b52a8c05b9b11a220fd94bdf8c7ce19bfc0194e837a4a2c02d4013c76855e4b9ca2ea604dd6ff3444aec67025e524967de5d5c5565225b3e85099e3cf4fe38a6093e3a5e8c1eb9563fc6e1e43f5c92df7522a61291d414cffba20ff1e69e211d8596c432e6ffa3084d66fba5e62ffedf295071501f04bdec772282e69f473c58ed1a2d6aae6d8a5212f026ae25443e63c4511527d03fc5c9adaf8918ca2c51481539f7b28350bd1cc5a0587dee172bc98b839696fea1b9ff63c3de28b07821352474086c19dee820265df38cc8c4467734bc063e62a198279646487388a27684e33877bad7f99c1ce2a22a8724a932b8add7bd35477f08c5df6d43f53f99b5427165d9422b9e362063ba7b029489771a14f94243b7bfc511999c893d401c3350343cc14e7ba2e3b0c074e53cddb40b853c4bf307a207ebb76e2bd33851088834632d68c0127fb2d2be3f8f4cc303251cf3a5717a7785d1499ada3ba6c9f9c646c4f36e9476e1648204a5c5fcea262aa88465d0663996ce5f6ed85d6cff9af8f46049750651f3add0d6aff2c10df9ff63f5bfa2db0647798c62518fab72a51e2903a9b2b127ee4243c8fb4bf16349e0f51c5c0e1021dc4c2d67cfc0ddcfd40e065259806f11685df62f49c4527d0ad636785614476649e14d52231a243fd266032a0293d961d97eee77efa7e96f7495777d3adb4963cdd96acd094f348e1f3157459f37167de96c080f51e62bc7242f153cb9e87ffc0e92ccab5c024836fb80c42333b32e6275e38bb87b0cc795b0068119af064e83d815f03ace28dac99d57efc67d2dee19d2368b67b39b7e683f5ea67679ae4f147e8234e57f13d115c78a4401dc681ed11b309bd9c6c509e6ee23af7906348a0e4443d1a1d69536b0d1c237bde8a3001f1d62f6e927a02a086b2079046d22066d8041ac0ed9e0f54a75cb4549a7263a91c146f7e860852c56fb5bc209f5d6a80ae6c9e24fa9aaccfa5fb3714c38a56e804f53fb83ecb1106521897a37d8ad6e692e8c038453c319af5dfad40db918e97a39676780e0c3435c838d9e7ecef28a87dd262589791cfafb13c56b00d4ca1c318c275105a944ad89a3d05293cda85ec54845b8fc4f4ee9eff7f5ce45249d1f28144215e6b2583032bfebe61a8d477c9e91b12b06724f603aab1de402cec2dfa8ab3d5e44507936ad10f9efe461fa3ea008eecf7ca881e09597e58816b4c67a538c32fb51182eb601e96481c4428de54b89ebe7b8266d7fd65fd2623853bf70e6e6b6cdc41645a7aad21c5f857846dcfa1821214af60b8267ad58564ed10ac741515a318954e4a3576bc25a8b842cc0a1f2a798fba104c5c71a705ac0390ae5b31c164581730293eb321a9a7f08bc83ff503a13b51e810910e26ac2b73741c19d3169d01bf783539eb75ff31f1ffc1aede28973883d2058545bcc62a9872e3a3e6a7b543095926535d6ca50deecca6b96c04bd7c2180c803c997090354e05535c7ff9a9805180c72d5d5822ff37978052e50dd3041017ae2ab9ae64cdfd521e7e2b03f0feca081f62623032563208a6b25dec1bbe5e78d10ed41620cf88d8d36616e7ce7fd4dcaba87e8dc08f1582065b5cad77bea19bae3f558de1f6a12a9662dd1448abe15d72ba6bf0c4af8fcfef9698967777ddf055644092cbe26f7b2daf949b534c47cb6617b77be8f43c1b7f954594d383104effbca57c9f1764339b8fe4dbb17a007bd334c004c2902c39eea7a6ddebcd27b9ca0f728c7eb0d18540545425564f2ffad4c9d0ac46a8a8f9d0792e8054dd7eaa3f84c5641e976f8785f1e3f38b3f9c7a1b8a9246721ea7a0acfe5617fc14f7b32c6013621eb33f42dffa64f932b0219493b07f2486fad1c3ea62703d9c3775e72c6886374f53fbd2c634773d7bec669ad7d15a02a19917d053c971f4e135db879a1668ffd96a8adfb352a3d2d1edae633100a30cdcf1cec281cb00012441f61b4ed2ce6cb171a0433f01d9b39491eceaa35bd40e6de85a9d4af09ad074ba1e3f7d54d658aa85fafef0a0a4def6a0592cfb24f6c1b27c665833ff458bc53436fc9bd1e13516f9008af511f078dc854a98a1e868be5e0cfd48957cc7b5374716c994990ba9c895cd7a0feaa05ccdf44a83f2de7a5e61104632c524bccafbcfd3431040797576ebbaa966acc2f767f5d33e69458a4df5fc0a849538a142e22ce7a0b3da33238a6a9ee2506b82fea12df8e982776d72f6a98a52cc577ec1fd94e1a67ef4ed60af74be693081abf22705ae4504b7342b1d863c6dd242494723da69ef00908745f472832f0ff81e2baa8d524cc2efad0cc33f7cafb1f5c4d15155b353465497f6ccc1ef976dab084712bdd12b62d2638be08805476ac7d10b9f1c1a01da7a6f99fc01b77c5db9a75f26a600f09c1d69fd2fcdfd74db5342b2afa6a0edd3191ce08a9d6d92791247cf9ad63858fc080658ddc3a38366aecb59621d26c033055441867027df7733e50354787547164f6b3d1d48227251f943e4ec6bed1ff2d0e529f9425ce3dd413daaab28607ef55a48b14860af9c01a149dcf7b1108aef091aefe7de2654b7c02759f75730c867afc87e91d301f0884b888b429500cf44402338af78edfa918fabc5a06d88820a0de830560184947b2c7ad5c92f7764aa2d999d3f83aea7bfc4a59693e087eca15d8811606dd6e66b86afbdd312f34a36a9a272addc701be5ce98d1bebfd7934ccdf3defd7a1c98f031730ca4d064e752bd521a2451b9c00c35ea31274f11b745f589cd877f7e3d1f81cd554d0d281dc5ccfe692bc965e7805cce5b32b06877726fa5f2d119ab94b88098a8a3c9adb24cf91c6b49782ac5e9d781bde593d581a67612862983e4fffbf151f15b3119c647ab7293f6e663b9f3ea317e1cd2f9f30528d5beb0d7697bb7692f3d013620a868d359fe9ee71873e8d1cfe9ee2427dc4ebcc8a03ec85efa3a4c16bbbf0512e715c9ef034b8d61a6786a360de533acceed88feb02a595bed989ac121703bfaa8dd7942d0e927bb977136df77fd32797e07e470c013741e2c0f4d5c5d2fb6d93fc317a2a6ec0195d7d8ae92b88667bb6ab6e0818079a592ad4662a2b8b14b169c08e119510e8bd950b26daf0443deaded0083415240935fe6ab6786c73e3671a30c2239513599cdf4d3bf2786b1f3b2f809d473ef1a6e83380a8cd93f2ed740dd1893bb7e03c40363287ad91203f72a5f370d9901e73e49bf17c6a8ae3c2fc0a60c96eaf56243702ac696323adbf7ee19fb26f6383ab81aa63ca85214a7cc64543a8bc6b11634e2041298cd604f845e35e6698a1771da459d238d02fcb993fea79680b5d7e96665f7093b2bcfbd8387d92f2e4b827036b829674a8a599be817ccb322ac13f10cce231821fa502e085d4a2a7ee570a76c7773ccf6c64cc44f457bb400914113ead1ef0e2c7ad8864d4224ce84eeb6bb18d44cf1640c652e59b52aa6ddc0f03d47ecefd6fd5316d535a55cbe470644a019c88d7a5c6ea9ae5a655a3ddffa969207f35548fd1091934f8e58077be36e1a122c56f444bfcfdfc6fd3fbbc09a7075df0aa71bc7c1e7a5db7515ea875e162f309c4e1f587ecf1cd53a1fbd09b422d273ea4b3abe3bf13983317e20fcd4a1a50aea0d2b256faf55b11f9e62e31ec6423c716676ad20fee608f0827a09e08eac7c9f9f65e7e798930b5a27cf1d291868c017ef3847427354720ec30573a2f4b5ea296f205afbfce9688f3484e2f677ce27d7637e88fe4d73ad55ab1df04420809f8c760bc1a940c23a772c20b4e18e8421741a87d30e1947fe7b51c4de8acdd1744f679e0cac6a19a9c14188cde4eee9737fb683570a80087052c72195420ec505019be0f3efe9dd95650e0ef1a94aa52de84aa9747daf09bdac5df7e776d7e8513c48f650f863c8eecdefa65f968ef4405fd0c3bc2c16eb6bd29ee29bcc42a115f130a9fb33eb46f8e54815a50539201dc9ecc02f53577aabf6ce479faad759ada3dc971502450a9772ad327d519efe2a1e0896a7b58d4d5893d27cc316f2e91a932217bfa3e2a0c7b108385cfe230cd620ac73f748a9dbe215814c1a46b4739e72a72b1665514cc8d134c944e429704501b700feff91bf342347ca46693691a5eed69c8e21a1f90d7e061e6b2b37267a15d96dd8d1f89998bea45619962e6b040aa234b8eaf0726ebed92c0c733ec06369af67d69a44629bde3ce5909a94a20f8408ce609c193283fe7e0f8b60666cd3fccf5ff65a5f5f3a8799e529e9b30a4b2125496c85c67cf95b7cb0e63c9086fe0d89cf9d1c6105a9fcfcc28f45c1ed2b582e1850c5e0a5609b8db22cec58708d45a330aa2bb975bd5e3a0995c6669b5b05ec16c0fb200ee774223d56bf3b73de65525d5088334fd1a34ce9fd866134a1619bc4e4a2d6d59ec28d88e03386cd968ef72d3278801ee8c2a11cd4cc7d3bda63256d9753956513007d4133abe9e1a3f2e96fa5d086670ba283a20f39e204da6ef9b89f4aa65640e78e7faff055948d4e22e7f045a6ea02d2be5a5e7eacbf1f9f692e971a506bae06894574c4a52c64cb72aac46aad20fcc4b3e91bdb35fb2e8d9b0abab28c5cc06512bb515433533e46b09ed194f0f91824c1ef4b7bed65d6b4a9deccaa9491ef58f97f1d0e86668dcd6d722cf25f3134e9f893f8ab4e8bd6fd6c2c840e789553b0f43e7fb5b0e8aa76c13945d044dbff02c46d675a36a8dd61d27ef3b4b418cff7faf42e04995bbd4036025010f0acd3f5cf735e143ea5e0ff19f5116be0783a401dc5c1151f5da28b677dc4caf53873c684f0e2d24a6654d6522dd286e5d6d5b93d87af88c5d2fd421c9b45b340e2922b9807cd3f2a3e560eacfe3fe398a100167acac051bf621532f9db8b1535d49b2a9b00f9f9f7b15fd2ffb162413972f8bc601d82ba3cc507f7a46c50be23721975818ce0381b44e4d8e00c6770183cae4c6207825f0bdd852baf12df952ba6983b4a67bb7b63e54194f4d108781d2251129103c2d60734edc862326bbb4b23bd7ad0c814fdcb67639cfcc5566e09e0496bbbe07c3c7960e0c56b7b9a60646549ac88ac60704d971f80ae8bd2d7918ed34827540f7252e29e976d38f3296bcf6c3234a8964b05ab4af8787d335dc03806a36921f1506a87c754ee9582bc0f88718ec91ddc75f1cd29a8b7210e0a8e7efacc214fbd6d740b0de7ae91b11ce02f9f136fc75de32ce0d89eddb4cdbaa20af5ec43569de5c913d6689459f65361c23b3e2fa9f68cf44c8c8605d5961a92d9a9e5b625bef48e24d47508f1bc161050ba5c99c031f827d13f191f1bd1183f3771ee21c3ecb99d8e0502d195019b78a44488f446046788f4a372be163f478e76cd4bd66f77d0bd7a4155465dc205fc213664c30c863c89df25cd0be4fb308c8cb40a78e6ce7237240786f124d85c18adfdd4fd283c51de1ec43abeb742a5c67a034ae3c0143ee3a87db6e27ef8fe4b7146535256dc7d7b83ee30bd80b66870dda17390637756ff1b15fbe9e3a180e6c6369cfba4764e8c553d3e230aa33f4f3dc63bceb767b93be7bbe3dca1adf23444a9812d0b11f98b0ece3349e68cac14986b685a919c57c9522937e088434d7f194b3984f632ed26feae287b069c95f884bc9197a717cbd10624c459cb1c46ccea5c28f5d659f4969c9ed75a0da16add08258d49d40549412cac48d830c8edb024af274dc18d04dd179d277fc962429d89709ef111bf4bfed67e66fda3e114a009b5d6f77467323bdb79ec0b5ec5a7edd0916c614a9bacbb5e52303228308f75af1afa54bbb4777af171d41b658dc8db98ed053af2e3f14fbda0c1ca4ab2ec563e451f754b985005ff212501b7d6d4ebf6311661618cd4e492ba5a3f0707c3c875f8afbf844d9db0c506201cfb70f4ae6b087cc7fdbc88d65608017749eb794e99f306cf6caba9b81ac70c5e5b924dd8fc2b73eb66037287d7a95640c5943bcc51c701c1ca74ea4675cbad3a715cdbba5a7786a30a878baeeecb9319c12da8c5da47c2fe3f5f4f2d12f816b7efdb6bf0324cb9952cadadb027eafac1ca26d62fedacc4058c1cf12d4043e35949ed483e18684033da29bdf8708a9d12c6d1a04fc4a9a676fe0c87cea8939d53af450b69d7f2348c9ca7cf115e68cc2dc12b2f911c29e37c803299ec87cce7adfcb92016cbf276d0bd0374762738d330e94ef25e41a8b138949b84fd7897873e494d7e13fd053d929b6ae27a966ec33ffde079f69fe44dc1d32a22f5d686707d90a8c8f5237d83cdab7bcc514a6418a4b923b7d65e1d1b1dd915ca746aa0b53eec8f7f8ee528451f84e105947b9bd08253a939b98656eb80be082adcdd0f4a8dea3fcb63fab2e12bd8a468eb72a5b0942003d0bc179a37c06ceb242f5a379ddac2a54a9f1c0a9fe0b9f7616207962ce45b7c631adf05c8ebf7622ee7f70950e9a1990a43387f5c36525ac5f7e96b0381a1e84c6e199154e0637a9d89da44320b011b7fa0a443a2598c38408bf31513a828abed167d66f92a3e96129630400f44a2bc204dfe62a6cc28a71d7835f118593fa4c31ddce12f915e5d52aea095e49f62c7adb878f1de18e71104268c01a8d889a1e4a50a1c0a837d1c8bc62161d5a8e09fa3142edb83a292c79d2778b8068a175d00eb869ff08b6b39c13695a87b3dd29c73907f67ac2486242561b12a7630418ece9dff54dcb6069eb11bf5c99d4b6cf59ab7082f0cf56a0d84ea591c1308fc57ea47063c49efc46d5f8b6d58e6789904b2cadc0219bcb8a19df77a72a3059c26dc243bccd0bc4d63fe8ff0bc5577809c3341a74fcabc52551913676d94a3e25d3c52d04f5dc4cad08737c6a1d802bfb47e01da561ad7556d1b32bc4505e23f96a6d6f8b57dacca14852a8f9ba9cbb233d1675b8dbfccef9a431bc0a0797967ae4e79554b11f83e9ea9c51ced1f6c0d4110501893b8ef9a259c3d569f69aca58f9646b0129901ae3709200ba5de29a2e3449727a72b4fe61a6946ac5b514a5ca896fe0d586e6cde3f3380052823722129feca1abd2aa5f78436358c6284c7139aca784c10f53c0acf57cc107d9f311480343c0f0205f0e2cb0f67cc8ab5ccdb960abf0ca1adac31b58e4c818a83049a27a0824a1f79786b36b355fdc2dad376a1cbfa4aca3388d669af20e6babaa895b6a551f4d9605edba418d59e665772e6bc869e5df67c3674ecbf06d7b793f96201d1a497c25ba891982c51f27e01f5fd11e9bf4e5a370f08baa522080604ed71b7047de3e6c6494e07d557399f2201db79c8c4f3df77889891b4f7e3b618a9efc6f5105d048ddc32057f5329156d7a597f7c9c6ef3064dc0f0435e2bb6ca7de5efaac9c6f94871d76d994da12b7aa973017510b0b25405d0aecdc7996ab8fd7968f7219937da2edebc64b20431d4f1fd84d0c75b7e064222af604a497bd3ec550e1233b2978cc5b50aae87aebd35998120b1b7caca6485d13871e401ff44f9a8da40d2faa84422a21f6623698ae9034d355db6965de65a789985e2bc8b540b44d68f0bed90bf0324f40e577f90ea0af065aa2d3bca83b04b8c3883df5fc74c3a3c4bf3be96218cb0216e37d0365300d557496cfad016f207b883b3243fd2d239b133c92ec91a5b18fb206925083c703b7daa11a4cca2cd5d6597088c178332d9786f28aa753a9804088b451e35e77232d444eadce5a43acab4e907bdc07f511d0a26894917702b37974da5e0fbce16177ea985347b58fb9a56071d1a8282bd4a80c3cbbae64c74fcf9b49cdb3150f206a9aded8b91bd6b26c86271d366af358c344b06b160cbf21187bea9f59cc51a2b1734399b0d91ea0418624078b51ec188673b611f3350dc5a663575b707a5a726ee92eabfdfd992eb1cc68988647f95d35a66a6d93cd33240f572bc89a2f2c3ab88ea422bed8f6d4eeeb7eb7779c7dfff8e33266e18f40004ea1f8cbff26b43f29c5cc565ede7a9f25a918a1124adcab84380f8f786a06aef14c87c1a7df13049b6322c721691866ddda128e70e6dfe51cd66420e567202e8939a11670c9b63e2d96222f4f1883f96a92f36831670c808e5f01f2c124b519eb0ea78c49ba6dd50f4fe3768fb5720008bbbcb9d82c1fef09501d64837e46666819203c99f79edbaa8d6bb20b9ab12c506f6b6bcba3ce26915f16d0a70803598d43c84d4864ad8435feaaf88cadcb0aa71d43f2644ad5dc445f6184fd4aff7dafbaf173532e49cda7c7474a8631a5c6b10e5480da264cde33e3f54c62455acc1cc990d71f949d1003e96dbf520af00fb36bdb46093213ace05a4a164715cca4987e4328e5af78aafb2222937b2b1344f938acfcc46aca2d9876a9dd920bc2601c964146ab18524659e1957f3a5fd406fb01533367e237b015a68051e80c0b254766889273b0828d77a309712faaaa5e8e2279a2a2b1a47035b10d199e194e6f53cf0cd4534be5fa0724cb1d14693695869244a284c35b7c5be47a2334541f1f27d4b68175579781277f335b988a7539694d4391cd3d59f68ae9de186f00b5d58de9527109758d63d603abd1b95a5d703f4472e1741bee88cb08865bc0a735e36e48147f18811838aaa3ba4b088b8c45f99be7d30e398bbe830fd584c2e69c33ceddab19e105ea15c8fea7b4c43a2b3b31184125fb5bfb30fb2fb60cf0a68453ebcd525639c03233d1294e6254822d2e184832380e0c80ad6add705cede2a2d9ad03fe8ac85f863111524d1f7b9d719baca83605c911b713776f9d077359270719f7befd9bd6a8a3bb976387fc8db2af48ce94f61c00fc06a0993702936075634bc4d6290d2d877cca4b9ce03f09b8d8464dddfe4dd92f449bfd9e3bb1f5bd1a05756a684e0082cab506ef3c3c1c16a8ed12ea76465e968c7281af18043848cd7c31964b683328dd9ddb8370eff718644daede24cd14822b1fd1e2bb7917f23b16ee529f531a43c02e62a8fa18ff46a02435b439d2165a2e2078cd3c826d550183cfc3cdaa54f5e60e7c8a849997d0943f2781faf8a4760a016cfca6fb18eff9ea5d085dc82ffe2f2238d13be9c9729bcaf569a695d0ca302507faca614c10241a0d409d267002d1a1d351c696d584ce11bd613a7b5fde35e2096e7680de20605c69bd18d79ce891a45f0fa88cf856f8e5959f47da27f407501e135d7c0075716a12609de4a63dc3398ce4b241304424a92b7df276371ce81ffaf6c0058d1d82a69d29537a45aab9d97f74d1825691afa642e28f0c50d49e50de3e9e4aa3d8155fae111680fac44e4ad991fe8c43b3c933752af6b8ba3358aef61f66e229303e9ba0feea663fc099b41f9cb0418b286814025dc824c245580a67daf73ad9c0d973c1228f32d94631b08c6ea787f64b4f5afbd23b8a64a778ba234d0fbe0a334ab38e5488d044ba751a518857e4948d07792a3af82c354327615caeb7199a22784ab8b0889ded54fe35a2ad011b44525e9a8f6acdc422ab5027f60b10d69e8a830d80809bc577988a68c5f02f4267e3aea1e1b713efd4a9c7bfa92729f62f2bdb20e726a5433a687eb3aa219b7b9a0016cbd95ce653a9a83a91a227067ee911a7a7780dfd5bea42314df193e63eed4f2c0224aa8abf0f3e3d989dc8069e9d969230b72076aae150e808c7376b411edb0d8e29a61b13dc844c93a0499a861430ac6adc31f26174a8a48c97029c7f974417c1ab0f7e9718c8510f14fb3cc2982831cdb0acba84fe5b24a4faa3888656473d9810be38ee74ccf638f43fdd922d2e770bf742a9948c20734339ad691e252d6ff7f59fd7b54a7cba75948553a70b15b5e08511025a3e71b2857fc20166fce586164818012f9dbc3960b2ede9906d63615955b698c3a5b195cb0572488a2960245a35032fd245af19958f6e8d9d2fedba32456e52e82ca58d81df8062b3578bc6b56bfd891d0e3cc8cc9a2956406cc8cc0da6b9d2be5072e4a4283dcd9afad0b0c0c76a0b6af704a16f291b572f7e5d1dbac4b4e3f8331b6887cc5c0c73a04f9872707de990ee4b8b2fd11d358144cb94f8f7b2ddf22a1f11f76ae0fa6c13499a5be0cf2836e6d806b23c5b4c9377a328a1d43f34f1554adf49526c90ba2afa1136d7073df811b26b1e04f35e7fd5dcd55a0c8841ac82134cf08497f8800fcff99e8f9ac33c1b6d0b902fd41059c66471ab9257e6e77e0ba0d8f501f986361798b039a6bfd84e899cb838a11f62489d0cf4792acbba6582345319074e0e94d1d93350236fd687041b373e7130f60a24e42ae16b1e5728361e85ca53747f74a0b5c04dc3f54ae6ab378c98452149ce8ed436b8a2abb161c4aebbce71887527f01647b60cb30170139e68d563b3ab7db07ee4b7d18e1356829745072179405126ea6f1081d6b00bedeb4daa47dff244ca7d25357d33278f74e5031187d9d15c8ddac9f49b55e22f23ca3c5f6b4f0b83faa925d89a20ad6ebb791345a5f16129362b75f09908baeabf5f1e5b7e4ac9bf460872af7da15bd9ef331d994c56816c05f7b2aba83c3608adfead3f85a2c24bb0aea148d4e719950d494f3c53ca9ebad7faa7b52ca0facc8b8c7dbf60c458737f56f75539a41cdf130e00d80fd05af157007bb1d77c76eca73584966fa703dac55b090b4bfedffec533027df1df4e11082b66da6d7aa18c2963c9765c49963b7d26a49d0295e4bf38cd0a9e256d470eced0a88bffed056bc72776b61d1c9243d6a94c2b1f80fac0035b4d20b2b4cf37d7606b822967e02510c04c851ff597a3eac747849c55bfe8120fb0f70e031fa520985aac0ba700a30335cc174ad68ecd18fdb4943460bda57b97b4d065548cde02bbff13256a081f20589e8c95efada3362a778c341595d062930fdfb41665f761d33d4beaba4a4fff0f2a1c15c9dd961eb7183b2c0b61bd5647daa30d0e4a9a18e0ef3672d4ff8fa0fc5c4a24b95d3e2a0177c709e50e6da08b10d2c3c60b18c0d46d3e300e78afd73913bddac7082ce3c2ba0a586a9831d03718d12a8c57cc698295da7782defe8f8a664305748c9bd268954e5848b132c62ae31423f3fcad9a5e77435e1d2dc35cfcbf45d4c81609317f1fab028ae5135dfd2e46f3ecf4c46e1cee0877d1bfc92f2f429ed6f26e565d227325982fa18d825ac7658781c04f77c786f9bb7fba7e5b275ba6f840e87f8051fc5b25f1d5c4d9834d32de094c8cd4c7492a7caa2e60611a7bd1704ac4e4ec45c34df12a4ef4338c8e49c1407041140cbacb10ccd61db264830fc83930acdd19a07a6713d0bc5225b7ad7ebc704858c617325e451a40ad2aa8f114a685c52948102a2c5c221fbc2b68531d5dd9263f28fb3119200ccfd300e252561055e2d68cb1b77ca970eef39fb1bb92a55e3d4f692cb40be9de1ada5a6564577e3f842bb2f5a9035d07d80bf3bd65510298acb55778418397af61dbe5819933c594d3bd4135ff9236501aff59a06cbd5022e071f7caee1998084cbb9ea66a026b0fae1b6bc8146f8f368e0f99f917d54807b404b14c5a43cd0981297858ea7aa64c46f5218de1b08ae031b92c8800260d33b63ebf1cd16663eebecd80f4067776ea7cead40fce183a748587a9e1cdf1be40b842a7fdbe6de3390ee0e78e6c132477d80efa342790e5fbcca0add75c2124b682038b00f5bcb91415d344f697d958036959c47b665ab9a89e16f30683581e4609125695d8af1e27bf96a3b7e5d5f9213f6c0eeb2d37fcc641a27aef038dd34167cad606e53417744b32ebc0babf5f356ed194f7aca00e4d9a0a37c541221fac6207ec2e0d0f388120b805235650eb51f0ff2fd22554b08de84d2e1cd8edafd8c8bdab89ee0b140f5e657ddae0188be41defbc0c360bc9a187a5eed558283433d79731f927b8b406a405918cffff7d821943121f3ba312c0d2d3ee965dc8219de6ba4bd02c6f389a09da47a7381ca0014395b450cc5e08f2ef3edc0c032ae34819242be0ab58c97271ef949ae1bf5bd1f9ab201c1295a888c26b8b483d661d9ac98a56a1590e16c7edfd8a268ddac0d22d77163be7aeb7289fb553ceb71b3baba31adc11138ed37a382db0e4fe181c7797c2395754b0802b12675e41af8453bcd82732e6f31562d5e60a5cc91432da334d87b321867bffc7f069e02f79f2b51f77b8030dcf8d24b521330647d391b836ffed88144a3df5e4af2d903d3f2d47288e0283c88c382d7a1b546ee582ed8c4b6d8688b8a2423a7faaebb556648f3a1cf7aa43ccc8937094a953c69143220f748b7fef7bff9749045b2ebc51c22e3808ac83b61df31caf8810264acbda91a784f2b1d81ba0a00e0b3df942c8c72eb8570990d62c22075615bfdfb38e8c4fa81af3631735a07b98b74784b151acc466ecb3d4b64a4f3a26df5b95d39f67d3a81635fdf8dcf6722bb9d5ebd348d9cf292c3f1fba512f854903bad9fa070f6f1dc6a99afb244949a172a476afeef4730b554b8cd6c1f51b70954526cad5962da06ca917435fdd84ef42eda92e06b066e1f17807a8f533ac96fd4d63ad958d4e3ae8b4dbf63a87ff4130c851eb98ae52ca5f2d25d49c9b608706412422382554d8daeb18ed6d21d213edc68c31681ba9de892bd0f07954f1ccddb469b01f30779e1bc1217cd03670882dc22b246157a34f450d90cab72c4a075bebafc9b569b06765c45476afc770b1da8473e433316dfc5c3fb684a25a2b49ed71fea9408576d012208bc13408ac5b08561bcc926b73cdaffc0ee99b61601cf6a6201252f25addc596bc5115a40e14f9da7807f82cf865a37e37e36efe50b4053bd3045b6caebb14b350e941f72223754f0cc083b8da675f5acdb1735e56f7bec8acf5f5e3db71bdf520a8e14c3c0199b98be94b161a9e6504d5e944c862158632ead31a3921bff5628a0502cad90d9ebf17da7a64813cbe9ebc915760ce36c22f40358ffb44946bdc7317e393c19ef54055a51905fafe817ac6e933ee5b804ac764e4fefaec9d34c972785dc3915350d2ddb2675b76b36d277f7adc73f6728596ce69a9d16f2fbb42d876671c24690d833caeef47f44077962fecfb91410072cbf9e1ec3ee62f02304eff0109c2751257c38734178ab938003b557d866bd77552f38231fe755ba5abc57fa756d336d3f3ecd615c21a6a95045fa54bee552a3d2561977e9f69c8e4c4e3a5d2c7a32fdd6d2e2015363e319ed2123578dd85db62e20ef5a2250be2342cfce65cf747c3e0bfbbb15750a13468204c060e6c5a84aabe7377420b49213e4bb79a13154d3b8fcb16c1852908694bd7b6feb12b4f64491d62199a8a414a31bacd4be3773264ef5d2b3b9184d222b1e3723ec518441d148f9ed20d5e38ddbd50859d4a1ec03f4482cacd67f4b6d0c5f95a6207b39711ecc3be9193d1dda413b38bbcbf6d05b0fae2790958f178ddf36e7c04136b05d302a32db6d15b485095c07a7b7f61794a404ad7b9fb3eb3469118ce159eb4d3a321a6ca4c966a256df0b3f7d4e2e79389cd79cbf83b16cbb92cccb31b713c87f0d72418937664831fb31d636e6fcf1e495818bea9395f171eff3d6a629301a7c2e5475d29bd3baec778e9a1890e0707cc8571b64ba1b0a6a868a4a4e98057ca3f43e14760301c392e2c12ba65214fcb8fc2c588ffeacbd41e62428c2cef40ac24ae6f144395eca282e11265db1459c1166b04317ee1b1f528c65d68d6d1b1968c9dee9abb7d2f80061143b69bdfb5352284028f4b02e991a480068356406bc9ab1744f79a0f766053f93581db7896ef974674f5a0047c63cd8437b903c844602ca9c12207bd2d39a68efe64ba24c95d976a4e971a46ee1fa7a3a00e79ecfb39a46aa811c51faaed2e34f96aba29fc037d7ab59bd9d562e5d90cb90dcf9a0f82b69ea7a1e8ca88c5d33978bee23f125fd518822fb2a99061f55e60d1635e228ebc791f25cd2ec95ea8e1c6a34c4de267c9fe06d1a0b55479c40f65869cdf687bb36bd17983bae2d958648cd8967ab2d625dce5399ce59f3870e1bafc23db9e8017371018e0df58449092c7efa57332292b006c4efc685f4a4fb5dd95900ba25817931d98d677937de80b2a9c40fb2a7cae3bb434c0625c6991e915cee10ff4d29a74c1051b74f66ea51fde240302af246c5d87d90969f94c57456a52dff8e1cfb5a1aaf26dd7ef986fe1a6e8e51d0a60d8ec8e1012c3a2b83e023b5b8f8d331ccecb9e728e343e98d14727784055cfe7e6be2d69dc4e9d9694ddf6ce9ff2323d671a2c0b3ec6ff12fd547845ee4589b47c8b46f7108ebd0b40b27aecccc85ec914df0a09a029d0b13c3c10038f25ac1345887009c4e57b8749a12c16368af26e0f0815efb22fb5678cb4fdf49c36a862fab995e42a61e9ff5ce5b2a3c019cd264f2175f4358d2c8feb6e3da951410e57c9783fdb06726dcdccb4465e377080504b52c18d478a0861524b6d8c54c23817565ee97c0e6e0ad8aa7dd3769533ef01b6717ebb24276f31914eff6ccf239bfbe0b75987f00446fa985e235fe87d5b91c7e864a4ecd11ca81627858c21a5c8b1c9cb27a4c26aea35db3ad528712529683720e1633609685a75bb68ab6d6b2ad6dca18bb0d5c29d76bc0e99ad17fbb7dd2fdb62621b498066140b7f5c5e840012efbd7c9a9a22926172c218796b0060ef7bcdda77de2ae6061a673283740301f756c1b48ea94cd0e9d962c8f4d8af95172ca0b48f123df44bf6bf794962c3f7dc10d46e893453774d96a9123aa4d3fd0945bd210d6619deea7799f3ba96cb1372c4a68ebc17aad527c70230650d28688df7a9ee695a7f6c4b7943d7c32dced9a1d054faa4b2072ef509c92c1dd5220cf40374efa60b556724efaad3d3ed06cb99fe46cc495921bb2208ca0d9be1a68332c850fcedb7f798abbf5288715c59658de341895832dc0aec810be74fa9498f64450fe1447d619d8cf919f90f0184cf244136c869935c022afcf3639d6c6dc8531a80250cb3fe5db69387ce0f1924736f2558ad8c2b95e0d05f759a60797cb9dc7a96b7cbf1542a8e9d546707ab85376ff936d7b39c281137183deb461f2951b4a891cc9a82fcea94afae3af35b5835b52b4c05da3901ac6a0ddff990a6f9a9701ae555a2b20572e085d9f19a9ed33dd3059fdbb9d88b08db0fd5cd7b7b7424039ec5bb71ed244c922a3f1c1fa345fd969cf07bbbdabb2fef2e3446f3829c56a6d4506075cec584a2eeebf1020e0d03cfd376841277aba2c6202984989be24b8cd148ced99858ef868148a0a0c607aaf05ffcbb66a1e395f1a0ee5987c29e912be0cfe70ad240032b98703688a93c8465d084edb48479bfb2e555e232e6061d477628c1c1cff0de704f2f4f08f1b7b90dec3a63c98cc56bc4ff5c1da982de2dc37ffd08e93e226ba73a0eee13cdfd42ec537b9d512400a99039b39c23dc489f9ee6c9a4ddcd6fb993f3ac7a6aaeeeee5dc0a069b7023cb4df6c46b4eba357304422ee0acee2d38f13203eaa5bd6f2c09c178db844610fde5d928b1f53ae11d91c2065131d4f65a96215ef6cf9da9244ffb3842197e61b236cc9ea8cb79f2b7e09b085c56cacdb9b3e401056d0a26e536f59ecdef8a292f15b06618f5a3ef569d86825c1d0e416401ba869f8e5a6b9660d64fa37ce9c6853e50c3f9f8f59ea7d550a47a3299ed937e5a1386d95b6588fa95b4633539749fd42680183b3754209ed6def8e45b9e0c7230bfabb373f3c9ebefc4a7aabb4369d5fce6d387c34e764857fe4d7540efacb03664fea07de324659dec4aed911437785cd398f8de8b20429ada71b430a1b34e7283a24ae23afd34a9da91a47999e71bbb5944a99b55b40f6de1733dea218e17698868fca75a5fe79337d33d67eab8eff80cde6f9ffbf4db88c933d45f6f8401b74bccd18674a76fb49ce62fec96ede7a10e8e713898fab58d9bb2a8867d7489e982a492baff75be3e86e0a58e94d47cd5b61cbc21f9f28b0a7affd71ac99a861ed824e108f3619c07427f25455394663d92c37140ec0db34d55d7d108f4bca9e05006dd436ad0b4c552dcf782b388705b9430d63bbea0416da784139f5c65aac3557a065208199a6152fbae27525b135b4b685fb1d452d5c4ee67e05c4538261975171e0d6a318ab61791602d28491faee3f0cf4eec34aa84aae5cbe282f20c6829e5bcad6da78fc9f56b2b877c60b3e97a03323adf1e38b0cc63dbba59fb6d34558c72d65d4f156770696ab495e2cfccd410e20ba08ad1f2a6d128853ef9190a0b0bf3ea2b986abcc544c9043873f16952e9553d83e9f22f4a1845a8663e18f74a2c95f6f2807b66122ae7daaf15831dc0c3b5a11dcfa7883f7d4627b8a015c5ec4263f9ec24860f8509066f4151791c12cdf4be3f3321e146be30d0c02b057eee46fb00d7db5cb45c747a3b76401c30d2f408a9a497f2a931174e2acb188257168e2170a30f8f55afb988d44a570b40ab75b85b9f90887eccba4074fb27e0bf4e151a3f2afad68ffca0f2d8e1a5c30f8a6ca80635acf9c55473f98214128c85966e1a705784c308912494e13fe7ba1c8047631037b65cdc6313f2df1efc9dd847139a200f80a4190873353ecceb4983fefaa57105357de1c37ccb42f9d5ae485eaf2d70fb462c752cce25c152ba14e7007271e078a995dd04adf68b3a01cf8e428357cc10aa1b8e9014435507aa030c081e5725c5e463be13d5426b5d13dd07252983aa9aefc6d50cb98093369c52646caa54b577d03f38d38addf0c0e61821260788cce5bf0dc3719b6c2bb7a104156b8b1a8230d61497b26ccb5d01a3ff46a28cf32adabc00ed7c8547572cb05248a0760e25da81e7c902a2e52bbc37ae33605d72632c358383ef685a7811b16336b7e1cd476683a5f6ddeb9c5b549f16ec29ec422db0e4b5e554569d9ff11191783dc5e6971999e19f252dd77716a4520c1fd298474711cf69aefbf5496c889256eabbc3d9e846e51d32b51bbd92d89b5eae5b8557cc4775d80164acdbe40b7cdae2e29bf36e513c9cebe9a6a38ba37757a7a847203fef77e85055c9a63bc67315f2ca8833e4f7eaa71d94d0148a0dcc7710811b15383d9417fbf4ec603b20c0ad91ddd459e2be0852ef3cbc0e5234796dfa2ee46049ca4facf440e8d27ebe446707636ac5af3bf5ba6179547ca85a612b6b204579e15543db92911668fc1d9dbf1a3b93af67ab8fb38dce2180195ed987ab40f7872a64183d86caf2767bd5270decb80d415719055e1556b557161abffa2e28304f0d7667f18628a1371938435b62f9c03408bc8421d71266e7f366fc780331b958cbe3bc0fc3947a3eb7973c1af6cef8147079d25077c8758641e12dfa3975115c6c0d66f7002faedb5c368a0c76fc35bd49f9d55aabde6d8a03b645e89c6bafd167096acc34098bc1ad617dc9e1a1966b94ffa19e52306ea5e8b5e125a162293a017474ac11cb6eedf457e952883dbe820d17c465ab5b882177bb70ab3cfbd578fd8baa2d001d4b4d3e619336ead3d800c133af9670e50bf3b6219e6ba144bad8b22447f8a0d188869b099f2bdc46af430028795948102e9425f7b642508fd4472c6b18c347c65d10d775b52d150feb68d00829b1d546692f9b2c618ccac9ccfa26bb72d4de6089be4ca3f55573a61ecd0065dd5906b487991a149fed9a1469c6df7439907c2965c22896adf5cb79d60eb476afdd1f091a6b2eda3f333102cbc78b50796e085db7871ab40bc35c858c879a0cf3ffbbccfe337719a04a4fd23436a8b9e8214edf5e2b23719322f69fd24143e0ba0060a828b63b9578a8ff1628b384b7da051446a9e80e210b2466a42d9d0928a94321edd245db202b1c17aeea102b466a1ab6f1b645090b763a36c9e7e1de99def8ae21e4bac066bb5e8293b7dac38e677c611c834d8442c7d0bd3adde4b907804a960b96c43f90141168dde93532eb93938d36c6c11c50776fbd4f0d4c1e2bde85101e31226e9fdf01747e18bcd51f609230f1d64f18e4f75981ba28e68d85b5620308090e74167e8a40373f18be6b9b478500497b4501b453a17f6c686c522bc4f85f077c55acd2fb6d0f47b5d827956436e6297060590e3a07bdf675cb247db1086303e992562928b383d21aaec83fe14b899edbbdc80411897a1b78aaf097b96379f798e2c6dab4db9caf13807984bfef10ee0c31819ad99c6f15e4af2f6df56577fa37b88be03230ba27e249abb237a38c40ebe74ff7a4622bd05cecb52e14d3198c299959c36365bce59fff920ea43b39451df69648eaeb79173add78eb4b8275bc4f3b544e0f5c4b7e51e212496e4e42eefec9bcae93fcfd1478bccc6accc3bf9f913b57f11aa3fe09f58b8e8407d8cb2b00d46794129e31ad4b1c10ebfe2685a60d194e863a134ec166577c0e1f533646015f0c0cc65d4abca5d99f977e5bd94c1161980852e647570a05432ee82cb0cf8cef9090a1848f1e838e6aaabaf57402039a0ba2712738254d178ad47001717a101086b915eae8ec06d90653fa1bb07397627d9ee7fb1af8ce71c2f6f3edd6e44e834b0cdb1c7b6fcc049021f5fbae554c69f268bdcb21499fe9a44c53aaaa18fa4c5af0c191bef7ee459f4958e6e98f5f9bcf573e18feffa2cf2130d6d6db3837fdaed4fe264b9f7cf0384bb193ebe8d824143a36b5b4481af7404c333287133dba57a7f338dda3478de7ee7ad25714670a3671a4e3a83853ca1b219b4f73dd59da4e31c71e018611169f0b8e92891b5c98867ed4df38099528d295e53e78a87882efcdc72950ec9d44f26943ee8b7a44cf93ac7599729c96e565ef922adf28d60c112c2fa5e8824904443f3a09f743d7aec1136acb667eeb23975ca7e1c29de87928fab806581ec1432346aad9e10fdd6b41ec77cdfa0bbde1981ebdede5c1a00368e45e1ee8f8264015e93ee0293189befc53665e855855996eda0530a805fc27084be39875ae942854bba6cd896a7af5ad811f23aa5a81f0167d50cdce5c73f223c6ced242b93794ea4bbce87f32ea438a9de0410fe88aca4f12fb7f425147f971dee6481546c1c0be670fd94b9170df9b5336d9693d983ad93807ec1cf538173d28c2931eede3603174308915128167a44daf0128b01bfda3e3be3010b13ea233dcf2896c383c5cb29aef837244344f3ec7f8fe16d566858b617b0e864e079d0d102d6941e5f549abee753d33517e5daf5778bc6932c289d2ac4d3a6c7bc92efbd9cbfecba62eee1c6fa74bfa3c4367b84b0473e9b95d651a7b6c4895c48b347607140e714430b4e7d729750525714bf81c10f81f328aad4345b568b24592f5a39177acf8f662a66341c7017f58c15379b45eed4c9e1910ce68d28d3f68da881ceb03d8df0f5661f74b861264929dfffcadf477efe5419e8058b358dc2a924a98ddeacf62176327e059d4c56be539094bb9ad8eea1f50dcf4a7ad18124310ba2232e134cf67290ddc0cea754c2034704f383cda76504db6c5f3635a24532e1cd22b55efc9c48cc62131671954de5c1e672eb6d294461e77add858c5b7377c6d194665c4c29e9ada393dffd7343dedad73fa5b130f77f9eb592ccac095b584b7b9c01ad105abc50c6aafe0a849520316d00d96c5b6bd46c8fa15a58c1e96f30d46ba30b21392b57a554ea623d589b8ab9999fec056cbb15e89963987facd3a2634506c2edf2209a03a62026adffcce9605f8c84d3ecc98b6c868145993dc4c8a8116928fc6b9a1ffa027ef2f44b021d9057bf91adddfed0927657aadf0709bc43f4af1ea34a01d6a2ed86321c5097a5f49eea7dfcde510debd7867a4c33f68184a0baee41f3cf0d5374aee5909285e01a1a20e7a010805ac225f4cc2d4ab010a350828472291ec300a21bf5b92d25e2e4688beda552b9853d84710846197f3990c8a73ec6739eaa108eedf49cc2404012ec70bbc2ee79ee73bdbd44c5d4162d54127b8916c3760b78ec5a6343a0e807b78f22115ab130c211eb8ded3540c14bfa69f0ecec510d23a61036cb24000c9018a1af9f7e6c9dffd8b33c667d47dc848639f6615e3c8537b7793f75c2546d2aaf30e950df5577ec93ed7ec5e38a74d9b725eadcc4e75eb11631cd8d87d0c60670a9f8edfbb07b1e8992d7221aef5fc2fea1b5695d106c84e553be22f0a7514043427ec2f01d055cd60625e6678bdb548b8a93c397695e7e0330c2f79f94f41733cc57bd4b17a2e6376c4b1c1509bcf87d211e4f9d2a414b55c22cce75c8504854659c0f78b1513d6b6e84c3fb4dc5e7d00c837fd1a2fbdd3e28587cfc0b1fccdcb05ad1c9d9cfe062c24d465aaf4435c97c0075fe39d4e7e32ffbb4f0e781433680b61f0ad5ef987494c3d8ee903c42ba2a2af82dfbf2e34d27125fb98900c148d2a2833eb2fa73e580f24be0660d50a8e411577b3707218181d1be315d59922e91b825c790b439ae2c8bcf8ba9bd3910fc7140fb993f49d9d404bb0d61bce30f9933e9cfc429152f4919d697b8664c9e40457bf1679498b4631d641a1ceba56787d51ab50b1a173c6fd55d718c63bbccaf6f67b804b85ffad9a66e57012eb4b75175187a8a1498dd955c2966a07991b1607b4614a2501383203aae4997ce839db90fa4693dc1da520b622b70e84eeca153e3e91017d046d5d8332069243dc4c116851f26a3515a5618aa4d46e3b7e9e433b52427b6e827404a152424914f197423e5e28488193d65d1920c24caf077af9a40975251c31b4c5c374960bfe372155aac1b3f2fd74c9af3845133c63ec5a8aa7144c720204f2a581c8e912191e69ee0ded18c46de0b07253e09c682b290efe620be17f883982b9e30da1540c79981d7d5a7b9db6c35b74da7133ddd3a52169d501186e0fe51cd81c7c86c94e78742f68394060710d0914beb427b64cb0b22245b33bf80b0a3d4604ea13de704217b7f01c1e751e0a266e5870b114e44d08b10a465dc0a05e36e92058d4fb3440ff29ab8b6473d90f512285ccc80753def96d3a586161b9ff495a89ab8bd8191e329590234f24c45d1871090b36cae25af60a9d93635d16fe0f7a7904e0026283187aa36790aa24bea06811ac57e7c34509c2439037033866360938ee88be4a337da1a301af98b93b27138a2119f2c6547ffe7ac9f7ffb7c927d8a2c4d44de13be41d69e173060a713b3f067598b580a89edbf79a02efcd68f89d25179b3cec2730f3bd8de5ac51441d919178c08f9fd8ffb6c248a9f0653a861f6886b58b2bc3ac75d4a84f854696fc03421ed4b10b136bcce5dccb5d0a5de4ef4843024ead08edd33bc568011c81cb858202a4ef5f99008b7801a7b0b3df29e228c9d9f59fc7b8be14b904b85237b68527eebe08542e35a810972088cbcbd24b9c081e4e7b0b4ae7fa5da0e9e977dbd37da7af464ae9fb44c0662ca75d13001aa3dbc4eb30597292326c82742b8632ec2575ac43df31d048dded4cd94c7e3a99ac2ba359b2d163a5402522e451b391e1f9f19857cb50f6ae9fb80e919158d908ee47bda8ce64df2d238ec089f87273f6efee372a3bee9fba608e262f0e6dc20a881083bf3c2a266320f6a79a918100d73902479494dcce1ed90b3941e0c94bf7486b9071abde8d1ba5b504c483b68fad6cfa8c6234c680345a00ff4906cf13dd3b3d8e5c2a6f1054e8ec8200a04c52e9ec1447c25938e39904ebfc1c2c3e621672eb802e2d0d564adb20c555cc32557d8fb104f68eaafe6dc632cb2a444e1770de6d0c0f74fcccfb7b8b9b2168edc7d229296d9981279c364fd54d7afd9f83a2d38f26e06f4ae770a77f4a407b9fbe68e8d8c76a4b265a382c97af4a83bff06c8a06cab1fca8f922f939fd4cd161f39aa3ecbb516a646e57fba8532af2a0a784edc5dbff1ed31e0826455075d44763245c3deb6e666d4bb5f50052150d0bdcd4de57ba80f496e70e6e5d33ac62124aaa3c21d43fa7a1369f6ea5d0e29a5afd12fd9f4853dd1185b15b4505cb4d4a21749ded5891bc031535512d515fea15e4784b92e1a8f6550bbb095c5bac9dbfa675aed9bd7a9a6c9f5045e40072a80359e527e98342db8d3c753df7022cf63c805d765d0ff345071368f134952d3f415a8af73f92ae82ce39fd2b2b3e066bd6020257e7a93ed091094541136792fbdcc6c1a8c9a6eaa7760afbd85de6f4ba67be576d95ad6cf0cb5f2e4fe0540b3c8e58eca40fb036682df53b83542947b553f26ad1db8f3543c3ccd4fb6a2f30b96e99b53e116ea128eb01c1bbda8e7c57896e0eb3e23a6f02a1048342e87ca0ec6fc7ba2497f825d6241835e1ed3c43dd9a1b7abc547200da9b340bc715bbb914d3fcd2a76d3e078476ddd9e1b4f4fb67bcadaf62668220abf425998bbbf1b3293edbf917d2a012f8895add43b477457954b2d0511935e6a35f562cbb14e25c56589cec25bf557d850effbda77b1187aff6cba2fc81cd623903adfe020f9e34bf27186c1af13215e88614f5f62b3214b25dd829a1e34d88337953a04219f9ea2b4361774adb4ea41dbb1fadaeb2cf973dad5fa130c850487ffe18b07aaa0dd338697f10cf68486f2b124a32396fcd97e95b5b3a632a032abe9a3ba4014d9187edf77275d23c3b54113d79fa6067b7831953a97074e5d8115d39f6e7cef2ea32283d46b8c85c1ac559f3c2fbbfaa427d79f12e9372de4de3edccd822f953a3644daf0a3a71f87a1601d5d61b1acba37e0b166160e5363d9138fa9a75aa21432099ddaa3bc919a3a303775d603adbc6e0cbefedad5602b93c7334df60af6873377085cba5863e2cc2e5d1f23060d2d5efc62fa280efa332887c4a088e339a7a06bad7dec8c3c3fbd20f50b69fc6d7ddd3ef0c45cd9abd839751fe5d81fcb95bfa7958b7ca7c70a8c95de40bde2776622a98f509e48b10ffdb65f4bd43f668e89629f28e3e8f4a4b630a9f88ae9781028eeb70f5d9c169516b0b86d2ac3baf5d87a6a6f3b5b08032bb31bf9a9a83e1ef6c83caaf779b907e079ac0646a795f042a25d814e0c86eeb68282c9aa1d07e0bec4749ee0a3ff7cd5fd584e9aa99c99dfed8299aed0459b331ff031c945495e27381684ce3a4927b2af906d89f5737cb48d55ceef240f21e30ca38bda2ba3c460203829df013a3f3fde9d875ac27195c32234d49633e3058d8694ae8e52634a8e7a0f3bf7df51b755d0b57b9bc1110af29ceff79098a146d6fb184320b1bc3b6efb7bef2c1bda621947102989d5ed0a12a5e810a798faba56cac46d5aba4e2a21c37a34f995527caad633b5bf1307eef1e2c14482cd87129a0c2dabff91a1b3cfe272562651ddbcdb829a6b7ba671115463a3903e20ba470355f9a914b57594b62280e469bf18dbfd735b1f55ab6045b1c87736530eb232f3544c0a3ca5efd3bd0997a4aa8daa15148afd954d62d05a6ad31f1182b48c135e6e737dd8e2035a35647bf688e735ab64d5a2d4c36fbf5ecb3ce0437cb90db59de3c2c29120c1ef319c9e8a581613c6758f8ae44902065c9ed74e2b34283135410078dc578eb82cf027c795dcdff13900addf85d84325f699d92bb474afa070f558b8abad1850a01355e5d67c169929d97c484edcbe98da59e1671ae757a1b333ff8e5b068222a0a85f60ade7647c121e7f8a997e2b8c10a451931ffaafbcad0e0fd75afb7336dcc63bcb5190d496a95c329d129f3f932ea76c0c210431a13a9e5198c21ced0eaf8fa1f1ce0152d03638ee93b515538a5f383b071eb6b7870018f62165ac189245bb187d30566781e055e4a6ed6e683eedf9461b72f0fa97e93ad5e63b43e1cf793ad89dcca3702daad071d5fbd90b232321d84b1521dff7aa490c0cb9f2e8702cb445d8797888e5d7274aec678873a5f8dfe5f4987a2a26ab528936ab4383f6e729f8609e01d2e40da570b5a831f8b04874d1a957f5ac46998a207f7ba4ea725487b79709a25d635b953e3fe14a76b3a85dda1743eab7b4613f7f7f3406cd0e4c9fa554247d9ddd3f5c80b2218d0e4b624017c97b08f4668791163c88de4306e2e56094de673d7ae60bb6f599598afd1d30e0dc1b41ec195a58fbe2537642eafc507e78444c2ce76cf9beedbd0bc3e71ec19db8985eac79f99006f1ceee86caf6293bbc3d5b5e2409d47aaddf9a5e6e93f59d2d2ba9adc73804826ef4ad6495ae52a2cc1f40f2ed9140b144018004d45eeafcd56fc7e2c88893d0447ac9d71d2ec3850952cc1b2f895f449c00276aa4eaccd19f03f2224f1f3de4c32af9c1ee8f9ccd3a29bf9ba6956019c20abba9dc35678ea215ed476d438ab33c119fc4c64c4d392a079afb9dbd9f687a48296bb75c938280fdc007999a79f8efb70d9ffa98b58d55d89e30f5bcce7f3b827af39a67e9bbad0e927ceed5ff60d36b30d8dc997d7b3de92b184978cf3a9eb0b79eefbeb0afe06a888cd051d28d7563c85f4e981492cac6dc7bfc47ba1d25d86cf7b349902fd703313cc477bf0c48fee2419118ccd1a2c58ca764d4a624efdf93c4398c9ab35825340ea1771910b5f3e2f56c737885a7268c03d063a9d50531b06fab9f65f3156c0d0b3855d6cf543908b385f53a4b3b51e8efa5f381c2e925748e1c35e002c1a6ae2d3152da0c6baa24fbb20cff995c48999129eaba00b59c2e1201fb9774c9ee0157363214dddeb790cecc4f9c032121639617ce51cabab17e0caa57896e390ead4133d70a28e9c5e80224ff555e5030fa40b952569c1eb64a6efbe215b4044ef09cdd8bf8ee7309a0a01154c27326f016db34b70d2d783af7497a9fd583ce09632401dba3c06ed12ea448252086080ea8fc6728c13d25bbdefabb19c31a628ee7010d568785a7883ae2612be86698ffdb03980c90e03101b282dbb42d4507b328ad461ab4eec22c41443c7798bd8f161bfb660ee06ad743daa0b1b747546eb601ccd19b3439fde38186783f2c0a54bc1aa4bb9c645c47cdd139178b3413ff393d99cd8481f011e6b47d38bd702e4d13cc5e4c3c82c74c437d486900c7a581307264270e5c2b24e6840009b5d9ead87b8c19af2fdb7436d1c36cdfde58297e08e13b2fadcf99fd9d9c05bd1b8b7bcf7d794eb3b5479732abedcac1efed1ead6fc93cf2a6ec5a6ddcf8ee43d8aa1f415eaf361bb8a716fd77049608ea0c465f14574688d4c988ade8a647c59c046f4a34a0d6f22abe785b532e4558c6eebec9507eef403a81c5b8d9099203989fd142f9f47da82902fff041bb3369b2976fd3df48b30978ec8ef9ed325471ed515b50326f9152c5a02994363436265dd350dc1052b60d2ada0591228eda97fac86019edb78443bffb96af0aa3ad9100497f5fad76edf583b43d89252b813959f1d0ca6bef2662b8993bdd7d3ee4ff390406613df43f48916f4c33ecf3b34607a1f6d27d75dc6bf81cac517f79bd8887f216c2eaba6143f3cf38a4a3bca5474caef8defab1a5815dd3c59a1990553f1b52399364305eb024d093832de9e3b25671980184b5a1cf0d32da16008de718018536e6c0929effb3b742e0d125d98040629de6b85eb741e8d520f3f098f7f067f507aa94d46e58dfcae005b755198ca60f090617918dad3c59736cb01cbd6a39e504b9ca0a6dc0a22687cc20de7c199ecc887106146e2749f3c84c63889077c96913c63bc6e79ad6f4ac370e3438470612ffd1566f69d6633690461e98453c553d63d2e75627ecce55d9070bbb87d3fdcf102849d606b9170e03d3bf601221a016b642502f525ab3066a6fabf3b5bea7a8874dfaf3ab3ef1464985dbd3c7faa3a73f5295bbb0e59aea0a7a79d9fc0974db1d86a9804859e0407eb88a011d6afa521e5711351a8ee51fd7b0010bbcf0def539e1b5ad2c470784faeb1f415865c26394a18146739737e4355129f404b4ae49def46cff6fb099e439452173b13bf978593f6fc006b4601dbda7a13df57a7a582965e4e2acfff3f068e7c74d985b5b7de42a8df8e0eed1ca974820a5321612375b1efeb792accc954fa627746b0052803f2061256c9f3f32c33347b8b2235e66494e85377c1841a5d56126a354e9a663401528725e485f2aa68277e8214a8144dc9bf913a290c67f51fd0c66e89d459633038e9dbe44047c407b9f85eb42d5189ab29650fb84b375e905ecb6cb01312fd94ab29f6bdcf45a892ab34de8dd21cac2ef8c563a3325e1ebca8b8c1d80f0e558e92ac78d1fd9d4bb00d7c498990c4d6a769608d20b94f24de6e0bc25a867a40aa8e73da0a026c2a58186e6b7a7e8c3ce9f53bfb92ee47d38e5de59cb73bf2e7feb20b68a2baafac114c74c320c86c9a109f52f754989798177ad4b58aa339f64d77e9c91b1ed5ecfa7c184735082b246feaa305f9cd69e2e710f98e28750e0181fdb49f59737070bd50e116343c79365a9458ebd98b9fa3114aeb1a43477fc14350aaafe2ba57ba514c5b2ee36085caec48b3d4add7d86e5bb040f0cae885a00297b30781a8ea78217d0cea21e0eb1d6663eaa6357674d6662b1bcfba5dfc2d3a433a924319178465c2df52d4da4d3a162b2ddbfea6488982a71d62e8220582a06739d3db7638fb161de7c5e944d8db3609957a37a18988e1532e0faa7d1fa89f93bbe8159d51e2b274259879df334dba68b7d071a37847180924c657a5ba56f16c16b1ad974ea1b746184d3c1b2192f1ecbb82068dbc38e048a1b1759aac6d8897c5501194fd3ea7526cc43eac521053cdbcd02be4aba0ab886aa4dfe847e5c44e20995f682a344c05e1cf70072667d52e455b07ac953a1360fa5ba00d2d11a37c484b57c9fe35c7b41d0fb17a025a1094a76f0a28d1825cec00d8e42e013d36ab979acd7b656c0bf027a9c2be0405a8eb15443aa8cddc013ae8e41a0ce4ed630149936705440d1a61f14765e04a9ddcbcb13c08fa8b1c81e491b5e7cb59e5fe5ba5aedb45872c7a5f88333efaa91487e9141348a574068dcf8347e4888ebd9be00ed6c6c17b85c08941d633a5e9777c77ca0fea3be391d21ea015bcd9a827e96e5c58451d510ad57bb53df97ee53b5604ad672d9525aa1b8b43d6bd14b08e796aa16f91550f784ee45eebafe87c405288c4a3dd0ceceac358ef31e16a7ffde48c3ca20a65ed86c1c1a03032cc242960d5daab36d26048d370e90038377d893882191b4230cf14f57e3bfc29fca1a506d50287bd9aecd52a91f44be32bd3b89015036edf3c8ce44a7bd963d00ac84758eb0d6ae1456f6075407b9177dee208128fa364170f759f76937c1f903003f3eecd7b2cc22f4b8a7fdc294a431fba267977fd9d2483ffc83ec65a36816a7b13fec2fd1f998d2f2cbe10e826e30572e9681df6c9829b1253d8c4f77aa33720e8b4f081c23694424f3bffae1576d9d4a1244704296ca0204db14d1cc9e9859ece91f567030114ae342c4aa509b8140e711dc1406f17adeb42a76b741802034b868747a9ffc2bd4a4114b7fbbabd2a80294d8adf300d77ca154af5413041592967ef8e572e488e70d4433697e91e79f460b29d5fc7015b5c81502f66ee5ffdcdab094395a41b11ada72c2a4e3696fec45ef260492d01760ffa47f721b8e3dd2756ac4146469110fee7f44cbe22480da299d560e42966e4f0a626f9afec0a7a8bd65d7cc260d766f62560630396112ef2f71a707175329be0296d5d3c77ec21aaa138e5cf9640fc3f112d4cd7ebdb15191e4e8d70aa268c397f6df083c9983f027486583f6ae2f03c4ea9906dfbe2e825adc742f4fbf56558e46d0ff5901cc7cd0d0b753f9adf0c703ebf73a8f449ad06f0d100a4bbea3a9a6b0b4e244fb21e4679b5c5f3c5a4db3dca4fff3b7a4dff7fc0db1c48340887a8af38186d226739c12dcfc920644a46f3f120c9be70035b034f3f11e310fb7d254cd7a3c0235737b627909b9829cae07f639bc285705fd489046963011aa4a0715ab6eaba8481711e059f1d40d27dc864cf7841a9ba434b5b0c4fb49665f3f0be6f33af3fe4365deac9d5de525dbcb3d42946b263591ae6ccb24d41e035ba9dae3bf71c65d5610c5be6cdb3c2bf3cbdfac24e37f121c9a846fdc16472a93c334dd4a685c3b6ece223e5f889f1ca5438b94a6091ec91cc2ac924292b55f1a39e5fe5c1722c0a1dedd3e6c59ccb499bce2c065358c5b55e8e6727652911696b0ec36ad7e16f8127041a739a2d364d4d11bd57d0e7568728e4e9b50694782e9cc7925788124d41aaf8a756a8f9160b299bfdc9a66b2111ac621d8bb9ab00a9ff9994f9bfa8d9d92aade7071a39738089803d85427e3810df3407d50f528d29c849e10033b22e488e2cfed00d0a3506a68e6e902874c46876df3b7d53bd37134f048ef73bf9ba54dea3366c9d6892bbb9e1aff62eb84b0c78619499cfed693e7d61009d0120397da74456eaf816d6d64f005ff180099ca3506d95085f2ea24025a718089ae555c3a8d42c7c9b75621fafcce057b89603b5d74181f413f6b7e47f100103ca30fb1c55d092827022c1fef9afced7329c17085f90a90c45c425d11ad802b247329924c669fdbb92fcde5809afd2f93629340e5cc331d9a95a236d0814fb74b0338f819bbe18e5f0c134427e8637cd445177373b569c84ce8a36e27d890779cfdff3075b4d28323db887c6979731e53fd811247c870b3d6b65237cbb25fec1e203173420723b7db6878b8dcae0f0559046bcb4fd12d70fb1dbadbccf68c10d8058160031011955d02f92b50110eedbd87c4577fb6b28399a6d2d52913d172648876c852711b76c36d3edd2231ea413fd3694ef6cd530a48a341df957e1e206dedf9ff6783d38e6f4449352d91ac5402243dd9744c6e31a143450668aea8dc51101ce734fd32903c4c85104c8c0f5f79565c463e5221240f26e3e6c1d4bfc85d52e64f3af7dc632531aee93577c66cfbbcef29b413478644264e58c6b42d9ad23acd2347a138b62b563351d911e3aa4a2954b0db9d9925598e9582f32e7730ae35973f1d842f4af9bb20cea2d333779351e4b65aaeab99b01ffd6b6b4883097ebd0138fc3d6dd67e603fdddf34640db226fc38b7959033ee0daf4731b08cc3cd2880855e793e054299c7ae295bd0bd5b1eb328def90a358815e5c6d0176f917f1467d6053bb9551ccc7d4a3cd1cc6b15fe005ee031cfc130976efa95def6f1db65aaca7e83b3756f18beb63bdae97c7636da8ab4ae0009bd59c1b8527e775fc3adf9e5eb3ab107452141d25c62b5e501e8667987af49be774a6de8896a18ab652fe60a7766b26657210aad6770a93e2cf4d3ae1760b643e83ba97c29d379df2bf14f01cde0b72a83fbe5bd4ff1eb3e04e21b99ba400e948d6431a62554497660246ab94201591e61bc7cf16a1cbc17180df4ecf364db4c7ab5384ae6d563bae291f56891457393c218a39e7bf4034d50bd8a4df59f5dbc718ec348029d3fea104dc86add8909d7367dca4a2f0e806bc05fe15897be7618abd96ebd993c11e202d9ef2aaa7111d1d3f9a890ba648673bf7f8d12aefd2988dd4dd89c700fcb25222b261e3f95830980d627bfce000861230606eea260b4adaaf2c351cbab984c2a94149cf3f8071e6e21cfc4305d3a5b17397a7e039344316c65daebec92e8145a3dc8f1d44d5effa5e6d3ce03b5e15cf27ba083cf673757c7b6b4ca76cba3a7636f8a811d34ff1ad62dc0e3a680c0b4aa8a94f48a631d7ed48cf5b95238ba7459d9e862e329cdd7f8152f26349038460eb4ac3daae39ba7e92b0209b25818d3c7f59800de1c5b7897adc8370f40655d2e8685f6ac29449664a1e960ea8f75d6e3ea367863fc37285d628baa122dbb067637cc3b9007aaf79142f28a1895b2dab4eaf1935ab7ab291e6bdf8c7c96806a745cb569c32177abdb00637cc89530a719ef9c034190087e6ebe92e102b6a1f49f5e80e61524fd5c67aea73682e89bc032431dca05d55146120e71d0d96cdf09f7df318fdc7f5ad5460b3902926b1680374423dfe66fafb6e762014b2e1b9e0633e289e4e28a56c62b615fc3028bc5f4b29643a878ab979c225a2d974b916b6034ddc9c958c32ac515ece022320e551b02232aac69a922f5be43f9094839e294c8a551d5a69a5b2296f19519eb86363dfab0b23d9a6e25c523ba5870fb5ed11e3c3a8c885b9cfe208e5018cda2d29d29dc967e459eb7255374cf14497f5caca9f068eb7a0556b711d52849629a52b8c209d92e827802130510fde48f7bc1cc46b20ac012ebce7840f503a38ffea59b17d87decaa6ee40849c30e4e4ba26afd1c88c48603c8123455eabbcf75bc0de26151856fbe87913c9d5a44965c5122b77e476ce6171f476c9c633d8f4b29fd690e26331eb12b23199e1823d9b5de3332db1bb6d65205b46edff809578359a4c1769e810fcac6b8f51fc627784a6c685f628b02f475f78b5fb017bef0d2de4e64af5fc3185ba9bd3b561b97df90c21a823016ba67b50a13c58ad3609a0ff94676dda18ce44fc3dc8afb292d407584e069283400e0e233794ef9f4316cf76f11cab365f0f6bf1b06dee3e4b438ff78570e59d5a344d321b6db9e40c7d609a0fab945e5856cb822c6d35f4b94385c9ffc7bc88b5452b1244043901337578aa137d337917982352cb70e684bf963edfe31cd198858441280630ee7bd334a31d32da7e402513e849cb3f924156b34115e3ac06cd8e97875dfcd5116bf0db47327cbaf210746258c09bef34560031be8d7c414cc65b377e53a99ade93e5fe3a039b7bdb797e03d740174b49d33f7d6eafcf605397db32190b4e503c89f92e2e31a9bcae87b1dc524202db8a2b4dbceddb78b75dfb2208cf6d06064ef33f2ec6a8f5666acfaaf78b2f4c25b27b42ef125ec9e2a3e28ac11130694d6208a169e14fdbc310f74ea6b0ab7981944b912b1eabd6c0f0bb4ae4145ef22b4d8931b2c285e87f70f3137b83398ff2c16b9e776c2d5545256878844cf333722376e724c1494686977bef5db7ecc981632e9d4a4deb3941cb691cbf5eb87e8b5fe3f33f64a46c586e9bc59ab3e9ec20ccb9057879230d4af8d2001b257259dc30ae38710a279ab1bd81b2d9452bc6bfad424b82dcdb8942d09fe4e55cca8fb2d63750504a00de042f1c70e6c91fd54991bd0a2afa9e833ab4a536b759472e907aadda15a269584c6d856084e9b958c47c09fedbf6d7b019251e554713e3cd552b99a549d676cc4e4b693c834195cfbc473214c1b0db677e8e51dd20043e5ac5a0741ed5fbe15b244fe92a3b1e93eefc4b33536883fdfd4dc6e437d468bae6d1111b484161cb108e658c9fa28f07fb020714cc3ede4bd5609e0356268de1731b21fa1b1bf055b6d127fdce46296d17dc2c5f250df8893e280c18844a32a4f2a1c29260dbaa0b555b5c8cfdae98a8eabf6ee0da73183bb48060b559a7e9b810bf26892b482a4c091b659a8e9d5d263dea50d69b12f52a4893277dd90112aefafa2fc964965bab1e93febc2a65aeb29381652f878dd24bb1fffa94183b417ef410b960fb503906ebc84004937df0570f617a32b837cd4a5f59e98c2f24ae5962a54697d6c2b1b30e8b1612e247369cca7a41b74c66221d7a8607195bffa1a85e69ef57e1c4356daf4dcbd845683faab57d2f023e570861d721899590e9d64cf0032cf3107bde3ac3fdbf3a59ac096d4e76e273b26607cc422c7a898af814d8ba3823a0ec897273beafab349321b1824a7c41e1c401cac8d193bb38fc65a8a0f953df0c8a12a0af87913538308f7cd66f4d6f3f6cd338c6c72c37cea54ed61c6b214b34b0427066e5090ed539ef39a859ed8dc7edc599f3dcbaa40235e8bf589ff30b11d0348f7a4b6d3f30ccee39ad72103d8bf18ed52a756d9f54f6b6382c3a077c66fe9894f79fae70fff28dae372f03ecd2856f0d95b0f10ed0c787655b6f1716e70a4dc880f1594a780f50610df4987ad834915241f8fc956a510f4b155392e8cea4f735eabf6800d38eba3d50c2104049e448f287087a463df2cca0266b208490af268e08f722177c703aa19973745aa689a8fe28778f637b352677aa1c95e0514133d60305dd965d3016692970b3f208b50776771568a3a61ed14196653bf9ecb141468efa077d0a9b910a49d9b9b988044d6316add3bdd3b6a45b3615f0e45b77d496e9ab7140d432e2b92e540e4fb3a119c1c05e827a70e263539d39e9e55b0493bf404aa9c590a04b9aef014f968af52086e98fba2a20109ca32b5c2e51d0bf7d79323e784f54d762ca4ea08bcf31c2bc4df3c178ad9732845bb3e507435eb4a0452f31211f6fc92f7b772ed64b6170f9fcd3ec04e7f0c46b5fdbe82054436943752f0b3feead8b3dfc815692cbb25683135172ccbf3cb6e049a2c30a6b281e81e4d31862fd91fbacd9d9e430404ad796aa3c608986acdebea4c295e635aacbb59a646924cfc2f22649e912a64518f41e31575f052efd4473a67fb99693c67e451f87196aba7ed30069aee21e951e13106a0f0f1c053f749df575a8afdc7ae563a42affb41dca844aef8430997233912f663bc11dc5cf6ae2ac1f81d76522775ec9c0ed0c251ed8254032de1cdf9855a5000df6541d457a9b08d5b631df3ddabc04f472e8bbcf0c01f2ea9f717e74696500884853637052e35003e055c879beff84e865848f80164e89be068e7d42225693b8d9649050c17318249d130c713d7dc51c2be39458c7619938d781a064f20ca84651be2a1d93b68b44aa6f7e16f30a9064c3a366b622eee14dfd763aaf3a545fc467cf8d7bd40ff102d09378a34cb92bbea18df843e3bba2beb81942f1fb4c2dd2e5584b3123fb12fbb8c5ae4830c3e4b4d4e74c1863b38a4182d5e97c6f595f46b80239967649f265854f7e78343d9206e7b25d752b8058247ff170ddbf43d26849c7bb06cb5ac73b79bc700def14203ddf88b2e4fc67a9d810103647c0668296b5d71cf7fd1ee338f1e3bd34c00feef723edaf45d841f2827ac41972001ab59bd18b69cce7002c40bfe38c4fc870d820ef5aac56a4be2be769a4ee599aef513589315b0ab0b0abf3f4117d101422805e977fdabf795b652bc7303b2015baf354f00f7e863ffb0874a4dcbfdbc2fe83c459f5df6692dae852737375f4a725e21918b2d6ca8592ec84d9ad44e20732c742ab15d47f3d212227e8f40dc15eeb6465640cfd9beca0d785afd1909d629456433d4d17507b84d598d7ecdee1076df7d0f914e40ad4c0242ed3ed95d9797ecc3f42fc6472b1f7051d0cf6364da9090164894c6d8cf56219e85e34cd048b2d0e2ec99e38ef7ffcdfdd69119e17ccd6e99fe5a91e8cb9f40a652682ccada3427f6636336b4cadbcbda6b6056e7b39f5ee92b1e09689e396b5516b0fba9a26c0f13d5b41785f940f90bb34f08e6fc0b22bdcb624c0322728786a8a3c0a0913845b40e87c1d7d56ad501eceb2dfcd7142d5b89b9642604b7271ef42caf1be9535b21e7389de76fe5d691d4c6d38d6886bb86cf31ff71f2b764e9650c73ac3ded7059a9f34ad2b2dc3d46bf0c55f5c7d9f9b82459833051bbef66a84cac991c6f1fd9a303f5fb18226077e3b7f1a5e952b4eb2e9d8d86b6368013d174c4286edcc10f0391356dbe374993bc0d226a5c14a3f4a4b8bee34acfd01c26a9d47ec440539c8c176b96b5c747731fac033b554a1c3a9e35594bb4905163b6707cd9723ed281eb9fdedb265710208c16a4aa8b68c66712c32e18c31f087187adeeec60848d7c6d59fe19653af3d762468b2204f40170b1401eff34777e98fdc4aa452128796fdd91681e1632e7fcb14030c3152b9c01ac88127b891dab756ff42525655cf7e4aa8b8bc27911ca2902720ff2e1951b3d962170f47bde6129db7b30fb326506ca10287813605f9434393d622c189d7389ab5af9df3caff64484ec8f8cd06286ced52a4f60a16619dc48edee3c64cb7f10f5673900736e9bbc2f3cf075bf504729cf1c3166e87c4c43a6a50fe7e55cf4c463f65927c8f15e2406282258d8031670f97198182a9e17bc740c335d3eda61102c29314f1ac6822ed75e31f5ae23de5f07ba3570947ca0407415f5fc6368545fc2e2be577a39539e7da52e56e0bb8e4f2dc4a398ec1e04a588bf493365167a98bd16c2cc87a2f0b009826e6c9df173e15743d500518c979fd5c850869803e8252e9f36283314114ea8e60d906e6d1c93b1cecb06db13d04b19bebce52e804170a2b48dfba5cb4e096a8f2c1255516b92e8ddf32434a4a3b1e30e79aebd7e2dba6c026aa0b776b428fddff3b5eb6f622cd7907c2ce3cfb7c0b6de075513d811748694dce71ba2d434459d3104a22431519c8089ed15a3d7fbe88b4122b3662d66b198f12e88d1f3cb0d3eeff194c9a6f9267bcecf17bd45c1b5b57b4be6553a990451d82b62500f5246e4dd5dbff0c7ab795258b4cde0f389994d75045251e3d37fd4f8051c33d2887ead9caea4c044202b0063e86f1006fb1729536d78b42c3c367a084f827f9e9ad72297044e5afd3e1b99d766cb02796bd41b1d1fd2d3cfb0a200cef10a9344fdcb7ee78cc2c1103a8673512f79243f4c660dbff27363060149a9720adbc2cd2331998487168bced1bcc8560928ab03768c2ee231eab6965a18f6c3beb4ed4b6c44d5f34771770fb429c4148400d588e298ceb60ff8059f61b92e3a12a2769dc7b6d6ba1967c5a00803ffca5ff20f4c91b503a212d68d60417ee57140797de16d41c3d253ce42a1a08fa2c12251fcdebbc0a5367736aa4eb32ecfc70ca297defc856f31d858e21b82c2510fc2f4d880616cafeaf5a67e492e59a373c4cf252f76dda180acd7eebb8019d39a9928e976db25c077cd5569faa7e6f4d3de7571f45f80a04a8d90a308ac2513b26327e7cfd7795ed27efe3d905748fbf2875a0e5ea18c9d286d7972c129c83f5a2b5cff4714f5f58935ef47ec615e7b2312241ffca3e4a3434d7af7d88d4c0e76282cb9daeb1b6c24d4e48d44b93d976c6d70d550727e99b1484624a6473d3f0fcfedf22f65f9b081dc2fc9ec631e2ed64a56936fe5ee19c4b988fb5e0f4b0954d215e28a4743cbc812b1b3fcb681686fba3cfded6680211e1d82429f6941bc2f61bd5dd1a9bdf2f61ed3a26ce622763c24e7e231d7d20ec8b2b88269ade9985dfba412f51d873e2554cacd50a88d5f1ef686ba706e44dc550eaf766450e4e162b1a1d1b66ff17abe4efda5f78e7966869d61a5ecd8e5a436f907a2978cecde186c338e85bfe84156f12851d9fcf4a8c360fd5ed85facb0d8beb13201b388ed9f15cfe8b18da0113fbe45b9c1c0c8b4b2019c504f89cd95f591f579c927f9209a3a5235ba363b3985a1de8b06165e51791fde41ddd103e0bb1bd9567733054acd6cce99afaf991b84203bebdc5f40aafdfdb75ae41e38c3b024566b9888a91d805283c782bf06cba1912ea71b0c1f3146196b3321b2f32c89b5937d3ffc2bd981e76170a79dafd3d8a208ced4310a239487e7c3a4f093a911ff3cefe267d1b4c216dc763de3d09de82983347602b31d211f8701dfcdab3626459ba2ac6d65115ee6e38ed5a44d3ed126c57b9312fc74d7fbc27136686a84b3ad9ec45261c8842b66bc549b994df2cf643ac5ff4f46c3c7db55d9e7419f25fdd22b27e528fdcf21d94ce9f70234471149733152f26c6307f8a6539903b4e5cb7300e047e855736ad71e7b9351ae606ea70aec4ee7c1efabcb6b663681b8c2f128935fe578bb6330108ebb5ea2d63fd735360b975a7fb8048e8fa598c6fd5cf2a091b7d2b88ee0d408fb79f6fead493c8c491cb8e7cc310f3121302cb623f895cde0fca0358d1e4082411e2e130085d8b63d0cafaf26d9bcf6a71a9b9208a0d797a56a1e0441dab06d57fa40ab0282ccd6832f14e801caa2cb722ead51405a4f1933e1517e922707e7bd2d29c00e9558b62f3f2ef5bbd2925129aaacc97f907590845711a8c758d67feebafd6fcbbfb9f40d654b96bc66091b02d0b845f90397369d661a6668a5dc6ce93a9a4a19b9c5402b83f1e2ddd8f4892973b40c2a77a3ce603e37c18ea3de900c6a37c90ebe4ba88bf9af1cf5f07c3d74454ed98e2d68f25f2fd922b43530889ff0566a74fd7f57540cefb7c8bce3be7d6faa0e20438aacb50fee44b5357b78f0b9b7b5886fb791ac4c6dcee4ccf926a1a650f1b217416ec279a1227b158cd48d9eccfb3405fc65007106b1bac753d18ecdbdf147bf39e5156e69eb3d6e8eb4bc093ba70c828d05bd75647aac03e4c411ef6a5a4095e7d0e08189e06c2f708de7794e27b342854c54ce014c48f28a774338d96821f34ee324c7cd64cfe207720f5849c6ae39bb4effc336fa138cecd10f6db9015537d1d059d16a973a0d3cb008504c5a60896e93652842507357637d238f738f47bdb22245726abf53081ac029f6e0e6dd88e226d5f4f0b7f0efbf95a8a38279e4e2837446510eeb1481f1192105377f0b0fec689790b3f292a03922502fe88c68fbe9a46566d46a7ad8cdd1c3985124f95f817580d2fad434b493058663c94397b80a708c2dde0efc1e81f9f656ac98d9d4dcc3274b51b42261a8d8d6eb09adf26300d7f3b51172ecf14b04691560a5493761c46037ada750b337f96ec7524cc05b9a239944439833e5b2b405e309883864b2dd94e128659525128dd05f214e28b192c6ec1bf458f169a142f4d08d51aeb6d227</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">gem5复现论文实验</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 学术论文 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
            <tag> 非易失性内存 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂记</title>
      <link href="/2022/03/01/%E6%9D%82%E8%AE%B0/"/>
      <url>/2022/03/01/%E6%9D%82%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h3 id="杂记"><a href="#杂记" class="headerlink" title="杂记"></a>杂记</h3><p>本篇博客记录一些容易忘记的技巧, 或是一些解决常见问题的方法</p><h3 id="一-终端命令行参数"><a href="#一-终端命令行参数" class="headerlink" title="一 终端命令行参数"></a>一 终端命令行参数</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/argc_argv.png" class="" title="argc_argv"><h3 id="二-cmake-添加-h链接库"><a href="#二-cmake-添加-h链接库" class="headerlink" title="二 cmake 添加.h链接库"></a>二 cmake 添加.h链接库</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/target.png" class="" title="target"><h3 id="三-git代理"><a href="#三-git代理" class="headerlink" title="三 git代理"></a>三 git代理</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/git%E4%BB%A3%E7%90%86.png" class="" title="git 设置"><h3 id="四-cmake配置MPI和”-lm”参数"><a href="#四-cmake配置MPI和”-lm”参数" class="headerlink" title="四 cmake配置MPI和”-lm”参数"></a>四 cmake配置MPI和”-lm”参数</h3><p><img src="https://cdn.jsdelivr.net/gh/okeyia/PictBed/Blogimg/202203241229563.png" alt="Clion带参数配置"></p><h3 id="五-md插入pdf文件"><a href="#五-md插入pdf文件" class="headerlink" title="五 md插入pdf文件"></a>五 md插入pdf文件</h3><p><object data="1.pdf" type="application/pdf" width="100%" height="877px"> </object></p><h3 id="六-双屏变单屏解决办法"><a href="#六-双屏变单屏解决办法" class="headerlink" title="六 双屏变单屏解决办法"></a>六 双屏变单屏解决办法</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/image-20220421153609068.png" class="" title="image-20220421153609068"><h3 id="七-学习git网站"><a href="#七-学习git网站" class="headerlink" title="七 学习git网站"></a>七 学习git网站</h3><p><a href="https://marklodato.github.io/visual-git-guide/index-zh-cn.html">图解Git</a></p><p><a href="http://onlywei.github.io/explain-git-with-d3/">Explain Git with D3 (onlywei.github.io)</a></p><h3 id="八-图工具"><a href="#八-图工具" class="headerlink" title="八 图工具"></a>八 图工具</h3><p>Gremlify is a free tool that provides an interface for querying a Graph database using the <a href="http://tinkerpop.apache.org/gremlin.html">Gremlin</a> query language.</p><p><a href="https://gremlify.com/">gremlifyy</a></p><h3 id="九-ubuntu下zsh设置永久环境变量"><a href="#九-ubuntu下zsh设置永久环境变量" class="headerlink" title="九 ubuntu下zsh设置永久环境变量"></a>九 ubuntu下zsh设置永久环境变量</h3><p>以git的仓库目录为例:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cat .bash_profile</span><br><span class="line">export DBG_ROOT=/home/server2/grasp</span><br><span class="line">export PATH=/bin:/usr/bin:/usr/local/bin:$PATH</span><br></pre></td></tr></table></figure><h3 id="十-Lambda-表示用法"><a href="#十-Lambda-表示用法" class="headerlink" title="十 Lambda 表示用法"></a>十 Lambda 表示用法</h3><p>lambda表达式可以理解为一个匿名的内联函数, 语法：[capture list] (parameter list) -&gt; return type {function body} </p><p>capture list：表示捕获列表，是一个lambda所在函数中定义的局部变量列表<br>parameter list：表示参数列表<br>return type：返回类型<br>function body：函数体</p><p>我们<strong>可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</strong>，</p><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/Clip_20220810_143813.png" class="" title="Clip_20220810_143813"><p>lambda 表达式本质: <strong>我们编写了一个lambda之后，编译器将该表达式翻译成一个未命名类的未命名对象</strong>。<strong>该类含有一个重载的函数调用运算符</strong>。</p><p>参考:  <a href="https://blog.csdn.net/sgh666666/article/details/89000215">C++ lambda表达式及其原理</a></p><h3 id="十一-c-类注释"><a href="#十一-c-类注释" class="headerlink" title="十一 c++类注释"></a>十一 c++类注释</h3><img src="/2022/03/01/%E6%9D%82%E8%AE%B0/image-20220804155226015.png" class="" title="image-20220804155226015"><h3 id="十二-C-优化等级"><a href="#十二-C-优化等级" class="headerlink" title="十二 C++ 优化等级"></a>十二 C++ 优化等级</h3><p>-O<br>接下来是-O变量。这个选项控制所有的优化等级。使用优化选项会使编译过程耗费更多的时间，并且占用更多的内存，尤其是在提高优化等级的时候。<br>-O设置一共有五种：-O0、-O1、-O2、-O3和-Os。你只能在/etc/make.conf里面设置其中的一种。<br>除了-O0以外，每一个-O设置都会多启用几个选项，请查阅gcc手册的优化选项章节，以便了解每个-O等级启用了哪些选项及它们有何作用。<br>让我们来逐一考察各个优化等级：<br>-O0<br>这个等级（字母“O”后面跟个零）关闭所有优化选项，也是CFLAGS或CXXFLAGS中没有设置-O等级时的默认等级。这样就不会优化代码，这通常不是我们想要的。<br>-O1<br>这是最基本的优化等级。编译器会在不花费太多编译时间的同时试图生成更快更小的代码。这些优化是非常基础的，但一般这些任务肯定能顺利完成。<br>-O2<br>-O1的进阶。这是推荐的优化等级，除非你有特殊的需求。-O2会比-O1启用多一些标记。设置了-O2后，编译器会试图提高代码性能而不会增大体积和大量占用的编译时间。<br>-O3<br>这是最高最危险的优化等级。用这个选项会延长编译代码的时间，并且在使用gcc4.x的系统里不应全局启用。自从3.x版本以来gcc的行为已经有了极大地改变。在3.x，-O3生成的代码也只是比-O2快一点点而已，而gcc4.x中还未必更快。用-O3来编译所有的软件包将产生更大体积更耗内存的二进制文件，大大增加编译失败的机会或不可预知的程序行为（包括错误）。这样做将得不偿失，记住过犹不及。在gcc 4.x.中使用-O3是不推荐的。<br>-Os<br>这个等级用来优化代码尺寸。其中启用了-O2中不会增加磁盘空间占用的代码生成选项。这对于磁盘空间极其紧张或者CPU缓存较小的机器非常有用。但也可能产生些许问题，因此软件树中的大部分ebuild都过滤掉这个等级的优化。使用-Os是不推荐的。<br>正如前面所提到的，-O2是推荐的优化等级。如果编译软件出现错误，请先检查是否启用了-O3。再试试把CFLAGS和CXXFLAGS倒回到较低的等级，如-O1甚或-O0 -g2 -ggdb（用来报告错误和检查可能存在的问题），再重新编译。</p>]]></content>
      
      
      
        <tags>
            
            <tag> cmake </tag>
            
            <tag> git代理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机房预约系统</title>
      <link href="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="机房预约系统"><a href="#机房预约系统" class="headerlink" title="./机房预约系统"></a>./机房预约系统</h1><h2 id="1、-机房预约系统需求"><a href="#1、-机房预约系统需求" class="headerlink" title="1、./机房预约系统需求"></a>1、./机房预约系统需求</h2><h3 id="1-1-系统简介"><a href="#1-1-系统简介" class="headerlink" title="1.1 系统简介"></a>1.1 系统简介</h3><ul><li>学校现有几个规格不同的机房，由于使用时经常出现”撞车”现象,现开发一套./机房预约系统，解决这一问题。</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682783885.png" class="" width="1548682783885"><h3 id="1-2-身份简介"><a href="#1-2-身份简介" class="headerlink" title="1.2 身份简介"></a>1.2 身份简介</h3><p>分别有三种身份使用该程序</p><ul><li><strong>学生代表</strong>：申请使用机房</li><li><strong>教师</strong>：审核学生的预约申请</li><li><strong>管理员</strong>：给学生、教师创建账号</li></ul><h3 id="1-3-机房简介"><a href="#1-3-机房简介" class="headerlink" title="1.3 机房简介"></a>1.3 机房简介</h3><p>机房总共有3间</p><ul><li>1号机房   — 最大容量20人</li><li>2号机房   — 最多容量50人</li><li>3号机房   — 最多容量100人</li></ul><h3 id="1-4-申请简介"><a href="#1-4-申请简介" class="headerlink" title="1.4 申请简介"></a>1.4 申请简介</h3><ul><li>申请的订单每周由管理员负责清空。</li><li>学生可以预约未来一周内的机房使用，预约的日期为周一至周五，预约时需要选择预约时段（上午、下午）</li><li>教师来审核预约，依据实际情况审核预约通过或者不通过</li></ul><h3 id="1-5-系统具体需求"><a href="#1-5-系统具体需求" class="headerlink" title="1.5 系统具体需求"></a>1.5 系统具体需求</h3><ul><li>首先进入登录界面，可选登录身份有：<ul><li>学生代表</li><li>老师</li><li>管理员</li><li>退出</li></ul></li><li>每个身份都需要进行验证后，进入子菜单<ul><li>学生需要输入 ：学号、姓名、登录密码</li><li>老师需要输入：职工号、姓名、登录密码</li><li>管理员需要输入：管理员姓名、登录密码</li></ul></li><li>学生具体功能<ul><li>申请预约    —   预约机房</li><li>查看自身的预约    —  查看自己的预约状态</li><li>查看所有预约   —   查看全部预约信息以及预约状态</li><li>取消预约    —   取消自身的预约，预约成功或审核中的预约均可取消</li><li>注销登录    —   退出登录</li></ul></li><li>教师具体功能<ul><li>查看所有预约   —   查看全部预约信息以及预约状态</li><li>审核预约    —   对学生的预约进行审核</li><li>注销登录    —   退出登录</li></ul></li><li>管理员具体功能<ul><li>添加账号    —   添加学生或教师的账号，需要检测学生编号或教师职工号是否重复</li><li>查看账号    —   可以选择查看学生或教师的全部信息</li><li>查看机房    —   查看所有机房的信息</li><li>清空预约    —   清空所有预约记录</li><li>注销登录    —   退出登录</li></ul></li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682206670.png" class="" width="1548682206670"><h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p><ul><li>创建新项目</li><li>添加文件</li></ul><h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><ul><li>打开vs2017后，点击创建新项目，创建新的C++项目</li></ul><p>如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682413343.png" class="" width="1548682413343"><ul><li>填写项目名称以及选取项目路径，点击确定生成项目</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682522544.png" class="" width="1548682522544"><h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><ul><li>右键源文件，进行添加文件操作</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682597721.png" class="" width="1548682597721"><ul><li>填写文件名称，点击添加</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682679989.png" class="" width="1548682679989"><ul><li>生成文件成功，效果如下图</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548682733912.png" class="" width="1548682733912"><h2 id="3、创建主菜单"><a href="#3、创建主菜单" class="headerlink" title="3、创建主菜单"></a>3、创建主菜单</h2><p><strong>功能描述：</strong></p><ul><li>设计主菜单，与用户进行交互</li></ul><h3 id="3-1-菜单实现"><a href="#3-1-菜单实现" class="headerlink" title="3.1 菜单实现"></a>3.1 菜单实现</h3><ul><li>在主函数main中添加菜单提示，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客./机房预约系统  =====================&quot;</span> </span><br><span class="line">         &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548557945611.png" class="" width="1548557945611"><h3 id="3-2-搭建接口"><a href="#3-2-搭建接口" class="headerlink" title="3.2 搭建接口"></a>3.2 搭建接口</h3><ul><li>接受用户的选择，搭建接口</li><li>在main中添加代码</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;======================  欢迎来到传智播客./机房预约系统  =====================&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span> &lt;&lt; <span class="string">&quot;请输入您的身份&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.学生代表           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.老    师           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.管 理 员           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.退    出           |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                               |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t -------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入您的选择: &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select; <span class="comment">//接受用户选择</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (select)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//学生身份</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//老师身份</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//管理员身份</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出系统</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">             <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新选择！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，输入0、1、2、3会重新回到界面，输入其他提示输入有误，清屏后重新选择</p><p>效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548558694230.png" class="" width="1548558694230"><p>至此，界面搭建完毕</p><h2 id="4、-退出功能实现"><a href="#4、-退出功能实现" class="headerlink" title="4、 退出功能实现"></a>4、 退出功能实现</h2><h3 id="4-1-退出功能实现"><a href="#4-1-退出功能实现" class="headerlink" title="4.1 退出功能实现"></a>4.1 退出功能实现</h3><p>在main函数分支 0 选项中，添加退出程序的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎下一次使用&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br></pre></td></tr></table></figure><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548558992754.png" class="" width="1548558992754"><h3 id="4-2-测试退出功能"><a href="#4-2-测试退出功能" class="headerlink" title="4.2 测试退出功能"></a>4.2 测试退出功能</h3><p>运行程序，效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548559026436.png" class="" width="1548559026436"><p>至此，退出程序功能实现</p><h2 id="5、-创建身份类"><a href="#5、-创建身份类" class="headerlink" title="5、 创建身份类"></a>5、 创建身份类</h2><h3 id="5-1-身份的基类"><a href="#5-1-身份的基类" class="headerlink" title="5.1 身份的基类"></a>5.1 身份的基类</h3><ul><li>在整个系统中，有三种身份，分别为：学生代表、老师以及管理员</li><li>三种身份有其共性也有其特性，因此我们可以将三种身份抽象出一个身份基类<strong>identity</strong></li><li>在头文件下创建Identity.h文件</li></ul><p>Identity.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//身份抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Identity</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作菜单</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name; <span class="comment">//用户名</span></span><br><span class="line"><span class="built_in">string</span> m_Pwd;  <span class="comment">//密码</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548573329273.png" class="" width="1548573329273"><h3 id="5-2-学生类"><a href="#5-2-学生类" class="headerlink" title="5.2 学生类"></a>5.2 学生类</h3><h4 id="5-2-1-功能分析"><a href="#5-2-1-功能分析" class="headerlink" title="5.2.1 功能分析"></a>5.2.1 功能分析</h4><ul><li><p>学生类主要功能是可以通过类中成员函数，实现预约实验室操作</p></li><li><p>学生类中主要功能有：</p><ul><li>显示学生操作的菜单界面</li><li>申请预约</li><li>查看自身预约</li><li>查看所有预约</li><li>取消预约</li></ul></li></ul><h4 id="5-2-2-类的创建"><a href="#5-2-2-类的创建" class="headerlink" title="5.2.2 类的创建"></a>5.2.2 类的创建</h4><ul><li>在头文件以及源文件下创建 student.h 和 student.cpp文件</li></ul><p>student.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//学生类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">applyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMyOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cancelOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生学号</span></span><br><span class="line"><span class="keyword">int</span> m_Id;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>student.cpp中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;student.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Student::Student()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="5-3-老师类"><a href="#5-3-老师类" class="headerlink" title="5.3 老师类"></a>5.3 老师类</h3><h4 id="5-3-1-功能分析"><a href="#5-3-1-功能分析" class="headerlink" title="5.3.1 功能分析"></a>5.3.1 功能分析</h4><ul><li><p>教师类主要功能是查看学生的预约，并进行审核</p></li><li><p>教师类中主要功能有：</p><ul><li><p>显示教师操作的菜单界面</p></li><li><p>查看所有预约</p></li><li><p>审核预约</p></li></ul></li></ul><h4 id="5-3-2-类的创建"><a href="#5-3-2-类的创建" class="headerlink" title="5.3.2 类的创建"></a>5.3.2 类的创建</h4><ul><li>在头文件以及源文件下创建 teacher.h 和 teacher.cpp文件</li></ul><p>teacher.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _CRT_SECURE_NO_WARNINGS</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Teacher</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showAllOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">validOrder</span><span class="params">()</span></span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_EmpId; <span class="comment">//教师编号</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>teacher.cpp中添加如下代码:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;teacher.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Teacher::Teacher()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-管理员类"><a href="#5-4-管理员类" class="headerlink" title="5.4 管理员类"></a>5.4 管理员类</h3><h4 id="5-4-1-功能分析"><a href="#5-4-1-功能分析" class="headerlink" title="5.4.1 功能分析"></a>5.4.1 功能分析</h4><ul><li><p>管理员类主要功能是对学生和老师账户进行管理，查看机房信息以及清空预约记录</p></li><li><p>管理员类中主要功能有：</p><ul><li><p>显示管理员操作的菜单界面</p></li><li><p>添加账号</p></li><li><p>查看账号</p></li><li><p>查看机房信息</p></li><li><p>清空预约记录</p></li></ul></li></ul><h4 id="5-4-2-类的创建"><a href="#5-4-2-类的创建" class="headerlink" title="5.4.2 类的创建"></a>5.4.2 类的创建</h4><ul><li>在头文件以及源文件下创建 manager.h 和 manager.cpp文件</li></ul><p>manager.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> :</span><span class="keyword">public</span> Identity</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager();</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造  管理员姓名，密码</span></span><br><span class="line">Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operMenu</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showComputer</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">cleanFile</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>manager.cpp中添加如下代码:</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//默认构造</span></span><br><span class="line">Manager::Manager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看账号</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，所有身份类创建完毕，效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548574390768.png" class="" width="1548574390768"><h2 id="6、-登录模块"><a href="#6、-登录模块" class="headerlink" title="6、  登录模块"></a>6、  登录模块</h2><h3 id="6-1-全局文件添加"><a href="#6-1-全局文件添加" class="headerlink" title="6.1 全局文件添加"></a>6.1 全局文件添加</h3><p>功能描述：</p><ul><li>不同的身份可能会用到不同的文件操作，我们可以将所有的文件名定义到一个全局的文件中</li><li>在头文件中添加 <strong>globalFile.h</strong> 文件</li><li>并添加如下代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//管理员文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ADMIN_FILE     <span class="meta-string">&quot;admin.txt&quot;</span></span></span><br><span class="line"><span class="comment">//学生文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> STUDENT_FILE   <span class="meta-string">&quot;student.txt&quot;</span></span></span><br><span class="line"><span class="comment">//教师文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEACHER_FILE   <span class="meta-string">&quot;teacher.txt&quot;</span></span></span><br><span class="line"><span class="comment">//机房信息文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COMPUTER_FILE  <span class="meta-string">&quot;computerRoom.txt&quot;</span></span></span><br><span class="line"><span class="comment">//订单文件</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ORDER_FILE     <span class="meta-string">&quot;order.txt&quot;</span></span></span><br></pre></td></tr></table></figure><p>并且在同级目录下，创建这几个文件</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548575650130.png" class="" width="1548575650130"><h3 id="6-2-登录函数封装"><a href="#6-2-登录函数封装" class="headerlink" title="6.2  登录函数封装"></a>6.2  登录函数封装</h3><p>功能描述：</p><ul><li>根据用户的选择，进入不同的身份登录</li></ul><p>在预约系统的.cpp文件中添加全局函数 <code>void LoginIn(string fileName, int type)</code></p><p>参数：</p><ul><li>fileName  — 操作的文件名</li><li>type      —  登录的身份  （1代表学生、2代表老师、3代表管理员）</li></ul><p>LoginIn中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;identity.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//登录功能</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LoginIn</span><span class="params">(<span class="built_in">string</span> fileName, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">Identity * person = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(fileName, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件不存在情况</span></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)<span class="comment">//学生登录</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你的学号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>) <span class="comment">//教师登录</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入你的职工号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入用户名：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//学生登录验证</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (type == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//教师登录验证</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(type == <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//管理员登录验证</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;验证登录失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在main函数的不同分支中，填入不同的登录接口</li></ul><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548575945985.png" class="" width="1548575945985"><h3 id="6-3-学生登录实现"><a href="#6-3-学生登录实现" class="headerlink" title="6.3 学生登录实现"></a>6.3 学生登录实现</h3><p>在student.txt文件中添加两条学生信息，用于测试</p><p>添加信息:   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 张三 <span class="number">123</span></span><br><span class="line"><span class="number">2</span> 李四 <span class="number">123456</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>第一列  代表  <strong>学号</strong></li><li>第二列  代表  <strong>学生姓名</strong></li><li>第三列  代表  <strong>密码</strong></li></ul><p>效果图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583693555.png" class="" width="1548583693555"><p>在Login函数的学生分支中加入如下代码，验证学生身份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生登录验证</span></span><br><span class="line"><span class="keyword">int</span> fId;</span><br><span class="line"><span class="built_in">string</span> fName;</span><br><span class="line"><span class="built_in">string</span> fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;学生验证登录成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">person = <span class="keyword">new</span> Student(id, name, pwd);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加代码效果图</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583915819.png" class="" width="1548583915819"><p>测试：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583950828.png" class="" width="1548583950828"><h3 id="6-4-教师登录实现"><a href="#6-4-教师登录实现" class="headerlink" title="6.4 教师登录实现"></a>6.4 教师登录实现</h3><p>在teacher.txt文件中添加一条老师信息，用于测试</p><p>添加信息:   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> 老王 <span class="number">123</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>第一列  代表  <strong>教师职工编号</strong></li><li>第二列  代表  <strong>教师姓名</strong></li><li>第三列  代表  <strong>密码</strong></li></ul><p>效果图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584030522.png" class="" width="1548584030522"><p>在Login函数的教师分支中加入如下代码，验证教师身份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//教师登录验证</span></span><br><span class="line"><span class="keyword">int</span> fId;</span><br><span class="line"><span class="built_in">string</span> fName;</span><br><span class="line"><span class="built_in">string</span> fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fId &amp;&amp; ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == fId &amp;&amp; name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;教师验证登录成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">person = <span class="keyword">new</span> Teacher(id, name, pwd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加代码效果图</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584158339.png" class="" width="1548584158339"><p>测试：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548584177003.png" class="" width="1548584177003"><h3 id="6-5-管理员登录实现"><a href="#6-5-管理员登录实现" class="headerlink" title="6.5 管理员登录实现"></a>6.5 管理员登录实现</h3><p>在admin.txt文件中添加一条管理员信息，由于我们只有一条管理员，因此本案例中没有添加管理员的功能</p><p>添加信息:   </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">admin <span class="number">123</span></span><br></pre></td></tr></table></figure><p>其中：<code>admin</code>代表管理员用户名，<code>123</code>代表管理员密码</p><p>效果图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548577855190.png" class="" width="1548577855190"><p>在Login函数的管理员分支中加入如下代码，验证管理员身份</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理员登录验证</span></span><br><span class="line"><span class="built_in">string</span> fName;</span><br><span class="line"><span class="built_in">string</span> fPwd;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; fName &amp;&amp; ifs &gt;&gt; fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (name == fName &amp;&amp; pwd == fPwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;验证登录成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//登录成功后，按任意键进入管理员界面</span></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="comment">//创建管理员对象</span></span><br><span class="line">person = <span class="keyword">new</span> Manager(name,pwd);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548588322712.png" class="" width="1548588322712"><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548583245072.png" class="" width="1548583245072"><p>至此，所有身份的登录功能全部实现！</p><h2 id="7、-管理员模块"><a href="#7、-管理员模块" class="headerlink" title="7、 管理员模块"></a>7、 管理员模块</h2><h3 id="7-1-管理员登录和注销"><a href="#7-1-管理员登录和注销" class="headerlink" title="7.1  管理员登录和注销"></a>7.1  管理员登录和注销</h3><h4 id="7-1-1-构造函数"><a href="#7-1-1-构造函数" class="headerlink" title="7.1.1 构造函数"></a>7.1.1 构造函数</h4><ul><li>在Manager类的构造函数中，初始化管理员信息，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-2-管理员子菜单"><a href="#7-1-2-管理员子菜单" class="headerlink" title="7.1.2  管理员子菜单"></a>7.1.2  管理员子菜单</h4><ul><li>在./机房预约系统.cpp中，当用户登录的是管理员，添加管理员菜单接口</li><li>将不同的分支提供出来<ul><li>添加账号</li><li>查看账号</li><li>查看机房</li><li>清空预约</li><li>注销登录</li></ul></li><li>实现注销功能</li></ul><p>添加全局函数 <code>void managerMenu(Identity * &amp;manager)</code>，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//管理员菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">managerMenu</span><span class="params">(Identity * &amp;manager)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//管理员菜单</span></span><br><span class="line">manager-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Manager* man = (Manager*)manager;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)  <span class="comment">//添加账号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;添加账号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;addPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看账号</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查看账号&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;showPerson(); </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看机房</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查看机房&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;showComputer();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//清空预约</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;清空预约&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">man-&gt;cleanFile();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> manager;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-3-菜单功能实现"><a href="#7-1-3-菜单功能实现" class="headerlink" title="7.1.3 菜单功能实现"></a>7.1.3 菜单功能实现</h4><ul><li>在实现成员函数<code>void Manager::operMenu()</code> 代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选择菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎管理员：&quot;</span>&lt;&lt;<span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.添加账号            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.查看账号            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.查看机房            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          4.清空预约            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录            |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ---------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-1-4-接口对接"><a href="#7-1-4-接口对接" class="headerlink" title="7.1.4 接口对接"></a>7.1.4 接口对接</h4><ul><li>管理员成功登录后，调用管理员子菜单界面</li><li>在管理员登录验证分支中，添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入管理员子菜单</span></span><br><span class="line">managerMenu(person);</span><br></pre></td></tr></table></figure><p>添加效果如：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589297779.png" class="" width="1548589297779"><p>测试对接，效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589344206.png" class="" width="1548589344206"><p>登录成功</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589328710.png" class="" width="1548589328710"><p>注销登录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548589416576.png" class="" width="1548589416576"><p>至此，管理员身份可以成功登录以及注销</p><h3 id="7-2-添加账号"><a href="#7-2-添加账号" class="headerlink" title="7.2 添加账号"></a>7.2 添加账号</h3><p>功能描述：</p><ul><li>给学生或教师添加新的账号</li></ul><p>功能要求：</p><ul><li>添加时学生学号不能重复、教师职工号不能重复</li></ul><h4 id="7-2-1-添加功能实现"><a href="#7-2-1-添加功能实现" class="headerlink" title="7.2.1 添加功能实现"></a>7.2.1 添加功能实现</h4><p>在Manager的<strong>addPerson</strong>成员函数中，实现添加新账号功能，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//添加账号  </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::addPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入添加账号的类型&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、添加学生&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、添加老师&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> fileName;</span><br><span class="line"><span class="built_in">string</span> tip;</span><br><span class="line">ofstream ofs;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fileName = STUDENT_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fileName = TEACHER_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofs.open(fileName, ios::out | ios::app);</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;tip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入姓名： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入密码： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; pwd;</span><br><span class="line"></span><br><span class="line">ofs &lt;&lt; id &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; name &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; pwd &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;添加成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"></span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试添加学生：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641024216.png" class="" width="1548641024216"><p>成功在学生文件中添加了一条信息</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641141027.png" class="" width="1548641141027"><p>测试添加教师：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641195834.png" class="" width="1548641195834"><p>成功在教师文件中添加了一条信息</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548641237513.png" class="" width="1548641237513"><h4 id="7-2-2-去重操作"><a href="#7-2-2-去重操作" class="headerlink" title="7.2.2 去重操作"></a>7.2.2 去重操作</h4><p>功能描述：添加新账号时，如果是重复的学生编号，或是重复的教师职工编号，提示有误</p><h5 id="7-2-2-1-读取信息"><a href="#7-2-2-1-读取信息" class="headerlink" title="7.2.2.1 读取信息"></a>7.2.2.1 读取信息</h5><ul><li>要去除重复的账号，首先要先将学生和教师的账号信息获取到程序中，方可检测</li><li>在manager.h中，添加两个容器，用于存放学生和教师的信息</li><li>添加一个新的成员函数  <code>void initVector()</code> 初始化容器</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initVector</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//学生容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Student&gt; vStu;</span><br><span class="line"></span><br><span class="line"><span class="comment">//教师容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Teacher&gt; vTea;</span><br></pre></td></tr></table></figure><p>添加位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644354561.png" class="" width="1548644354561"><p>在Manager的有参构造函数中，获取目前的学生和教师信息</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::initVector</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//读取学生文件中信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(STUDENT_FILE, ios::in);</span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件读取失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">vStu.clear();</span><br><span class="line">     vTea.clear();</span><br><span class="line">    </span><br><span class="line">Student s;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; s.m_Id &amp;&amp; ifs &gt;&gt; s.m_Name &amp;&amp;  ifs &gt;&gt; s.m_Pwd)</span><br><span class="line">&#123;</span><br><span class="line">vStu.push_back(s);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前学生数量为： &quot;</span> &lt;&lt; vStu.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ifs.close(); <span class="comment">//学生初始化</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//读取老师文件信息</span></span><br><span class="line">ifs.open(TEACHER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">Teacher t;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; t.m_EmpId &amp;&amp; ifs &gt;&gt; t.m_Name &amp;&amp;  ifs &gt;&gt; t.m_Pwd)</span><br><span class="line">&#123;</span><br><span class="line">vTea.push_back(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前教师数量为： &quot;</span> &lt;&lt; vTea.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在有参构造函数中，调用初始化容器函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造</span></span><br><span class="line">Manager::Manager(<span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initVector();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试，运行代码可以看到测试代码获取当前学生和教师数量</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548642488049.png" class="" width="1548642488049"><h5 id="7-2-2-2-去重函数封装"><a href="#7-2-2-2-去重函数封装" class="headerlink" title="7.2.2.2 去重函数封装"></a>7.2.2.2 去重函数封装</h5><p>在manager.h文件中添加成员函数<code> bool checkRepeat(int id, int type);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//检测重复 参数:(传入id，传入类型) 返回值：(true 代表有重复，false代表没有重复)</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkRepeat</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span>;</span><br></pre></td></tr></table></figure><p>在manager.cpp文件中实现成员函数  <code> bool checkRepeat(int id, int type);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Manager::checkRepeat</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (type == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Student&gt;::iterator it = vStu.begin(); it != vStu.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == it-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Teacher&gt;::iterator it = vTea.begin(); it != vTea.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (id == it-&gt;m_EmpId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="7-2-2-3-添加去重操作"><a href="#7-2-2-3-添加去重操作" class="headerlink" title="7.2.2.3 添加去重操作"></a>7.2.2.3 添加去重操作</h5><p>在添加学生编号或者教师职工号时，检测是否有重复，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">string</span> errorTip; <span class="comment">//重复错误提示</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">fileName = STUDENT_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入学号： &quot;</span>;</span><br><span class="line">errorTip = <span class="string">&quot;学号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">fileName = TEACHER_FILE;</span><br><span class="line">tip = <span class="string">&quot;请输入职工编号：&quot;</span>;</span><br><span class="line">errorTip = <span class="string">&quot;职工号重复，请重新输入&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">ofs.open(fileName, ios::out | ios::app);</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">string</span> pwd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;tip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> ret = <span class="keyword">this</span>-&gt;checkRepeat(id, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret) <span class="comment">//有重复</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; errorTip &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548643909979.png" class="" width="1548643909979"><p>检测效果：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644151974.png" class="" width="1548644151974"><h5 id="7-2-2-4-bug解决"><a href="#7-2-2-4-bug解决" class="headerlink" title="7.2.2.4 bug解决"></a>7.2.2.4 bug解决</h5><p>bug描述：</p><ul><li>虽然可以检测重复的账号，但是刚添加的账号由于没有更新到容器中，因此不会做检测</li><li>导致刚加入的账号的学生号或者职工编号，再次添加时依然可以重复</li></ul><p>解决方案：</p><ul><li>在每次添加新账号时，重新初始化容器</li></ul><p>在添加完毕后，加入代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化容器</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initVector();</span><br></pre></td></tr></table></figure><p>位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548644779578.png" class="" width="1548644779578"><p>再次测试，刚加入的账号不会重复添加了！</p><h3 id="7-3-显示账号"><a href="#7-3-显示账号" class="headerlink" title="7.3  显示账号"></a>7.3  显示账号</h3><p>功能描述：显示学生信息或教师信息</p><h4 id="7-3-1-显示功能实现"><a href="#7-3-1-显示功能实现" class="headerlink" title="7.3.1 显示功能实现"></a>7.3.1 显示功能实现</h4><p>在Manager的<strong>showPerson</strong>成员函数中，实现显示账号功能，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStudent</span><span class="params">(Student &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;学号： &quot;</span> &lt;&lt; s.m_Id &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; s.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; s.m_Pwd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTeacher</span><span class="params">(Teacher &amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;职工号： &quot;</span> &lt;&lt; t.m_EmpId &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; t.m_Name &lt;&lt; <span class="string">&quot; 密码：&quot;</span> &lt;&lt; t.m_Pwd &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择查看内容：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、查看所有学生&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、查看所有老师&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;所有学生信息如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(vStu.begin(), vStu.end(), printStudent);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;所有老师信息如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(vTea.begin(), vTea.end(), printTeacher);</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="7-3-2-测试"><a href="#7-3-2-测试" class="headerlink" title="7.3.2 测试"></a>7.3.2 测试</h4><p>测试查看学生效果</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548646791248.png" class="" width="1548646791248"><p>测试查看教师效果</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548646833665.png" class="" width="1548646833665"><p>至此，显示账号功能实现完毕</p><h3 id="7-4-查看机房"><a href="#7-4-查看机房" class="headerlink" title="7.4 查看机房"></a>7.4 查看机房</h3><h4 id="7-4-1-添加机房信息"><a href="#7-4-1-添加机房信息" class="headerlink" title="7.4.1 添加机房信息"></a>7.4.1 添加机房信息</h4><p>案例需求中，机房一共有三个，其中1号机房容量20台机器，2号50台，3号100台</p><p>我们可以将信息录入到computerRoom.txt中</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548647538570.png" class="" width="1548647538570"><h4 id="7-4-2-机房类创建"><a href="#7-4-2-机房类创建" class="headerlink" title="7.4.2 机房类创建"></a>7.4.2 机房类创建</h4><p>在头文件下，创建新的文件 computerRoom.h</p><p>并添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//机房类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputerRoom</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_ComId; <span class="comment">//机房id号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_MaxNum; <span class="comment">//机房最大容量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-4-3-初始化机房信息"><a href="#7-4-3-初始化机房信息" class="headerlink" title="7.4.3 初始化机房信息"></a>7.4.3 初始化机房信息</h4><p>在Manager管理员类下，添加机房的容器,用于保存机房信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure><p>在Manager有参构造函数中，追加如下代码，初始化机房信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line"></span><br><span class="line">ifs.open(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">vCom.push_back(c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;当前机房数量为： &quot;</span> &lt;&lt; vCom.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure><p>位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548647976462.png" class="" width="1548647976462"><p>因为机房信息目前版本不会有所改动，如果后期有修改功能，最好封装到一个函数中，方便维护</p><h4 id="7-4-4-显示机房信息"><a href="#7-4-4-显示机房信息" class="headerlink" title="7.4.4 显示机房信息"></a>7.4.4 显示机房信息</h4><p>在Manager类的showComputer成员函数中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看机房信息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showComputer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;机房信息如下： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;ComputerRoom&gt;::iterator it = vCom.begin(); it != vCom.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;机房编号： &quot;</span> &lt;&lt; it-&gt;m_ComId &lt;&lt; <span class="string">&quot; 机房最大容量： &quot;</span> &lt;&lt; it-&gt;m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试显示机房信息功能：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548648276929.png" class="" width="1548648276929"><h3 id="7-5-清空预约"><a href="#7-5-清空预约" class="headerlink" title="7.5 清空预约"></a>7.5 清空预约</h3><p>功能描述：</p><p>清空生成的<code>order.txt</code>预约文件</p><h4 id="7-5-1-清空功能实现"><a href="#7-5-1-清空功能实现" class="headerlink" title="7.5.1 清空功能实现"></a>7.5.1 清空功能实现</h4><p>在Manager的cleanFile成员函数中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::cleanFile</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::trunc)</span></span>;</span><br><span class="line">ofs.close();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试清空，可以随意写入一些信息在order.txt中，然后调用cleanFile清空文件接口，查看是否清空干净</p><h2 id="8、-学生模块"><a href="#8、-学生模块" class="headerlink" title="8、 学生模块"></a>8、 学生模块</h2><h3 id="8-1-学生登录和注销"><a href="#8-1-学生登录和注销" class="headerlink" title="8.1 学生登录和注销"></a>8.1 学生登录和注销</h3><h4 id="8-1-1-构造函数"><a href="#8-1-1-构造函数" class="headerlink" title="8.1.1 构造函数"></a>8.1.1 构造函数</h4><ul><li>在Student类的构造函数中，初始化学生信息，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造(学号、姓名、密码)</span></span><br><span class="line">Student::Student(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-2-管理员子菜单"><a href="#8-1-2-管理员子菜单" class="headerlink" title="8.1.2  管理员子菜单"></a>8.1.2  管理员子菜单</h4><ul><li>在./机房预约系统.cpp中，当用户登录的是学生，添加学生菜单接口</li><li>将不同的分支提供出来<ul><li>申请预约</li><li>查看我的预约</li><li>查看所有预约</li><li>取消预约</li><li>注销登录</li></ul></li><li>实现注销功能</li></ul><p>添加全局函数 <code>void studentMenu(Identity * &amp;manager)</code> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//学生菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">studentMenu</span><span class="params">(Identity * &amp;student)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//学生菜单</span></span><br><span class="line">student-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Student* stu = (Student*)student;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//申请预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;applyOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>) <span class="comment">//查看自身预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;showMyOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">3</span>) <span class="comment">//查看所有预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;showAllOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">4</span>) <span class="comment">//取消预约</span></span><br><span class="line">&#123;</span><br><span class="line">stu-&gt;cancelOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> student;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-3-菜单功能实现"><a href="#8-1-3-菜单功能实现" class="headerlink" title="8.1.3 菜单功能实现"></a>8.1.3 菜单功能实现</h4><ul><li>在实现成员函数<code>void Student::operMenu()</code> 代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎学生代表：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.申请预约              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.查看我的预约          |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          3.查看所有预约          |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          4.取消预约              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                 |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-1-4-接口对接"><a href="#8-1-4-接口对接" class="headerlink" title="8.1.4 接口对接"></a>8.1.4 接口对接</h4><ul><li>学生成功登录后，调用学生的子菜单界面</li><li>在学生登录分支中，添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入学生子菜单</span></span><br><span class="line">studentMenu(person);</span><br></pre></td></tr></table></figure><p>添加效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659552298.png" class="" width="1548659552298"><p>测试对接，效果如图：</p><p>登录验证通过：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659590221.png" class="" width="1548659590221"><p>学生子菜单：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659670651.png" class="" width="1548659670651"><p>注销登录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548659682402.png" class="" width="1548659682402"><h3 id="8-2-申请预约"><a href="#8-2-申请预约" class="headerlink" title="8.2 申请预约"></a>8.2 申请预约</h3><h4 id="8-2-1-获取机房信息"><a href="#8-2-1-获取机房信息" class="headerlink" title="8.2.1 获取机房信息"></a>8.2.1 获取机房信息</h4><ul><li>在申请预约时，学生可以看到机房的信息，因此我们需要让学生获取到机房的信息</li></ul><p>在student.h中添加新的成员函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//机房容器</span></span><br><span class="line"><span class="built_in">vector</span>&lt;ComputerRoom&gt; vCom;</span><br></pre></td></tr></table></figure><p>在学生的有参构造函数中追加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取机房信息</span></span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(COMPUTER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line">ComputerRoom c;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; c.m_ComId &amp;&amp; ifs &gt;&gt; c.m_MaxNum)</span><br><span class="line">&#123;</span><br><span class="line">vCom.push_back(c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br></pre></td></tr></table></figure><p>追加位置如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548661562158.png" class="" width="1548661562158"><p>至此，vCom容器中保存了所有机房的信息</p><h4 id="8-2-2-预约功能实现"><a href="#8-2-2-预约功能实现" class="headerlink" title="8.2.2 预约功能实现"></a>8.2.2 预约功能实现</h4><p>在student.cpp中实现成员函数 <code>void Student::applyOrder()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申请预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::applyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;机房开放时间为周一至周五！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入申请预约的时间：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、周一&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、周二&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3、周三&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4、周四&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;5、周五&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> date = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> interval = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> room = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; date;</span><br><span class="line"><span class="keyword">if</span> (date &gt;= <span class="number">1</span> &amp;&amp; date &lt;= <span class="number">5</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入申请预约的时间段：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、上午&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、下午&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; interval;</span><br><span class="line"><span class="keyword">if</span> (interval &gt;= <span class="number">1</span> &amp;&amp; interval &lt;= <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择机房：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">0</span>].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">1</span>].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3号机房容量：&quot;</span> &lt;&lt; vCom[<span class="number">2</span>].m_MaxNum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; room;</span><br><span class="line"><span class="keyword">if</span> (room &gt;= <span class="number">1</span> &amp;&amp; room &lt;= <span class="number">3</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约成功！审核中&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::app)</span></span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; date &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; interval &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; room &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="number">1</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">ofs.close();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，测试代码:</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548728936052.png" class="" width="1548728936052"><p>在order.txt文件中生成如下内容：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548662281801.png" class="" width="1548662281801"><h3 id="8-3-显示预约"><a href="#8-3-显示预约" class="headerlink" title="8.3 显示预约"></a>8.3 显示预约</h3><h4 id="8-3-1-创建预约类"><a href="#8-3-1-创建预约类" class="headerlink" title="8.3.1 创建预约类"></a>8.3.1 创建预约类</h4><p>功能描述：显示预约记录时，需要从文件中获取到所有记录，用来显示，创建预约的类来管理记录以及更新</p><p>在头文件以及源文件下分别创建<strong>orderFile.h</strong> 和 <strong>orderFile.cpp</strong>文件</p><p>orderFile.h中添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;globalFile.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OrderFile</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">OrderFile();</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新预约记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateOrder</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录的容器  key --- 记录的条数  value --- 具体记录的键值对信息</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&gt; m_orderData;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预约记录条数</span></span><br><span class="line"><span class="keyword">int</span> m_Size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>构造函数</strong>中获取所有信息，并存放在容器中，添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line">OrderFile::OrderFile()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(ORDER_FILE, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> date;      <span class="comment">//日期</span></span><br><span class="line"><span class="built_in">string</span> interval;  <span class="comment">//时间段</span></span><br><span class="line"><span class="built_in">string</span> stuId;     <span class="comment">//学生编号</span></span><br><span class="line"><span class="built_in">string</span> stuName;   <span class="comment">//学生姓名</span></span><br><span class="line"><span class="built_in">string</span> roomId;    <span class="comment">//机房编号</span></span><br><span class="line"><span class="built_in">string</span> status;    <span class="comment">//预约状态</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>; <span class="comment">//预约记录个数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; date &amp;&amp; ifs &gt;&gt; interval &amp;&amp; ifs &gt;&gt; stuId &amp;&amp; ifs &gt;&gt; stuName &amp;&amp; ifs &gt;&gt; roomId &amp;&amp;  ifs &gt;&gt; status)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">cout &lt;&lt; date &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; interval &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; stuId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; stuName &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; roomId &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">cout &lt;&lt; status &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> key;</span><br><span class="line"><span class="built_in">string</span> value;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = date.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = date.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = date.substr(pos + <span class="number">1</span>, date.size() - pos <span class="number">-1</span>);</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = interval.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = interval.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = interval.substr(pos + <span class="number">1</span>, interval.size() - pos <span class="number">-1</span> );</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = stuId.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = stuId.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = stuId.substr(pos + <span class="number">1</span>, stuId.size() - pos <span class="number">-1</span> );</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = stuName.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = stuName.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = stuName.substr(pos + <span class="number">1</span>, stuName.size() - pos <span class="number">-1</span>);</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = roomId.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = roomId.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = roomId.substr(pos + <span class="number">1</span>, roomId.size() - pos <span class="number">-1</span> );</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pos = status.find(<span class="string">&quot;:&quot;</span>);</span><br><span class="line"><span class="keyword">if</span> (pos != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">key = status.substr(<span class="number">0</span>, pos);</span><br><span class="line">value = status.substr(pos + <span class="number">1</span>, status.size() - pos <span class="number">-1</span>);</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(key, value));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_orderData.insert(<span class="built_in">make_pair</span>(<span class="keyword">this</span>-&gt;m_Size, m));</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="comment">//for (map&lt;int, map&lt;string, string&gt;&gt;::iterator it = m_orderData.begin(); it != m_orderData.end();it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;key = &quot; &lt;&lt; it-&gt;first &lt;&lt; &quot; value = &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for (map&lt;string, string&gt;::iterator mit = it-&gt;second.begin(); mit != it-&gt;second.end(); mit++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; mit-&gt;first &lt;&lt; &quot; &quot; &lt;&lt; mit-&gt;second &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    ifs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>更新预约记录的成员函数updateOrder代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OrderFile::updateOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(ORDER_FILE, ios::out | ios::trunc)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_Size;i++)</span><br><span class="line">&#123;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;date:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;date&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;interval:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;interval&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;stuName:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;stuName&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;roomId:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;roomId&quot;</span>] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;status:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_orderData[i][<span class="string">&quot;status&quot;</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ofs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="8-3-2-显示自身预约"><a href="#8-3-2-显示自身预约" class="headerlink" title="8.3.2 显示自身预约"></a>8.3.2 显示自身预约</h4><p>首先我们先添加几条预约记录，可以用程序添加或者直接修改order.txt文件</p><p>order.txt文件内容如下： 比如我们有三名同学分别产生了3条预约记录</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667534747.png" class="" width="1548667534747"><p>在Student类的<code>void Student::showMyOrder()</code>成员函数中，添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看我的预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showMyOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (atoi(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].c_str()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667252474.png" class="" width="1548667252474"><h4 id="8-3-3-显示所有预约"><a href="#8-3-3-显示所有预约" class="headerlink" title="8.3.3 显示所有预约"></a>8.3.3 显示所有预约</h4><p>在Student类的<code>void Student::showAllOrder()</code>成员函数中，添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548667591734.png" class="" width="1548667591734"><h3 id="8-4-取消预约"><a href="#8-4-取消预约" class="headerlink" title="8.4 取消预约"></a>8.4 取消预约</h3><p>在Student类的<code>void Student::cancelOrder()</code>成员函数中，添加如下代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取消预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Student::cancelOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;审核中或预约成功的记录可以取消，请输入取消的记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (atoi(of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>].c_str()) == <span class="keyword">this</span>-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span> || of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt;  index ++  &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入取消的记录,0代表返回&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"><span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;记录所在位置： &quot; &lt;&lt; v[select - 1] &lt;&lt; endl;</span></span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">of.updateOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;已取消预约&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>测试取消预约：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669551036.png" class="" width="1548669551036"><p>再次查看个人预约记录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669728023.png" class="" width="1548669728023"><p>查看所有预约</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669753496.png" class="" width="1548669753496"><p>查看order.txt预约文件</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548669798037.png" class="" width="1548669798037"><p>至此，学生模块功能全部实现</p><h2 id="9、-教师模块"><a href="#9、-教师模块" class="headerlink" title="9、 教师模块"></a>9、 教师模块</h2><h3 id="9-1-教师登录和注销"><a href="#9-1-教师登录和注销" class="headerlink" title="9.1 教师登录和注销"></a>9.1 教师登录和注销</h3><h4 id="9-1-1-构造函数"><a href="#9-1-1-构造函数" class="headerlink" title="9.1.1 构造函数"></a>9.1.1 构造函数</h4><ul><li>在Teacher类的构造函数中，初始化教师信息，代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//有参构造 (职工编号，姓名，密码)</span></span><br><span class="line">Teacher::Teacher(<span class="keyword">int</span> empId, <span class="built_in">string</span> name, <span class="built_in">string</span> pwd)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpId = empId;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Pwd = pwd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-2-教师子菜单"><a href="#9-1-2-教师子菜单" class="headerlink" title="9.1.2  教师子菜单"></a>9.1.2  教师子菜单</h4><ul><li>在./机房预约系统.cpp中，当用户登录的是教师，添加教师菜单接口</li><li>将不同的分支提供出来<ul><li>查看所有预约</li><li>审核预约</li><li>注销登录</li></ul></li><li>实现注销功能</li></ul><p>添加全局函数 <code>void TeacherMenu(Person * &amp;manager)</code> 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//教师菜单</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TeacherMenu</span><span class="params">(Identity * &amp;teacher)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//教师菜单</span></span><br><span class="line">teacher-&gt;operMenu();</span><br><span class="line"></span><br><span class="line">Teacher* tea = (Teacher*)teacher;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查看所有预约</span></span><br><span class="line">tea-&gt;showAllOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (select == <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//审核预约</span></span><br><span class="line">tea-&gt;validOrder();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> teacher;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;注销成功&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-3-菜单功能实现"><a href="#9-1-3-菜单功能实现" class="headerlink" title="9.1.3 菜单功能实现"></a>9.1.3 菜单功能实现</h4><ul><li>在实现成员函数<code>void Teacher::operMenu()</code> 代码如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//教师菜单界面</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::operMenu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎教师：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot;登录！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          1.查看所有预约          |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          2.审核预约              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|          0.注销登录              |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t|                                  |\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;\t\t ----------------------------------\n&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择您的操作： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-1-4-接口对接"><a href="#9-1-4-接口对接" class="headerlink" title="9.1.4 接口对接"></a>9.1.4 接口对接</h4><ul><li>教师成功登录后，调用教师的子菜单界面</li><li>在教师登录分支中，添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//进入教师子菜单</span></span><br><span class="line">TeacherMenu(person);</span><br></pre></td></tr></table></figure><p>添加效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670866708.png" class="" width="1548670866708"><p>测试对接，效果如图：</p><p>登录验证通过：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670949885.png" class="" width="1548670949885"><p>教师子菜单：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670958602.png" class="" width="1548670958602"><p>注销登录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548670966988.png" class="" width="1548670966988"><h3 id="9-2-查看所有预约"><a href="#9-2-查看所有预约" class="headerlink" title="9.2 查看所有预约"></a>9.2 查看所有预约</h3><h4 id="9-2-1-所有预约功能实现"><a href="#9-2-1-所有预约功能实现" class="headerlink" title="9.2.1 所有预约功能实现"></a>9.2.1 所有预约功能实现</h4><p>该功能与学生身份的查看所有预约功能相似，用于显示所有预约记录</p><p>在Teacher.cpp中实现成员函数 <code>void Teacher::showAllOrder()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::showAllOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 学号：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuId&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 姓名：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;stuName&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0 取消的预约   1 审核中   2 已预约 -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;2&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约成功&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;-1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核未通过，预约失败&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;预约已取消&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-2-2-测试功能"><a href="#9-2-2-测试功能" class="headerlink" title="9.2.2 测试功能"></a>9.2.2 测试功能</h4><p>运行测试教师身份的查看所有预约功能</p><p>测试效果如图：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548676922678.png" class="" width="1548676922678"><h3 id="9-3-审核预约"><a href="#9-3-审核预约" class="headerlink" title="9.3 审核预约"></a>9.3 审核预约</h3><h4 id="9-3-1-审核功能实现"><a href="#9-3-1-审核功能实现" class="headerlink" title="9.3.1 审核功能实现"></a>9.3.1 审核功能实现</h4><p>功能描述：教师审核学生的预约，依据实际情况审核预约</p><p>在Teacher.cpp中实现成员函数 <code>void Teacher::validOrder()</code></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//审核预约</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Teacher::validOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">OrderFile of;</span><br><span class="line"><span class="keyword">if</span> (of.m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无预约记录&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;待审核的预约记录如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; of.m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ++index &lt;&lt; <span class="string">&quot;、 &quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;预约日期： 周&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;date&quot;</span>];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 时段：&quot;</span> &lt;&lt; (of.m_orderData[i][<span class="string">&quot;interval&quot;</span>] == <span class="string">&quot;1&quot;</span> ? <span class="string">&quot;上午&quot;</span> : <span class="string">&quot;下午&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 机房：&quot;</span> &lt;&lt; of.m_orderData[i][<span class="string">&quot;roomId&quot;</span>];</span><br><span class="line"><span class="built_in">string</span> status = <span class="string">&quot; 状态： &quot;</span>;  <span class="comment">// 0取消的预约   1 审核中   2 已预约  -1 预约失败</span></span><br><span class="line"><span class="keyword">if</span> (of.m_orderData[i][<span class="string">&quot;status&quot;</span>] == <span class="string">&quot;1&quot;</span>)</span><br><span class="line">&#123;</span><br><span class="line">status += <span class="string">&quot;审核中&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; status &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入审核的预约记录,0代表返回&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"><span class="keyword">if</span> (select &gt;= <span class="number">0</span> &amp;&amp; select &lt;= v.size())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入审核结果&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、通过&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、不通过&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; ret;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;2&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">of.m_orderData[v[select - <span class="number">1</span>]][<span class="string">&quot;status&quot;</span>] = <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">of.updateOrder();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;审核完毕！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误，请重新输入&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="9-3-2-测试审核预约"><a href="#9-3-2-测试审核预约" class="headerlink" title="9.3.2 测试审核预约"></a>9.3.2 测试审核预约</h4><p>测试 - 审核通过</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677286679.png" class="" width="1548677286679"><p>审核通过情况</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677383681.png" class="" width="1548677383681"><p>测试-审核未通过</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677402705.png" class="" width="1548677402705"><p>审核未通过情况：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677632792.png" class="" width="1548677632792"><p>学生身份下查看记录：</p><img src="/2022/01/29/%E6%9C%BA%E6%88%BF%E9%A2%84%E7%BA%A6%E7%B3%BB%E7%BB%9F/1548677798815.png" class="" width="1548677798815"><p>审核预约成功！</p><p>至此本案例制作完毕！  <code>^_^</code></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于STL的演讲比赛流程管理系统</title>
      <link href="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="演讲比赛流程管理系统"><a href="#演讲比赛流程管理系统" class="headerlink" title="演讲比赛流程管理系统"></a>演讲比赛流程管理系统</h1><h2 id="1、-演讲比赛程序需求"><a href="#1、-演讲比赛程序需求" class="headerlink" title="1、 演讲比赛程序需求"></a>1、 演讲比赛程序需求</h2><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154762048.png" class="" width="1548154762048"><h3 id="1-1-比赛规则"><a href="#1-1-比赛规则" class="headerlink" title="1.1 比赛规则"></a>1.1 比赛规则</h3><ul><li>学校举行一场演讲比赛，共有<strong>12个人</strong>参加。<strong>比赛共两轮</strong>，第一轮为淘汰赛，第二轮为决赛。</li><li>比赛方式：<strong>分组比赛，每组6个人</strong>；选手每次要随机分组，进行比赛</li><li>每名选手都有对应的<strong>编号</strong>，如 10001 ~ 10012 </li><li>第一轮分为两个小组，每组6个人。 整体按照选手编号进行<strong>抽签</strong>后顺序演讲。</li><li>当小组演讲完后，淘汰组内排名最后的三个选手，<strong>前三名晋级</strong>，进入下一轮的比赛。</li><li>第二轮为决赛，<strong>前三名胜出</strong></li><li>每轮比赛过后需要<strong>显示晋级选手的信息</strong></li></ul><h3 id="1-2-程序功能"><a href="#1-2-程序功能" class="headerlink" title="1.2 程序功能"></a>1.2 程序功能</h3><ul><li>开始演讲比赛：完成整届比赛的流程，每个比赛阶段需要给用户一个提示，用户按任意键后继续下一个阶段</li><li>查看往届记录：查看之前比赛前三名结果，每次比赛都会记录到文件中，文件用.csv后缀名保存</li><li>清空比赛记录：将文件中数据清空</li><li>退出比赛程序：可以退出当前程序</li></ul><h3 id="1-3-程序效果图："><a href="#1-3-程序效果图：" class="headerlink" title="1.3 程序效果图："></a>1.3 程序效果图：</h3><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548155966702.png" class="" width="1548155966702"><h2 id="2、-项目创建"><a href="#2、-项目创建" class="headerlink" title="2、 项目创建"></a>2、 项目创建</h2><p>创建项目步骤如下：</p><ul><li>创建新项目</li><li>添加文件</li></ul><h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><ul><li>打开vs2017后，点击创建新项目，创建新的C++项目</li></ul><p>如图：</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548121881969.png" class="" width="1548121881969"><ul><li>填写项目名称以及选取项目路径，点击确定生成项目</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122271773.png" class="" width="1548122271773"><h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><ul><li>右键源文件，进行添加文件操作</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122420253.png" class="" width="1548122420253"><ul><li>填写文件名称，点击添加</li></ul><ul><li>生成文件成功，效果如下图</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548122619712.png" class="" width="1548122619712"><ul><li>至此，项目已创建完毕</li></ul><h2 id="3、-创建管理类"><a href="#3、-创建管理类" class="headerlink" title="3、 创建管理类"></a>3、 创建管理类</h2><p><strong>功能描述：</strong></p><ul><li>提供菜单界面与用户交互</li><li>对演讲比赛流程进行控制</li><li>与文件的读写交互</li></ul><h3 id="3-1创建文件"><a href="#3-1创建文件" class="headerlink" title="3.1创建文件"></a>3.1创建文件</h3><ul><li>在头文件和源文件的文件夹下分别创建speechManager.h 和 speechManager.cpp文件</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548123402593.png" class="" width="1548123402593"><h3 id="3-2-头文件实现"><a href="#3-2-头文件实现" class="headerlink" title="3.2 头文件实现"></a>3.2 头文件实现</h3><p>在speechManager.h中设计管理类</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//演讲管理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SpeechManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">SpeechManager();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~SpeechManager();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-源文件实现"><a href="#3-3-源文件实现" class="headerlink" title="3.3 源文件实现"></a>3.3 源文件实现</h3><p>在speechManager.cpp中将构造和析构函数空实现补全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;speechManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">SpeechManager::SpeechManager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SpeechManager::~SpeechManager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>至此演讲管理类以创建完毕</li></ul><h2 id="4、-菜单功能"><a href="#4、-菜单功能" class="headerlink" title="4、 菜单功能"></a>4、 菜单功能</h2><p>功能描述：与用户的沟通界面</p><h3 id="4-1-添加成员函数"><a href="#4-1-添加成员函数" class="headerlink" title="4.1 添加成员函数"></a>4.1 添加成员函数</h3><p>在管理类speechManager.h中添加成员函数  <code>void show_Menu();</code></p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548123942072.png" class="" width="1548123942072"><h3 id="4-2-菜单功能实现"><a href="#4-2-菜单功能实现" class="headerlink" title="4.2 菜单功能实现"></a>4.2 菜单功能实现</h3><ul><li>在管理类speechManager.cpp中实现 show_Menu()函数</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::show_Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  欢迎参加演讲比赛 ************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  1.开始演讲比赛  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  2.查看往届记录  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  3.清空比赛记录  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  0.退出比赛程序  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-测试菜单功能"><a href="#4-3-测试菜单功能" class="headerlink" title="4.3 测试菜单功能"></a>4.3 测试菜单功能</h3><ul><li>在演讲比赛流程管理系统.cpp中测试菜单功能</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;speechManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SpeechManager sm;</span><br><span class="line"></span><br><span class="line">sm.show_Menu();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>运行效果如图：</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548124599641.png" class="" width="1548124599641"><ul><li>菜单界面搭建完毕</li></ul><h2 id="5、-退出功能"><a href="#5、-退出功能" class="headerlink" title="5、 退出功能"></a>5、 退出功能</h2><h3 id="5-1-提供功能接口"><a href="#5-1-提供功能接口" class="headerlink" title="5.1  提供功能接口"></a>5.1  提供功能接口</h3><ul><li>在main函数中提供分支选择，提供每个功能接口</li></ul><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">SpeechManager sm;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> choice = <span class="number">0</span>; <span class="comment">//用来存储用户的选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">sm.show_Menu();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入您的选择： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; choice; <span class="comment">// 接受用户的选项</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:  <span class="comment">//开始比赛</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:  <span class="comment">//查看记录</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//清空记录</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>:  <span class="comment">//退出系统</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>); <span class="comment">//清屏</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-实现退出功能"><a href="#5-2-实现退出功能" class="headerlink" title="5.2 实现退出功能"></a>5.2 实现退出功能</h3><p>在speechManager.h中提供退出系统的成员函数 <code>    void exitSystem();</code></p><p>在speechManager.cpp中提供具体的功能实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::exitSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3测试功能"><a href="#5-3测试功能" class="headerlink" title="5.3测试功能"></a>5.3测试功能</h3><p>在main函数分支 0  选项中，调用退出程序的接口</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548124853576.png" class="" width="1548124853576"><p>运行测试效果如图：</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548124888578.png" class="" width="1548124888578"><h2 id="6、演讲比赛功能"><a href="#6、演讲比赛功能" class="headerlink" title="6、演讲比赛功能"></a>6、演讲比赛功能</h2><h3 id="6-1-功能分析"><a href="#6-1-功能分析" class="headerlink" title="6.1 功能分析"></a>6.1 功能分析</h3><p>比赛流程分析：</p><p>抽签 → 开始演讲比赛 → 显示第一轮比赛结果 → </p><p>抽签 → 开始演讲比赛 → 显示前三名结果 → 保存分数</p><h3 id="6-2-创建选手类"><a href="#6-2-创建选手类" class="headerlink" title="6.2 创建选手类"></a>6.2 创建选手类</h3><ul><li>选手类中的属性包含：选手姓名、分数</li><li>头文件中创建 speaker.h文件，并添加代码：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Speaker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">double</span> m_Score[<span class="number">2</span>]; <span class="comment">//分数  最多有两轮得分</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-3-比赛"><a href="#6-3-比赛" class="headerlink" title="6.3 比赛"></a>6.3 比赛</h3><h4 id="6-3-1-成员属性添加"><a href="#6-3-1-成员属性添加" class="headerlink" title="6.3.1 成员属性添加"></a>6.3.1 成员属性添加</h4><ul><li>在speechManager.h中添加属性</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比赛选手 容器  12人</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一轮晋级容器  6人</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"></span><br><span class="line"><span class="comment">//胜利前三名容器  3人</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vVictory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存放编号 以及对应的 具体选手 容器</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, Speaker&gt; m_Speaker;</span><br></pre></td></tr></table></figure><h4 id="6-3-2-初始化属性"><a href="#6-3-2-初始化属性" class="headerlink" title="6.3.2 初始化属性"></a>6.3.2 初始化属性</h4><ul><li>在speechManager.h中提供开始比赛的的成员函数 <code>void initSpeech();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initSpeech</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现<code>void initSpeech();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::initSpeech</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//容器保证为空</span></span><br><span class="line"><span class="keyword">this</span>-&gt;v1.clear();  </span><br><span class="line"><span class="keyword">this</span>-&gt;v2.clear();</span><br><span class="line"><span class="keyword">this</span>-&gt;vVictory.clear();</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Speaker.clear();</span><br><span class="line"><span class="comment">//初始化比赛轮数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Index = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SpeechManager构造函数中调用<code>void initSpeech();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">SpeechManager::SpeechManager()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initSpeech();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="6-3-3-创建选手"><a href="#6-3-3-创建选手" class="headerlink" title="6.3.3 创建选手"></a>6.3.3 创建选手</h4><ul><li>在speechManager.h中提供开始比赛的的成员函数 <code>void createSpeaker();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化创建12名选手</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createSpeaker</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现<code>void createSpeaker();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::createSpeaker</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDEFGHIJKL&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nameSeed.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">Speaker sp;</span><br><span class="line">sp.m_Name = name;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">sp.m_Score[i] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//12名选手编号</span></span><br><span class="line"><span class="keyword">this</span>-&gt;v1.push_back(i + <span class="number">10001</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//选手编号 以及对应的选手 存放到map容器中</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Speaker.insert(<span class="built_in">make_pair</span>(i + <span class="number">10001</span>, sp));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>SpeechManager类的 构造函数中调用<code>void createSpeaker();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">SpeechManager::SpeechManager()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initSpeech();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//创建选手</span></span><br><span class="line"><span class="keyword">this</span>-&gt;createSpeaker();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试 在main函数中，可以在创建完管理对象后，使用下列代码测试12名选手初始状态</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, Speaker&gt;::iterator it = sm.m_Speaker.begin(); it != sm.m_Speaker.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span>  &lt;&lt; <span class="string">&quot;选手编号：&quot;</span> &lt;&lt; it-&gt;first </span><br><span class="line">          &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; it-&gt;second.m_Name </span><br><span class="line">          &lt;&lt; <span class="string">&quot; 成绩： &quot;</span> &lt;&lt; it-&gt;second.m_Score[<span class="number">0</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548141605742.png" class="" width="1548141605742"><ul><li>测试效果如图：</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548141560164.png" class="" width="1548141560164"><ul><li>测试完毕后，可以将测试代码删除或注释。</li></ul><h4 id="6-3-4-开始比赛成员函数添加"><a href="#6-3-4-开始比赛成员函数添加" class="headerlink" title="6.3.4 开始比赛成员函数添加"></a>6.3.4 开始比赛成员函数添加</h4><ul><li>在speechManager.h中提供开始比赛的的成员函数 <code>void startSpeech();</code></li><li>该函数功能是主要控制比赛的流程</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始比赛 - 比赛流程控制</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpeech</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中将startSpeech的空实现先写入</li><li>我们可以先将整个比赛的流程 写到函数中</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始比赛</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::startSpeech</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//第一轮比赛</span></span><br><span class="line"><span class="comment">//1、抽签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、比赛</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、显示晋级结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二轮比赛</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、抽签</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、比赛</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、显示最终结果</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、保存分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="6-3-5-抽签"><a href="#6-3-5-抽签" class="headerlink" title="6.3.5 抽签"></a>6.3.5 抽签</h4><p><strong>功能描述：</strong></p><ul><li>正式比赛前，所有选手的比赛顺序需要打乱，我们只需要将存放选手编号的容器  打乱次序即可</li></ul><ul><li>在speechManager.h中提供抽签的的成员函数 <code>void speechDraw();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽签</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speechDraw</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void speechDraw();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::speechDraw</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第 &lt;&lt; &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot; &gt;&gt; 轮比赛选手正在抽签&quot;</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;抽签后演讲顺序如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">random_shuffle(v1.begin(), v1.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v1.begin(); it != v1.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">random_shuffle(v2.begin(), v2.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v2.begin(); it != v2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在startSpeech比赛流程控制的函数中，调用抽签函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548143871202.png" class="" width="1548143871202"><ul><li>在main函数中，分支1选项中，调用开始比赛的接口</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548143543475.png" class="" width="1548143543475"><ul><li>测试</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548143610682.png" class="" width="1548143610682"><h4 id="6-3-6-开始比赛"><a href="#6-3-6-开始比赛" class="headerlink" title="6.3.6 开始比赛"></a>6.3.6 开始比赛</h4><ul><li>在speechManager.h中提供比赛的的成员函数 <code>void speechContest();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//比赛</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speechContest</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void speechContest();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::speechContest</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------- 第&quot;</span>&lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮正式比赛开始：------------- &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt; groupScore; <span class="comment">//临时容器，保存key分数 value 选手编号</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">//记录人员数，6个为1组</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span> &lt;<span class="keyword">int</span>&gt;v_Src;   <span class="comment">//比赛的人员容器</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">v_Src = v1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v_Src = v2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历所有参赛选手</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v_Src.begin(); it != v_Src.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">num++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//评委打分</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">double</span>&gt;d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">double</span> score = (rand() % <span class="number">401</span> + <span class="number">600</span>) / <span class="number">10.f</span>;  <span class="comment">// 600 ~ 1000</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; score &lt;&lt; &quot; &quot;;</span></span><br><span class="line">d.push_back(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sort(d.begin(), d.end(), greater&lt;<span class="keyword">double</span>&gt;());<span class="comment">//排序</span></span><br><span class="line">d.pop_front();<span class="comment">//去掉最高分</span></span><br><span class="line">d.pop_back();<span class="comment">//去掉最低分</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> sum = accumulate(d.begin(), d.end(), <span class="number">0.0f</span>);<span class="comment">//获取总分</span></span><br><span class="line"><span class="keyword">double</span> avg = sum / (<span class="keyword">double</span>)d.size();<span class="comment">//获取平均分</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个人平均分</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;编号： &quot; &lt;&lt; *it  &lt;&lt; &quot; 选手： &quot; &lt;&lt; this-&gt;m_Speaker[*it].m_Name &lt;&lt; &quot; 获取平均分为： &quot; &lt;&lt; avg &lt;&lt; endl;  //打印分数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Speaker[*it].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] = avg;</span><br><span class="line"></span><br><span class="line"><span class="comment">//6个人一组，用临时容器保存</span></span><br><span class="line">groupScore.insert(<span class="built_in">make_pair</span>(avg, *it));</span><br><span class="line"><span class="keyword">if</span> (num % <span class="number">6</span> == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; num / <span class="number">6</span> &lt;&lt; <span class="string">&quot;小组比赛名次：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multimap</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = groupScore.begin(); it != groupScore.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;编号: &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Speaker[it-&gt;second].m_Name &lt;&lt; <span class="string">&quot; 成绩： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Speaker[it-&gt;second].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//取前三名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multimap</span>&lt;<span class="keyword">double</span>, <span class="keyword">int</span>, greater&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = groupScore.begin(); it != groupScore.end() &amp;&amp; count &lt; <span class="number">3</span>; it++, count++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back((*it).second);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">vVictory.push_back((*it).second);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">groupScore.clear();</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;------------- 第&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮比赛完毕  ------------- &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在startSpeech比赛流程控制的函数中，调用比赛函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548144491984.png" class="" width="1548144491984"><ul><li>再次运行代码，测试比赛</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548144765146.png" class="" width="1548144765146"><h4 id="6-3-7-显示比赛分数"><a href="#6-3-7-显示比赛分数" class="headerlink" title="6.3.7 显示比赛分数"></a>6.3.7 显示比赛分数</h4><ul><li>在speechManager.h中提供比赛的的成员函数 <code>void showScore();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示比赛结果</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showScore</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void  showScore();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::showScore</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------第&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Index &lt;&lt; <span class="string">&quot;轮晋级选手信息如下：-----------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Index == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">v = v2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">v = vVictory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;选手编号：&quot;</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; 姓名： &quot;</span> &lt;&lt; m_Speaker[*it].m_Name &lt;&lt; <span class="string">&quot; 得分： &quot;</span> &lt;&lt; m_Speaker[*it].m_Score[<span class="keyword">this</span>-&gt;m_Index - <span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">this</span>-&gt;show_Menu(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在startSpeech比赛流程控制的函数中，调用显示比赛分数函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548146903960.png" class="" width="1548146903960"><ul><li>运行代码，测试效果</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548146961550.png" class="" width="1548146961550"><h4 id="6-3-8-第二轮比赛"><a href="#6-3-8-第二轮比赛" class="headerlink" title="6.3.8 第二轮比赛"></a>6.3.8 第二轮比赛</h4><p>第二轮比赛流程同第一轮，只是比赛的轮是+1，其余流程不变</p><ul><li>在startSpeech比赛流程控制的函数中，加入第二轮的流程</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548148593215.png" class="" width="1548148593215"><p>测试，将整个比赛流程都跑通</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548148536395.png" class="" width="1548148536395"><h3 id="6-4-保存分数"><a href="#6-4-保存分数" class="headerlink" title="6.4 保存分数"></a>6.4 保存分数</h3><p><strong>功能描述：</strong></p><ul><li>将每次演讲比赛的得分记录到文件中</li></ul><p><strong>功能实现：</strong></p><ul><li>在speechManager.h中添加保存记录的成员函数 <code>void saveRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">saveRecord</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void saveRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::saveRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(<span class="string">&quot;speech.csv&quot;</span>, ios::out | ios::app); <span class="comment">// 用输出的方式打开文件  -- 写文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将每个人数据写入到文件中</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = vVictory.begin(); it != vVictory.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line">ofs &lt;&lt; *it &lt;&lt; <span class="string">&quot;,&quot;</span></span><br><span class="line">&lt;&lt; m_Speaker[*it].m_Score[<span class="number">1</span>] &lt;&lt; <span class="string">&quot;,&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">ofs &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//关闭文件</span></span><br><span class="line">ofs.close();</span><br><span class="line">    </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;记录已经保存&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在startSpeech比赛流程控制的函数中，最后调用保存记录分数函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548149937860.png" class="" width="1548149937860"><ul><li>测试，整个比赛完毕后记录保存情况</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548149912863.png" class="" width="1548149912863"><p>利用记事本打开文件 speech.csv，里面保存了前三名选手的编号以及得分</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548150047975.png" class="" width="1548150047975"><p>至此，整个演讲比赛功能制作完毕！</p><h2 id="7、-查看记录"><a href="#7、-查看记录" class="headerlink" title="7、 查看记录"></a>7、 查看记录</h2><h3 id="7-1-读取记录分数"><a href="#7-1-读取记录分数" class="headerlink" title="7.1 读取记录分数"></a>7.1 读取记录分数</h3><ul><li>在speechManager.h中添加保存记录的成员函数 <code>void loadRecord();</code></li><li>添加判断文件是否为空的标志  <code>bool fileIsEmpty;</code></li><li>添加往届记录的容器<code>map&lt;int, vector&lt;string&gt;&gt; m_Record;</code>   </li></ul><p>其中m_Record 中的key代表第几届，value记录具体的信息</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//读取记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loadRecord</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件为空的标志</span></span><br><span class="line"><span class="keyword">bool</span> fileIsEmpty;</span><br><span class="line"></span><br><span class="line"><span class="comment">//往届记录</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; m_Record;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void loadRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::loadRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">ifstream <span class="title">ifs</span><span class="params">(<span class="string">&quot;speech.csv&quot;</span>, ios::in)</span></span>; <span class="comment">//输入流对象 读取文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">true</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ifs &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (ifs.eof())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件不为空</span></span><br><span class="line"><span class="keyword">this</span>-&gt;fileIsEmpty = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">ifs.putback(ch); <span class="comment">//读取的单个字符放回去</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> data;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; data)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//cout &lt;&lt; data &lt;&lt; endl;</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line">pos = data.find(<span class="string">&quot;,&quot;</span>, start); <span class="comment">//从0开始查找 &#x27;,&#x27;</span></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>; <span class="comment">//找不到break返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> tmp = data.substr(start, pos - start); <span class="comment">//找到了,进行分割 参数1 起始位置，参数2 截取长度</span></span><br><span class="line">v.push_back(tmp);</span><br><span class="line">start = pos + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Record.insert(<span class="built_in">make_pair</span>(index, v));</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在SpeechManager构造函数中调用获取往届记录函数</li></ul><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548151977242.png" class="" width="1548151977242"><h3 id="7-2-查看记录功能"><a href="#7-2-查看记录功能" class="headerlink" title="7.2 查看记录功能"></a>7.2 查看记录功能</h3><ul><li>在speechManager.h中添加保存记录的成员函数 <code>void showRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示往届得分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showRecord</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void showRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::showRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Record.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第&quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot;届 &quot;</span> &lt;&lt;</span><br><span class="line"><span class="string">&quot;冠军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">0</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">1</span>] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="string">&quot;亚军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">2</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">3</span>] &lt;&lt; <span class="string">&quot; &quot;</span></span><br><span class="line"><span class="string">&quot;季军编号：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">4</span>] &lt;&lt; <span class="string">&quot; 得分：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Record[i][<span class="number">5</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="7-3-测试功能"><a href="#7-3-测试功能" class="headerlink" title="7.3 测试功能"></a>7.3 测试功能</h3><p>在main函数分支 2  选项中，调用查看记录的接口</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548152359604.png" class="" width="1548152359604"><p>显示效果如图：（本次测试添加了4条记录）</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548152394715.png" class="" width="1548152394715"><h3 id="7-4-bug解决"><a href="#7-4-bug解决" class="headerlink" title="7.4 bug解决"></a>7.4 bug解决</h3><p>目前程序中有几处bug未解决：</p><ol><li>查看往届记录，若文件不存在或为空，并未提示</li></ol><p>解决方式：在showRecord函数中，开始判断文件状态并加以判断</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548152803116.png" class="" width="1548152803116"><ol start="2"><li>若记录为空或不存在，比完赛后依然提示记录为空</li></ol><p>解决方式：saveRecord中更新文件为空的标志</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548153005042.png" class="" width="1548153005042"><ol start="3"><li>比完赛后查不到本届比赛的记录，没有实时更新</li></ol><p>解决方式：比赛完毕后，所有数据重置</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548153319587.png" class="" width="1548153319587"><ol start="4"><li>在初始化时，没有初始化记录容器</li></ol><p>解决方式：initSpeech中添加 初始化记录容器</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154340974.png" class="" width="1548154340974"><ol start="5"><li>每次记录都是一样的</li></ol><p>解决方式：在main函数一开始 添加随机数种子</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br></pre></td></tr></table></figure><p>所有bug解决后 测试：</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548153571603.png" class="" width="1548153571603"><h2 id="8、-清空记录"><a href="#8、-清空记录" class="headerlink" title="8、 清空记录"></a>8、 清空记录</h2><h3 id="8-1-清空记录功能实现"><a href="#8-1-清空记录功能实现" class="headerlink" title="8.1 清空记录功能实现"></a>8.1 清空记录功能实现</h3><ul><li>在speechManager.h中添加保存记录的成员函数 <code>void clearRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空记录</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clearRecord</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><ul><li>在speechManager.cpp中实现成员函数 <code>void clearRecord();</code></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SpeechManager::clearRecord</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;确认清空？&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、确认&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、返回&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打开模式 ios::trunc 如果存在删除文件并重新创建</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(<span class="string">&quot;speech.csv&quot;</span>, ios::trunc)</span></span>;</span><br><span class="line">ofs.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化属性</span></span><br><span class="line"><span class="keyword">this</span>-&gt;initSpeech();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建选手</span></span><br><span class="line"><span class="keyword">this</span>-&gt;createSpeaker();</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取往届记录</span></span><br><span class="line"><span class="keyword">this</span>-&gt;loadRecord();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-2-测试清空"><a href="#8-2-测试清空" class="headerlink" title="8.2 测试清空"></a>8.2 测试清空</h3><p>在main函数分支 3  选项中，调用清空比赛记录的接口</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154674242.png" class="" width="1548154674242"><p>运行程序，测试清空记录：</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154004738.png" class="" width="1548154004738"><p>speech.csv中记录也为空</p><img src="/2022/01/27/%E5%9F%BA%E4%BA%8ESTL%E7%9A%84%E6%BC%94%E8%AE%B2%E6%AF%94%E8%B5%9B%E6%B5%81%E7%A8%8B%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1548154508831.png" class="" width="1548154508831"><ul><li>至此本案例结束！ <code>^_^</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 提高编程</title>
      <link href="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="C-提高编程"><a href="#C-提高编程" class="headerlink" title="C++提高编程"></a>C++提高编程</h1><ul><li>本阶段主要针对C++==泛型编程==和==STL==技术做详细讲解，探讨C++更深层的使用</li></ul><h2 id="1-模板"><a href="#1-模板" class="headerlink" title="1 模板"></a>1 模板</h2><h3 id="1-1-模板的概念"><a href="#1-1-模板的概念" class="headerlink" title="1.1 模板的概念"></a>1.1 模板的概念</h3><p>模板就是建立<strong>通用的模具</strong>，大大<strong>提高复用性</strong></p><p>例如生活中的模板</p><p>一寸照片模板：</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547105026929.png" class="" width="1547105026929"><p>PPT模板：</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547103297864.png" class="" width="1547103297864"><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547103359158.png" class="" width="1547103359158"><p>模板的特点：</p><ul><li>模板不可以直接使用，它只是一个框架</li><li>模板的通用并不是万能的</li></ul><h3 id="1-2-函数模板"><a href="#1-2-函数模板" class="headerlink" title="1.2 函数模板"></a>1.2 函数模板</h3><ul><li>C++另一种编程思想称为 ==泛型编程== ，主要利用的技术就是模板</li></ul><ul><li>C++提供两种模板机制:<strong>函数模板</strong>和<strong>类模板</strong> </li></ul><h4 id="1-2-1-函数模板语法"><a href="#1-2-1-函数模板语法" class="headerlink" title="1.2.1 函数模板语法"></a>1.2.1 函数模板语法</h4><p>函数模板作用：</p><p>建立一个通用函数，其函数返回值类型和形参类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</p><p><strong>语法：</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">函数声明或定义</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//交换整型函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapInt</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换浮点型函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swapDouble</span><span class="params">(<span class="keyword">double</span>&amp; a, <span class="keyword">double</span>&amp; b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//swapInt(a, b);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用模板实现交换</span></span><br><span class="line"><span class="comment">//1、自动类型推导</span></span><br><span class="line">mySwap(a, b);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、显示指定类型</span></span><br><span class="line">mySwap&lt;<span class="keyword">int</span>&gt;(a, b);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; a &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>函数模板利用关键字 template</li><li>使用函数模板有两种方式：自动类型推导、显示指定类型</li><li>模板的目的是为了提高复用性，将类型参数化</li></ul><h4 id="1-2-2-函数模板注意事项"><a href="#1-2-2-函数模板注意事项" class="headerlink" title="1.2.2 函数模板注意事项"></a>1.2.2 函数模板注意事项</h4><p>注意事项：</p><ul><li>自动类型推导，必须推导出一致的数据类型T,才可以使用</li></ul><ul><li>模板必须要确定出T的数据类型，才可以使用</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//利用模板提供通用的交换函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1、自动类型推导，必须推导出一致的数据类型T,才可以使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line">mySwap(a, b); <span class="comment">// 正确，可以推导出一致的T</span></span><br><span class="line"><span class="comment">//mySwap(a, c); // 错误，推导不出一致的T类型</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、模板必须要确定出T的数据类型，才可以使用</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func 调用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//func(); //错误，模板不能独立使用，必须确定出T的类型</span></span><br><span class="line">func&lt;<span class="keyword">int</span>&gt;(); <span class="comment">//利用显示指定类型的方式，给T一个类型，才可以使用该模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>使用模板时必须确定出通用数据类型T，并且能够推导出一致的类型</li></ul><h4 id="1-2-3-函数模板案例"><a href="#1-2-3-函数模板案例" class="headerlink" title="1.2.3 函数模板案例"></a>1.2.3 函数模板案例</h4><p>案例描述：</p><ul><li>利用函数模板封装一个排序的函数，可以对<strong>不同数据类型数组</strong>进行排序</li><li>排序规则从大到小，排序算法为<strong>选择排序</strong></li><li>分别利用<strong>char数组</strong>和<strong>int数组</strong>进行测试</li></ul><p>示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//交换的函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySwap</span><span class="params">(T &amp;a, T&amp;b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">T temp = a;</span><br><span class="line">a = b;</span><br><span class="line">b = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span> <span class="comment">// 也可以替换成typename</span></span><br><span class="line"><span class="comment">//利用选择排序，进行对数组从大到小的排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mySort</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> max = i; <span class="comment">//最大数的下标</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; len; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (arr[max] &lt; arr[j])</span><br><span class="line">&#123;</span><br><span class="line">max = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (max != i) <span class="comment">//如果最大数的下标不是i，交换两者</span></span><br><span class="line">&#123;</span><br><span class="line">mySwap(arr[max], arr[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printArray</span><span class="params">(T arr[], <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试char数组</span></span><br><span class="line"><span class="keyword">char</span> charArr[] = <span class="string">&quot;bdcfeagh&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> num = <span class="keyword">sizeof</span>(charArr) / <span class="keyword">sizeof</span>(<span class="keyword">char</span>);</span><br><span class="line">mySort(charArr, num);</span><br><span class="line">printArray(charArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//测试int数组</span></span><br><span class="line"><span class="keyword">int</span> intArr[] = &#123; <span class="number">7</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">9</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> num = <span class="keyword">sizeof</span>(intArr) / <span class="keyword">sizeof</span>(<span class="keyword">int</span>);</span><br><span class="line">mySort(intArr, num);</span><br><span class="line">printArray(intArr, num);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：模板可以提高代码复用，需要熟练掌握</p><h4 id="1-2-4-普通函数与函数模板的区别"><a href="#1-2-4-普通函数与函数模板的区别" class="headerlink" title="1.2.4 普通函数与函数模板的区别"></a>1.2.4 普通函数与函数模板的区别</h4><p><strong>普通函数与函数模板区别：</strong></p><ul><li>普通函数调用时可以发生自动类型转换（隐式类型转换）</li><li>函数模板调用时，如果利用自动类型推导，不会发生隐式类型转换</li><li>如果利用显示指定类型的方式，可以发生隐式类型转换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">myAdd01</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function">T <span class="title">myAdd02</span><span class="params">(T a, T b)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数模板时，如果用自动类型推导，不会发生自动类型转换,即隐式类型转换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="keyword">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myAdd01(a, c) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//正确，将char类型的&#x27;c&#x27;隐式转换为int类型  &#x27;c&#x27; 对应 ASCII码 99</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//myAdd02(a, c); // 报错，使用自动类型推导时，不会发生隐式类型转换</span></span><br><span class="line"></span><br><span class="line">myAdd02&lt;<span class="keyword">int</span>&gt;(a, c); <span class="comment">//正确，如果用显示指定类型，可以发生隐式类型转换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议使用显示指定类型的方式，调用函数模板，因为可以自己确定通用类型T</p><h4 id="1-2-5-普通函数与函数模板的调用规则"><a href="#1-2-5-普通函数与函数模板的调用规则" class="headerlink" title="1.2.5 普通函数与函数模板的调用规则"></a>1.2.5 普通函数与函数模板的调用规则</h4><p>调用规则如下：</p><ol><li>如果函数模板和普通函数都可以实现，优先调用普通函数</li><li>可以通过空模板参数列表来强制调用函数模板</li><li>函数模板也可以发生重载</li><li>如果函数模板可以产生更好的匹配,优先调用函数模板</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通函数与函数模板调用规则</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用的普通函数&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用的模板&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(T a, T b, T c)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;调用重载的模板&quot;</span> &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//1、如果函数模板和普通函数都可以实现，优先调用普通函数</span></span><br><span class="line"><span class="comment">// 注意 如果告诉编译器  普通函数是有的，但只是声明没有实现，或者不在当前文件内实现，就会报错找不到</span></span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line">myPrint(a, b); <span class="comment">//调用普通函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、可以通过空模板参数列表来强制调用函数模板</span></span><br><span class="line">myPrint&lt;&gt;(a, b); <span class="comment">//调用函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数模板也可以发生重载</span></span><br><span class="line"><span class="keyword">int</span> c = <span class="number">30</span>;</span><br><span class="line">myPrint(a, b, c); <span class="comment">//调用重载的函数模板</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//4、 如果函数模板可以产生更好的匹配,优先调用函数模板</span></span><br><span class="line"><span class="keyword">char</span> c1 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="keyword">char</span> c2 = <span class="string">&#x27;b&#x27;</span>;</span><br><span class="line">myPrint(c1, c2); <span class="comment">//调用函数模板</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：既然提供了函数模板，最好就不要提供普通函数，否则容易出现二义性</p><h4 id="1-2-6-模板的局限性"><a href="#1-2-6-模板的局限性" class="headerlink" title="1.2.6 模板的局限性"></a>1.2.6 模板的局限性</h4><p><strong>局限性：</strong></p><ul><li>模板的通用性并不是万能的</li></ul><p><strong>例如：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   a = b;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中提供的赋值操作，如果传入的a和b是一个数组，就无法实现了</p><p>再例如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T a, T b)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">   <span class="keyword">if</span>(a &gt; b) &#123; ... &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>在上述代码中，如果T的数据类型传入的是像Person这样的自定义数据类型，也无法正常运行</p><p>因此C++为了解决这种问题，提供模板的重载，可以为这些<strong>特定的类型</strong>提供<strong>具体化的模板</strong></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(T&amp; a, T&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (a == b)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体化，显示具体化的原型和定意思以template&lt;&gt;开头，并通过名称来指出类型</span></span><br><span class="line"><span class="comment">//具体化优先于常规模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt; <span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(Person &amp;p1, Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( p1.m_Name  == p2.m_Name &amp;&amp; p1.m_Age == p2.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">//内置数据类型可以直接使用通用的函数模板</span></span><br><span class="line"><span class="keyword">bool</span> ret = myCompare(a, b);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a == b &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;a != b &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;Tom&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="comment">//自定义数据类型，不会调用普通的函数模板</span></span><br><span class="line"><span class="comment">//可以创建具体化的Person数据类型的模板，用于特殊处理这个类型</span></span><br><span class="line"><span class="keyword">bool</span> ret = myCompare(p1, p2);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 == p2 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;p1 != p2 &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用具体化的模板，可以解决自定义类型的通用化</li><li>学习模板并不是为了写模板，而是在STL能够运用系统提供的模板</li></ul><h3 id="1-3-类模板"><a href="#1-3-类模板" class="headerlink" title="1.3 类模板"></a>1.3 类模板</h3><h4 id="1-3-1-类模板语法"><a href="#1-3-1-类模板语法" class="headerlink" title="1.3.1 类模板语法"></a>1.3.1 类模板语法</h4><p>类模板作用：</p><ul><li>建立一个通用类，类中的成员 数据类型可以不具体制定，用一个<strong>虚拟的类型</strong>来代表。</li></ul><p><strong>语法：</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">类</span><br></pre></td></tr></table></figure><p><strong>解释：</strong></p><p>template  —  声明创建模板</p><p>typename  — 表面其后面的符号是一种数据类型，可以用class代替</p><p>T    —   通用的数据类型，名称可以替换，通常为大写字母</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span>&gt;</span> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 指定NameType 为string类型，AgeType 为 int类型</span></span><br><span class="line">Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt;P1(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">999</span>);</span><br><span class="line">P1.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板和函数模板语法相似，在声明模板template后面加类，此类称为类模板</p><h4 id="1-3-2-类模板与函数模板区别"><a href="#1-3-2-类模板与函数模板区别" class="headerlink" title="1.3.2 类模板与函数模板区别"></a>1.3.2 类模板与函数模板区别</h4><p>类模板与函数模板区别主要有两点：</p><ol><li>类模板没有自动类型推导的使用方式</li><li>类模板在模板参数列表中可以有默认参数</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、类模板没有自动类型推导的使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// Person p(&quot;孙悟空&quot;, 1000); // 错误 类模板使用时候，不可以用自动类型推导</span></span><br><span class="line">Person &lt;<span class="built_in">string</span> ,<span class="keyword">int</span>&gt;p(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>); <span class="comment">//必须使用显示指定类型的方式，使用类模板</span></span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、类模板在模板参数列表中可以有默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>&gt; p(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">999</span>); <span class="comment">//类模板中的模板参数列表 可以指定默认参数</span></span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>类模板使用只能用显示指定类型方式</li><li>类模板中的模板参数列表可以有默认参数</li></ul><h4 id="1-3-3-类模板中成员函数创建时机"><a href="#1-3-3-类模板中成员函数创建时机" class="headerlink" title="1.3.3 类模板中成员函数创建时机"></a>1.3.3 类模板中成员函数创建时机</h4><p>类模板中成员函数和普通类中成员函数创建时机是有区别的：</p><ul><li>普通类中的成员函数一开始就可以创建</li><li>类模板中的成员函数在调用时才创建</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person1</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person1 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person2</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Person2 show&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T obj;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中的成员函数，并不是一开始就创建的，而是在模板调用时再生成</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun1</span><span class="params">()</span> </span>&#123; obj.showPerson1(); &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fun2</span><span class="params">()</span> </span>&#123; obj.showPerson2(); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyClass&lt;Person1&gt; m;</span><br><span class="line"></span><br><span class="line">m.fun1();</span><br><span class="line"></span><br><span class="line"><span class="comment">//m.fun2();//编译会出错，说明函数调用才会去创建成员函数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中的成员函数并不是一开始就创建的，在调用时才去创建</p><h4 id="1-3-4-类模板对象做函数参数"><a href="#1-3-4-类模板对象做函数参数" class="headerlink" title="1.3.4 类模板对象做函数参数"></a>1.3.4 类模板对象做函数参数</h4><p>学习目标：</p><ul><li>类模板实例化出的对象，向函数传参的方式</li></ul><p>一共有三种传入方式：</p><ol><li>指定传入的类型   — 直接显示对象的数据类型</li><li>参数模板化           — 将对象中的参数变为模板进行传递</li><li>整个类模板化       — 将这个对象类型 模板化进行传递</li></ol><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//类模板</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">NameType</span>, <span class="keyword">class</span> <span class="title">AgeType</span> =</span> <span class="keyword">int</span>&gt; </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(NameType name, AgeType age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;mName = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;name: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mName &lt;&lt; <span class="string">&quot; age: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">NameType mName;</span><br><span class="line">AgeType mAge;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、指定传入的类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson1</span><span class="params">(Person&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; &amp;p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">100</span>);</span><br><span class="line">printPerson1(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、参数模板化</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt;&amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">p.showPerson();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T1的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T2的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">90</span>);</span><br><span class="line">printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、整个类模板化</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson3</span><span class="params">(T &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;T的类型为： &quot;</span> &lt;&lt; <span class="keyword">typeid</span>(T).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p.showPerson();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>);</span><br><span class="line">printPerson3(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line">test03();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>通过类模板创建的对象，可以有三种方式向函数中进行传参</li><li>使用比较广泛是第一种：指定传入的类型</li></ul><h4 id="1-3-5-类模板与继承"><a href="#1-3-5-类模板与继承" class="headerlink" title="1.3.5 类模板与继承"></a>1.3.5 类模板与继承</h4><p>当类模板碰到继承时，需要注意一下几点：</p><ul><li>当子类继承的父类是一个类模板时，子类在声明的时候，要指定出父类中T的类型</li><li>如果不指定，编译器无法给子类分配内存</li><li>如果想灵活指定出父类中T的类型，子类也需变为类模板</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">T m;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//class Son:public Base  //错误，c++编译需要给子类分配内存，必须知道父类中T的类型才可以向下继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span><span class="keyword">public</span> Base&lt;<span class="keyword">int</span>&gt; <span class="comment">//必须指定一个类型</span></span><br><span class="line">&#123;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板继承类模板 ,可以用T2指定父类中的T类型</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son2</span> :</span><span class="keyword">public</span> Base&lt;T2&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Son2()</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T1).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">typeid</span>(T2).name() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Son2&lt;<span class="keyword">int</span>, <span class="keyword">char</span>&gt; child1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果父类是类模板，子类需要指定出父类中T的数据类型</p><h4 id="1-3-6-类模板成员函数类外实现"><a href="#1-3-6-类模板成员函数类外实现" class="headerlink" title="1.3.6 类模板成员函数类外实现"></a>1.3.6 类模板成员函数类外实现</h4><p>学习目标：能够掌握类模板中的成员函数类外实现</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//类模板中成员函数类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">//成员函数类内声明</span></span><br><span class="line">Person(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::showPerson() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, int&gt; p(&quot;Tom&quot;, 20);</span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：类模板中成员函数类外实现时，需要加上模板参数列表</p><h4 id="1-3-7-类模板分文件编写"><a href="#1-3-7-类模板分文件编写" class="headerlink" title="1.3.7 类模板分文件编写"></a>1.3.7 类模板分文件编写</h4><p>学习目标：</p><ul><li>掌握类模板成员函数分文件编写产生的问题以及解决方式</li></ul><p>问题：</p><ul><li>类模板中成员函数创建时机是在调用阶段，导致分文件编写时链接不到</li></ul><p>解决：</p><ul><li>解决方式1：直接包含.cpp源文件</li><li>解决方式2：将声明和实现写到同一个文件中，并更改后缀名为.hpp，hpp是约定的名称，并不是强制</li></ul><p><strong>示例：</strong></p><p>person.hpp中代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(T1 name, T2 age);</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line">Person&lt;T1, T2&gt;::Person(T1 name, T2 age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//成员函数 类外实现</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="keyword">void</span> Person&lt;T1, T2&gt;::showPerson() &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名: &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄:&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>类模板分文件编写.cpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#include &quot;person.h&quot;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.cpp&quot;</span> <span class="comment">//解决方式1，包含cpp源文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解决方式2，将声明和实现写到一起，文件后缀名改为.hpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;person.hpp&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person&lt;string, int&gt; p(&quot;Tom&quot;, 10);</span><br><span class="line">p.showPerson();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：主流的解决方式是第二种，将类模板成员函数写到一起，并将后缀名改为.hpp</p><h4 id="1-3-8-类模板与友元"><a href="#1-3-8-类模板与友元" class="headerlink" title="1.3.8 类模板与友元"></a>1.3.8 类模板与友元</h4><p>学习目标：</p><ul><li>掌握类模板配合友元函数的类内和类外实现</li></ul><p>全局函数类内实现 - 直接在类内声明友元即可</p><p>全局函数类外实现 - 需要提前让编译器知道全局函数的存在</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数配合友元  类外实现 - 先做函数模板声明，下方在做函数模板定义，在做友元</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//如果声明了函数模板，可以将实现写到后面，否则需要将实现体写到类的前面让编译器提前看到</span></span><br><span class="line"><span class="comment">//template&lt;class T1, class T2&gt; void printPerson2(Person&lt;T1, T2&gt; &amp; p); </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPerson2</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;类外实现 ---- 姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T1</span>, <span class="keyword">class</span> <span class="title">T2</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="comment">//1、全局函数配合友元   类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">printPerson</span><span class="params">(Person&lt;T1, T2&gt; &amp; p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p.m_Name &lt;&lt; <span class="string">&quot; 年龄：&quot;</span> &lt;&lt; p.m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//全局函数配合友元  类外实现</span></span><br><span class="line"><span class="keyword">friend</span> <span class="keyword">void</span> printPerson2&lt;&gt;(Person&lt;T1, T2&gt; &amp; p);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Person(T1 name, T2 age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T1 m_Name;</span><br><span class="line">T2 m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、全局函数在类内实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;Tom&quot;</span>, <span class="number">20</span>);</span><br><span class="line">printPerson(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、全局函数在类外实现</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Person &lt;<span class="built_in">string</span>, <span class="keyword">int</span> &gt;p(<span class="string">&quot;Jerry&quot;</span>, <span class="number">30</span>);</span><br><span class="line">printPerson2(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：建议全局函数做类内实现，用法简单，而且编译器可以直接识别</p><h4 id="1-3-9-类模板案例"><a href="#1-3-9-类模板案例" class="headerlink" title="1.3.9 类模板案例"></a>1.3.9 类模板案例</h4><p>案例描述:  实现一个通用的数组类，要求如下：</p><ul><li>可以对内置数据类型以及自定义数据类型的数据进行存储</li><li>将数组中的数据存储到堆区</li><li>构造函数中可以传入数组的容量</li><li>提供对应的拷贝构造函数以及operator=防止浅拷贝问题</li><li>提供尾插法和尾删法对数组中的数据进行增加和删除</li><li>可以通过下标的方式访问数组中的元素</li><li>可以获取数组中当前元素个数和数组的容量</li></ul><p><strong>示例：</strong></p><p>myArray.hpp中代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">MyArray(<span class="keyword">int</span> capacity)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line">MyArray(<span class="keyword">const</span> MyArray &amp; arr)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = arr.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = arr.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//如果T为对象，而且还包含指针，必须需要重载 = 操作符，因为这个等号不是 构造 而是赋值，</span></span><br><span class="line"><span class="comment">// 普通类型可以直接= 但是指针类型需要深拷贝</span></span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = arr.pAddress[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载= 操作符  防止浅拷贝问题</span></span><br><span class="line">MyArray&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyArray&amp; myarray) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = myarray.m_Capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = myarray.m_Size;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="keyword">new</span> T[<span class="keyword">this</span>-&gt;m_Capacity];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_Size; i++) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[i] = myarray[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重载[] 操作符  arr[0]</span></span><br><span class="line">T&amp; <span class="keyword">operator</span> [](<span class="keyword">int</span> index)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;pAddress[index]; <span class="comment">//不考虑越界，用户自己去处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾插法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push_back</span><span class="params">(<span class="keyword">const</span> T &amp; val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Capacity == <span class="keyword">this</span>-&gt;m_Size)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress[<span class="keyword">this</span>-&gt;m_Size] = val;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Pop_back</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Size == <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组容量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Capacity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span><span class="title">getSize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>-&gt;m_Size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//析构</span></span><br><span class="line">~MyArray()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;pAddress != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;pAddress;</span><br><span class="line"><span class="keyword">this</span>-&gt;pAddress = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Capacity = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Size = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">T * pAddress;  <span class="comment">//指向一个堆空间，这个空间存储真正的数据</span></span><br><span class="line"><span class="keyword">int</span> m_Capacity; <span class="comment">//容量</span></span><br><span class="line"><span class="keyword">int</span> m_Size;   <span class="comment">// 大小</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>类模板案例—数组类封装.cpp中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;myArray.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printIntArray</span><span class="params">(MyArray&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">array1.Push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array1);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的大小：&quot;</span> &lt;&lt; array1.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array1的容量：&quot;</span> &lt;&lt; array1.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;--------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MyArray&lt;<span class="keyword">int</span>&gt; <span class="title">array2</span><span class="params">(array1)</span></span>;</span><br><span class="line">array2.Pop_back();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2打印输出：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printIntArray(array2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的大小：&quot;</span> &lt;&lt; array2.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;array2的容量：&quot;</span> &lt;&lt; array2.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person() &#123;&#125; </span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printPersonArray</span><span class="params">(MyArray&lt;Person&gt;&amp; personArr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; personArr.getSize(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名：&quot;</span> &lt;&lt; personArr[i].m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; personArr[i].m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建数组</span></span><br><span class="line"><span class="function">MyArray&lt;Person&gt; <span class="title">pArray</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;韩信&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;妲己&quot;</span>, <span class="number">18</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;王昭君&quot;</span>, <span class="number">15</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">24</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入数据</span></span><br><span class="line">pArray.Push_back(p1);</span><br><span class="line">pArray.Push_back(p2);</span><br><span class="line">pArray.Push_back(p3);</span><br><span class="line">pArray.Push_back(p4);</span><br><span class="line">pArray.Push_back(p5);</span><br><span class="line"></span><br><span class="line">printPersonArray(pArray);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的大小：&quot;</span> &lt;&lt; pArray.getSize() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pArray的容量：&quot;</span> &lt;&lt; pArray.getCapacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>能够利用所学知识点实现通用的数组</p><h2 id="2-STL初识"><a href="#2-STL初识" class="headerlink" title="2 STL初识"></a>2 STL初识</h2><h3 id="2-1-STL的诞生"><a href="#2-1-STL的诞生" class="headerlink" title="2.1 STL的诞生"></a>2.1 STL的诞生</h3><ul><li><p>长久以来，软件界一直希望建立一种可重复利用的东西</p></li><li><p>C++的<strong>面向对象</strong>和<strong>泛型编程</strong>思想，目的就是<strong>复用性的提升</strong></p></li><li><p>大多情况下，数据结构和算法都未能有一套标准,导致被迫从事大量重复工作</p></li><li><p>为了建立数据结构和算法的一套标准,诞生了<strong>STL</strong></p></li></ul><h3 id="2-2-STL基本概念"><a href="#2-2-STL基本概念" class="headerlink" title="2.2 STL基本概念"></a>2.2 STL基本概念</h3><ul><li>STL(Standard Template Library,<strong>标准模板库</strong>)</li><li>STL 从广义上分为: <strong>容器(container) 算法(algorithm) 迭代器(iterator)</strong></li><li><strong>容器</strong>和<strong>算法</strong>之间通过<strong>迭代器</strong>进行无缝连接。</li><li>STL 几乎所有的代码都采用了模板类或者模板函数</li></ul><h3 id="2-3-STL六大组件"><a href="#2-3-STL六大组件" class="headerlink" title="2.3 STL六大组件"></a>2.3 STL六大组件</h3><p>STL大体分为六大组件，分别是:<strong>容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器</strong></p><ol><li>容器：各种数据结构，如vector、list、deque、set、map等,用来存放数据。</li><li>算法：各种常用的算法，如sort、find、copy、for_each等</li><li>迭代器：扮演了容器与算法之间的胶合剂。</li><li>仿函数：行为类似函数，可作为算法的某种策略。</li><li>适配器：一种用来修饰容器或者仿函数或迭代器接口的东西。</li><li>空间配置器：负责空间的配置与管理。</li></ol><h3 id="2-4-STL中容器、算法、迭代器"><a href="#2-4-STL中容器、算法、迭代器" class="headerlink" title="2.4  STL中容器、算法、迭代器"></a>2.4  STL中容器、算法、迭代器</h3><p><strong>容器：</strong>置物之所也</p><p>STL<strong>容器</strong>就是将运用<strong>最广泛的一些数据结构</strong>实现出来</p><p>常用的数据结构：数组, 链表,树, 栈, 队列, 集合, 映射表 等</p><p>这些容器分为<strong>序列式容器</strong>和<strong>关联式容器</strong>两种:</p><p>​    <strong>序列式容器</strong>:强调值的排序，序列式容器中的每个元素均有固定的位置。<br>​    <strong>关联式容器</strong>:二叉树结构，各元素之间没有严格的物理上的顺序关系</p><p><strong>算法：</strong>问题之解法也</p><p>有限的步骤，解决逻辑或数学上的问题，这一门学科我们叫做算法(Algorithms)</p><p>算法分为:<strong>质变算法</strong>和<strong>非质变算法</strong>。</p><p>质变算法：是指运算过程中会更改区间内的元素的内容。例如拷贝，替换，删除等等</p><p>非质变算法：是指运算过程中不会更改区间内的元素内容，例如查找、计数、遍历、寻找极值等等</p><p><strong>迭代器：</strong>容器和算法之间粘合剂</p><p>提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>每个容器都有自己专属的迭代器</p><p>迭代器使用非常类似于指针，初学阶段我们可以先理解迭代器为指针</p><p>迭代器种类：</p><table><thead><tr><th>种类</th><th>功能</th><th>支持运算</th></tr></thead><tbody><tr><td>输入迭代器</td><td>对数据的只读访问</td><td>只读，支持++、==、！=</td></tr><tr><td>输出迭代器</td><td>对数据的只写访问</td><td>只写，支持++</td></tr><tr><td>前向迭代器</td><td>读写操作，并能向前推进迭代器</td><td>读写，支持++、==、！=</td></tr><tr><td>双向迭代器</td><td>读写操作，并能向前和向后操作</td><td>读写，支持++、–，</td></tr><tr><td>随机访问迭代器</td><td>读写操作，可以以跳跃的方式访问任意数据，功能最强的迭代器</td><td>读写，支持++、–、[n]、-n、&lt;、&lt;=、&gt;、&gt;=</td></tr></tbody></table><p>常用的容器中迭代器种类为双向迭代器，和随机访问迭代器</p><h3 id="2-5-容器算法迭代器初识"><a href="#2-5-容器算法迭代器初识" class="headerlink" title="2.5 容器算法迭代器初识"></a>2.5 容器算法迭代器初识</h3><p>了解STL中容器、算法、迭代器概念之后，我们利用代码感受STL的魅力</p><p>STL中最常用的容器为Vector，可以理解为数组，下面我们将学习如何向这个容器中插入数据、并遍历这个容器</p><h4 id="2-5-1-vector存放内置数据类型"><a href="#2-5-1-vector存放内置数据类型" class="headerlink" title="2.5.1 vector存放内置数据类型"></a>2.5.1 vector存放内置数据类型</h4><p>容器：     <code>vector</code></p><p>算法：     <code>for_each</code></p><p>迭代器： <code>vector&lt;int&gt;::iterator</code></p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建vector容器对象，并且通过模板参数指定容器中存放的数据的类型</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="comment">//向容器中放数据</span></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//每一个容器都有自己的迭代器，迭代器是用来遍历容器中的元素</span></span><br><span class="line"><span class="comment">//v.begin()返回迭代器，这个迭代器指向容器中第一个数据</span></span><br><span class="line"><span class="comment">//v.end()返回迭代器，这个迭代器指向容器元素的最后一个元素的下一个位置</span></span><br><span class="line"><span class="comment">//vector&lt;int&gt;::iterator 拿到vector&lt;int&gt;这种容器的迭代器类型</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pBegin = v.begin();</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator pEnd = v.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">//第一种遍历方式：</span></span><br><span class="line"><span class="keyword">while</span> (pBegin != pEnd) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *pBegin &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pBegin++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//第二种遍历方式：</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//第三种遍历方式：</span></span><br><span class="line"><span class="comment">//使用STL提供标准遍历算法  头文件 algorithm</span></span><br><span class="line">for_each(v.begin(), v.end(), MyPrint);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-2-Vector存放自定义数据类型"><a href="#2-5-2-Vector存放自定义数据类型" class="headerlink" title="2.5.2 Vector存放自定义数据类型"></a>2.5.2 Vector存放自定义数据类型</h4><p>学习目标：vector中存放自定义数据类型，并打印输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) &#123;</span><br><span class="line">mName = name;</span><br><span class="line">mAge = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> mName;</span><br><span class="line"><span class="keyword">int</span> mAge;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//存放对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; (*it).mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it).mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//放对象指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person*&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;eee&quot;</span>, <span class="number">50</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(&amp;p1);</span><br><span class="line">v.push_back(&amp;p2);</span><br><span class="line">v.push_back(&amp;p3);</span><br><span class="line">v.push_back(&amp;p4);</span><br><span class="line">v.push_back(&amp;p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person*&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line">Person * p = (*it);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Name:&quot;</span> &lt;&lt; p-&gt;mName &lt;&lt; <span class="string">&quot; Age:&quot;</span> &lt;&lt; (*it)-&gt;mAge &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-5-3-Vector容器嵌套容器"><a href="#2-5-3-Vector容器嵌套容器" class="headerlink" title="2.5.3 Vector容器嵌套容器"></a>2.5.3 Vector容器嵌套容器</h4><p>学习目标：容器中嵌套容器，我们将所有数据进行遍历输出</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//容器嵌套容器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;  v;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v3;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">v2.push_back(i + <span class="number">2</span>);</span><br><span class="line">v3.push_back(i + <span class="number">3</span>);</span><br><span class="line">v4.push_back(i + <span class="number">4</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器元素插入到vector v中</span></span><br><span class="line">v.push_back(v1);</span><br><span class="line">v.push_back(v2);</span><br><span class="line">v.push_back(v3);</span><br><span class="line">v.push_back(v4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator vit = (*it).begin(); vit != (*it).end(); vit++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vit &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-STL-常用容器"><a href="#3-STL-常用容器" class="headerlink" title="3 STL- 常用容器"></a>3 STL- 常用容器</h2><h3 id="3-1-string容器"><a href="#3-1-string容器" class="headerlink" title="3.1 string容器"></a>3.1 string容器</h3><h4 id="3-1-1-string基本概念"><a href="#3-1-1-string基本概念" class="headerlink" title="3.1.1 string基本概念"></a>3.1.1 string基本概念</h4><p><strong>本质：</strong></p><ul><li>string是C++风格的字符串，而string本质上是一个类</li></ul><p>*<em>string和char * 区别：*</em></p><ul><li>char * 是一个指针</li><li>string是一个类，类内部封装了char*，管理这个字符串，是一个char*型的容器。</li></ul><p><strong>特点：</strong></p><p>string 类内部封装了很多成员方法</p><p>例如：查找find，拷贝copy，删除delete 替换replace，插入insert</p><p>string管理char*所分配的内存，不用担心复制越界和取值越界等，由类内部进行负责</p><h4 id="3-1-2-string构造函数"><a href="#3-1-2-string构造函数" class="headerlink" title="3.1.2 string构造函数"></a>3.1.2 string构造函数</h4><p>构造函数原型：</p><ul><li><code>string();</code>                          //创建一个空的字符串 例如: string str;<br>   <code>string(const char* s);</code>            //使用字符串s初始化</li><li><code>string(const string&amp; str);</code>    //使用一个string对象初始化另一个string对象</li><li><code>string(int n, char c);</code>           //使用n个字符c初始化 </li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="comment">//string构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> s1; <span class="comment">//创建空字符串，调用无参构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; s1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(str)</span></span>; <span class="comment">//把c_string转换成了string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; s2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(s2)</span></span>; <span class="comment">//调用拷贝构造函数</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s4</span><span class="params">(<span class="number">10</span>, <span class="string">&#x27;a&#x27;</span>)</span></span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; s3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-1-3-string赋值操作"><a href="#3-1-3-string赋值操作" class="headerlink" title="3.1.3 string赋值操作"></a>3.1.3 string赋值操作</h4><p>功能描述：</p><ul><li>给string字符串进行赋值</li></ul><p>赋值的函数原型：</p><ul><li><code>string&amp; operator=(const char* s);</code>             //char*类型字符串 赋值给当前的字符串</li><li><code>string&amp; operator=(const string &amp;s);</code>         //把字符串s赋给当前的字符串</li><li><code>string&amp; operator=(char c);</code>                          //字符赋值给当前的字符串</li><li><code>string&amp; assign(const char *s);</code>                  //把字符串s赋给当前的字符串</li><li><code>string&amp; assign(const char *s, int n);</code>     //把字符串s的前n个字符赋给当前的字符串</li><li><code>string&amp; assign(const string &amp;s);</code>              //把字符串s赋给当前字符串</li><li><code>string&amp; assign(int n, char c);</code>                  //用n个字符c赋给当前字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1;</span><br><span class="line">str1 = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2;</span><br><span class="line">str2 = str1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str2 = &quot;</span> &lt;&lt; str2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3;</span><br><span class="line">str3 = <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str4;</span><br><span class="line">str4.assign(<span class="string">&quot;hello c++&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str4 = &quot;</span> &lt;&lt; str4 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str5;</span><br><span class="line">str5.assign(<span class="string">&quot;hello c++&quot;</span>,<span class="number">5</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str5 = &quot;</span> &lt;&lt; str5 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str6;</span><br><span class="line">str6.assign(str5);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str6 = &quot;</span> &lt;&lt; str6 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str7;</span><br><span class="line">str7.assign(<span class="number">5</span>, <span class="string">&#x27;x&#x27;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str7 = &quot;</span> &lt;&lt; str7 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>​    string的赋值方式很多，<code>operator=</code>  这种方式是比较实用的</p><h4 id="3-1-4-string字符串拼接"><a href="#3-1-4-string字符串拼接" class="headerlink" title="3.1.4 string字符串拼接"></a>3.1.4 string字符串拼接</h4><p><strong>功能描述：</strong></p><ul><li>实现在字符串末尾拼接字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; operator+=(const char* str);</code>                   //重载+=操作符</li><li><code>string&amp; operator+=(const char c);</code>                         //重载+=操作符</li><li><code>string&amp; operator+=(const string&amp; str);</code>                //重载+=操作符</li><li><code>string&amp; append(const char *s); </code>                               //把字符串s连接到当前字符串结尾</li><li><code>string&amp; append(const char *s, int n);</code>                 //把字符串s的前n个字符连接到当前字符串结尾</li><li><code>string&amp; append(const string &amp;s);</code>                           //同operator+=(const string&amp; str)</li><li><code>string&amp; append(const string &amp;s, int pos, int n);</code>//字符串s中从pos开始的n个字符连接到字符串结尾</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串拼接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;我&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&quot;爱玩游戏&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str1 += <span class="string">&#x27;:&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str2 = <span class="string">&quot;LOL DNF&quot;</span>;</span><br><span class="line"></span><br><span class="line">str1 += str2;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str3 = <span class="string">&quot;I&quot;</span>;</span><br><span class="line">str3.append(<span class="string">&quot; love &quot;</span>);</span><br><span class="line">str3.append(<span class="string">&quot;game abcde&quot;</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">//str3.append(str2);</span></span><br><span class="line">str3.append(str2, <span class="number">4</span>, <span class="number">3</span>); <span class="comment">// 从下标4位置开始 ，截取3个字符，拼接到字符串末尾</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str3 = &quot;</span> &lt;&lt; str3 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串拼接的重载版本很多，初学阶段记住几种即可</p><h4 id="3-1-5-string查找和替换"><a href="#3-1-5-string查找和替换" class="headerlink" title="3.1.5 string查找和替换"></a>3.1.5 string查找和替换</h4><p><strong>功能描述：</strong></p><ul><li>查找：查找指定字符串是否存在</li><li>替换：在指定的位置替换字符串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>int find(const string&amp; str, int pos = 0) const;</code>              //查找str第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos = 0) const; </code>                     //查找s第一次出现位置,从pos开始查找</li><li><code>int find(const char* s, int pos, int n) const; </code>               //从pos位置查找s的前n个字符第一次位置</li><li><code>int find(const char c, int pos = 0) const; </code>                       //查找字符c第一次出现位置</li><li><code>int rfind(const string&amp; str, int pos = npos) const;</code>      //查找str最后一次位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos = npos) const;</code>              //查找s最后一次出现位置,从pos开始查找</li><li><code>int rfind(const char* s, int pos, int n) const;</code>              //从pos查找s的前n个字符最后一次位置</li><li><code>int rfind(const char c, int pos = 0) const;  </code>                      //查找字符c最后一次出现位置</li><li><code>string&amp; replace(int pos, int n, const string&amp; str); </code>       //替换从pos开始n个字符为字符串str</li><li><code>string&amp; replace(int pos, int n,const char* s); </code>                 //替换从pos开始的n个字符为字符串s</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找和替换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pos = str1.find(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos == <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pos = str1.rfind(<span class="string">&quot;de&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;pos = &quot;</span> &lt;&lt; pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//替换</span></span><br><span class="line"><span class="built_in">string</span> str1 = <span class="string">&quot;abcdefgde&quot;</span>;</span><br><span class="line">str1.replace(<span class="number">1</span>, <span class="number">3</span>, <span class="string">&quot;1111&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;str1 = &quot;</span> &lt;&lt; str1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>find查找是从左往后，rfind从右往左</li><li>find找到字符串后返回查找的第一个字符位置，找不到返回-1</li><li>replace在替换时，要指定从哪个位置起，多少个字符，替换成什么样的字符串</li></ul><h4 id="3-1-6-string字符串比较"><a href="#3-1-6-string字符串比较" class="headerlink" title="3.1.6 string字符串比较"></a>3.1.6 string字符串比较</h4><p><strong>功能描述：</strong></p><ul><li>字符串之间的比较</li></ul><p><strong>比较方式：</strong></p><ul><li>字符串比较是按字符的ASCII码进行对比</li></ul><p>= 返回   0</p><p>&gt; 返回   1 </p><p>&lt; 返回  -1</p><p><strong>函数原型：</strong></p><ul><li><code>int compare(const string &amp;s) const; </code>  //与字符串s比较</li><li><code>int compare(const char *s) const;</code>      //与字符串s比较</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串比较</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> s2 = <span class="string">&quot;aello&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = s1.compare(s2);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ret == <span class="number">0</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 等于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 大于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1 小于 s2&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：字符串对比主要是用于比较两个字符串是否相等，判断谁大谁小的意义并不是很大</p><h4 id="3-1-7-string字符存取"><a href="#3-1-7-string字符存取" class="headerlink" title="3.1.7 string字符存取"></a>3.1.7 string字符存取</h4><p>string中单个字符存取方式有两种</p><ul><li><code>char&amp; operator[](int n); </code>     //通过[]方式取字符</li><li><code>char&amp; at(int n);   </code>                    //通过at方法获取字符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//字符修改</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line">str.at(<span class="number">1</span>) = <span class="string">&#x27;x&#x27;</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：string字符串中单个字符存取有两种方式，利用 [ ] 或 at</p><h4 id="3-1-8-string插入和删除"><a href="#3-1-8-string插入和删除" class="headerlink" title="3.1.8 string插入和删除"></a>3.1.8 string插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对string字符串进行插入和删除字符操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string&amp; insert(int pos, const char* s);  </code>                //插入字符串</li><li><code>string&amp; insert(int pos, const string&amp; str); </code>        //插入字符串</li><li><code>string&amp; insert(int pos, int n, char c);</code>                //在指定位置插入n个字符c</li><li><code>string&amp; erase(int pos, int n = npos);</code>                    //删除从Pos开始的n个字符 </li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字符串插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">str.insert(<span class="number">1</span>, <span class="string">&quot;111&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">str.erase(<span class="number">1</span>, <span class="number">3</span>);  <span class="comment">//从1号位置开始3个字符</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>插入和删除的起始下标都是从0开始</p><h4 id="3-1-9-string子串"><a href="#3-1-9-string子串" class="headerlink" title="3.1.9 string子串"></a>3.1.9 string子串</h4><p><strong>功能描述：</strong></p><ul><li>从字符串中获取想要的子串</li></ul><p><strong>函数原型：</strong></p><ul><li><code>string substr(int pos = 0, int n = npos) const;</code>   //返回由pos开始的n个字符组成的字符串</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//子串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> str = <span class="string">&quot;abcdefg&quot;</span>;</span><br><span class="line"><span class="built_in">string</span> subStr = str.substr(<span class="number">1</span>, <span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;subStr = &quot;</span> &lt;&lt; subStr &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> email = <span class="string">&quot;hello@sina.com&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> pos = email.find(<span class="string">&quot;@&quot;</span>);</span><br><span class="line"><span class="built_in">string</span> username = email.substr(<span class="number">0</span>, pos);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;username: &quot;</span> &lt;&lt; username &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>灵活的运用求子串功能，可以在实际开发中获取有效的信息</p><h3 id="3-2-vector容器"><a href="#3-2-vector容器" class="headerlink" title="3.2 vector容器"></a>3.2 vector容器</h3><h4 id="3-2-1-vector基本概念"><a href="#3-2-1-vector基本概念" class="headerlink" title="3.2.1 vector基本概念"></a>3.2.1 vector基本概念</h4><p><strong>功能：</strong></p><ul><li>vector数据结构和<strong>数组非常相似</strong>，也称为<strong>单端数组</strong></li></ul><p><strong>vector与普通数组区别：</strong></p><ul><li>不同之处在于数组是静态空间，而vector可以<strong>动态扩展</strong></li></ul><p><strong>动态扩展：</strong></p><ul><li>并不是在原空间之后续接新空间，而是找更大的内存空间，然后将原数据拷贝新空间，释放原空间</li></ul><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002.jpg" class="" title="说明: 2015-11-10_151152"><ul><li>vector容器的迭代器是支持随机访问的迭代器</li></ul><h4 id="3-2-2-vector构造函数"><a href="#3-2-2-vector构造函数" class="headerlink" title="3.2.2 vector构造函数"></a>3.2.2 vector构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建vector容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&lt;T&gt; v; </code>                            //采用模板实现类实现，默认构造函数</li><li><code>vector(v.begin(), v.end());   </code>       //将v[begin(), end())区间中的元素拷贝给本身。</li><li><code>vector(n, elem);</code>                            //构造函数将n个elem拷贝给本身。</li><li><code>vector(const vector &amp;vec);</code>         //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1.begin(), v1.end())</span></span>;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(<span class="number">10</span>, <span class="number">100</span>)</span></span>;</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(v3)</span></span>;</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>vector的多种构造方式没有可比性，灵活使用即可</p><h4 id="3-2-3-vector赋值操作"><a href="#3-2-3-vector赋值操作" class="headerlink" title="3.2.3 vector赋值操作"></a>3.2.3 vector赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给vector容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>vector&amp; operator=(const vector &amp;vec);</code>//重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>       //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>        //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1; <span class="comment">//无参构造</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line">v2 = v1;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v3;</span><br><span class="line">v3.assign(v1.begin(), v1.end());</span><br><span class="line">printVector(v3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v4;</span><br><span class="line">v4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printVector(v4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结： vector赋值方式比较简单，使用operator=，或者assign都可以</p><h4 id="3-2-4-vector容量和大小"><a href="#3-2-4-vector容量和大小" class="headerlink" title="3.2.4  vector容量和大小"></a>3.2.4  vector容量和大小</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器的容量和大小操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>empty(); </code>                            //判断容器是否为空</p></li><li><p><code>capacity();</code>                      //容器的容量</p></li><li><p><code>size();</code>                              //返回容器中元素的个数</p></li><li><p><code>resize(int num);</code>             //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                          //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(int num, elem);</code>  //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><p>​                              //如果容器变短，则末尾超出容器长度的元素被删除</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="keyword">if</span> (v1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的容量 = &quot;</span> &lt;&lt; v1.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的大小 = &quot;</span> &lt;&lt; v1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更大，默认用0填充新位置，可以利用重载版本替换默认填充</span></span><br><span class="line">v1.resize(<span class="number">15</span>,<span class="number">10</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//resize 重新指定大小 ，若指定的更小，超出部分元素被删除</span></span><br><span class="line">v1.resize(<span class="number">5</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空  — empty</li><li>返回元素个数  — size</li><li>返回容器容量  — capacity</li><li>重新指定大小  —  resize</li></ul><h4 id="3-2-5-vector插入和删除"><a href="#3-2-5-vector插入和删除" class="headerlink" title="3.2.5 vector插入和删除"></a>3.2.5 vector插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对vector容器进行插入、删除操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>push_back(ele);</code>                                         //尾部插入元素ele</li><li><code>pop_back();</code>                                                //删除最后一个元素</li><li><code>insert(const_iterator pos, ele);</code>        //迭代器指向位置pos插入元素ele</li><li><code>insert(const_iterator pos, int count,ele);</code>//迭代器指向位置pos插入count个元素ele</li><li><code>erase(const_iterator pos);</code>                     //删除迭代器指向的元素</li><li><code>erase(const_iterator start, const_iterator end);</code>//删除迭代器从start到end之间的元素</li><li><code>clear();</code>                                                        //删除容器中所有元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">v1.push_back(<span class="number">10</span>);</span><br><span class="line">v1.push_back(<span class="number">20</span>);</span><br><span class="line">v1.push_back(<span class="number">30</span>);</span><br><span class="line">v1.push_back(<span class="number">40</span>);</span><br><span class="line">v1.push_back(<span class="number">50</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">v1.pop_back();</span><br><span class="line">printVector(v1);</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">v1.insert(v1.begin(), <span class="number">100</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line">v1.insert(v1.begin(), <span class="number">2</span>, <span class="number">1000</span>);</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">v1.erase(v1.begin());</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">v1.erase(v1.begin(), v1.end());</span><br><span class="line">v1.clear();</span><br><span class="line">printVector(v1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插  — push_back</li><li>尾删  — pop_back</li><li>插入  — insert    (位置迭代器)</li><li>删除  — erase  （位置迭代器）</li><li>清空  —  clear  </li></ul><h4 id="3-2-6-vector数据存取"><a href="#3-2-6-vector数据存取" class="headerlink" title="3.2.6 vector数据存取"></a>3.2.6 vector数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对vector中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>       //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v1.size(); i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; v1.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的第一个元素为： &quot;</span> &lt;&lt; v1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1的最后一个元素为： &quot;</span> &lt;&lt; v1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取vector容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-2-7-vector互换容器"><a href="#3-2-7-vector互换容器" class="headerlink" title="3.2.7 vector互换容器"></a>3.2.7 vector互换容器</h4><p><strong>功能描述：</strong></p><ul><li>实现两个容器内元素进行互换</li></ul><p><strong>函数原型：</strong></p><ul><li><code>swap(vec);</code>  // 将vec与本身的元素互换</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printVector</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10</span>; i &gt; <span class="number">0</span>; i--)</span><br><span class="line">&#123;</span><br><span class="line">v2.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printVector(v2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//互换容器</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;互换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">v1.swap(v2);</span><br><span class="line">printVector(v1);</span><br><span class="line">printVector(v2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">v.resize(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//收缩内存</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(v).swap(v); <span class="comment">//匿名对象</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的容量为：&quot;</span> &lt;&lt; v.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v的大小为：&quot;</span> &lt;&lt; v.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：swap可以使两个容器互换，可以达到实用的收缩内存效果</p><h4 id="3-2-8-vector预留空间"><a href="#3-2-8-vector预留空间" class="headerlink" title="3.2.8 vector预留空间"></a>3.2.8 vector预留空间</h4><p><strong>功能描述：</strong></p><ul><li>减少vector在动态扩展容量时的扩展次数</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reserve(int len);</code>//容器预留len个元素长度，预留位置不初始化，元素不可访问。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//预留空间</span></span><br><span class="line">v.reserve(<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span>* p = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line"><span class="keyword">if</span> (p != &amp;v[<span class="number">0</span>]) &#123;</span><br><span class="line">p = &amp;v[<span class="number">0</span>];</span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num:&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">    </span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：如果数据量较大，可以一开始利用reserve预留空间</p><h3 id="3-3-deque容器"><a href="#3-3-deque容器" class="headerlink" title="3.3 deque容器"></a>3.3 deque容器</h3><h4 id="3-3-1-deque容器基本概念"><a href="#3-3-1-deque容器基本概念" class="headerlink" title="3.3.1 deque容器基本概念"></a>3.3.1 deque容器基本概念</h4><p><strong>功能：</strong></p><ul><li>双端数组，可以对头端进行插入删除操作</li></ul><p><strong>deque与vector区别：</strong></p><ul><li>vector对于头部的插入删除效率低，数据量越大，效率越低</li><li>deque相对而言，对头部的插入删除速度回比vector快</li><li>vector访问元素时的速度会比deque快,这和两者内部实现有关</li></ul><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547547642923.jpg" class="" title="说明: 2015-11-19_204101"><p>deque内部工作原理:</p><p>deque内部有个<strong>中控器</strong>，维护每段缓冲区中的内容，缓冲区中存放真实数据</p><p>中控器维护的是每个缓冲区的地址，使得使用deque时像一片连续的内存空间</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547547896341.jpg" class="" title="clip_image002-1547547896341"><ul><li>deque容器的迭代器也是支持随机访问的</li></ul><h4 id="3-3-2-deque构造函数"><a href="#3-3-2-deque构造函数" class="headerlink" title="3.3.2 deque构造函数"></a>3.3.2 deque构造函数</h4><p><strong>功能描述：</strong></p><ul><li>deque容器构造</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&lt;T&gt;</code> deqT;                      //默认构造形式</li><li><code>deque(beg, end);</code>                  //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>deque(n, elem);</code>                    //构造函数将n个elem拷贝给本身。</li><li><code>deque(const deque &amp;deq);</code>   //拷贝构造函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//deque构造</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1; <span class="comment">//无参构造函数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"><span class="function"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; <span class="title">d2</span><span class="params">(d1.begin(),d1.end())</span></span>;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d3(<span class="number">10</span>,<span class="number">100</span>);</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d4 = d3;</span><br><span class="line">printDeque(d4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>deque容器和vector容器的构造方式几乎一致，灵活使用即可</p><h4 id="3-3-3-deque赋值操作"><a href="#3-3-3-deque赋值操作" class="headerlink" title="3.3.3 deque赋值操作"></a>3.3.3 deque赋值操作</h4><p><strong>功能描述：</strong></p><ul><li>给deque容器进行赋值</li></ul><p><strong>函数原型：</strong></p><ul><li><code>deque&amp; operator=(const deque &amp;deq); </code>         //重载等号操作符</li></ul><ul><li><code>assign(beg, end);</code>                                           //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>                                             //将n个elem拷贝赋值给本身。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//赋值操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2 = d1;</span><br><span class="line">printDeque(d2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d3;</span><br><span class="line">d3.assign(d1.begin(), d1.end());</span><br><span class="line">printDeque(d3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d4;</span><br><span class="line">d4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printDeque(d4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：deque赋值操作也与vector相同，需熟练掌握</p><h4 id="3-3-4-deque大小操作"><a href="#3-3-4-deque大小操作" class="headerlink" title="3.3.4 deque大小操作"></a>3.3.4 deque大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对deque容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>deque.empty();</code>                       //判断容器是否为空</p></li><li><p><code>deque.size();</code>                         //返回容器中元素的个数</p></li><li><p><code>deque.resize(num);</code>                //重新指定容器的长度为num,若容器变长，则以默认值填充新位置。</p><p>​                                         //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>deque.resize(num, elem);</code>     //重新指定容器的长度为num,若容器变长，则以elem值填充新位置。</p><p>​                                                     //如果容器变短，则末尾超出容器长度的元素被删除。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">d1.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断容器是否为空</span></span><br><span class="line"><span class="keyword">if</span> (d1.empty()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1不为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//统计大小</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;d1的大小为：&quot;</span> &lt;&lt; d1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">d1.resize(<span class="number">15</span>, <span class="number">1</span>);</span><br><span class="line">printDeque(d1);</span><br><span class="line"></span><br><span class="line">d1.resize(<span class="number">5</span>);</span><br><span class="line">printDeque(d1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>deque没有容量的概念</li><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-3-5-deque-插入和删除"><a href="#3-3-5-deque-插入和删除" class="headerlink" title="3.3.5 deque 插入和删除"></a>3.3.5 deque 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>向deque容器中插入和删除数据</li></ul><p><strong>函数原型：</strong></p><p>两端插入操作：</p><ul><li><code>push_back(elem);</code>          //在容器尾部添加一个数据</li><li><code>push_front(elem);</code>        //在容器头部插入一个数据</li><li><code>pop_back();</code>                   //删除容器最后一个数据</li><li><code>pop_front();</code>                 //删除容器第一个数据</li></ul><p>指定位置操作：</p><ul><li><p><code>insert(pos,elem);</code>         //在pos位置插入一个elem元素的拷贝，返回新数据的位置。</p></li><li><p><code>insert(pos,n,elem);</code>     //在pos位置插入n个elem数据，无返回值。</p></li><li><p><code>insert(pos,beg,end);</code>    //在pos位置插入[beg,end)区间的数据，无返回值。</p></li><li><p><code>clear();</code>                           //清空容器的所有数据</p></li><li><p><code>erase(beg,end);</code>             //删除[beg,end)区间的数据，返回下一个数据的位置。</p></li><li><p><code>erase(pos);</code>                    //删除pos位置的数据，返回下一个数据的位置。</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两端操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">d.pop_back();</span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">d.pop_front();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), <span class="number">1000</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), <span class="number">2</span>,<span class="number">10000</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d2;</span><br><span class="line">d2.push_back(<span class="number">1</span>);</span><br><span class="line">d2.push_back(<span class="number">2</span>);</span><br><span class="line">d2.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">d.insert(d.begin(), d2.begin(), d2.end());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">d.erase(d.begin(), d.end());</span><br><span class="line">d.clear();</span><br><span class="line">printDeque(d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line"></span><br><span class="line">    test03();</span><br><span class="line">    </span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入和删除提供的位置是迭代器！</li><li>尾插   —  push_back</li><li>尾删   —  pop_back</li><li>头插   —  push_front</li><li>头删   —  pop_front</li></ul><h4 id="3-3-6-deque-数据存取"><a href="#3-3-6-deque-数据存取" class="headerlink" title="3.3.6 deque 数据存取"></a>3.3.6 deque 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对deque 中的数据的存取操作</li></ul><p><strong>函数原型：</strong></p><ul><li><code>at(int idx); </code>     //返回索引idx所指的数据</li><li><code>operator[]; </code>      //返回索引idx所指的数据</li><li><code>front(); </code>            //返回容器中第一个数据元素</li><li><code>back();</code>              //返回容器中最后一个数据元素</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; d.size(); i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; d.at(i) &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;front:&quot;</span> &lt;&lt; d.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;back:&quot;</span> &lt;&lt; d.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>除了用迭代器获取deque容器中元素，[ ]和at也可以</li><li>front返回容器第一个元素</li><li>back返回容器最后一个元素</li></ul><h4 id="3-3-7-deque-排序"><a href="#3-3-7-deque-排序" class="headerlink" title="3.3.7  deque 排序"></a>3.3.7  deque 排序</h4><p><strong>功能描述：</strong></p><ul><li>利用算法实现对deque容器进行排序</li></ul><p><strong>算法：</strong></p><ul><li><code>sort(iterator beg, iterator end)</code>  //对beg和end区间内元素进行排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printDeque</span><span class="params">(<span class="keyword">const</span> <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;&amp; d)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = d.begin(); it != d.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; d;</span><br><span class="line">d.push_back(<span class="number">10</span>);</span><br><span class="line">d.push_back(<span class="number">20</span>);</span><br><span class="line">d.push_front(<span class="number">100</span>);</span><br><span class="line">d.push_front(<span class="number">200</span>);</span><br><span class="line"></span><br><span class="line">printDeque(d);</span><br><span class="line">sort(d.begin(), d.end());</span><br><span class="line">printDeque(d);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：sort算法非常实用，使用时包含头文件 algorithm即可</p><h3 id="3-4-案例-评委打分"><a href="#3-4-案例-评委打分" class="headerlink" title="3.4 案例-评委打分"></a>3.4 案例-评委打分</h3><h4 id="3-4-1-案例描述"><a href="#3-4-1-案例描述" class="headerlink" title="3.4.1 案例描述"></a>3.4.1 案例描述</h4><p>有5名选手：选手ABCDE，10个评委分别对每一名选手打分，去除最高分，去除评委中最低分，取平均分。</p><h4 id="3-4-2-实现步骤"><a href="#3-4-2-实现步骤" class="headerlink" title="3.4.2 实现步骤"></a>3.4.2 实现步骤</h4><ol><li>创建五名选手，放到vector中</li><li>遍历vector容器，取出来每一个选手，执行for循环，可以把10个评分打分存到deque容器中</li><li>sort算法对deque容器中分数排序，去除最高和最低分</li><li>deque容器遍历一遍，累加总分</li><li>获取平均分</li></ol><p><strong>示例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//选手类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> score)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Score = score;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name; <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> m_Score;  <span class="comment">//平均分</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createPerson</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDE&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name = <span class="string">&quot;选手&quot;</span>;</span><br><span class="line">name += nameSeed[i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> score = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p</span><span class="params">(name, score)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将创建的person对象 放入到容器中</span></span><br><span class="line">v.push_back(p);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打分</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//将评委的分数 放入到deque容器中</span></span><br><span class="line"><span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;d;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> score = rand() % <span class="number">41</span> + <span class="number">60</span>;  <span class="comment">// 60 ~ 100</span></span><br><span class="line">d.push_back(score);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;选手： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 打分： &quot; &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//for (deque&lt;int&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; *dit &lt;&lt; &quot; &quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">sort(d.begin(), d.end());</span><br><span class="line"></span><br><span class="line"><span class="comment">//去除最高和最低分</span></span><br><span class="line">d.pop_back();</span><br><span class="line">d.pop_front();</span><br><span class="line"></span><br><span class="line"><span class="comment">//取平均分</span></span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt;::iterator dit = d.begin(); dit != d.end(); dit++)</span><br><span class="line">&#123;</span><br><span class="line">sum += *dit; <span class="comment">//累加每个评委的分数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> avg = sum / d.size();</span><br><span class="line"></span><br><span class="line"><span class="comment">//将平均分 赋值给选手身上</span></span><br><span class="line">it-&gt;m_Score = avg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showScore</span><span class="params">(<span class="built_in">vector</span>&lt;Person&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 平均分： &quot;</span> &lt;&lt; it-&gt;m_Score &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//随机数种子</span></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建5名选手</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;v;  <span class="comment">//存放选手容器</span></span><br><span class="line">createPerson(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Person&gt;::iterator it = v.begin(); it != v.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; (*it).m_Name &lt;&lt; &quot; 分数： &quot; &lt;&lt; (*it).m_Score &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2、给5名选手打分</span></span><br><span class="line">setScore(v);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、显示最后得分</span></span><br><span class="line">showScore(v);</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 选取不同的容器操作数据，可以提升代码的效率</p><h3 id="3-5-stack容器"><a href="#3-5-stack容器" class="headerlink" title="3.5 stack容器"></a>3.5 stack容器</h3><h4 id="3-5-1-stack-基本概念"><a href="#3-5-1-stack-基本概念" class="headerlink" title="3.5.1 stack 基本概念"></a>3.5.1 stack 基本概念</h4><p><strong>概念：</strong>stack是一种<strong>先进后出</strong>(First In Last Out,FILO)的数据结构，它只有一个出口</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547604555425.jpg" class="" title="说明: 2015-11-15_195707"><p>栈中只有顶端的元素才可以被外界使用，因此栈不允许有遍历行为</p><p>栈中进入数据称为  — <strong>入栈</strong>  <code>push</code></p><p>栈中弹出数据称为  — <strong>出栈</strong>  <code>pop</code></p><p>生活中的栈：</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002.png" class="" title="img"><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547605111510.jpg" class="" title="img"><h4 id="3-5-2-stack-常用接口"><a href="#3-5-2-stack-常用接口" class="headerlink" title="3.5.2 stack 常用接口"></a>3.5.2 stack 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>stack&lt;T&gt; stk;</code>                                 //stack采用模板类实现， stack对象的默认构造形式</li><li><code>stack(const stack &amp;stk);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>stack&amp; operator=(const stack &amp;stk);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>      //向栈顶添加元素</li><li><code>pop();</code>                //从栈顶移除第一个元素</li><li><code>top(); </code>                //返回栈顶元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//栈容器常用接口</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//创建栈容器 栈容器必须符合先进后出</span></span><br><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向栈中添加元素，叫做 压栈 入栈</span></span><br><span class="line">s.push(<span class="number">10</span>);</span><br><span class="line">s.push(<span class="number">20</span>);</span><br><span class="line">s.push(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (!s.empty()) &#123;</span><br><span class="line"><span class="comment">//输出栈顶元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈顶元素为： &quot;</span> &lt;&lt; s.top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//弹出栈顶元素</span></span><br><span class="line">s.pop();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;栈的大小为：&quot;</span> &lt;&lt; s.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入栈   — push</li><li>出栈   — pop</li><li>返回栈顶   — top</li><li>判断栈是否为空   — empty</li><li>返回栈大小   — size</li></ul><h3 id="3-6-queue-容器"><a href="#3-6-queue-容器" class="headerlink" title="3.6 queue 容器"></a>3.6 queue 容器</h3><h4 id="3-6-1-queue-基本概念"><a href="#3-6-1-queue-基本概念" class="headerlink" title="3.6.1 queue 基本概念"></a>3.6.1 queue 基本概念</h4><p><strong>概念：</strong>Queue是一种<strong>先进先出</strong>(First In First Out,FIFO)的数据结构，它有两个出口</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547606475892.jpg" class="" title="说明: 2015-11-15_214429"><p>队列容器允许从一端新增元素，从另一端移除元素</p><p>队列中只有队头和队尾才可以被外界使用，因此队列不允许有遍历行为</p><p>队列中进数据称为 — <strong>入队</strong>    <code>push</code></p><p>队列中出数据称为 — <strong>出队</strong>    <code>pop</code></p><p>生活中的队列：</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/1547606785041.png" class="" width="1547606785041"><h4 id="3-6-2-queue-常用接口"><a href="#3-6-2-queue-常用接口" class="headerlink" title="3.6.2 queue 常用接口"></a>3.6.2 queue 常用接口</h4><p>功能描述：栈容器常用的对外接口</p><p>构造函数：</p><ul><li><code>queue&lt;T&gt; que;</code>                                 //queue采用模板类实现，queue对象的默认构造形式</li><li><code>queue(const queue &amp;que);</code>            //拷贝构造函数</li></ul><p>赋值操作：</p><ul><li><code>queue&amp; operator=(const queue &amp;que);</code>           //重载等号操作符</li></ul><p>数据存取：</p><ul><li><code>push(elem);</code>                             //往队尾添加元素</li><li><code>pop();</code>                                      //从队头移除第一个元素</li><li><code>back();</code>                                    //返回最后一个元素</li><li><code>front(); </code>                                  //返回第一个元素</li></ul><p>大小操作：</p><ul><li><code>empty();</code>            //判断堆栈是否为空</li><li><code>size(); </code>              //返回栈的大小</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建队列</span></span><br><span class="line"><span class="built_in">queue</span>&lt;Person&gt; q;</span><br><span class="line"></span><br><span class="line"><span class="comment">//准备数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;唐僧&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;孙悟空&quot;</span>, <span class="number">1000</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;猪八戒&quot;</span>, <span class="number">900</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;沙僧&quot;</span>, <span class="number">800</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//向队列中添加元素  入队操作</span></span><br><span class="line">q.push(p1);</span><br><span class="line">q.push(p2);</span><br><span class="line">q.push(p3);</span><br><span class="line">q.push(p4);</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列不提供迭代器，更不支持随机访问</span></span><br><span class="line"><span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line"><span class="comment">//输出队头元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队头元素-- 姓名： &quot;</span> &lt;&lt; q.front().m_Name </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span>&lt;&lt; q.front().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队尾元素-- 姓名： &quot;</span> &lt;&lt; q.back().m_Name  </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; q.back().m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="comment">//弹出队头元素</span></span><br><span class="line">q.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;队列大小为：&quot;</span> &lt;&lt; q.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>入队   — push</li><li>出队   — pop</li><li>返回队头元素   — front</li><li>返回队尾元素   — back</li><li>判断队是否为空   — empty</li><li>返回队列大小   — size</li></ul><h3 id="3-7-list容器"><a href="#3-7-list容器" class="headerlink" title="3.7 list容器"></a>3.7 list容器</h3><h4 id="3-7-1-list基本概念"><a href="#3-7-1-list基本概念" class="headerlink" title="3.7.1 list基本概念"></a>3.7.1 list基本概念</h4><p><strong>功能：</strong>将数据进行链式存储</p><p><strong>链表</strong>（list）是一种物理存储单元上非连续的存储结构，数据元素的逻辑顺序是通过链表中的指针链接实现的</p><p>链表的组成：链表由一系列<strong>结点</strong>组成</p><p>结点的组成：一个是存储数据元素的<strong>数据域</strong>，另一个是存储下一个结点地址的<strong>指针域</strong></p><p>STL中的链表是一个双向循环链表</p><img src="/2022/01/24/C++%E6%8F%90%E9%AB%98%E7%BC%96%E7%A8%8B/clip_image002-1547608564071.jpg" class="" title="说明: 2015-11-15_225145"><p>由于链表的存储方式并不是连续的内存空间，因此链表list中的迭代器只支持前移和后移，属于<strong>双向迭代器</strong></p><p>list的优点：</p><ul><li>采用动态存储分配，不会造成内存浪费和溢出</li><li>链表执行插入和删除操作十分方便，修改指针即可，不需要移动大量元素</li></ul><p>list的缺点：</p><ul><li>链表灵活，但是空间(指针域) 和 时间（遍历）额外耗费较大</li></ul><p>List有一个重要的性质，插入操作和删除操作都不会造成原有list迭代器的失效，这在vector是不成立的。</p><p>总结：STL中<strong>List和vector是两个最常被使用的容器</strong>，各有优缺点</p><h4 id="3-7-2-list构造函数"><a href="#3-7-2-list构造函数" class="headerlink" title="3.7.2  list构造函数"></a>3.7.2  list构造函数</h4><p><strong>功能描述：</strong></p><ul><li>创建list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>list&lt;T&gt; lst;</code>                               //list采用采用模板类实现,对象的默认构造形式：</li><li><code>list(beg,end);</code>                           //构造函数将[beg, end)区间中的元素拷贝给本身。</li><li><code>list(n,elem);</code>                             //构造函数将n个elem拷贝给本身。</li><li><code>list(const list &amp;lst);</code>            //拷贝构造函数。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2(L1.begin(),L1.end());</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3(L2);</span><br><span class="line">printList(L3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L4(<span class="number">10</span>, <span class="number">1000</span>);</span><br><span class="line">printList(L4);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list构造方式同其他几个STL常用容器，熟练掌握即可</p><h4 id="3-7-3-list-赋值和交换"><a href="#3-7-3-list-赋值和交换" class="headerlink" title="3.7.3 list 赋值和交换"></a>3.7.3 list 赋值和交换</h4><p><strong>功能描述：</strong></p><ul><li>给list容器进行赋值，以及交换list容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>assign(beg, end);</code>            //将[beg, end)区间中的数据拷贝赋值给本身。</li><li><code>assign(n, elem);</code>              //将n个elem拷贝赋值给本身。</li><li><code>list&amp; operator=(const list &amp;lst);</code>         //重载等号操作符</li><li><code>swap(lst);</code>                         //将lst与本身的元素互换。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值和交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2 = L1;</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L3;</span><br><span class="line">L3.assign(L2.begin(), L2.end());</span><br><span class="line">printList(L3);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L4;</span><br><span class="line">L4.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line">printList(L4);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L2;</span><br><span class="line">L2.assign(<span class="number">10</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">L1.swap(L2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printList(L1);</span><br><span class="line">printList(L2);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：list赋值和交换操作能够灵活运用即可</p><h4 id="3-7-4-list-大小操作"><a href="#3-7-4-list-大小操作" class="headerlink" title="3.7.4 list 大小操作"></a>3.7.4 list 大小操作</h4><p><strong>功能描述：</strong></p><ul><li>对list容器的大小进行操作</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>size(); </code>                             //返回容器中元素的个数</p></li><li><p><code>empty(); </code>                           //判断容器是否为空</p></li><li><p><code>resize(num);</code>                   //重新指定容器的长度为num，若容器变长，则以默认值填充新位置。</p><p>​                        //如果容器变短，则末尾超出容器长度的元素被删除。</p></li><li><p><code>resize(num, elem); </code>       //重新指定容器的长度为num，若容器变长，则以elem值填充新位置。</p><pre><code>                                           //如果容器变短，则末尾超出容器长度的元素被删除。</code></pre></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小操作</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (L1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;L1的大小为： &quot;</span> &lt;&lt; L1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//重新指定大小</span></span><br><span class="line">L1.resize(<span class="number">10</span>);</span><br><span class="line">printList(L1);</span><br><span class="line"></span><br><span class="line">L1.resize(<span class="number">2</span>);</span><br><span class="line">printList(L1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>判断是否为空   — empty</li><li>返回元素个数   — size</li><li>重新指定个数   — resize</li></ul><h4 id="3-7-5-list-插入和删除"><a href="#3-7-5-list-插入和删除" class="headerlink" title="3.7.5 list 插入和删除"></a>3.7.5 list 插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>对list容器进行数据的插入和删除</li></ul><p><strong>函数原型：</strong></p><ul><li>push_back(elem);//在容器尾部加入一个元素</li><li>pop_back();//删除容器中最后一个元素</li><li>push_front(elem);//在容器开头插入一个元素</li><li>pop_front();//从容器开头移除第一个元素</li><li>insert(pos,elem);//在pos位置插elem元素的拷贝，返回新数据的位置。</li><li>insert(pos,n,elem);//在pos位置插入n个elem数据，无返回值。</li><li>insert(pos,beg,end);//在pos位置插入[beg,end)区间的数据，无返回值。</li><li>clear();//移除容器的所有数据</li><li>erase(beg,end);//删除[beg,end)区间的数据，返回下一个数据的位置。</li><li>erase(pos);//删除pos位置的数据，返回下一个数据的位置。</li><li>remove(elem);//删除容器中所有与elem值匹配的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line"><span class="comment">//尾插</span></span><br><span class="line">L.push_back(<span class="number">10</span>);</span><br><span class="line">L.push_back(<span class="number">20</span>);</span><br><span class="line">L.push_back(<span class="number">30</span>);</span><br><span class="line"><span class="comment">//头插</span></span><br><span class="line">L.push_front(<span class="number">100</span>);</span><br><span class="line">L.push_front(<span class="number">200</span>);</span><br><span class="line">L.push_front(<span class="number">300</span>);</span><br><span class="line"></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//尾删</span></span><br><span class="line">L.pop_back();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//头删</span></span><br><span class="line">L.pop_front();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L.begin();</span><br><span class="line">L.insert(++it, <span class="number">1000</span>);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">it = L.begin();</span><br><span class="line">L.erase(++it);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//移除</span></span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">L.push_back(<span class="number">10000</span>);</span><br><span class="line">printList(L);</span><br><span class="line">L.remove(<span class="number">10000</span>);</span><br><span class="line">printList(L);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清空</span></span><br><span class="line">L.clear();</span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>尾插   — push_back</li><li>尾删   — pop_back</li><li>头插   — push_front</li><li>头删   — pop_front</li><li>插入   — insert</li><li>删除   — erase</li><li>移除   — remove</li><li>清空   — clear</li></ul><h4 id="3-7-6-list-数据存取"><a href="#3-7-6-list-数据存取" class="headerlink" title="3.7.6 list 数据存取"></a>3.7.6 list 数据存取</h4><p><strong>功能描述：</strong></p><ul><li>对list容器中数据进行存取</li></ul><p><strong>函数原型：</strong></p><ul><li><code>front();</code>        //返回第一个元素。</li><li><code>back();</code>         //返回最后一个元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//数据存取</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;L1;</span><br><span class="line">L1.push_back(<span class="number">10</span>);</span><br><span class="line">L1.push_back(<span class="number">20</span>);</span><br><span class="line">L1.push_back(<span class="number">30</span>);</span><br><span class="line">L1.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1.at(0) &lt;&lt; endl;//错误 不支持at访问数据</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; L1[0] &lt;&lt; endl; //错误  不支持[]方式访问数据</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一个元素为： &quot;</span> &lt;&lt; L1.front() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;最后一个元素为： &quot;</span> &lt;&lt; L1.back() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//list容器的迭代器是双向迭代器，不支持随机访问</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator it = L1.begin();</span><br><span class="line"><span class="comment">//it = it + 1;//错误，不可以跳跃访问，即使是+1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>list容器中不可以通过[]或者at方式访问数据</li><li>返回第一个元素   — front</li><li>返回最后一个元素   — back</li></ul><h4 id="3-7-7-list-反转和排序"><a href="#3-7-7-list-反转和排序" class="headerlink" title="3.7.7 list 反转和排序"></a>3.7.7 list 反转和排序</h4><p><strong>功能描述：</strong></p><ul><li>将容器中的元素反转，以及将容器中的数据进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><code>reverse();</code>   //反转链表</li><li><code>sort();</code>        //链表排序</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(<span class="keyword">const</span> <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;&amp; L)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::const_iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">myCompare</span><span class="params">(<span class="keyword">int</span> val1 , <span class="keyword">int</span> val2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val1 &gt; val2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转和排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; L;</span><br><span class="line">L.push_back(<span class="number">90</span>);</span><br><span class="line">L.push_back(<span class="number">30</span>);</span><br><span class="line">L.push_back(<span class="number">20</span>);</span><br><span class="line">L.push_back(<span class="number">70</span>);</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转容器的元素</span></span><br><span class="line">L.reverse();</span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line">L.sort(); <span class="comment">//默认的排序规则 从小到大</span></span><br><span class="line">printList(L);</span><br><span class="line"></span><br><span class="line">L.sort(myCompare); <span class="comment">//指定规则，从大到小</span></span><br><span class="line">printList(L);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>反转   — reverse</li><li>排序   — sort （成员函数）</li></ul><h4 id="3-7-8-排序案例"><a href="#3-7-8-排序案例" class="headerlink" title="3.7.8 排序案例"></a>3.7.8 排序案例</h4><p>案例描述：将Person自定义数据类型进行排序，Person中属性有姓名、年龄、身高</p><p>排序规则：按照年龄进行升序，如果年龄相同按照身高进行降序</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age , <span class="keyword">int</span> height) &#123;</span><br><span class="line">m_Name = name;</span><br><span class="line">m_Age = age;</span><br><span class="line">m_Height = height;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;  <span class="comment">//姓名</span></span><br><span class="line"><span class="keyword">int</span> m_Age;      <span class="comment">//年龄</span></span><br><span class="line"><span class="keyword">int</span> m_Height;   <span class="comment">//身高</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ComparePerson</span><span class="params">(Person&amp; p1, Person&amp; p2)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (p1.m_Age == p2.m_Age) &#123;</span><br><span class="line"><span class="keyword">return</span> p1.m_Height  &gt; p2.m_Height;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span>  p1.m_Age &lt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">list</span>&lt;Person&gt; L;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span> , <span class="number">175</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">45</span> , <span class="number">180</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;孙权&quot;</span>, <span class="number">40</span> , <span class="number">170</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">25</span> , <span class="number">190</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span> , <span class="number">160</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p6</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span> , <span class="number">200</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">L.push_back(p1);</span><br><span class="line">L.push_back(p2);</span><br><span class="line">L.push_back(p3);</span><br><span class="line">L.push_back(p4);</span><br><span class="line">L.push_back(p5);</span><br><span class="line">L.push_back(p6);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;---------------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">L.sort(ComparePerson); <span class="comment">//排序</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">list</span>&lt;Person&gt;::iterator it = L.begin(); it != L.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age </span><br><span class="line">              &lt;&lt; <span class="string">&quot; 身高： &quot;</span> &lt;&lt; it-&gt;m_Height &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>对于自定义数据类型，必须要指定排序规则，否则编译器不知道如何进行排序</li></ul><ul><li>高级排序只是在排序规则上再进行一次逻辑规则制定，并不复杂</li></ul><h3 id="3-8-set-multiset-容器"><a href="#3-8-set-multiset-容器" class="headerlink" title="3.8 set/ multiset 容器"></a>3.8 set/ multiset 容器</h3><h4 id="3-8-1-set基本概念"><a href="#3-8-1-set基本概念" class="headerlink" title="3.8.1 set基本概念"></a>3.8.1 set基本概念</h4><p><strong>简介：</strong></p><ul><li>所有元素都会在插入时自动被排序</li></ul><p><strong>本质：</strong></p><ul><li>set/multiset属于<strong>关联式容器</strong>，底层结构是用<strong>二叉树</strong>实现。</li></ul><p><strong>set和multiset区别</strong>：</p><ul><li>set不允许容器中有重复的元素</li><li>multiset允许容器中有重复的元素</li></ul><h4 id="3-8-2-set构造和赋值"><a href="#3-8-2-set构造和赋值" class="headerlink" title="3.8.2 set构造和赋值"></a>3.8.2 set构造和赋值</h4><p>功能描述：创建set容器以及赋值</p><p>构造：</p><ul><li><code>set&lt;T&gt; st;</code>                        //默认构造函数：</li><li><code>set(const set &amp;st);</code>       //拷贝构造函数</li></ul><p>赋值：</p><ul><li><code>set&amp; operator=(const set &amp;st);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造和赋值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//拷贝构造</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s2(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;s3;</span><br><span class="line">s3 = s2;</span><br><span class="line">printSet(s3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>set容器插入数据时用insert</li><li>set容器插入数据的数据会自动排序</li></ul><h4 id="3-8-3-set大小和交换"><a href="#3-8-3-set大小和交换" class="headerlink" title="3.8.3 set大小和交换"></a>3.8.3 set大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计set容器大小以及交换set容器</li></ul><p><strong>函数原型：</strong></p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//大小</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (s1.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;s1的大小为： &quot;</span> &lt;&lt; s1.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"></span><br><span class="line">s2.insert(<span class="number">100</span>);</span><br><span class="line">s2.insert(<span class="number">300</span>);</span><br><span class="line">s2.insert(<span class="number">200</span>);</span><br><span class="line">s2.insert(<span class="number">400</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s1.swap(s2);</span><br><span class="line">printSet(s1);</span><br><span class="line">printSet(s2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-8-4-set插入和删除"><a href="#3-8-4-set插入和删除" class="headerlink" title="3.8.4 set插入和删除"></a>3.8.4 set插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>set容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(elem);</code>            //删除容器中值为elem的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSet</span><span class="params">(<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; &amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入和删除</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">s1.erase(s1.begin());</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line">s1.erase(<span class="number">30</span>);</span><br><span class="line">printSet(s1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line"><span class="comment">//s1.erase(s1.begin(), s1.end());</span></span><br><span class="line">s1.clear();</span><br><span class="line">printSet(s1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>插入   — insert</li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-8-5-set查找和统计"><a href="#3-8-5-set查找和统计" class="headerlink" title="3.8.5 set查找和统计"></a>3.8.5 set查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对set容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator pos = s1.find(<span class="number">30</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != s1.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 ： &quot;</span> &lt;&lt; *pos &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="keyword">int</span> num = s1.count(<span class="number">30</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于set，结果为0或者1）</li></ul><h4 id="3-8-6-set和multiset区别"><a href="#3-8-6-set和multiset区别" class="headerlink" title="3.8.6 set和multiset区别"></a>3.8.6 set和multiset区别</h4><p><strong>学习目标：</strong></p><ul><li>掌握set和multiset的区别</li></ul><p><strong>区别：</strong></p><ul><li>set不可以插入重复数据，而multiset可以</li><li>set插入数据的同时会返回插入结果，表示插入是否成功</li><li>multiset不会检测数据，因此可以插入重复数据</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//set和multiset区别</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator, <span class="keyword">bool</span>&gt;  ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第一次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ret = s.insert(<span class="number">10</span>);</span><br><span class="line"><span class="keyword">if</span> (ret.second) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入成功!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;第二次插入失败!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//multiset</span></span><br><span class="line"><span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt; ms;</span><br><span class="line">ms.insert(<span class="number">10</span>);</span><br><span class="line">ms.insert(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">multiset</span>&lt;<span class="keyword">int</span>&gt;::iterator it = ms.begin(); it != ms.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>如果不允许插入重复数据可以利用set</li><li>如果需要插入重复数据利用multiset</li></ul><h4 id="3-8-7-pair对组创建"><a href="#3-8-7-pair对组创建" class="headerlink" title="3.8.7 pair对组创建"></a>3.8.7 pair对组创建</h4><p><strong>功能描述：</strong></p><ul><li>成对出现的数据，利用对组可以返回两个数据</li></ul><p><strong>两种创建方式：</strong></p><ul><li><code>pair&lt;type, type&gt; p ( value1, value2 );</code></li><li><code>pair&lt;type, type&gt; p = make_pair( value1, value2 );</code></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//对组创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">pair&lt;string, int&gt; p(string(&quot;Tom&quot;), 20);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt;  p.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pair</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>&gt; p2 = <span class="built_in">make_pair</span>(<span class="string">&quot;Jerry&quot;</span>, <span class="number">10</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; p2.first &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; p2.second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>两种方式都可以创建对组，记住一种即可</p><h4 id="3-8-8-set容器排序"><a href="#3-8-8-set容器排序" class="headerlink" title="3.8.8 set容器排序"></a>3.8.8 set容器排序</h4><p>学习目标：</p><ul><li>set容器默认排序规则为从小到大，掌握如何改变排序规则</li></ul><p>主要技术点：</p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例一</strong>   set存放内置数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;    </span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">s1.insert(<span class="number">10</span>);</span><br><span class="line">s1.insert(<span class="number">40</span>);</span><br><span class="line">s1.insert(<span class="number">20</span>);</span><br><span class="line">s1.insert(<span class="number">30</span>);</span><br><span class="line">s1.insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = s1.begin(); it != s1.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//指定排序规则</span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="keyword">int</span>,MyCompare&gt; s2;</span><br><span class="line">s2.insert(<span class="number">10</span>);</span><br><span class="line">s2.insert(<span class="number">40</span>);</span><br><span class="line">s2.insert(<span class="number">20</span>);</span><br><span class="line">s2.insert(<span class="number">30</span>);</span><br><span class="line">s2.insert(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;<span class="keyword">int</span>, MyCompare&gt;::iterator it = s2.begin(); it != s2.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：利用仿函数可以指定set容器的排序规则</p><p><strong>示例二</strong> set存放自定义数据类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comparePerson</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person&amp; p1, <span class="keyword">const</span> Person &amp;p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//按照年龄进行排序  降序</span></span><br><span class="line"><span class="keyword">return</span> p1.m_Age &gt; p2.m_Age;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">set</span>&lt;Person, comparePerson&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">23</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">27</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">21</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">s.insert(p1);</span><br><span class="line">s.insert(p2);</span><br><span class="line">s.insert(p3);</span><br><span class="line">s.insert(p4);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">set</span>&lt;Person, comparePerson&gt;::iterator it = s.begin(); it != s.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄： &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><p>对于自定义数据类型，set必须指定排序规则才可以插入数据</p><h3 id="3-9-map-multimap容器"><a href="#3-9-map-multimap容器" class="headerlink" title="3.9 map/ multimap容器"></a>3.9 map/ multimap容器</h3><h4 id="3-9-1-map基本概念"><a href="#3-9-1-map基本概念" class="headerlink" title="3.9.1 map基本概念"></a>3.9.1 map基本概念</h4><p><strong>简介：</strong></p><ul><li>map中所有元素都是pair</li><li>pair中第一个元素为key（键值），起到索引作用，第二个元素为value（实值）</li><li>所有元素都会根据元素的键值自动排序</li></ul><p><strong>本质：</strong></p><ul><li>map/multimap属于<strong>关联式容器</strong>，底层结构是用二叉树实现。</li></ul><p><strong>优点：</strong></p><ul><li>可以根据key值快速找到value值</li></ul><p>map和multimap<strong>区别</strong>：</p><ul><li>map不允许容器中有重复key值元素</li><li>multimap允许容器中有重复key值元素</li></ul><h4 id="3-9-2-map构造和赋值"><a href="#3-9-2-map构造和赋值" class="headerlink" title="3.9.2  map构造和赋值"></a>3.9.2  map构造和赋值</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行构造和赋值操作</li></ul><p><strong>函数原型：</strong></p><p><strong>构造：</strong></p><ul><li><code>map&lt;T1, T2&gt; mp;</code>                     //map默认构造函数: </li><li><code>map(const map &amp;mp);</code>             //拷贝构造函数</li></ul><p><strong>赋值：</strong></p><ul><li><code>map&amp; operator=(const map &amp;mp);</code>    //重载等号操作符</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;m; <span class="comment">//默认构造</span></span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2(m); <span class="comment">//拷贝构造</span></span><br><span class="line">printMap(m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m3;</span><br><span class="line">m3 = m2; <span class="comment">//赋值</span></span><br><span class="line">printMap(m3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：map中所有元素都是成对出现，插入数据时候要使用对组</p><h4 id="3-9-3-map大小和交换"><a href="#3-9-3-map大小和交换" class="headerlink" title="3.9.3 map大小和交换"></a>3.9.3 map大小和交换</h4><p><strong>功能描述：</strong></p><ul><li>统计map容器大小以及交换map容器</li></ul><p>函数原型：</p><ul><li><code>size();</code>          //返回容器中元素的数目</li><li><code>empty();</code>        //判断容器是否为空</li><li><code>swap(st);</code>      //交换两个集合容器</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (m.empty())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m不为空&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;m的大小为： &quot;</span> &lt;&lt; m.size() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//交换</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m;</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m2;</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">4</span>, <span class="number">100</span>));</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">5</span>, <span class="number">200</span>));</span><br><span class="line">m2.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">6</span>, <span class="number">300</span>));</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">printMap(m);</span><br><span class="line">printMap(m2);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">m.swap(m2);</span><br><span class="line">printMap(m);</span><br><span class="line">printMap(m2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>统计大小   — size</li><li>判断是否为空   — empty</li><li>交换容器   — swap</li></ul><h4 id="3-9-4-map插入和删除"><a href="#3-9-4-map插入和删除" class="headerlink" title="3.9.4 map插入和删除"></a>3.9.4 map插入和删除</h4><p><strong>功能描述：</strong></p><ul><li>map容器进行插入数据和删除数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>insert(elem);</code>           //在容器中插入元素。</li><li><code>clear();</code>                    //清除所有元素</li><li><code>erase(pos);</code>              //删除pos迭代器所指的元素，返回下一个元素的迭代器。</li><li><code>erase(beg, end);</code>    //删除区间[beg,end)的所有元素 ，返回下一个元素的迭代器。</li><li><code>erase(key);</code>            //删除容器中值为key的元素。</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printMap</span><span class="params">(<span class="built_in">map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator it = m.begin(); it != m.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key = &quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line"><span class="comment">//第一种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line"><span class="comment">//第二种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line"><span class="comment">//第三种插入方式</span></span><br><span class="line">m.insert(<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::value_type(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"><span class="comment">//第四种插入方式</span></span><br><span class="line">m[<span class="number">4</span>] = <span class="number">40</span>; </span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除</span></span><br><span class="line">m.erase(m.begin());</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line">m.erase(<span class="number">3</span>);</span><br><span class="line">printMap(m);</span><br><span class="line"></span><br><span class="line"><span class="comment">//清空</span></span><br><span class="line">m.erase(m.begin(),m.end());</span><br><span class="line">m.clear();</span><br><span class="line">printMap(m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>map插入方式很多，记住其一即可</li></ul><ul><li>插入   — insert </li><li>删除   — erase</li><li>清空   — clear</li></ul><h4 id="3-9-5-map查找和统计"><a href="#3-9-5-map查找和统计" class="headerlink" title="3.9.5 map查找和统计"></a>3.9.5 map查找和统计</h4><p><strong>功能描述：</strong></p><ul><li>对map容器进行查找数据以及统计数据</li></ul><p><strong>函数原型：</strong></p><ul><li><code>find(key);</code>                  //查找key是否存在,若存在，返回该键的元素的迭代器；若不存在，返回set.end();</li><li><code>count(key);</code>                //统计key的元素个数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查找和统计</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;m; </span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">pair</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::iterator pos = m.find(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pos != m.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了元素 key = &quot;</span> &lt;&lt; (*pos).first &lt;&lt; <span class="string">&quot; value = &quot;</span> &lt;&lt; (*pos).second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到元素&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//统计</span></span><br><span class="line"><span class="keyword">int</span> num = m.count(<span class="number">3</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>查找   —  find    （返回的是迭代器）</li><li>统计   —  count  （对于map，结果为0或者1）</li></ul><h4 id="3-9-6-map容器排序"><a href="#3-9-6-map容器排序" class="headerlink" title="3.9.6 map容器排序"></a>3.9.6 map容器排序</h4><p><strong>学习目标：</strong></p><ul><li>map容器默认排序规则为 按照key值进行 从小到大排序，掌握如何改变排序规则</li></ul><p><strong>主要技术点:</strong></p><ul><li>利用仿函数，可以改变排序规则</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span> v2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">//默认从小到大排序</span></span><br><span class="line"><span class="comment">//利用仿函数实现从大到小排序</span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt; m;</span><br><span class="line"></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">1</span>, <span class="number">10</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">2</span>, <span class="number">20</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">3</span>, <span class="number">30</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">4</span>, <span class="number">40</span>));</span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(<span class="number">5</span>, <span class="number">50</span>));</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, MyCompare&gt;::iterator it = m.begin(); it != m.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;key:&quot;</span> &lt;&lt; it-&gt;first &lt;&lt; <span class="string">&quot; value:&quot;</span> &lt;&lt; it-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>利用仿函数可以指定map容器的排序规则</li><li>对于自定义数据类型，map必须要指定排序规则,同set容器</li></ul><h3 id="3-10-案例-员工分组"><a href="#3-10-案例-员工分组" class="headerlink" title="3.10 案例-员工分组"></a>3.10 案例-员工分组</h3><h4 id="3-10-1-案例描述"><a href="#3-10-1-案例描述" class="headerlink" title="3.10.1 案例描述"></a>3.10.1 案例描述</h4><ul><li>公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</li><li>员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</li><li>随机给10名员工分配部门和工资</li><li>通过multimap进行信息的插入  key(部门编号) value(员工)</li><li>分部门显示员工信息</li></ul><h4 id="3-10-2-实现步骤"><a href="#3-10-2-实现步骤" class="headerlink" title="3.10.2 实现步骤"></a>3.10.2 实现步骤</h4><ol><li>创建10名员工，放到vector中</li><li>遍历vector容器，取出每个员工，进行随机分组</li><li>分组后，将员工部门编号作为key，具体员工作为value，放入到multimap容器中</li><li>分部门显示员工信息</li></ol><p><strong>案例代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">- 公司今天招聘了10个员工（ABCDEFGHIJ），10名员工进入公司之后，需要指派员工在那个部门工作</span></span><br><span class="line"><span class="comment">- 员工信息有: 姓名  工资组成；部门分为：策划、美术、研发</span></span><br><span class="line"><span class="comment">- 随机给10名员工分配部门和工资</span></span><br><span class="line"><span class="comment">- 通过multimap进行信息的插入  key(部门编号) value(员工)</span></span><br><span class="line"><span class="comment">- 分部门显示员工信息</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CEHUA  0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MEISHU 1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YANFA  2</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Salary;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createWorker</span><span class="params">(<span class="built_in">vector</span>&lt;Worker&gt;&amp;v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">string</span> nameSeed = <span class="string">&quot;ABCDEFGHIJ&quot;</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">Worker worker;</span><br><span class="line">worker.m_Name = <span class="string">&quot;员工&quot;</span>;</span><br><span class="line">worker.m_Name += nameSeed[i];</span><br><span class="line"></span><br><span class="line">worker.m_Salary = rand() % <span class="number">10000</span> + <span class="number">10000</span>; <span class="comment">// 10000 ~ 19999</span></span><br><span class="line"><span class="comment">//将员工放入到容器中</span></span><br><span class="line">v.push_back(worker);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工分组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setGroup</span><span class="params">(<span class="built_in">vector</span>&lt;Worker&gt;&amp;v,<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;Worker&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//产生随机部门编号</span></span><br><span class="line"><span class="keyword">int</span> deptId = rand() % <span class="number">3</span>; <span class="comment">// 0 1 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//将员工插入到分组中</span></span><br><span class="line"><span class="comment">//key部门编号，value具体员工</span></span><br><span class="line">m.insert(<span class="built_in">make_pair</span>(deptId, *it));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showWorkerByGourp</span><span class="params">(<span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;&amp;m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="comment">// 0  A  B  C   1  D  E   2  F G ...</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;策划部门：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>,Worker&gt;::iterator pos = m.find(CEHUA);</span><br><span class="line"><span class="keyword">int</span> count = m.count(CEHUA); <span class="comment">// 统计具体人数</span></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++ , index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;美术部门： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pos = m.find(MEISHU);</span><br><span class="line">count = m.count(MEISHU); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;研发部门： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">pos = m.find(YANFA);</span><br><span class="line">count = m.count(YANFA); <span class="comment">// 统计具体人数</span></span><br><span class="line">index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; pos != m.end() &amp;&amp; index &lt; count; pos++, index++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;姓名： &quot;</span> &lt;&lt; pos-&gt;second.m_Name &lt;&lt; <span class="string">&quot; 工资： &quot;</span> &lt;&lt; pos-&gt;second.m_Salary &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//1、创建员工</span></span><br><span class="line"><span class="built_in">vector</span>&lt;Worker&gt;vWorker;</span><br><span class="line">createWorker(vWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、员工分组</span></span><br><span class="line"><span class="built_in">multimap</span>&lt;<span class="keyword">int</span>, Worker&gt;mWorker;</span><br><span class="line">setGroup(vWorker, mWorker);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//3、分组显示员工</span></span><br><span class="line">showWorkerByGourp(mWorker);</span><br><span class="line"></span><br><span class="line"><span class="comment">////测试</span></span><br><span class="line"><span class="comment">//for (vector&lt;Worker&gt;::iterator it = vWorker.begin(); it != vWorker.end(); it++)</span></span><br><span class="line"><span class="comment">//&#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; &quot;姓名： &quot; &lt;&lt; it-&gt;m_Name &lt;&lt; &quot; 工资： &quot; &lt;&lt; it-&gt;m_Salary &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>当数据以键值对形式存在，可以考虑用map 或 multimap</li></ul><h2 id="4-STL-函数对象"><a href="#4-STL-函数对象" class="headerlink" title="4 STL- 函数对象"></a>4 STL- 函数对象</h2><h3 id="4-1-函数对象"><a href="#4-1-函数对象" class="headerlink" title="4.1 函数对象"></a>4.1 函数对象</h3><h4 id="4-1-1-函数对象概念"><a href="#4-1-1-函数对象概念" class="headerlink" title="4.1.1 函数对象概念"></a>4.1.1 函数对象概念</h4><p><strong>概念：</strong></p><ul><li>重载<strong>函数调用操作符</strong>的类，其对象常称为<strong>函数对象</strong></li><li><strong>函数对象</strong>使用重载的()时，行为类似函数调用，也叫<strong>仿函数</strong></li></ul><p><strong>本质：</strong></p><p>函数对象(仿函数)是一个<strong>类</strong>，不是一个函数</p><h4 id="4-1-2-函数对象使用"><a href="#4-1-2-函数对象使用" class="headerlink" title="4.1.2  函数对象使用"></a>4.1.2  函数对象使用</h4><p><strong>特点：</strong></p><ul><li>函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</li><li>函数对象超出普通函数的概念，函数对象可以有自己的状态</li><li>函数对象可以作为参数传递</li></ul><p><strong>示例:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1、函数对象在使用时，可以像普通函数那样调用, 可以有参数，可以有返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyAdd</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span> :</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 + v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyAdd myAdd;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; myAdd(<span class="number">10</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2、函数对象可以有自己的状态</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">MyPrint()</span><br><span class="line">&#123;</span><br><span class="line">count = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; test &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">count++; <span class="comment">//统计使用次数</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> count; <span class="comment">//内部自己的状态</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line">myPrint(<span class="string">&quot;hello world&quot;</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;myPrint调用次数为： &quot;</span> &lt;&lt; myPrint.count &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3、函数对象可以作为参数传递</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">(MyPrint &amp;mp , <span class="built_in">string</span> test)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">mp(test);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test03</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">MyPrint myPrint;</span><br><span class="line">doPrint(myPrint, <span class="string">&quot;Hello C++&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"><span class="comment">//test02();</span></span><br><span class="line">test03();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：</p><ul><li>仿函数写法非常灵活，可以作为参数进行传递。</li></ul><h3 id="4-2-谓词"><a href="#4-2-谓词" class="headerlink" title="4.2  谓词"></a>4.2  谓词</h3><h4 id="4-2-1-谓词概念"><a href="#4-2-1-谓词概念" class="headerlink" title="4.2.1 谓词概念"></a>4.2.1 谓词概念</h4><p><strong>概念：</strong></p><ul><li>返回bool类型的仿函数称为<strong>谓词</strong></li><li>如果operator()接受一个参数，那么叫做一元谓词</li><li>如果operator()接受两个参数，那么叫做二元谓词</li></ul><h4 id="4-2-2-一元谓词"><a href="#4-2-2-一元谓词" class="headerlink" title="4.2.2 一元谓词"></a>4.2.2 一元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//1.一元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GreaterFive</span>&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有一个的谓词，称为一元谓词</p><h4 id="4-2-3-二元谓词"><a href="#4-2-3-二元谓词" class="headerlink" title="4.2.3 二元谓词"></a>4.2.3 二元谓词</h4><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="comment">//二元谓词</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> num1 &gt; num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认从小到大</span></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用函数对象改变算法策略，排序从大到小</span></span><br><span class="line">sort(v.begin(), v.end(), MyCompare());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：参数只有两个的谓词，称为二元谓词</p><h3 id="4-3-内建函数对象"><a href="#4-3-内建函数对象" class="headerlink" title="4.3 内建函数对象"></a>4.3 内建函数对象</h3><h4 id="4-3-1-内建函数对象意义"><a href="#4-3-1-内建函数对象意义" class="headerlink" title="4.3.1 内建函数对象意义"></a>4.3.1 内建函数对象意义</h4><p><strong>概念：</strong></p><ul><li>STL内建了一些函数对象</li></ul><p><strong>分类:</strong></p><ul><li><p>算术仿函数</p></li><li><p>关系仿函数</p></li><li><p>逻辑仿函数</p></li></ul><p><strong>用法：</strong></p><ul><li>这些仿函数所产生的对象，用法和一般函数完全相同</li><li>使用内建函数对象，需要引入头文件 <code>#include&lt;functional&gt;</code></li></ul><h4 id="4-3-2-算术仿函数"><a href="#4-3-2-算术仿函数" class="headerlink" title="4.3.2 算术仿函数"></a>4.3.2 算术仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现四则运算</li><li>其中negate是一元运算，其他都是二元运算</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; T plus&lt;T&gt;</code>                //加法仿函数</li><li><code>template&lt;class T&gt; T minus&lt;T&gt;</code>              //减法仿函数</li><li><code>template&lt;class T&gt; T multiplies&lt;T&gt;</code>    //乘法仿函数</li><li><code>template&lt;class T&gt; T divides&lt;T&gt;</code>         //除法仿函数</li><li><code>template&lt;class T&gt; T modulus&lt;T&gt;</code>         //取模仿函数</li><li><code>template&lt;class T&gt; T negate&lt;T&gt;</code>           //取反仿函数</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="comment">//negate</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">negate&lt;<span class="keyword">int</span>&gt; n;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; n(<span class="number">50</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//plus</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">plus&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p(<span class="number">10</span>, <span class="number">20</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：使用内建函数对象时，需要引入头文件 <code>#include &lt;functional&gt;</code></p><h4 id="4-3-3-关系仿函数"><a href="#4-3-3-关系仿函数" class="headerlink" title="4.3.3 关系仿函数"></a>4.3.3 关系仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现关系对比</li></ul><p><strong>仿函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool equal_to&lt;T&gt;</code>                    //等于</li><li><code>template&lt;class T&gt; bool not_equal_to&lt;T&gt;</code>            //不等于</li><li><code>template&lt;class T&gt; bool greater&lt;T&gt;</code>                      //大于</li><li><code>template&lt;class T&gt; bool greater_equal&lt;T&gt;</code>          //大于等于</li><li><code>template&lt;class T&gt; bool less&lt;T&gt;</code>                           //小于</li><li><code>template&lt;class T&gt; bool less_equal&lt;T&gt;</code>               //小于等于</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCompare</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> v1 &gt; v2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"></span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自己实现仿函数</span></span><br><span class="line"><span class="comment">//sort(v.begin(), v.end(), MyCompare());</span></span><br><span class="line"><span class="comment">//STL内建仿函数  大于仿函数</span></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = v.begin(); it != v.end(); it++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：关系仿函数中最常用的就是greater&lt;&gt;大于</p><h4 id="4-3-4-逻辑仿函数"><a href="#4-3-4-逻辑仿函数" class="headerlink" title="4.3.4 逻辑仿函数"></a>4.3.4 逻辑仿函数</h4><p><strong>功能描述：</strong></p><ul><li>实现逻辑运算</li></ul><p><strong>函数原型：</strong></p><ul><li><code>template&lt;class T&gt; bool logical_and&lt;T&gt;</code>              //逻辑与</li><li><code>template&lt;class T&gt; bool logical_or&lt;T&gt;</code>                //逻辑或</li><li><code>template&lt;class T&gt; bool logical_not&lt;T&gt;</code>              //逻辑非</li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v;</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line">v.push_back(<span class="literal">true</span>);</span><br><span class="line">v.push_back(<span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v.begin();it!= v.end();it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//逻辑非  将v容器搬运到v2中，并执行逻辑非运算</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; v2;</span><br><span class="line">v2.resize(v.size());</span><br><span class="line">transform(v.begin(), v.end(),  v2.begin(), logical_not&lt;<span class="keyword">bool</span>&gt;());</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;::iterator it = v2.begin(); it != v2.end(); it++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：逻辑仿函数实际应用较少，了解即可</p><h2 id="5-STL-常用算法"><a href="#5-STL-常用算法" class="headerlink" title="5 STL- 常用算法"></a>5 STL- 常用算法</h2><p><strong>概述</strong>:</p><ul><li>算法主要是由头文件<code>&lt;algorithm&gt;</code> <code>&lt;functional&gt;</code> <code>&lt;numeric&gt;</code>组成。</li></ul><ul><li><code>&lt;algorithm&gt;</code>是所有STL头文件中最大的一个，范围涉及到比较、 交换、查找、遍历操作、复制、修改等等</li><li><code>&lt;numeric&gt;</code>体积很小，只包括几个在序列上面进行简单数学运算的模板函数</li><li><code>&lt;functional&gt;</code>定义了一些模板类,用以声明函数对象。</li></ul><h3 id="5-1-常用遍历算法"><a href="#5-1-常用遍历算法" class="headerlink" title="5.1 常用遍历算法"></a>5.1 常用遍历算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的遍历算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>for_each</code>     //遍历容器</li><li><code>transform</code>   //搬运容器到另一个容器中</li></ul><h4 id="5-1-1-for-each"><a href="#5-1-1-for-each" class="headerlink" title="5.1.1 for_each"></a>5.1.1 for_each</h4><p><strong>功能描述：</strong></p><ul><li>实现遍历容器</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>for_each(iterator beg, iterator end, _func);  </code></p><p>// 遍历算法 遍历容器元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _func 函数或者函数对象</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print01</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//函数对象</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">print02</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//for_each算法基本用法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) </span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历算法</span></span><br><span class="line">for_each(v.begin(), v.end(), print01);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), print02());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>for_each在实际开发中是最常用遍历算法，需要熟练掌握</p><h4 id="5-1-2-transform"><a href="#5-1-2-transform" class="headerlink" title="5.1.2 transform"></a>5.1.2 transform</h4><p><strong>功能描述：</strong></p><ul><li>搬运容器到另一个容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><code>transform(iterator beg1, iterator end1, iterator beg2, _func);</code></li></ul><p>//beg1 源容器开始迭代器</p><p>//end1 源容器结束迭代器</p><p>//beg2 目标容器开始迭代器</p><p>//_func 函数或者函数对象</p><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//常用遍历算法  搬运 transform</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TransForm</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;vTarget; <span class="comment">//目标容器</span></span><br><span class="line"></span><br><span class="line">vTarget.resize(v.size()); <span class="comment">// 目标容器需要提前开辟空间</span></span><br><span class="line"></span><br><span class="line">transform(v.begin(), v.end(), vTarget.begin(), TransForm());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), vTarget.end(), MyPrint());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 搬运的目标容器必须要提前开辟空间，否则无法正常搬运</p><h3 id="5-2-常用查找算法"><a href="#5-2-常用查找算法" class="headerlink" title="5.2 常用查找算法"></a>5.2 常用查找算法</h3><p>学习目标：</p><ul><li>掌握常用的查找算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>find</code>                     //查找元素</li><li><code>find_if</code>               //按条件查找元素</li><li><code>adjacent_find</code>    //查找相邻重复元素</li><li><code>binary_search</code>    //二分查找法</li><li><code>count</code>                   //统计元素个数</li><li><code>count_if</code>             //按条件统计元素个数</li></ul><h4 id="5-2-1-find"><a href="#5-2-1-find" class="headerlink" title="5.2.1 find"></a>5.2.1 find</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素，找到返回指定元素的迭代器，找不到返回结束迭代器end()</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find(iterator beg, iterator end, value);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找容器中是否有 5 这个元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find(v.begin(), v.end(), <span class="number">5</span>);</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//重载==</span></span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person&amp; p) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Name == p.m_Name &amp;&amp; <span class="keyword">this</span>-&gt;m_Age == p.m_Age) </span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = find(v.begin(), v.end(), p2);</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结： 利用find可以在容器中找指定的元素，返回值是<strong>迭代器</strong></p><h4 id="5-2-2-find-if"><a href="#5-2-2-find-if" class="headerlink" title="5.2.2 find_if"></a>5.2.2 find_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件查找元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>find_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 函数或者谓词（返回bool类型的仿函数）</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GreaterFive</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt; <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = find_if(v.begin(), v.end(), GreaterFive());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到大于5的数字:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater20</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &gt; <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建数据</span></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;aaa&quot;</span>, <span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;bbb&quot;</span>, <span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;ccc&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;ddd&quot;</span>, <span class="number">40</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt;::iterator it = find_if(v.begin(), v.end(), Greater20());</span><br><span class="line"><span class="keyword">if</span> (it == v.end())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;没有找到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到姓名:&quot;</span> &lt;&lt; it-&gt;m_Name &lt;&lt; <span class="string">&quot; 年龄: &quot;</span> &lt;&lt; it-&gt;m_Age &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：find_if按条件查找使查找更加灵活，提供的仿函数可以改变不同的策略</p><h4 id="5-2-3-adjacent-find"><a href="#5-2-3-adjacent-find" class="headerlink" title="5.2.3 adjacent_find"></a>5.2.3 adjacent_find</h4><p><strong>功能描述：</strong></p><ul><li>查找相邻重复元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>adjacent_find(iterator beg, iterator end);  </code></p><p>// 查找相邻重复元素,返回相邻元素的第一个位置的迭代器</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//查找相邻重复元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it = adjacent_find(v.begin(), v.end());</span><br><span class="line"><span class="keyword">if</span> (it == v.end()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找不到!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到相邻重复元素为:&quot;</span> &lt;&lt; *it &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：面试题中如果出现查找相邻重复元素，记得用STL中的adjacent_find算法</p><h4 id="5-2-4-binary-search"><a href="#5-2-4-binary-search" class="headerlink" title="5.2.4 binary_search"></a>5.2.4 binary_search</h4><p><strong>功能描述：</strong></p><ul><li>查找指定元素是否存在</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>bool binary_search(iterator beg, iterator end, value);  </code></p><p>// 查找指定的元素，查到 返回true  否则false</p><p>// 注意: 在<strong>无序序列中不可用</strong></p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 查找的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;v;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分查找</span></span><br><span class="line"><span class="keyword">bool</span> ret = binary_search(v.begin(), v.end(),<span class="number">2</span>);</span><br><span class="line"><span class="keyword">if</span> (ret)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;找到了&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;未找到&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>二分查找法查找效率很高，值得注意的是查找的容器中元素必须的有序序列</p><h4 id="5-2-5-count"><a href="#5-2-5-count" class="headerlink" title="5.2.5 count"></a>5.2.5 count</h4><p><strong>功能描述：</strong></p><ul><li>统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count(iterator beg, iterator end, value);  </code></p><p>// 统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 统计的元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.begin(), v.end(), <span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">bool</span> <span class="keyword">operator</span>==(<span class="keyword">const</span> Person &amp; p)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_Age == p.m_Age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line">    </span><br><span class="line">    <span class="function">Person <span class="title">p</span><span class="params">(<span class="string">&quot;诸葛亮&quot;</span>,<span class="number">35</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count(v.begin(), v.end(), p);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;num = &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> 统计自定义数据类型时候，需要配合重载 <code>operator==</code></p><h4 id="5-2-6-count-if"><a href="#5-2-6-count-if" class="headerlink" title="5.2.6 count_if"></a>5.2.6 count_if</h4><p><strong>功能描述：</strong></p><ul><li>按条件统计元素个数</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>count_if(iterator beg, iterator end, _Pred);  </code></p><p>// 按条件统计元素出现次数</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _Pred 谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Greater4</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内置数据类型</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">1</span>);</span><br><span class="line">v.push_back(<span class="number">2</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">5</span>);</span><br><span class="line">v.push_back(<span class="number">3</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line">v.push_back(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.begin(), v.end(), Greater4());</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;大于4的个数为： &quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//自定义数据类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Person(<span class="built_in">string</span> name, <span class="keyword">int</span> age)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> m_Name;</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AgeLess35</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Person &amp;p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> p.m_Age &lt; <span class="number">35</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;Person&gt; v;</span><br><span class="line"></span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;刘备&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;关羽&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(<span class="string">&quot;张飞&quot;</span>, <span class="number">35</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p4</span><span class="params">(<span class="string">&quot;赵云&quot;</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p5</span><span class="params">(<span class="string">&quot;曹操&quot;</span>, <span class="number">25</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">v.push_back(p1);</span><br><span class="line">v.push_back(p2);</span><br><span class="line">v.push_back(p3);</span><br><span class="line">v.push_back(p4);</span><br><span class="line">v.push_back(p5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = count_if(v.begin(), v.end(), AgeLess35());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;小于35岁的个数：&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//test01();</span></span><br><span class="line"></span><br><span class="line">test02();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>按值统计用count，按条件统计用count_if</p><h3 id="5-3-常用排序算法"><a href="#5-3-常用排序算法" class="headerlink" title="5.3 常用排序算法"></a>5.3 常用排序算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的排序算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>sort</code>             //对容器内元素进行排序</li><li><code>random_shuffle</code>   //洗牌   指定范围内的元素随机调整次序</li><li><code>merge </code>           // 容器元素合并，并存储到另一容器中</li><li><code>reverse</code>       // 反转指定范围的元素</li></ul><h4 id="5-3-1-sort"><a href="#5-3-1-sort" class="headerlink" title="5.3.1 sort"></a>5.3.1 sort</h4><p><strong>功能描述：</strong></p><ul><li>对容器内元素进行排序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>sort(iterator beg, iterator end, _Pred);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>//  beg    开始迭代器</p><p>//  end    结束迭代器</p><p>// _Pred  谓词</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">myPrint</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort默认从小到大排序</span></span><br><span class="line">sort(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从大到小排序</span></span><br><span class="line">sort(v.begin(), v.end(), greater&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>sort属于开发中最常用的算法之一，需熟练掌握</p><h4 id="5-3-2-random-shuffle"><a href="#5-3-2-random-shuffle" class="headerlink" title="5.3.2 random_shuffle"></a>5.3.2 random_shuffle</h4><p><strong>功能描述：</strong></p><ul><li>洗牌   指定范围内的元素随机调整次序</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>random_shuffle(iterator beg, iterator end);  </code></p><p>// 指定范围内的元素随机调整次序</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">srand((<span class="keyword">unsigned</span> <span class="keyword">int</span>)time(<span class="literal">NULL</span>));</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span>;i++)</span><br><span class="line">&#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打乱顺序</span></span><br><span class="line">random_shuffle(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>random_shuffle洗牌算法比较实用，使用时记得加随机数种子</p><h4 id="5-3-3-merge"><a href="#5-3-3-merge" class="headerlink" title="5.3.3 merge"></a>5.3.3 merge</h4><p><strong>功能描述：</strong></p><ul><li>两个容器元素合并，并存储到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>merge(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 容器元素合并，并存储到另一容器中</p><p>// 注意: 两个容器必须是<strong>有序的</strong></p><p>// beg1   容器1开始迭代器<br>// end1   容器1结束迭代器<br>// beg2   容器2开始迭代器<br>// end2   容器2结束迭代器<br>// dest    目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span> ; i++) </span><br><span class="line">    &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vtarget;</span><br><span class="line"><span class="comment">//目标容器需要提前开辟空间</span></span><br><span class="line">vtarget.resize(v1.size() + v2.size());</span><br><span class="line"><span class="comment">//合并  需要两个有序序列</span></span><br><span class="line">merge(v1.begin(), v1.end(), v2.begin(), v2.end(), vtarget.begin());</span><br><span class="line">for_each(vtarget.begin(), vtarget.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>merge合并的两个容器必须的有序序列</p><h4 id="5-3-4-reverse"><a href="#5-3-4-reverse" class="headerlink" title="5.3.4 reverse"></a>5.3.4 reverse</h4><p><strong>功能描述：</strong></p><ul><li>将容器内元素进行反转</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>reverse(iterator beg, iterator end);  </code></p><p>// 反转指定范围的元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">reverse(v.begin(), v.end());</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>reverse反转区间内元素，面试题可能涉及到</p><h3 id="5-4-常用拷贝和替换算法"><a href="#5-4-常用拷贝和替换算法" class="headerlink" title="5.4 常用拷贝和替换算法"></a>5.4 常用拷贝和替换算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的拷贝和替换算法</li></ul><p><strong>算法简介：</strong></p><ul><li><code>copy</code>                      // 容器内指定范围的元素拷贝到另一容器中</li><li><code>replace</code>                // 将容器内指定范围的旧元素修改为新元素</li><li><code>replace_if </code>          // 容器内指定范围满足条件的元素替换为新元素</li><li><code>swap</code>                     // 互换两个容器的元素</li></ul><h4 id="5-4-1-copy"><a href="#5-4-1-copy" class="headerlink" title="5.4.1 copy"></a>5.4.1 copy</h4><p><strong>功能描述：</strong></p><ul><li>容器内指定范围的元素拷贝到另一容器中</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>copy(iterator beg, iterator end, iterator dest);  </code></p><p>// 按值查找元素，找到返回指定位置迭代器，找不到返回结束迭代器位置</p><p>// beg  开始迭代器</p><p>// end  结束迭代器</p><p>// dest 目标起始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line">v2.resize(v1.size());</span><br><span class="line">copy(v1.begin(), v1.end(), v2.begin());</span><br><span class="line"></span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>利用copy算法在拷贝时，目标容器记得提前开辟空间</p><h4 id="5-4-2-replace"><a href="#5-4-2-replace" class="headerlink" title="5.4.2 replace"></a>5.4.2 replace</h4><p><strong>功能描述：</strong></p><ul><li>将容器内指定范围的旧元素修改为新元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace(iterator beg, iterator end, oldvalue, newvalue);  </code></p><p>// 将区间内旧元素 替换成 新元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// oldvalue 旧元素</p><p>// newvalue 新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中的20 替换成 2000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">replace(v.begin(), v.end(), <span class="number">20</span>,<span class="number">2000</span>);</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>replace会替换区间内满足条件的元素</p><h4 id="5-4-3-replace-if"><a href="#5-4-3-replace-if" class="headerlink" title="5.4.3 replace_if"></a>5.4.3 replace_if</h4><p><strong>功能描述:</strong>  </p><ul><li>将区间内满足条件的元素，替换成指定元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>replace_if(iterator beg, iterator end, _pred, newvalue);  </code></p><p>// 按条件替换元素，满足条件的替换成指定元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// _pred 谓词</p><p>// newvalue 替换的新元素</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReplaceGreater30</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> val &gt;= <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">30</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line">v.push_back(<span class="number">40</span>);</span><br><span class="line">v.push_back(<span class="number">50</span>);</span><br><span class="line">v.push_back(<span class="number">10</span>);</span><br><span class="line">v.push_back(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将容器中大于等于的30 替换成 3000</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;替换后：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">replace_if(v.begin(), v.end(), ReplaceGreater30(), <span class="number">3000</span>);</span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>replace_if按条件查找，可以利用仿函数灵活筛选满足的条件</p><h4 id="5-4-4-swap"><a href="#5-4-4-swap" class="headerlink" title="5.4.4 swap"></a>5.4.4 swap</h4><p><strong>功能描述：</strong></p><ul><li>互换两个容器的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>swap(container c1, container c2);  </code></p><p>// 互换两个容器的元素</p><p>// c1容器1</p><p>// c2容器2</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换前： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;交换后： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">swap(v1, v2);</span><br><span class="line">for_each(v1.begin(), v1.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">for_each(v2.begin(), v2.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>swap交换容器时，注意交换的容器要同种类型</p><h3 id="5-5-常用算术生成算法"><a href="#5-5-常用算术生成算法" class="headerlink" title="5.5 常用算术生成算法"></a>5.5 常用算术生成算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的算术生成算法</li></ul><p><strong>注意：</strong></p><ul><li>算术生成算法属于小型算法，使用时包含的头文件为 <code>#include &lt;numeric&gt;</code></li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>accumulate</code>      // 计算容器元素累计总和</p></li><li><p><code>fill</code>                 // 向容器中添加元素</p></li></ul><h4 id="5-5-1-accumulate"><a href="#5-5-1-accumulate" class="headerlink" title="5.5.1 accumulate"></a>5.5.1 accumulate</h4><p><strong>功能描述：</strong></p><ul><li> 计算区间内 容器元素累计总和</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>accumulate(iterator beg, iterator end, value);  </code></p><p>// 计算容器元素累计总和</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 起始值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">100</span>; i++) &#123;</span><br><span class="line">v.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> total = accumulate(v.begin(), v.end(), <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;total = &quot;</span> &lt;&lt; total &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>accumulate使用时头文件注意是 numeric，这个算法很实用</p><h4 id="5-5-2-fill"><a href="#5-5-2-fill" class="headerlink" title="5.5.2 fill"></a>5.5.2 fill</h4><p><strong>功能描述：</strong></p><ul><li>向容器中填充指定的元素</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>fill(iterator beg, iterator end, value);  </code></p><p>// 向容器中填充元素</p><p>// beg 开始迭代器</p><p>// end 结束迭代器</p><p>// value 填充的值</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;numeric&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">v.resize(<span class="number">10</span>);</span><br><span class="line"><span class="comment">//填充</span></span><br><span class="line">fill(v.begin(), v.end(), <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">for_each(v.begin(), v.end(), myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong>利用fill可以将容器区间内元素填充为 指定的值</p><h3 id="5-6-常用集合算法"><a href="#5-6-常用集合算法" class="headerlink" title="5.6 常用集合算法"></a>5.6 常用集合算法</h3><p><strong>学习目标：</strong></p><ul><li>掌握常用的集合算法</li></ul><p><strong>算法简介：</strong></p><ul><li><p><code>set_intersection</code>          // 求两个容器的交集</p></li><li><p><code>set_union</code>                       // 求两个容器的并集</p></li><li><p><code>set_difference </code>              // 求两个容器的差集</p></li></ul><h4 id="5-6-1-set-intersection"><a href="#5-6-1-set-intersection" class="headerlink" title="5.6.1 set_intersection"></a>5.6.1 set_intersection</h4><p><strong>功能描述：</strong></p><ul><li>求两个容器的交集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_intersection(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的交集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较小的值给目标容器开辟空间</span></span><br><span class="line">vTarget.resize(min(v1.size(), v2.size()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_intersection(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求交集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器中取小值</strong></li><li>set_intersection返回值既是交集中最后一个元素的位置</li></ul><h4 id="5-6-2-set-union"><a href="#5-6-2-set-union" class="headerlink" title="5.6.2 set_union"></a>5.6.2 set_union</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的并集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_union(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的并集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个容器的和给目标容器开辟空间</span></span><br><span class="line">vTarget.resize(v1.size() + v2.size());</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_union(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line"></span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求并集的两个集合必须的有序序列</li><li>目标容器开辟空间需要<strong>两个容器相加</strong></li><li>set_union返回值既是并集中最后一个元素的位置</li></ul><h4 id="5-6-3-set-difference"><a href="#5-6-3-set-difference" class="headerlink" title="5.6.3  set_difference"></a>5.6.3  set_difference</h4><p><strong>功能描述：</strong></p><ul><li>求两个集合的差集</li></ul><p><strong>函数原型：</strong></p><ul><li><p><code>set_difference(iterator beg1, iterator end1, iterator beg2, iterator end2, iterator dest);  </code></p><p>// 求两个集合的差集</p><p>// <strong>注意:两个集合必须是有序序列</strong></p><p>// beg1 容器1开始迭代器<br>// end1 容器1结束迭代器<br>// beg2 容器2开始迭代器<br>// end2 容器2结束迭代器<br>// dest 目标容器开始迭代器</p></li></ul><p><strong>示例：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myPrint</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">v1.push_back(i);</span><br><span class="line">v2.push_back(i+<span class="number">5</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vTarget;</span><br><span class="line"><span class="comment">//取两个里面较大的值给目标容器开辟空间</span></span><br><span class="line">vTarget.resize( max(v1.size() , v2.size()));</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回目标容器的最后一个元素的迭代器地址</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v1与v2的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator itEnd = </span><br><span class="line">        set_difference(v1.begin(), v1.end(), v2.begin(), v2.end(), vTarget.begin());</span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;v2与v1的差集为： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">itEnd = set_difference(v2.begin(), v2.end(), v1.begin(), v1.end(), vTarget.begin());</span><br><span class="line">for_each(vTarget.begin(), itEnd, myPrint());</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">test01();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong> </p><ul><li>求差集的两个集合必须的有序序列</li><li>目标容器开辟空间需要从<strong>两个容器取较大值</strong></li><li>set_difference返回值既是差集中最后一个元素的位置</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Gem5 Intro</title>
      <link href="/2022/01/05/Gem5%20Intro/"/>
      <url>/2022/01/05/Gem5%20Intro/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5ef32e2389e0c63c117a043f8f28007fc46ad03d0dcaafbfcd9f56c47c3d750d">e8ddf16f6a907c53c402f597f0c2281f2d7aac72253b3449ac2f4958d425e47017651887d89d161c8bf08fb6b8649ee3011092f2e67e0b90a95d0ff2dfcf63dc99049a61a937ebeed6cc7c9792cb946090dfebd2a62b84c035dc6a96c7e0d3653dd0bdfff5bb9e295b8d692a230c75cb5e4550476c4b53b985980ffedbd5b6af57c19c588d7c79b9b6879776d8b5ffaebce6f2ba568e5fec3dcc9318b26d15452183d11aef92ced5bc78520175cdbe2c44cae0d41fb2e9d9ec5b9c0262817e2d667dc07a0939edbb09162c0bac480a7c20008774bb2bbcff698645e599acc10491ac5a858f937c22144a9afca532b4d8a4af4894a19b5a4642dd77a2ff0148148fea93393f7256bf6ad275e9c4fbe9f34939bf71e7c728943c4838d5f72f53fe97dd41c90b8d00f9271a709420f62641c3f96e640b6567c9708dfb879b34343b37d720347bb78c7a349e8e3d2f1b6b2446574d530f26f49c013473e7cd0c1bb6e37b87a01c63afd6d5d023a0dbf7107e940eb8077c9e3728e029ec076fe53562c6f9c209fbdc3b60ef1d10969b7764f4c21ded6fba48b5bce1297cf97f9bcf8cf7f8a96fef2be90d071c9bab43f0c1386af3eaa4cc31ba7ab619355b5acc4c6227f3ff89580ceeb54ae298e346b5dc9657da6ecc1d50bdd5d1f48235d2843878a8aef6c1377a5422ce40409173e23503fadf559df478d5202a11cb8243054a19c81391dc164a59296de11ff3e48f71b24d2670478c20af1cf2c33bd996aad247307df9e120dc17f54c6116897c0cd280d2dd54121028fed47e28e4c00d89c1501c7b71bf65224c2f45925ef8857c688b0da90c483a1f8613159f33dfed017aedb0e9f4ade163d125843caa1b614a4e3e2e75f8007befceb04052e5981a33151b83c7dea6aa105c0b897dc6963c2c77dc8472c4ee6f9192b262664af52d8827523023988916c67c4a991f84313d857393d51696c96f12a41faf37733de4ea86d27a387e393cb1afb9c6461c246c6a713f7d1dbd6ef033a1491bdd6a8733aec73bd9e17d3bb73992ce4d6a042b071ab1785798b3b8a03d12b48d088a9094f4e1f9b7cbff0ae6bbb9cb89b7fd18479e50f007c92de180d75480541eda2b06ffff91f96971918e6ef1de6cab6395ab1799f29abdf613aca7f30aa6415d9ae4a36d1725190e0550e622ed5884d6f5c7c48dddf2a95a9a3de7a5ac5c50d7ee2fd2577d1528b8adb401cdf0364ab41ae4f7e1307b933242c9cebddef9281565746ac74d4ceb4f38ac48d8354d8dda157da674b7e7bf67f566684f55a8ce9a6daeb94cd4ba22aba7ab0443d4b1a808ced7f01cd2592751ed792e39042b9692eeefcfc992d3f0f0d8faad5c8effaac7a5d079ef10b1337cf518a946e2d61e48596c789e3ab00b3ea778a2baa3d1c6f14bb7111a05a4b80870ab88dec113752f08666c0c2c2d3399b048f97fd25e6cfaf560211e8c3fea968d7341424d89f8217fd4e80b15d7225de4cea169586f05ead63706f2a60bb716c53bfcdad48dba09aff277f58502ae75d92effd5ef1e12d8e0620c4e6b7273bdb976de320ea71254f80abab84155ef1abf793e54483254827e2420b0cdd11b235ea529be9b116561cef225a560f43aa006fd7caca103deeacd6d1eac15b21ae26c4d93540024cd7890298b005d41cc5bebe069b67cb8ab74dad05892864e275011183e07a483ba74fc59292194d6624a30cf223a333a0af5c4d783bcdbe9a4d7382b787aef0e34e250afc938e5e8317bac87df7d971982de9a7d97a9409cbf0dba13f1d9cf3fcff41cf6bab375097d49fd70bf8504d2478e0d3d72a23bfd3dad0cc0f1d53a148aa95e49b0024dbc78f76dbbd99d3ced907924f9a7e65adfb518cf43d06a7a92d34d7af973b3194f5e9146fda0dbc1631d6eff93f1343664526c04d980eb3b695db4578414261fc9a515650ac8bcba550cfa5d364455b0564209bd8c427e96c0c7a5ec5fc3ee9ed57e8d22edf4512b721ffa52f9c6094206ee40f97b22df218197685959f20a10cd93e1a4f42b2f18513ea09469715064cecadc385d3eb3899d0c0803483f30ddae0c41da87c87b6d896032620f68cd1b1a59e46df69f108f67abfd4bbb96a370c90e533921a0f2813532f2b1a538376e0a4c69db6fa77f052e592a0e8728ebd7bbeff234d533946df594a1b9ded927b67500748ae145f58674c90357b6274c568f28003101b739ffcea85c504ce52923a02b34a5d32f45a34953cceeeab93273d27a39b0d6f913b6b7ce264273e636a8897556236affcce4a1052477a092d573abc4b102dbecf870df07386fc45c8d6673fa8d1befc33710ffbea9948c6a857cc6c6ac537641146b9331c1f01fc7049d911c3b19e17862179a3d8c58c037b19a9297fc548c0b5f27e449bbdd4e11f1abbb40e71708e62cb31f9d7ba085b05c3a45afaf86a24f921b6f820690a38a0d9298f438137b4814bc18f2427479c1f093dd25f95127d98564c915e21bed0f70a996cb86c195a4a4aebe19279043edacd741954a6e9bd402b03124a51bb28b4f3697bd1a40e0e7bffe922632d516eed602ff48374e18bb7e3156e6d65297ca04e39556fd9b84d5c3377774ced13eab5c195b17d0bb19ffe28c3b3a60d2635fe9510252b7466d1e2ee7d3cd3548d8e5fe5ac7a3554b92a562c0054dc2db338e20340f452be5f98273f09ffcff924424d6799b5286293b4af8e3281c197c7fdbb04d256ba131bae3acf230468d1342374e0b84c11cbcb1cc11d38a5e263af37841f6080e392145d7bd99935b928a2e4836d902b9925fe55cc72fd4ee0403a396a55bac1632e690f422e433b13326eaa89d61a9d179834bc7b25bc34aa3c7a3b1605a1b06a2398a4fd3051e7ec56470b8e8e6a539e6ad2040ccaef758be97bffc9132561390d6f608706926cd663cdce836ca205ef5f6bdc510d25568d7d1a3b2020c342a1598191a4ac50a2abae5ebdbabb436ebf7f0c7ade80aef09f61bcb19f1a32df76eaef952375b3abfc95158a99748bface9dfba3c4e13ca7e2aa7e6c08d6afbf413f233d58ae0d9c88424092deace32953ed4cb4027f3b82714f8087d2b500991df820ed82c95a94b81c8eeb3688884f4912ed2e55a45ca84ad1ef7d46ba776dd84c0a7e2e5d9bc02907774820e45a95cc7183d4106113e24e3ab87e14b4be27aeac31c879abf1c2c34ec37226da206a18495c2e00915dace1d0f378b10a1e3cd2b207069038423c0c3f9121c14efebcbca0d69559795e36ffe96990feca7bbb393534a9ed5265c5f10f601a3e84b33d66bfbff57b6d5297b491593cf938b0abc83071c48368be4aa2b3fb9ad6d96d6e5d51718c57d75939f1c298177e5bdfb2ba034c4aad12dea59c68d3298eb60915a2c4bffcf14fd1ffb0e7d9d30cf1b29fc349a1166ca2f0f629ddcece59010b03483e17f8f14abe523779b6f84843780c134c8ffd316127c5469070be178d4867aeba33a68a9da93d8d1d233354c764586d7e9d43aae20897b4d7e0be3a1fd341f7debe1f0fda3f9ce15f33959309db42fb354ed15bf149fc70e1e3b61ac19157266ea7e6fc10e8811c95ea36e1443ef762277837a94b98c1a93f59edf04e1c250cb7d89aee38825e8c295a304f5a7c703791ecdea676585db426df2355669b7114481baf25490af1b9fea873652bbecd47f1245c38abab9371edba2974f6fe2c82aa5e8405b6aa7f4db515f3765d8c50579e3098161c17a7daac9f2bdc64869827d1c4697f8a97295f3d5da163325cb4d217d1ae98a88179f6eb12b3e7e4f8e29b7c2d9906e6960789c03e531196bcd822d815eef6251e0ef9e2904d0065190bb36a2dbb194cd842809ed03329b5971b5b9db880a70fd89905d1f64fd36344c024dd6e1ae267bebb795faa8eb4dfe804f7291aa4751fd2d8584167fe0db008bb540bb5c0311111c8384c05679d5909b7f35644179723c893d699317d29ffcd45dc62f05388cb69bb3fa6e3f1457565e93afa38ae873ff28ecb5ae022d4c300f03ce10003f1afd6fb62a9f802335a734c59d51c8285e6886719f3acaff4484dab3ce8af37e4e08590b7eda073de7d5e7bf223d3e4deb99dd064e39102cab53dd7c92b72eae9a4cd04fe45dd9e3c95e121bc1f3dbc5ad0682af297e56efe6439a36d8980525f055c8571b54ad2699a446f3792ea602d8891db694f0432d894ccfa264f9d9792e755c6800ea903bd43fe430d16c0065972cd442ff5e08133bca5103ee8715df49df81e4c4bca80bbdd4add023baa91580c6da13cd3fee49d8d17d19b694745843aebb881916fa7aeb7ca94d05909c045028b3bef4cc2bcc335b18bc8201d842b130a723bcca593c707c52fc0565ad7fc513b10250514d51f6c503eab96a08544250517fbcac07118bdf51c5c5f20c94393839ebe86467567f0dd79e9835137c8bb9f5540a5cb308cd43ae6e513329d0f2fff657df731a12c9a39afcfc48dfd393b6fc3e092e3baa89697544b101446207ba90528c3e1e7d1ae85145ad8fea3f40c34e0e3d28b040e6459db3d490b453e1eca621667a2d5ca0cbf75c922967333fed4d687b6197808eb60c2b174fc6ff5c5b7d9be620112e76c7a779fc8f32cad2d4feaea7e5f20676061fd7d55960ba476190a086d33c029dfff37cbc087234253e8da79e8c98fc9c0e4d5ec82a2caea74df398d6ced51d60ad85c7b6d16e2461354f7217568ae322c41b252bc00fae28332e0f1969a62515929edcb46308cbca2b031ddfa3a1bfdae78413341f6ea2df60051b54c43f96a67e049b747d9f281ad914ca513d063bd7239b4cc514d30e90d65c3c7d22890a2aff1ee376b10a6c217ec70085c73ff1cd5f54b879c06a3ab9d7830c8d042fb14101c194993161ec3bd4e5d94c00716f0ee175f504933a6872bd85bbce2fdd67bbfd3c938f205f78273371533cffbb9dedd42c43ed7cb829ccc81b8a98bb3bf46d25bdd3b8b884b107829a44ad8cf222f92d2d05081e5517691af375076bd2fcbc87343e84e3d00847e64e7feb9e213fb28ee7850b40797147fc5b1b6a4a29dd2f769efa56ec29e9d3b0fd1c913f04fdc3699f2f9aacde481546eeb9cb535fbd57895ec4f47c7a1fb39b37eb108e4e4d347d7fa015b62576fa530329892b9c03e539dd74e485fd24af886fc36675f9aba2e2daa38f8b989f3a9ea3b95ee6e652870a8241e6e02697411f96a394dead56261de60ee586aa829f5b8efab9a71a517e96e209c03b03b7eb0dd10f1eb11c2efd3a8ce8382ef3aa774cceec5d346a6a5c9e63dc2d4df1e23786c3c98e601e3b07fa72912bc2006e46263afa72a212baefb4e078403f5bb32c4b78aa8670ff114f0377640b3654db9f91bcb080759ea1b6ed5f14c4c6f8911ff996e020a513497cde71874992542b1dcc6e732e6a6423ba6597c3ef2ce7d0dda6fb62dd6a15516fdfb031803e10fadd143556b7377fd23f1fde9f05c9e23cd83f6b4af3361e8034b99614aba916fe645c5f7dc1c4bce0950a497a1179669bf648b21cb076c65198162c7d230ae80fab7c66c316b796f6dfa34380ab9c97052d0272feecab0ffbfac5043d8715172057ef9272f797ed5e5d92e31372ae83eea1c4602a1af0bd8c9942b97dda2417fd8977414be357ccdbf0984e407e2f8bafab1d86adc3c964c47487203470b6b9b087c5be3df0b4c6f353c0196a2203c375e816dec48b4bf12dcf8237d82f27cde5892c6fb86e2122410240f3569cdd10c115b45eb89e905637496942f8dace02f8796c75b976ff254651e19b93283969f83df6fc7adfcf4a3eaf93f8686fc1954f62c51831b5a5f8fc38a12081e181d5a9a99cc48f626bfae4a2dd3d50f1bd13686d12d7a55f3064a5417ff337455baf210db9a0247cfd51a2c5462bb29beaafca5f96ebfcdafa71e8e1fd3215cfb234f51e7abe728ff3054460cc0e2fae4c93e21cc3cfc3d037a77c5999c5469732ee3ab2f4b283589cc3c35afb8fbe665ad57cd9753881597fda0c692adc2378b56e8c1635070d806760d96fd2c366d365e59b5e1b4290474c57a4dd8e89eba1b853d0a6a69932e0ffc1853386b71488079a895a46c4caeb21deef183c9d3594729fd8599aee56ac8c7dcc0636e08feb267339ad7c37f0b39c39800a4dcf4d7049d6e32e113023769f6f84aa84668f556c9494656853a8582dab3d7a74d416c170cc91bda961f7ae96e3153d5bba63d17ec09e20931eb9fe5ce8b302ce8d4b94105fd4531900c3db18d2a2beaf58c2eab9c7dbb6f4870024aa45907569df5aa10eb7c59fee156d19ba709a9815e5cbc31f37c2222c86ebd9e115b883c5349c93ba747a009067fd38a5b6cacd83375cfcd51d75c07a752961fcc68237149e93c8487f78c235b874c5bcc0af1c80baafd5749ada61c589fe2ede12d944f3042976b10606f6df4d1635bf9d47a3c15316fff8d7f06c8a67b2d51855b13d3d6571d140009016d16bd30264c6d1de019710f0da76fdf163a8404434bd6a5e85cb9363d3faf8b4ec262b82b90d2da82430d7ec03df0958325b9900d544bc45b16d045bcf20f8baa9daa12e06861acb3f935ec1aaf5322cee838be5b5fbf82f28a782097b309551e2c2feadae053b86efa71099178a6daf6c5df47165dae070d17a3c3c18490bb63dee502e74a1e646353575ece96bf5938a0c7d05e3eab387a91129475414d54dbadf043b024e10580832576b7de05544f5e8da82f51711ab17cb4719b06c9d0cbce1f3ed7378532205911c19d8053ee0ac3b6b6b2ddf0f2e5a2fe888709e0a9e2fe2eb14df564c3e3123dabe39b07f1b7ce49f902e93ae1baa0e657ae67da0b932c1777b5e16fbba6215f5b37d75c89998aac95cf41fed05f4a3e73346bac4dccd072cc9c39b58671960cfa035372088805c150f43f0946628c1f63467794f8f1888994760f5b7ccb28ca11d7341fb6b8dd0f3a9f9ea7494a83e2024ceda842c1b206bec823fb40b2cfb78880126da0cfaec9f7f0033946a39fed5f8c0bc33dca4bd0e937a6ead3860b5ea4a7fdb6d674503a7c2f9d737fd4954571dfe4e66e38a68f2943fc2eb2e5a9084eae38c6a60e78b82688a4d7d8c5b8be79897364090a4308546be28105898e235425de1fa79de4bdbbe2198cfcd18981848e2080a3de2f766defc969b08af2d6682ea64b880553eaece1e41326cb3eaf84c4b9fc43e524ad676042d00b7fc2e86056406025ce605893bb2f3920a943d0b51fd2b7351a0b3dc5c9d33dd66d3ae0312f0e4b01a96cf7efd99d8b56caf03e34133459dc2a6dbfcda6c7b9245bc6473f9ac74cb63a883a49e660a3e7e046984b2c245b26ba49375cb4dcc81db4e633ead2549711571c1eab43b60b64bb384bde0ae9b59db3d159f9737e04842cc34521d1484583ce0b12082c98498c4c44d09aed69d091713ac4d62c74f7ab417d267e6f82f0191f210a7f93d4d96097126d490b7d142731ef8f02db3abb92789986b8ef8e67e0d794a5c5a88e6d2904fa6f1c1a46d1094ef19ea4e866bfeb142832e076b1b2e8c2d65bd5622dace511df404caf09958bb65376a693a9e94c368cb9ce99dc03ff1cf0c84d35677480221473a70ee98d110b6535faddb2d51ada335f765f0afecc1844fcb16cfe3c8927657ad354c46f38176195fd8868eec8e9912d4730f4dde90c5f4f2965be3fb4f32139914c665905fcb4d4117625eb4638c3828a4a34e38a034540ba6ddeeeab90c3bce2c723167af781f4700b55d4cd9365504580877363f19541cdddc1007f4b5e1700887faad7fa2c082ba0291fb72eb2404d8f20b2355596e258dd8efe3b59f3b37df89d8cf0f9d80c8460a551ef89f7f7c8da83751627e72bab49f24deee656af048dd27412fcd0250704816c9ebd0eb613ce5d294c0474a7d85279bb79e00b69a74086ae21e139dfe148ab15edce90053efbd6010b7bfd3b7a0e510a6674532e33e0ab1156b5378afdf144df633fa4584532670d9a651e3ec1f5986e7eae5fbd1b501b01fac56f9bc3548d3feaad61c14603fbd3b9698f8f4ce58eee984a155c98b6ab008f01a716cd9077003c15516dc845994a323a19b9bad2df1ea840a0455b1b00755ed404a10f17c28581b8de682901a3cb56300d0922fbef317ccf5606a6f3b6f1eaf2499c4b60935f2b8078440f27f7fa40f65f564fef2681ed74ee74f1ede9477b2ccc177c18e31433aec25b65faf171626deb91a2e8378203c02a6098e4a6d71ad8c0a49223fefdabc9a3e4b7da7f59dccb8f3b7c2f4a769236d5636b4287dda840008c0da1d411a7ef6c9e3c245ec50c4e0286d389a92a6c0b87f645d76dc851924b8e9cb7aa924e081733dd547ad1c899d2a64389dfc04cfa1cc5cf5c975ed4505b09119c94337223a26015c3b02b228a943dfcccf74651fe0a5843a9044cca0cfbaec4716ed00172ffe4bc49d527720ca5ad75091de16753e6bbe6728a5b97cd6cec2a2122b50e3dd0030589d2aaa070d5a12fe2e5f44a13e946705d9a9857981c369b063430905afb583e97ee14d05986847789d51066a3c996ee8213f235aabb41c2f0c180df473fb1573619e28635886c44106a91544ef841abfc32e3ebc60fd24ef038fcd67b58507640ad59f95f5890e22f35f4dd6911ab87ea3be2f3b08b4d9e2ab44c0b8ceb9501600191d9b8dd83b0e33de61db1ec53ecb713e49a8d121d762779f286649f22374b58f50225a581efa316044a1a7c19b407c1272d1a83767cf02bccc85d8990682645ea3dc70a3f569751b026fb5e1796782e22e866c4c63c38b955312e4add2050e2e40f0279cfafe14db19a0d580eaddc6417d2e98650bb83dd06ee5204a24631d125d48ad53ec8803b640512385a6954ad749ae3b51cd67db84d981a9bd575b1a04671bd1996c7e7c29ec8235a5d92120a7a2de47bf551d04b1688356fccaf30f7ab722b42f9921b7a66b79c043a151a9a845e72027559f3e23087bb1f8b0d551e0772652bc11980c944431a09be8de03ace881ad57f8519ac1e633ff168e37fd6ccd41f3a486e7f424372e14bc5e038857f4b58056d45d5dd223e3c1ace51cc76aa139a0efca7125865babf426db92297a2f265905699bde4b781c339f10b0ec5f5b980742c3b74cf5c07526740b08228ed50fef0afe93c62d3a3b9c3346d07bf9665481ec21eec15884f79433341c14c73150a692f5c368ba8b2a1b152a4985d790523682d42e82b0469afec455557f66195b6e8f112c24f66699822fbf7cac26afb87949f0a36009b8c15023a1c497652fbdcae9828be85f1cc92aa5a1962b52cfd7e3ecef4013b951caff6bd44a7c5687f3127b10acac12bc44e0db4d4d280c0cb9fe8e3bddf23b63cd623fddc524d1f7fe1ea46045324d88eb17566d91a0d341528efa14a1bc2ba57f9102d2497e887c5484aabe96c4fb9cda1dca61ad5b83398bb8c412ba2e942214e62e6ef4c1c4391e2532b5ac46878418941cdb29342296114b13b608119a1f3a6acbe0bc22ba555b036fcbe44309eeb7df9d9cdf18a75f0baa59a3348ec62c7df631fef645fcc3fb16fab48d4ab9a1483c8d936b69b4c824d85bcc07cda4d19bfc085552dd2aae80d3a272a1638aebd752fc06c019cfae6ce9b22af06e9aef5f0cc5ce35ad10fc1716a61f2be906d2aa4203d255ad6950cc442822b205ce4c2c4de68ec6185d2d358e3fbf5f4feea311a5ee27b2d8d8af61fadefb333fcf1dc8419ae77857b1fb4ba69852b78a80f193f0d42c6f6a40e0e4d5f189fc16c91b7054a59c3b486699750ea787d2e25d76179bd5151f881ec36b6169b02c35e147d9fdbdce4a2dc70135ee0efbb433ae9cf72348d03957ceb1831faabfb23b0e46efda6ec26e747a15d48c628353784bc2466e07d70528b65ecf7c177511bcd010e7009f3781a1beed7471ed17679b5b1253a61a5442be135c2886efe071581945005debf4335a4ac5a70830e5b5852f888258fa8fffb0c5da1ae2f48c054fd84927dc744bd94eded341057b3d2d427af1abc9a6f151045b41061d76fa9ceddd27c934d897deff866360b1263bff7f7b57fd8256504bdf2c34d3459cc6aacc56a78610f7fcbf33b03e49b7e44ae25b0d3ece128f8d0526dcdcb90c14c0522efd749838b21579d2123127187053661d4ef92470c1bb3d2bfe3142f9bf3b69b46ab3148e665b78ea6a1238d5da3b70e3bcc155d05c2f221f5ceabaef63f76da565ba745d84532d0a2070f7164a637d609050e0f840c88ea01ed03b1dec2c48e038e70523761583cb1f104b79933a215ca14a581f4dfc6a88e28b6b148e3829bdee15b7096205b483bdedd5d8f296a0653ee5e6c401d8dcbf6f6448d471e1d6a0e2cdd20cc5eefb59d860f2e531c4ba25c81e384af962cf2f201a50b594628d73ccbb6de947bb2faecd9c0c7392995b1632c4662003e85c6be8413c7d3fd4ee081e50ff308eaccf9ce0617e859c8ed9a9088ceffb52a8f5c254cae51d6401566600a857ea35c8c7d4805e5a69a020b4c8f318e27d00ea3b8b76cd4de76309f157c24cc3c093fbe55c81858f300628637a735b01292966f513f0ecce17ed4c1d7c3f75f71e6e929072775b02161b8bf075245768fb68b634e8698020c04672db8922778f546bba87c0a20f05183aa281e789418baaa6b5aedb020f30a589d036598e7c9c5506a93732079ea42e5a83d1d3f8961d87a5b59eaa57f39f472ebee20f696a1c873c57030bc715f16f574bd5ef855e3423da138c2f619958f1f88843ca88e70878b680dd6eb5137c73eb6017df80cde5ed8572c7b41b646eaa6e0653d823e61f957df134756f40c378af26f3a3d3fa6acf713a6697bb753ced3bd9411b6cbaa4916f4a17deaab569d320139fd5005b72f583594faa34f52226c7932f2094be3fdffd5c952396f91a5cec4934b26a49ec9091863ca44d207b5c1ec51e1e41c14f7082b95df12655be1e1f72e4f801ffb6ba0b479e1051a479e4f2641c2d434364fd4218bad86226cd93e8d9234adad1fb3b764434528a875063ffe240bdddd27dbb1fed9ce1d23cbe2e326ba86a3fc7774a1d210afb5047cdca71b23ed7f4ebc34ef0199e52121a20d88ac557014819872a6182dd2a1a2d0913023b33368c5b8ec90e9ca94660ba63707b0445e162a1b2f228c1a0cf4dcb58b0e0d23eb352bfdfc307398102fe8c62f41dbdf9ec69d2f220751ba55aa31bc1a71a463bb7a6112c0984b41fa2c1283049f1841562e3c30f91ad61644e813226950b4d3602995faf5b2654b3f83de027a91179dd4c525b770127664a65b38bdf8cf5d799cda28b6cf9e2ba41bffd9fc1d3f1f973e9c00e0dc810bff90e0a64819118d7b6e6939362aca08249de6658dc2705fa820455f855b3f879610e89a47b1ea5a137488ea245ff74b2954858b5e9b63e59ca2880f71afa627a0b16f29d5cb861ab7f3fbb52ccbefc350ba5322da3cdef4437c3d9ccf0bf40117a27d9cea961b95529fd3945b0978a6d630ddb1ab2d573f3b4480d023123a0e7f05b130b9fcc9948d7c805156f910694e8467ce46d10463431a67bafd53ac492f277e5079fc660fcc8bdabac49ff1c2ebd449f7a706e71c14590a018de4839a0b32ac6ef6fc55ce9ccc9dbf057b2a1486cbd2ec049e6a1bcd24eedc9ddd4ed0594dc8a4056e081cda16f8dd5673abfbc85c62d7adc8c4a344daf359212dbfdf92d38a47e8b87e8c09db42b4c20307a3d2de5b5c782781a5562e0efc38c3822aa4d60c002bd96f3030fc86a7db1e520ca1787afa43906c00da285a6318b04362fab23f216574335c638d11945b0bf1006effa61870fd2a75eb2b06a785cd75755e85631b3e85a7ddca58f46f79c634111a5126b56f2ae9f90b2e4e2d26a256d3de8131cebd699317f275475369f519da2f0b11aae32d72cc774cbe7534636bad3ea7da573ce440749a98fcbd0db8616988637bce0959f6f8616291aa1df0807920253c68c113d7b8fae1e4c668b6ec14e2ba42ab3af08a299ea4f1d5b45e0e7cc66b60f3d5bbf5fdc3e46772cb067c5a5ca35c764c492bad413142b5d036ad0ce1d047e7e43d97a305f02718e8fa611e6369da2d166f2ba1ed5af37b044831035fc7a15e28e62c93b06387d71c1c845299d22bf8be9bde5f7ddcbea6daa43de11a201a24d456e61fce5196be1b09afbeba7c5f65b7fc3231cd374549b20c71950258bf17360b819b9fd4c5397490c2896e24551e8039ab3f0668df2e00ec0067afc1cc1602e74559855de9ce83c05b1de88f2b4c6fe2320ec33687c72abbbc9e9dc47ad246d344a0811ae2a47cd864e000cca90c82eb368acd73a5a67b26dcd2f00b778e0c6f8cc62197e14b7aa009eb38e4be0a16b2bf92867df769d9fce8eb1d8b0883646a3d057aea0ab55335eb0236c501f2fcda5b75b5d279693aacbcad148e71cba374dc3a519074012e80ec1159da6855921caeee439a391a06165a9ea189f1af4ca026e8d99885e3b8dd276033e1c0deb6a6d8c835fbac09d41efe48641eef5b18e1574adb547a4cd64982a6ded826f5eb594e882097bdcb1a4ff9f7420345a24d1ddcaf93dc00cca0d4487c33aa3946317841592c72331051479a79c959940733906fdef196aa8f875b32f23814b9b28195fe87b3e5dd42de091a8e11f57ee41bd224420230bf5d72a3864ba2f2ccbb500e1dd984e6641a15be1a2ecff0cff4c5502a25d5f2ae3c62bb8ea4c7855492f161c83f75b1b0e81be08483683c2db58a2659b54569c91dbd50bf8ea1415b12e0e80cf53533d48c08a1a343aab3db8fa298e8dd21e469eb922a3745cea798e2290641228d40f0bce5c0540e268cba33fafb6c9a30c8ce84421131a92f849d27ebb692cf642790e68dd3388e8adfcd8fcb77e3116b3d871ce653fe0c5bcdce1a3b91fb54cb4076ed4582c77e970f2db101c1c4948d76307abc566bf03f1a5627c77294ab5628de7595e5604ab8a4bb02f5c6ed66e24c060e58910f0e1aaa0ebd86036d165c8672c1a4ad4868bc746bfbe773f79225b002a0dd155fbe1deb5165909befe30510d88cf2c62db7770b9d36d84c48b46f6a6198544d664f969720ebb4969761b62aa1dd47f2e5a4ac1e25756a19deedffed16df7cc0319416819cb19b72d1e60ac6d64e1e30da4b5eded26c46653fbc2ba0f4c2e5782eeec4d0a77a65919bdbbd03c9cf6bc95c55903651b775e72552c8e7d12329f740396d948a3e3e5a671bc55f0d1b7e65e49269532368d37e18df8012167ce28a6405ca4ad35522139d159323952953bc447f429c979e43c8361d1a7771b6da6a34b71081036ad7ca814894c435968f52a352fa32f7db0d6cd2c4757c538be9314bb065ee9fe8286938ea6373f999b7cc37e97bcf547aa4390fb252ff89367475a7bb036361756f446fa2abb8f10d25735e5e13212a5df46490f4ed1abadeec0e8817024b9f4eb9ce726c6cc56d367a66d240a3ccf4292c1c2afe0329ee57d7476a499ca7371bcf8a2384f9995d9f749d294de3dfc59be3ea9e0ec8e8f5a5b005bc6b960c9063529cf5e53567401c8c0644e65b0b3dd25bfea972c18e44263f18e6cbe136f5b0dd9e4da2e50f2852966c0f663195e0e8cd9e86a99e16c1cc46fd11b4fc1f014bdff130f4b96955a6536c74bcd05a9fffdf790356f39da298b541c5336c84bb18088f866e3f65cddf075ab00b985074b02965d5d659053db26272106dab45ce2def417a74d92afbc5d5409d788738646f0feec9be4a9f7bdaeb13e97411c64a98d3e33af32d36a2a10e8fdb94a3af8388a2839938067bf1eecb1e9391052af6ebb036cbfbeb4f685ac64c6b5ef0a3d519016b3f330be83e5042baf536a4a6eea86437cf89f15a165acea511c77539fc34881e4e5f018359da5017ae7c946406bf159e389eaa068c386435ef4e473f392de20db07458dbfc46e581029aa63ce6da11dcfa1e496f4fd32e4bfaba08acc0fa99ce009d442cba6adf6cc60bdb316c3a9a3da13f15b8c4fec927fc3b7a1d37cc5ee1bcaae2785faf30d8d7bfd2e57cd0d628fbf6a64a3aa20d08170f86b2c73428085ccac9557e13e11e5326cd38af9b2fcf539959e074a7a93be2182eff9f7e893685f8c361ae97f0562b08f8315836666f04ed1c67a6f6ec999d4dafda8e801d4214e8c686bb5ab1100ea422b29010e9adc144e3b46fe0d3f1d42bb643367ef52229232180de10270af869ac1bbd42c120d8c8431a7436c9f59a111ed1d2043032ef263a5755928046a5a425138d1f3494f9e10fc0e6be70f608fd39db741b5c88b24af3b298dd2110188879d889aa4717548928d5f11a5186aef35ce9b553f3a6f7d28729788af226890764b29080b4650a9cf0fd4cbb5de02de03cd32fe6235a78c24339c56b3e42ae7d05e041be6e4053fe60d2f9af229148b12affb9372a22bd513844ced5a774e654bc5875e70c31cfe220dff56261dff1ca1d881d26ac4ea44804585104f122b7d396efbfac6263bd2fc349ee71b6666c14364fe70d8fd5b7f21b1ba4d032150c751f38ad6306784e3c620fd6e7f02a5e4b29543d91200277c0a2f3f8c6cf2746c6e998b92db16d88c0ceac687b302f06009665ab8ec2826af04a46eda3611abd1a8b8b2907654efe6b908c6ee94cc64d29692bf41bcfab9afbb8e779bcbd40278b46de59988e6bc3d2bce420ab4f14ff051ac339c0df2ca318bb8f7e1cac728b9e2521978114c43a3923de66ed24e7255af316d179f2258c872a6ce738e4e5328aca2a235d6806049c125b69263f783703980263c8589e4c5ca457aa28a4a39727f029340bbce05e14278ad16a1329a8202f8e9404f93b0c01da99ae8cf35c45c7013dab3c0cdebb2f69cbc3fc372240eb536457c3494c131a0dbe543d25eca51573d8c2c6824853238a222084583faae3349edbf5d0b16033ca3d245b6903141c70ac911dc15b1651eceadb378ecc575cdd8b66f80ee3b4320fc605c7ae1522eabededaf4b47c5714372f1059c8bdc8ba5c9ee7fc947cb060c0f85e833a8bc56235e24e338780923c995981dbf1e3173c080e41508985e64e61b975947fb6bd13a7733cddb4c3b97f8f9ceeb470049b91da454fc48da0ac275144afc034c1a32ebb844678a7ff1e9581d90bef762bbfcf91c56fa932734c00f9dc0d5e61e99d3d27f19ed7676cb7518cb89ec5c7c301bb59a3134709aca24508692644f45c51e1f674fa2627109121eccd9c4096a47493def8f6af003df057fff2d1009794150e390fb99803422873aa065d32620fbf877c739d055dd65be655a5af23bd48f505035781cdc1abbad4357b92a3be7b678f4cf25fef35ba6868cbac099d9790bb6997458a031064c3dc98deca5982f5bcdb06ecf48c08e8e5ca845b564d8c8732b5101f44becb6ddff43b614dbfd4eca25c3edd50aa10d9fc8dc385dc0175804012e795b8339488012bda4c3be24f96ef64b8a423fe25bf61502c154a142b79c321a1020e9e47ea0d1a86409d5241bbb2dca8d6d969dedb85d4bf0fe939b300cc7af5451d34bd862854db8201635d1a9a58b69c1cfc4b7466b2a095d2630abbd89cd918a456853eb73cb8e67d5523cdaba7a0ba74d58173afd342f2792c5dabc8b898a527d03421844dfe998e71c8f10bd779b2624169ad13276743ecd047f26a3829f643a0497ac8bc90a0895773db3f7c924115a39dab99b8cc8f9f46b0f3a21643fb2c16a15615e0a5e854977ceadf14f3f36aa403a53d0ccf208654fe51c98528f903312314588d397664ffd925e2fb10bc8d94145b969980239b5bda78e3ba436c266d8a84fc121d6c40db7c6bdac84c4a10d181c9af8e3b5dc1726553f0d8c910137abbea56e22418f623f0bf0235543559295ff2fdc9ac911635ea47c8b989adfa7b0b631e7644ff6cb04a5b35bdc5f0b5635175e595ac86b841ad97c7ff7c76ce6b2214ba8bb19147741a47d6d5eeb43646ede88fd250611fb8e86edfd29c97b02fbefe530184aee581d7275aeb5c139bbca2ab77ce17b9e4e53c6243ba613cf6f8a3116f25f671ad14a0a7bfe208630f410f824a6a7f888bbabb6813307f5c975f4bb9ddfcb7f8b922a081b5c1aa15c28a4d88a72da1335d8be217af1daec7aa30c34cd02ad4af466430c89047cbf670833a95f96c9e6eb157c867bf0f141bb9fbb3751863bd4b10c69d0a1d1f33ace96e9af1aca7a726add5b29ed55f4286aa45b62d0cd7844700b5ae42f6cab6c109979da70ec7e46565f0bd139e01ef22171f259fd28aa45ab2d2fd9bf33473d83a5ff214b77b46e7d929654ebaea84531b8177da8c3b410f67839901c3b48571a5b014a94cd452937a38ebe5d02dcb1a93e9e3734b3b81d34ca3d40b7c3f29aec93ae6ad35cde2f91fe265ab7b95a7dc5f7914f30fb2cce7b5c553ed413c2203a7901af756b136227095509518a1fcd77b21b66d520a5be70a262a6d60346fc0dc3657716f677e81413f65737b185d6987773705b00b0c290ec2cf31c1a98c14fa041337f828a25826952d9e7fb8dce90406dfa1cd3dc821b45cff6c9b2ee2a959abd7fa52fac6c9dc869bd4287bd279cdec01cedb730b2dcc986649b0fa2557437f3b149a5c81e40b6aedf2db88b9b8dd741aa56999c5d00e0c230ee393a5bb4794cfda7e6619f3b9b4b896922c90f195c3b3ca4d6e8fba9cd1ef5eba59ca195e803abc7ed55265c225ba976ecfd637f57cf53038175ebb7acdd9dc6bf1be6785ba63a1ac4c15fccc25aec22d0462e3535487bd4cf85a7aa7515f3b82912c5ee73f44b70474ae556b8f62cfa2981c55f800f93f67bd89c8c978ca1b14c8d8a806b283ea634ca2fd843cc58ff65a0555edd92911c3d1715471454af39a96b40b848e5ad0a022fc422259f9ea437cba302401d0e05296a663c516a8c43290bbd831ccdee7916df61adb6e72bd7019407d2016713e3c7de520be711f013e08161e4f56708e33c2ba9cac7e2f2b8bad1ede86958317eb6e18a29b045a0e9141a64e9ca605b55c27a3a848c720dfc23e562130f859d0bb7d21d3aac3784e13f1a826737ba9a6add80da8e2bec00d7635f7da7cd8f43510205d2e3b5cb79b4bdae77742c4d2419a18df8cb920285f73f4fc0663371af8968abaca33233419f98a6ffa908792458400d89e52f1fbcc84301668de8795de706587f5f5c28770836bb29881029c51f39f605f0aa08f7f250146e6bd519191d8718374d167b051f65977a4975ccf5e29a2ec5eb1179c09e659b5d7a67f2874f28534dc62c632a441706d6648b3be2923795cdff087dc1e1fe1135e750dc2a0f519dae501c75b6170a11b9323a9055b534d7bb4320f1bc3d3145e474ea044c9563470dc87401f8662461da91d1beb67897525475c8a191b0d511444b6a68d6114931a7ea0ece65c7a984a94d50c047e54aaabe77af321616c4bf122966fe2a670f2775f65e415c629722a84a157be4375f5f2d6e2e847aa1119cc174f7c80ecebc234c96ef249eab29ab2d5077e708035faa0c311f844206f837d93fe1c68eb1f0d83ecf0ab6b140bcb7484acf1b489a03e50611044509b7cfbcba4673973fd2d35075347800450b1cb91290f91697fd9f23dd5e983ed223257b90e52863352cfc84112f8d1602698f27f6be27819f31783003eca239cb3b77896bd924119c2f69aa4818e879918e0b799b36dc6752c2074758fdd28c625a07bd69c3a224be9db8069b71bee97ff429861f6329278edda8e69ba359a3d1e1ecde48e2ca41454667eb9e6f30b855663784163bc07b72014b0ca7417914d67ca0835594baa4b0f523c1c0b5dca320ebe02a7585972a1911470910827c7f675169097a1ac48df208765ab3ef79a5cffcb2ed6117b2ac11d7dd77a3c155a342f7e13019a90aec88f6c562ed4830a1be47b35d4019d340cf62587f5a9de68add07d4ab25399231d10a055ee2177941872acbf26eb74ce1e16efdcfd951921209b5032bed2de6465c21668c3010d9749ff87d6cce48696936f2cc78e3b513a6f4f91b86e61df2c4335d6096eb5dce894fcff66ca203069f563d4e7c52007c02a054a864155cfe02dabcfe8a0d049ab4a549830171679547608f95671d90b5465b4591482822abf9894385090dce471428612053f77e800e0755390335adfb1dff7195b45d7f12838de8ef595bcfb32734d2a19cd3122b17750147ca9ed17b0fd3d94caccabe789220ffdb3e46cbe67187bc3a88b90bd2fdaf791417d750ac41a70bc755023b3e838549beca3b803a39cec21d756730fa65803cb3dd520da31bf5abe3cfb2598d9c86991ea14a9f2d0d44a6342843e7c763a8e12cdd7be5eabd971a044ddc3fbe80ee4e88a985c0ac8b4acfaea9612ac379b17cae2f07bf5408afa7282ed90e34fe3e5abf7fb554cb8c15f51e9460989e43eea2d856a6e1499214db2fab1e0b6af44c16c1460edc4c92be344952a6739bab62ca70765b6151cf92730542fa9d2d600b13adf7e2f5a38dff2e81e0abf545d461bcb331e81504c2190103339fcd6bab4408b8396edc1d12b3be95ac557edfb42960fbd7e6be19fab4106e59761f040713a8c634bb7a4509e18f47a52b7e3f77dc7c2d57694ec57931cfd33a70135dc57c80507345f0ca1822e004c2963c8b1cb85a669a8139b903c5176b2052d4e89a09b0578911b178731ac3a708d0a6886d76426685938594593ec6a3ef859604abe328dcc73773e1c2910fe5f1940546764d913d1d0502fb26d965bd5b295c25cde80ac03b17ec4d25e71b2e89b392854e62a0c42abd6b35cd86ad4298a559922fadcfddde813eec13628ac9f097481274968ab7a88acbcdcf7f772b1c6844e1c8695dc0e741fce98daa60cddf37fd88035952757d6322adbcf4f05648725cc6059e35472f8428ba651f473923d6bb6d2b58615f3f60852c9d5f6c8fb2fea310007adb0bdd02905619a163885c3883d3b71ae3e2965bb485e5f6b866f8077ae83dae584499f31919beba8c39a7eb234e58823b7cbd0b8d66ec18a230adb792609481e8a82805d30d74e692460321f5520c96fc815a05bc851a5726066f7efb19b1a88d67e634b329f4a3e17063fc588ad0e5dca4c76164720140bc13991ff013c8f174f7032c7ea002c618b734961b0fdae81a5005dfe6b9df8223a0b0b5e268107630517d002e09e0ef4c627991ebd6db8248e047502bf0aa4658b5c751a55b9c4485ff1b1ea8c83396374bf2ab47c7a4d8eab6660ac6fc9fd5279d192171054dc0aaf2de2ee4cad47f006ecaa8d7c8caaccbfcf0f2b888c9cbe6bdd93acd34748a11ce3d633c22f34f34285b323cb32e339c9a23f0ad9f28727eaec03e5b7fbe063a75f52d67816c852b3bfdb31c15c31659f68bd3d60b21b209e98bd1f816bb873ced40e953ff5a842a9f7f37bab4130d8e843442265cab59b12c862cc6503e03efe9087d7d14806723974fff7dc836eb2d613748b220d3abf8662a6b1ad62318426b1ad4ea1ede55d42145fc3e8de4274a788184e821cd8bfe44ad9aa7a5d4a4883c922d01583a3ef55e74330919257b4e3a9ce570b68c65c4a91b4b8e1b3d8b4fd0cd118e0af3993b5b06122d52142e16f5c65de50af0ad4b2a0b19f84469ba88e9ded3cf888272be6adea2a2696cba1a63664c168de7da8da0f46a736589eef3c60a727bc2e05b3fab3e619aa301882838a69c3a2828dcbe376e551bddba7fc760ae401552f15e3500765b46f6bc74f5d029da4e9708b4a446bb7022ccf88abfb1203b35e213eb7a11e980d5686c11ad1feeaf4db58e548c6a247ced7e624a17a53e56463c484b27b31d870740e94ded4ca5194dfccc5a2004914a3bd0d17fd47faae43e4a6949654b2a535cbdb9e67199806092f699e31ac60762eb441b6c74b0a528d770f60a60eebdbcefbe047323812d14baff27ea62394dbaf43f77d6d34e9075696f75865ce029ba6c174e6106eb34227efc4c937ed909eda05aac0c4ac7b0b8ae4e9ec90ee6eb5b597d2f7d09aea935553dd3b9af38a0ccbd1c4387af2a3abe27230b8ca95f39240b0f7a6a30ac61a031b3286a26aeeff0dae79a6e2952c3f2aac4648f89335e29d4825d220bbd9092b245af7000e07311ddad0b6cb72d449ec1c1b8f29385cfb6ac522543c8a7310fa492de22533ba3dc3982b1cfb94ce0f812bd3a585a534ff9b31e1cff3c52c0ca1bd436976011bc53ac8dbb4c1a1b1b2aad11c89369cdfda69e15bd26b23b9045394788c43fc4a405908d39d06a9f35c4bd0de56fdfbd38a70d0f458d87cd8c7a087f63edf8501a2bc34cf89829bce176f03ff64dc7c01fd58c961686ed803ef02bf2f48d8aa638bc7a11c6d4118b52f0678ea0b6969376c361b0f3f96dca780ccab7ff1c8700944a58df7f0b73a1e41cec12b61665644c756bc52f30f0c38100890078254d7d48d3c9184ed93e6d096db83f66d85a9e3095558ab208f67aba7b0b833a324e61c90bcad384f052d336d3dd6c1037c62ae7513b9e70b9395e2f7c57e2eb9c8672d82b78c53fd14de23c818cf8b049431a0fcaa8ca198d934518fa1e6ebaab8a519695136f7a19207c436f470c7ce95744b059f18b06788483fab3056acbed4c5ecbea8c89d566486c5f89e33eced4a3b4a5ea8ec4e50d310c132b3f005067bd6bdf67b26bb0900cf7638f85297441057dd4757cdde1b2dd6b9756f019f0aad4ff3f3d369cf6e73c0c880550ff9d94ad94757855da0283cdc60a498bbf72dc1d7a272d01e58fa5b44d606c14b901c2cf3259ebd8fd92df14431593cc98d9c0eae8afe28a950eda3feb23477054b481c670c852017217f7fbe36cb0cf9b7c8d9ba8b976e23261d0ad00a2460e465b8b652771e35209d7b43d58365b6f75420140b1e8827b0e1b529759d24f2d42a54e04b2e98a0d3ad0297534d4a4e5385aae67ff6003547dd0705e7579aad248b31179c353cd3c6e81df0c21f4995977922d65f37ac0f342d95bf86a52671f12170e025aaca25c8bcf796e9fad7a3499e195603fe6ce2806e9c51e32b460733f8d419d734c0b07daee0539663a140def5cdc556fb7e1e7464a893a0452040594e44db31535c729d790f23d4b87b724d280f243e269b4bcd49d45e1318c1760f2a1948e8cb6cd0bf7166b82693d1fc1cf494efbe578edcfe266f280cab9461186da56c611fe8cc5760463a32f7bb9f54a86f2ac86b1f6fea980b3ed5335b07a88258210a2cdf24d554f1b96b1482623b935b6e313c28144baca6724ad41adc00ec0089d559d354a14e519c607157d98f8dad37c4243eb219e0f44b7459f86e379f2d9eaf57fde6604dab45d0df751b2fc0a4e4928921c74804e8716da2073bc151a124ee2aee4aa44ded29652f7d7ecb62f5d616b620baa5db4cd808ca94678f662ca71ec5aa6dedec57dcc25aa16ced0720f81a3637ebeb7eebd41e4bd32d74099aab51179156ee2c61a1800db80e870fedfc0edd7c47fb4002aaf25bc58208e947a42008693b568595c1350e3d0fedab72adc66b2a5bb7f24217cfb1f386140a2db4d482b4e10283c04965bbabd738098296fff0f0e5ec495bd361a3c05ed80fbad32b03299b48296b919eff2aee381a6ca961a63757cb05a7f60b2d054bc831aaa7b2b4c01b3d9fffcdc8023446041f1f3819c27b0c62f4a7ac9ba7579978b4aeb317cf021b3455ea6e7fe6c3a097d0851f9754215e280624d51af7d31e78c4707317188dcbbc7ec2d469e0b6eb7614f9420fb27923ada097a29c3ffb39b6987fb02c35c210fc4364fc62de4440acd771086901cf6016eac7ec66f8c442d1be6510c32739ef8ebcc0d3ca09a624518c5623aab8dcd3ad3e322253680e1b2de483ccb5c98dee5cc460e4b3ebc5f3ec4177c0b5d712dfcb5d0d74deb68e2d06286907720949c59b5efe76ce461f3e9a327ea4bc1f73cb9a82fc049ec2e7b83c9b8fae23d79ae63b9bac1088bf848bb42e0ffd6aa903ea51ed6d4ef10eded6254436c4375673e1713fee3bcb461371851e2cb6aace362d2f73033019b7d042ed34ca379e3c51ffa557a6649f291cb344a9675a6aa88bb287a96237822e9a3be34d188090224e3730121984e075b48dac3f61c0d0fcb9bea21d715eb0cfded019eac380edf004b8d0de31bd87908f45c4b0aa18205d29d94078ee1b340e5f8028ead6166ca7736396a2319aa70153a9c6a4f92414e308c5d622d64f8ff593e896e9d287d269f547ed59ff95ff91d67ad9e8ae915a2edcf2e12403be0c0d72a291a198495c4675a82140b63cae63d870b5cc66abcee1fdc6cef93d6078b25c635b0e0a67cf7a1fd026a62724c22754c9e32f64e6b0a379b0e8d3cf9f360cb40d2ce8b19978a84881ce51454c0919308f3475f465837d515cac278aa54722bf7629d36b6348f684858b65166451cf5f406f7c0a8a4ebc23c0a319a386ce6319ca4f78c34800cdeb5d4dda069980a6c45561c8fe71b7fa2b1534afec33200af27b4e3ded813b2e434c93d0ed71b416d33998cef35e1dcac7075ab8b7c01b9ca9c08a2d15540a01db517bd83f22418f62753b75f39d097e0f7c7038567492a2aa5bf8dd4b89673fed1246961849cebbff9faa5e92ccdb1cc66b91bbcbe1b267dee2003d765bc56af90d478903f6028ff89bbab09277f3f9e5fd1868e3cad15fde2485bd741d84592c4be169b99da26586f1f1708503143bb1a7f7e962b261fc596d4dd7493f842dc62cc12b9ecea7c4c7a9b53da8a2f667681b1a7fb10843eedff51c93fc4c1f14aa2ac0cfffa4049d5f098621b51a55b5b4de5abe44179c2b6663244c9c40fc496c39353318237bdbf3bf51184af76b4e43aaf5a105b1b6e1bbb211d5c0d04df5b5c8b0110c4a7bf5c2d827c1ec0d87b06ed9d04d73f7ecb8b8b9110f20cc1580784ffcc476f80569e866c9d1fcca6866179149ef70c5f602fb89c7f9e5253d46ab74b49f9268b8a61e0e3493c9100d3d34851abd7762027ceb6ab042582005e8bd8d71735784db39fc733d0be65e1d69aa69883daa34a8241b5e976b757269d0bd299a429f41c071c9b5d25814737c90addfba3be370f6062f44a23fa9b702d4fc17ee668309f91da575e61e49e70ae77abaab9be5d679221f59327194e518024186459a5ad3eb693877ae573e65b698ad412db5a3467eb323d29d786000f188413da55e48f7cbff4e625bf5a4298f20e015b931aed0d7de8608f77bc76de8a6e5d7889b3a1fc83aa86debd5bc532dbe2786e42bd0cbb98da20e9cff4a696252b16ab293dce3ddc916500a22ce376bfd4e0605dc696f5b3636657f923971c2beea6897b7af4859282340acba5a5bc75fcc3dd4f7df545700eba98d8d88ec4222ff076ac8cd88077ee94d43d5b49482e83f076ff8b92cf4df984ec99d70c8971b7ebad02e8f0529b7cc889d9ebb9e7f5ca72ddf2a59e77066f8f6c158b835dfed60147f8dca83a42335fbc105c3b178aa02ed2d21d1cbffbab68fac4cc7234737f8fb5ef9a7aab889494488af2a01189e1d8681c38c9fee1b14e80c8c33c23239d59f64af0b95cd70ead15f56771c8fda8a295aa9b3e650b021693ba0116fd0125d0a988d0be246a434a9b468136728c72b5974bc3e539e7c035ea2a61a8fb8676784620d52ceb67a8e94e4b21ff5fd41fe140f3117ae38201f83cd09377ee35c6b553824c3adeede1e748bc8a6eae4f519abaaf33470924093460a02b4cc67c4e05c87e0613cd008d4d49c704c5c1a393e86a01d82452448ebe6cc7a251c247519f67a86041ef4ad5924792f3868829f5c352979cd18dc5292f7408408ee1e5769d2bb2c9abf7b91c19c68d047bb0ab46c21cabe69e509c8550c554e4ffb1493ac4097c6c2fdac0a92e7cf21a1b406f2ecfb8b48144e77ac5f4be473451fc85937309292b0284022efd5e8159dad4e8595d0b867c9d01092e41bff77815bffd520dfe05ccf3cbefb3dcd1a8b6768ca57a6e14391c1e80f4579e6e8481d47331d4e88d896aca55b85da615336472c4b1ec332370e6c67a70ab51b6c97650ece84b64954e2588140d1f5cbbd3981560068d42920112599d7aa1119546e89e7bc1e98fe6793d1a9316ea687a26e72c3cae827466862fa2a16a15b39ec8ddfc06a9c7a4256feca66658b390efe8a8ca152a01f4b7b3b433a5ad2a9aff5db0294f5072f81c5d2a983319fb42485cf602f7c88a92b3559c5527e525c35e7e3198fb0eda40f349dfd7f754c89c06dbd4778f490fde8367c13e17f3d361affcf248b3a287ddad4c1ba456ca9edcf2e243eba2fa2c92d05966e6a67a897f95ea507e1a4f3da136e6d9fb110da4d2420312d11fbd4a0593ad84f71f9b5d1c55bc96c0602acb64a0323cffad653d57bd03f3dd44bf8e97f5a4ef7994995ac3f5f3f067450572feb367895cf5e9ecee34976e09fd25855b4bb94ba8541f12e3f17a8184d5b292343863e54bf78bf3df1decb9793969458712b35cd6b8bc8615e969d1257c8105c3575f77a29f17571de5e42b3e1833182678155a070eff437dd429ba82bdb720312c72c2fbcedbc6c709e1ebbd53b2982fb3521f2f448af2f5242aee9d6acf2d000cc877c2d4c2a20ac8320190312f61f6f166a8b6ac1d753d9ed47d12d41adcd3dd1bda17b5c424bf72098fd54fb1a3ce43cf53ba6c6d3b5e364fde8c3559724f0594bf4e562e259088fe351cc095ce4dfa2a49f82e242467f610e03c58fb5f0892a26db7e643df83545215060d478392ff33b0a63eb5d0886afb90f37776ada4e75921c4a83c469e50c26766d3a826ebc5fd0a719c1a68d9c915a722a3dfa613b0e6d1bd48e9a114d769790b38268104e24504a0d2db545982c3b742bd5ecdfa647722e2bf13b29875043e9b486ae446d87d08d6a851d345c7df28360c014ffc8446b7336184a2f1fafad2184c71540c398835eed8e0925d0abaed2566212f5dc844c108181fd40560589768cc0b0860714c03138ac4737a198e5cb33b02ca3568330139afd634e939880f2a9ef37f9f9d44f7a1cd3b27fb3494801ecff11efb204ebdb7a3a52022bd07f72b3b981f38f370385902298277d56424f630e36da2bb2df3d454691d2381544ebd448e0b6c36ac6082669df480f50198ab937c059e7a7087f68aeb988192b4783675a1544fff4428aedf00d065ebcea643e697b1884800527d55a90c5cc3c8e37f0830295e1c89a39a889eea72318f8708d47ec39d5f042be4ea57b3644ee320f8b27654b61590b6b8f9ad9d51a5f62f97a9eade4b58822b60a87c24941a8cad789ae9d866ce10ca9de6e770ae886b0431c254d5bbb1951ef6ccaf77397d22e194586ad95a2be76c68bb18af57a2c0e60341b8cc189836842ba0d4382d0cfd894a58974239a64a6cf2dcc70e3ff84573477a2119f93b9e375dcb530181091e5d029e98ffb06f17c1846be6e5e6591e95a4c5130b1d8e908c4127123ea72c49d2bc95798ed0ddb67625f6037e8c7eba62de76b3a28d0c64a250b136893cc95997b27e8ceb96811179665aefcd94bc05d03621f0a3d5edc08b582635d38f70bf8226d692a57541cdcf84a135c3573dfcd0e8185a3b8b58a002f25c3c324f6185d8980237ed20d54edb1cedc5b436e907f54ee18ca572970c9d4cacce76859be1ec22280186610d1778f4c509870f09bf4a744cedfa6777e549309b094592e4d321ae2d8f0733f45a6a96986d8daf7ae47a349eb28a4585776bbdb3bff716a39e20b92fe3e84bdcfcc812896c8798f618d3e4e3444f548a03f7a38b3970824d62ebe9bceab66f50c15255b12a057d6fc4847310c0660b92fb37aeac3511f93386fa5f094036b6ff399b127bc5941be122d914aea16a72756e07167371fb2f5e1ca8c375dbcad579619a24992bbe671b74e073797d93bd23379e5a7f0fe596917fc3d2a27768bd23dd6468469421871d7cebe88cc80f60ed6bac5040ae51af187bc5258c4d9ae1e6960fff14d2ae41a2cfe704c1ed6675475d87a295d82c6ab393d6feef5ba4dfffb8dcd9f59146893947f38ff3c80b7ea392384919a47f9a747b9e04851ea1ec46cdd3b6cb07f3c3517da4be6d818570f7cfe0ef1452aabaa80c733f44df5c6836c45e235e26abea632808845da9aecfcf6c97a51058791d77dc6aa51e7754c77da99af24be3bd4da43a0b531a0a5797733f2ed7bd06cf575241cbbabb4791aed5664d968b8e55826d8a7b3f9f5c20867d9353541539a7e8892f78ff337cf8162bae95ef2f6657ee9b74e9157c883bf6774d826ee18185f11bdfa34a9960442b21da031a1777dcc3303f5276c314caecf073bf2941d973753d5ab450524932a8b614ddae9719a4d8653fb05bbb80723b685b6e6fc834f52d3b898da01e5e9cea0ffbc6a3b47c88b183775cec6293f8f383b72ae015df6feb6e986cc5ff26fedd2188a2866804c1557f695b1a38e5f4a15c2fc7e607d1e77d9d022e55734839a7564e5d02b3a0338316aaa231d275a8ce7fbeac48c7c1d31290520b08640abf21369b63a0a69e6c955f891985e314bbafeb88ea832009f912f2388c768844bd3fe4c3886f2fd4dcead245789875b4840de438ab7fe95660b329d349a1117a6d88be7d8b07a6ebc3ef9d843a5ce37a78c7754dd87907b5a117374cd622dc9de2b04e21eb0b5a3ee86a5ba33c8a262a584cae509488b70e82e5815376e08c03072579b4396f23f6bf483eccaac3dfb8928e42a97d4995e376bc34d855fcf0c3134d3faca3f22dcb7bc8ad327adb34c48bd6f363b740614e4aa23574e87b293da93f613acda3730d81ba5e612784967e73e0411cd92c7bed9813ca5cd53c5388c7111a49448af2c7cf00bb02e37e443268729cfb512ee01a7e87f854dd3264d98dbda0c601f0ca2000e022714b0b3da59fc60c25b57fabca875773b6a0306bcc681b49d986444c71eaa6c816c2b31877de3755361c4500ff6665b39336fea64346f224226b42aa2f94bc6a2bf1d1aaab963affed59d821abc530f9a6217e8f47155c6070809229484a2a40ed0724100a68c86947552731a3b184f876d7e71d88da4e04c1381e775ed78a2df221e63eb6629fcc3530ed0039b3d78ae9acecf3e603ab2f7bde65575e64de5481e114a2c4a04d58de19e905d42fbbc3e5076487728f88edde5e90ea5d2eb7ea4f87f9d3366c39a98afcb46bf5ee5f97773f8cd456ba8da833312af8361e82c969ef961fca3483411286fd6ec1517efae4df2d0e13720f62bbafb968f4eaccd201793a2a8ed1411230e1c2ce7b18948162fb854e847afbb9508b0b61591478d746876e1aba8a327b3fce534a34f1cc86095cf0e27cb8eb5f51e3791c9d3e8c57c6ec2227bb96f4909814dde2584edeed74d69e5c452d0392ebf12dbb44db1cdd10b815e7ba5a763e6f18328f1d8aaa471daee583154c3df936e1b639eeb848e275b420225fe7332a58e80521911b8ccad54212f248cb90d72cbb66046a450469e3e9542f15caf2307a19af870af157a7071cdc3ccad80e344d0c73ca81b82768a518a85731f35f27e9361057895296bd6b3217f718ed6db173e0d1ddc739a6dcf067e1d017e74baf3de4d3e2fcb57cd66c0fd30fc50467e5fc455f26d81bb395fc64509260d420e9bfb47382f1a2cce6aade388a48c8f4f8fc6ecb692756c2d9d4dbec6b678908590d900c73ef5cd34e2c9871faf4e0d4ff3c42f3122eb16fbea7631ab3816b9778feb1a9a082df1644acce1beb32629c7f3b6763c3b2f65a36fad6caf98526ad4b84bd8bc346d2b592e3ba9f1007cceabecbc16bfab9750d46e0bb321a46643294dae756bd5f03620b90eb52bcb24b65bc7ab8b84b08f659acff9ec9d20c925cfde492080a2b6246b4b9f5641a89920cb760753efda96c10fc24e700349c44c118a6f5e8cadd25d14f57066dc2d050512f58d6350baa465ee570d065fe8cd21ba4861f9734c5558c3998e517dcdcd440f885fe3d5e4233c95a38e9f69b3ee0cf5b576005842d0aaec1f6105ea04999f911d56be069dc87d25c6b4043b5857e82f8a744639d1e358eacb44ef0c0e391a79fce66eafa4f6eb1635088954202c1ac0d506ea252891f4b047f28a5335431d5fd5a2a550866e206156a3ab4acc5b4e533ed0d1af3b341d760f09670fc8067c55f848843529eff69c5e2fe0c2d1aba8f11061e2a5ab78dc044e696c79daaef0f79034eb839d064de1a1b999f488a83499f88fda73b088def4848cd0200c65ae45256b6dfb51cd07ac8cb2e6f75ddf712391091706992e06a0837d05e03ac428cb61c4ab3722fd81f91799a6c93aa7ea80fecbc82da6b593933af77c63d0174553dba05373653376c473de44b6dd9dfc99f842819e24be112b5cbb2e7315b0b17c525cecc94716f5562c8e68cd725eb93c41a8be8fbb62cd1ad444233ef91047cef252c25619171f2677b62db59612687c80b09734ebd2fbca5230263da4d146195f80b8383be1eea64a5a8334d59eb32f9a1ade9567a9fe6caa5cba357dd077a76fef77e67b61dd6cd9de3d4ecca264f65fb5176bf6d7b12e553e1e8267b06ca70f4c803f0c8eea12f1ae5d616b31b5f195e5a7aa30971ece59964b8b285b8cbdac81f086a6a711ed14662821cb1a4b507b938254d5d1c5df4a698bd7b1f316c634b9a3d1638ec7cc819df5dcba7ea484cc46c198d97bebae03e1d8b4c00526d546b4e9197d7b2f33727b8c931a6663b377c7964e1aa26bf8e82f133e0de74132c32bbeb9e7a776771f8f18e44fc41036588bec28f52e68c3e45873743d1dab6c8a8b2f9a5a53758491d250abecdb7ffe490ae37851ab3f1f43e8280164e7d53dc3f3ca9820c807ddc80ec67e9daff0e92523b28177f67f2ff7772005c6fa835a13bd8b8634130ec60ea10e3ed88e77a1d64216143181da128169cb0785d126ac157051f9b75c99918885fadac5025800e5100e3d0aa5935ea4fd1276990a36a680ba41f113664306992dca20ee236b3bec3104064b5ff33319447465f708754179b927f535e9f0a4132d94ee0a8d13e24e62802b885870b9bfcfa5e87612f8e3a348ba1c5177ebdd32f8ea2900774a43b6ec0d2617118b31c22f9d84a4e7e539eae5ae65f7d809744b49fcc48caacec8236f73adb2b990f0d8fc46cc57f45fb3d2387168dbae9de4ad7e5c7175a52e4d50d386c3dc7334b94c1413ba55c7a551e1a212e9b762f3cb38397e08143c5fca5f652dadda0480e18fc869e47602f4d7573b513ff82b0382091d611941e31dc6bb6a6fd7ea800907c1ff11c25daf4e09ce802de77cb85146fb6a4115205039150da03d5dafb5b0e4a23a4df6a49359e476f0445e2ec6202dd4363b4f16ebb9ba3d202ef31e02baa0024673a2e3dbe2a62f268a342fdbf8291f3e471a1b14e6621c66467284de4858cdea79ae20fad85918516991ba358ee962df637c6daa949a030d4fa7ed91800634e7680f05fe6aa13dd2186778f135b155c721c0e40f94318d27cba248d2d007196651975b260f88be42834d2c3a26ce404f8b71c439ce2f4727ecb12b22cdf6b4a74aed3a6b558a455d2f40194f5857e263ddeeb0a2d21c2bd8ce249011fbb9c92076fc7998ddc8aaf3dd143b4b151b6eed268bddce3bbabaaaea4c7479fcaf29c3e12b6834a5af56a354f68b4a28ffeeb5eecd2a5a262a216438d66c313a04f27bb9a389e1a685fb9d6af6263d6c8863725d9d82e68b69b1b2f71dc1541480f60da5bd586b2585711f2ab78f999fcabc333f5a44c361ac38a5463d08b89a9a29654506f64a5668daf524e60fabb959629de88c917a13b11de5961d39a92701c857e2c780de096320fab4e47c4dcc447d2a12a8be7cc13d664cfbd92d0377862374fba3165c44396e95837fb3bc5465449f415ec80bd17f0800291549b957d24a659de3034950f05be4e26fd067508c43e8abb22b7631ed65fab5ac1db4ff71e55bd54b6502c35ff98135b6a269d69d668e146da3c8bf14089b65c46d1c5c4cb0e91a06b1fb1420fb196940411cdf3aee69503bf01e63340f85ff9ed45e1a81593be40a37c65822c67de3abdc29f51a4439e65c436a3b23b4a1ae5aa35e02d7fe1f1452942dc137add7978f0fd52f584cd4299331e92a1928983a6406b18760899ddd530d4de7e01a8843d52fac87f2ab5441ea985514f8ccda9e69cf81ccd26f72baa06dc9cf9d7f65190c31d90083109c94e3a3fc312a992ed427e3676fa4249e35b7d897d6c6b21a7a6d91aab6dd13f9c6e7de59200000ee7a70242817f9c8bd30f72754cbdd288e5cd1e99e53be94f3daf7579fce3def229b8f45df13e43207c43d7cd7fc539cf1956ce2bd8760be098633eae0613974fd30222b2c282befc1a7dbd018368a76fcc2920d082e67d7488a841b60e422f87ec2fd92753ee3ed59c71580b39b6b4cc7f4a601a54108205433b6ce189ffa1c0a648d02fe309e5e4efb9b743ff0f128ee7e01e13ff259d6ba4137932d5101a9ca100c1c8949a113d03785b500133d3ff6571ecc3bf02b5fd462885b78dfbe635771ed89a6b331d9176fdd43faa6f4743d8b0c19b3d7d0a81fcf1f04a33a5949ddd001ec68cacccdc869ba91e6f1dd1defb10eb746d484bc69ca4681e882af9e0fd03477b8eef5f11f16b42db9778c4a501143568250f10e1650697e9ab129c62f59ea7d36e2c2bda589efd06eac3028b09c4b4da424830cfeddc5eb9ca05835a4b62650fad883899eb07a2d387c779bf111118a0d06055786eca88a063997109dae7443595b89523683664304bbf555a6275c883361db73aeb29d1b01ceb9b238132da17b9534a5d8e8a375649c067fb87e7155d7ddfaffcb51d95ec2847cb6e784e5091b0f8b7dac3e378215fe2df5c46896fa2a93be2cab239d00372f4cbbb0f47a88b88fbc8ac8bb56033d16155d687f80e25594b58fb7710258cb0d097f978db3d857320513a07dce66a56c405370699645be64aeaffd6d5beb9093227374040988e02db8d584937b6d2b6a718edcf59b22f8ed67dc331a35c807f7da729b14a79ff93f898d7684884f5c06d63f79aa339dbd3ab013b5d66c88060d00f88088e70f8a83e35b19cf818568792bc7eaeffe1ab56022817f25642b767de4e08dc0bba5eac7038ed9110eeadf70eca583293e469ff8b06a31ad4d9a975b75b934bbcc198e8da2a7fb1572b24e291455fea4730283fd469718fe5bc94b692a69df3fde11953e1f2986d992308590f70c831b7bb08ff81fb59382818928c0230ba61eba33a6676cf0127b8a209fc99da402c1a20f478ec2136802ba9abe60995b399cd76ac1bfe20a2df35d67cc514d5a47eca1be9c9b5671ca6907418ff4baf189444c137061174f5f6f7dd815f4e7e0dc622d508b0f27ba4adccec6065604e2aad7ba97e31f5b5c827dc921595207e50b7afcafc7b6862a26df6accc14c5a5938fa01c8660221770a3d08ef34733c2d7a434d88955343367f8a8992fd390600899e162301ca3359ecdfcaefcddc7ab973e75a7df1dfb53442192ac08a61104550aa27a02f93c1cefe71eb0a7b809c29a7f8abda690ee330dafbe636a0932ab19842f33c509373b5498348bb480325a53c8ff72513e28d50163c69750a098ab47fb2000bb588bb14512c63d42ed7ffa1521e9b655fe9f87efa47d1b9b92580aa44107e9beae40900dbd4ed9d3bb92662110f42e124b00bcaf1ff1461864a2ebf67cde4223f4c00f3f0edfe9747433bab0f3fc32bbdd41652208a1f5c5bd08f989959b8e327d8a9a992b95a70ba82ee2f7cc92af1f4b2728ade5b3974f531cf414e0d3e311859944e98ea38422d08dd907fdbe1251499eb90e36637823cb0b659a516fde0a225dc2f82ddf8981ba18f7c98bb66953701d71afde48bb37b6f8982d2929b411a42fdb2c5d1342cd5c2e52e96a694b00b0220fc0936b2a3e3542374eb4cdb8caf2cef7845eb97bf6a1bd111f43930ba1d7cf1af024bc5f800a5f2fc4e2182d74b7bc48ed0d632658e17f63f8c6336fe6be8ffd9d6e1bf437f80255ed1f7446f91c1e8d2f98645df664d8456a89ec7fc4fef92886c3cfca420c40d4aa6f5520bddd80c966789a3d6e3dd049bf10c981d8f619eea8e496161b00b2aa127b380c7e8ff7837c95ab32d4f05397ec1af652eca6bd224f765d8114b61fb89e831e7ac020b5a5a08dd0236d41650457237ac3927def65ecbc5e2861ece02e8115003306b7aed2025fe4a050a3aa57910ae416c302fd435b1f10d9f0946f592849dee0eaba7fba435317dbe78779a83d35a07fb69410194fc016b0b062500b19a2fb7edf62174f58b73f88c12146ddc03e46fd4f124f87e5c79c25df310ecf45f5be880fa05592c19f08bff0135a5cedb554a4178f1473e8ee03cc72060d650d9afa547e07f25a30634f0e9b5e3ea6fe98aeabb6040302a2bae91a8bc24df95534b93eb2d251ac7cd112d7e88107a21d7c554258de000d2eb37f5f9974e6ce70c84aca1c6ec44b3457dcd6207ede998ed14aeb5b02c70c233a667db7fa9dddab0395ff869f21eef7ba710a509984dae4f7f5cf8ac21d7f5475e73a5466620d0326a1872e1047b0dad392b882d6ca9460359a8f63eebb553722d31c7600aa5524b6e175d07b40668dab96198e8d4adffb0153dcdbc0d303253a5f901f13e8fa024cf3b9ea8eb011e232db93d47231d34f20dfd32bd5cc90c0de02d71e4817dc2b20266a5f834bb14c7e7c32cf2b92ceae283630196818d66af13cbb80a626fa7ff54a03f7170b31a0e812eb35b5ec1d757873253ca27e69ae47a9b7155cd482b756644723bd01f157bac6e3ec35ef34b246d3119915bf4228ad5f9136b7c390821dfbff278c73076feca9960d1d6dab5c706dc5c71061085785caf31bc89ce07ca8e07fb80c98163c2326f278cf11977d08586b08e58041e0fe53e78ebe07c7a31a1e2d7a60b46d53d3fa678cb861f3091b4185b5ca9463bc57537ad45295f3a5e04d6b1f80e6c697e5d8ca684557c83996bb48023ab6541a08bedaf4297a5b14e251ddf9be4d744de2d7ba7edd3a4adaf8f85dd45f8845e0852d4c58b22a7a94b9ccf09e21f8ada6439d3fda3e37dd1927c7645ada415a67146aaf080958756c6cbe495b0edf817b82205bf6178a4ef86dc3c9232b7f32cfddbff18d3b12b2857ac1b0d078d0980458f4262645092d4e71167885293ca064ff34fb2bf1cac85ac9c24c7eef91335885036236cebb7e252a684c46ecbbb32f73436516bcfc5048d60084e9f812abf95ba095af2121b3edaa4eb45a7c1d6348e3f9aa062f36adfadab1872598b2910e9d92b6b06d393f9149acec733eef7a2130f2a89885b31fb079c30f65abc74e1a2c1b6a2fbf4b5c5e2cacf14e51874cd20d70609d85a53c9bb87f4c3738b871d17ccc53f16c1af3c21aefbfbd8b54b2aaf7fdfc1fbf9e3b5e2d63113d72cb4e5b86c48773bc8fa1a539b1139f76087c7b1950832178d1471bb676b5c144ec983cdc410f763f85f07f8e8cc6c572e60952690f398e20c947f5b0adb6a80999b629e75d4ea2e0635452552ab415f83d4cbe7aeecc72c643c5e69ab9a530c6b3803bcd6c614990acf08bde16845b9e0ebe3ef813bf835dd58593d868ad0307ce62ee310fbfdc1d26752e9a38c8fce36058cbd0e488f95ce5ed85bfd236d65ddfb2fd38e97108649fcd0ef57264288ef080cbd63b8b6a058e60725696836ac53403788b243176b9974006f623f59fd764380d8a2de8dbe31786c41ce732d8276d9f27e2f92aa9ae5f005ea743d2a7260947cf4011735f087d9a4d6ddb42c60201844ac1ffb53d76ab6410c8a52b7d612e0f743733b548bb47a5b836cd4977860fa7b07f4acb785ff60ec07e1b4b04d489fa3ec910da83301304699071ce16b80fe9ee30cb8104d7c9d71bdd5b19272601a3f5da669d52ebb208512162957bcbe0082bae2155c9358a5ce95894f21eebe42069f74a4d6e253700b502f321689bd339801db5def21230b75da1f931d1d8e6bd9485076ab0af0707d33c98a44243c8c4f7beae08f8ed15f5129d8ca2d13f56f98a7205546770628e0aa0f8d33cf109406717a122bb45b72972f3ac79d7b953dcdb6d83f3cbaf645e441e08c2bf70e3381fab338f25a9a5da8cb436634c1c9c3dcf9efd2fd71feaf04d1f11cab7ce95fec6a17eb3caa4d9bd5f5db744a321eebecb6114052aa3519fdcc06423d5aefcc204ee11ed5952bdc7b148d013ce8a80b497eebbc9e2d60e5dc3a894c8241ed6eae678561dc42224ee343ec0c5fa7b754700b145d135ac1e579ee76e172337ee92a1f2917e1efe3cdb07ec53a248982a2e88ce145dfd0f5e63ae991c7bc913680d39f9f6fd2c5c3ddafa453c90f677b27764f01dad00265a11c2290649b5bf36a647a38fb3de5c0b7b040989cb375621b6ebb3b9aa9177742c3bf95c43537b3db74fec464bf8671ad410d27060b5b336c4090f66b43760e968dd580130452b9cf301fedd15eaa5e9cae96228a31482bad24d2037a971e0e0754554f4af1d929bfcf7d43091dba7c1a779ab387ae43e94b99a774f48f292847db42b643ae0256fcfb35df1741b5d73a559f4c1bf43921764fd60f779ef65873602bdcb126adf3ecea68acb597d28355356e07d914866fa2cbb5542fe334dc0ad34deaf77dfc8866ce6efa9d918d6fa9baf038fd340a2a55ee3c8d581719d27c8897fff351d2c50959e975758a56c6c19c741e8980e712a6931d2865cc4f21df24a8b45da170410826410344fd6c47a924d69d438978bf0a7393b71030171d65dc169f7bb93523ad1f666ca3fea093341fa73a1c3decd0379e3ebfc42c8163d5b0855308d31929cb008735466af5139227d2c909d90fccf088cdc10019f32b5e34b50cd647e04f5af1605b07f46ceff9ba88baad355156aba21528a608215eb3c73e9f416f57e150c65578f94e0ff2e2bb7816c27272145ce7ba8de7399c7d683add6a35a05fb5b23a19c08cd1c3e2f3afb976a91dd3352da73fed7cee10dea450c6985deb221e1f89ad8e9f50185c19b3f7885d5fa82e9e6f7c94bd2cd814ad48560bbce51166fb6bf5414eba92c278db06a8bc4af3d78e1f5002fc22816021ea83b8488fea817f63bdf48f734e18658babf48ec4f792b46db00e03de50eae1bc48999e3bfd9c6ea45e0ecbc5ed7974c095b9b84f30281aa3a63de964af2ff4f9e7801099247ed95db41466c88d4573a7ef7fb48354d6772532abefe120a3417894ebfa05508271c0b154018779bec4c182e4f20b358eb9f05973da21e7f1ca29b4fdb4efded6ee79366d65b892c03312248d8c5e2090425b07889655ae245fb8e63badd7789802ee1f203993ca799eb9a05b57b75ada13ddd49968b94fad3c2d3acb5b63e2aec2ad36700b2e6d7209ddfcbfd482c3b33ba8361df776d35707e9b045363974aa568e6bd2ba54f04820a08fb48448e88da481d63d7bf33713c886b4c13ffeb098871e9cc9974da7ceccf2daa5672ae00ec08306ec0c17db57a13096d7c602748cb135569cb170f9f6af40f6ea7b5ed1f95b1d3e3b1fb4297d0c2157a22edbed764ae080c31bb20ae070619ca6306e681450ad78782c66fa924f5cc3d5b515839e91e2cb17922541bea9f642bd77124b32608804e0ce6f42dcf137b5b069c08de2db13109bee6f0750fe5c1997779fc42d84dae65e19628d39e1e6b586736edf4c6238f9331ab0819e518c2e742390e87f9da0f52a40c7fb44c42db8cce0863bd264aa2e9435fd7c5afdcef86f80256e202bae60955b8c1636a09f14af0e56454b250b5bca4a848b43a99b4e0cbeb17e51d311cb4ef53e1031b193ef85b09af8d5f3c6f7d95c3758c0bba1ad2ece4449709eb3808199b15880b915a11b3c81d50135d9938500cae4e41b03554f4a91d3ddce91456673ba1fc09cb00360a46551fcb917b5b51cb2b9afea83b85bdae932f3485784ea3616cd98dc4b265c72bac3fd70ceffb3b9271055fe0a8eda5373e9eb4b01265891728a18db0da3a4a0e93f5b9b6f204cc5be6a24bf0d84d4329634fa3d0588c850faa5bece82aab4de40c939adf35769f559bfcdfb4701c703d2b346eaeba4c3417c044239a4856fec54e14ca4487ed369b2939f4d61c2b1b342f2d17648af692129aa196a42c098a06539e59e76649121f2cd4b24177d700d690df44ffdc9da931717c2ac7f42fcd37c2147a48760e364aecd17a7483010741a0d85998fea562f86c49efbe572a212e95a2fb12c465978503715ae9ee1e0361edb635504982c554f032b2083e31cbf02838e91b6e73b173988477080517d97a57787d671edc31a41a736cd4e275d35fc31ac89074b8293eafb8731c98b7cd7b90d8cbbc32e797f932778c72ca712618057a9290f3ad1d574df41f0b9f755594de171fc2767637cb12ff754cfc062d9c027d8721563fe3b253f2f160056ce5de331ec0a55f2f72cc03d92ab71521a04705b36556a7fd62f7b972d1923f1906023e9f03dd86d4868b3fd76e4b8b976552d9d166d281a8955f9b2bc40848eb434f809c89747e9bd27328c016292c4eb5270e8efff56733986e16f0fd3a44fa9992e45ed5296b732c521136e84bfa7b5a293862e9a24d2719987563755a45eabe8aad556f6700c8242d5f97c2538e6e6798a7de2e110c6aec20b094eb966ff58135164421732c1831cb2ad46fccbe97870c7d118bc34d247e896fc71696709a2dc9943b3370e94e9945d8b44445589612c41c6adddc4607dfa2e212bdb50d40be7c48c548906fceec52f7bafa2e319aa688a5a7b8a20266a6cd277268781ae21cb78312eed85c0deb1ea450795495e21054da1ca5221b5c6056af54feb077db9169482b29ebe91d8e7ceb28b856916fd2405c0d05fc3c94978c059e4cfd2e142a5c764d1d432c54331acdd16bd9f74f750657d2e8b623f4e0e54f57649d5fd59c07a77b6e8c347d79d6dc1ddb28d70414d44f49d5bb2c0e3a01085a5f7b00e697563cfd0e1c46f2ca6c017e09aec259a9a7d52cac8596685f7556aa9d19a8c426d29dd3211b06a03ae7676212567b5e55c89a0949d5863df2ff0a43d2758131159218e974b9419c0c09827fd5c2f7e8b89cff1bd20d6908e76a00f7fc894764644017443969ada5f94ceaf8324de54039c4c2a02326eaf6d95dac77602f59976dc81b47b7096072c8b7dd0653a05bdc5109d876ad09349aaee1dbe6533ff949e65ffefefbcf2fc30a3522dd5fdf50499bb793aaffe08510338c40d23710bbcfb315f785391cb2b9265e1045700c26159df194b95cceecdfd2b1ca072c81ffbd530f1bf4021cc434a9ab05fb9c8346c397b42ce0de4107577b5971836ad94c25ae65a20e3b49ff1e81341db89be47af31405bbe65f4ccb4d7521568af82f69a6bffb5f63c22e813daebddf9b8a8e059560179d21d4f4a6ba4c4cfc9cdcb7a5292b75ed4241cd4eaa780bb0d918884f73840cecf34e892c1cf3fac4d61b83a51f7034068fe4659d8bdb5a6a356a92a7c76c35a037c8c1165cb88825b2d8f7bb8e7e89b94202c2927ca387aeb477012d5653798b0a31fc6a1918c7b94199265440020bfd1b8dd446510d251ede03f0f38bd48df9b6ed125c0388c42a9e39a03bd50776a234490403581e2d5136bbadb81059783d58909c1a689d593f1ba7ee58ff4f55608cf7be0fb2ff3b99f06e6535a5a85470fcf2ad6c2056a54c2c4cea64480df611bc50e68c19922ea009d0d82c601bd7c5dcc9f57f38d65f6040cf94dfe519d67a834efcc5afd492983928f678d717f6d90655285a4bff19fb3323a3e48aad8a523758a96f746c3a59b4faecb5be66f9f20d88111447214d5b1c00b68cd330bcd3ef4b1796c61b57d84d980e9c722cd3de471c027c490a8773066a8a119e00fd192969548e0f1d575e04c09542426e39432d07702c4d83ba94165ad9357bac4b31df7c2ccad2e121b7cfb38f9fd73f95bd93e6f710d9852ed04baacb1f93d87d220bdd29d9be8cd9b418cbfe37c05329acd54fd733c770e1075e322b1bc4557f385c93a5359e30c9287c8b6a1eb6485181271f0c51ef89236f04ac4dc6d12e01c1869e384123514e21721c66b295e72fadb588993ad6e75369b4d33b8dc55d6052d70d240241f902f9079fd7fe690f1c90780baa4f852318ecdd7fba8b594e4c9676ee75e657e2e8194a20f12289735eeb7081ebea5ca6ab7a7a2a24a5e7b51ef727ae4f6c51452353eb14e9f6ca99d117a2499e97eaed6c91f86074a654c551685bcd97c26ba0672665ad8c17bf5ffdaced3ab810167476377c0f1789b207dd06751cc666c1cbf345c56f24aa669628a93aa7013fab8c71267a0cc74fafe1905b338216c7350d17c441436619249741ac152208c3436dca33581164bdf3d8ce0425523b3b783eecf2c4a3a54c7f63cd1c951050efb40c8af5e2bd590b4f2321de59f92feac6ddb1b7e802441758156c04d37347eebec317eb9ab64ba81871d6c940b076c457a297d4c868466ac9e714bbe07d8fea7e6599ad6d528bf8740a6332ab43adec266a52e4ed417717f97ed54de5b8ad2e5c746d7c3e4d1bfcc25ef13096e6a47af4a39c7e8642ce3ff1da289703e9c0e7d970ce9ab3d9fd98851b752a62b068eb9b99ba1fbc536426ac1a47d58679a6119d3a0b08c802e816d899f8e0c7fb8cb783f7fa342bf6ddd4c895ec7a186a26b6ab7fa52178f4fe921d5701bec38fd199e70b67d55c3bedc3ef977be76cce4a1b561804a592e565a4da89d43b287718fd40ef39831c958b109ab8c9cf1b2b4f3aa67012ee09f7acc4d98ba5ae02cf0d2e05f3c7022d93ed9feae60ccd58a3a9b7e21248429f6bb38dd7e9f6c4ab247831ca1d95c0bc3805d5b43e35ab2e2ce0ec7b44857784d00943c70bbea420eb3b4e73dee0277089a29e3b3c96fe06ed73acbd08bd772626afaa1e84ee3549f7ad411ca321389ec0e96704c77c93e1eefa5a8986d53a6f55dbcd09e4f5b66ca5c911960cbaaf508e41476130bed8286eb69d857665ea45c1b4bba93ace7e60775d09979fbbc5e3893580eff08a5657cd3ac45caa16154ee1acecdb0556546b1f1fa81e0df5ee58f4f97db9222d1d6602b1ea115c5c44dba85c37830c9a8bb722eaf43daa26e66027fc60e2b4efbbce27bcf7e9d495c363bd78b3aae72edf36ff7c398f16cd34fdcdb607dd89e0a5e4044206b501c0d8b36c051fbf57714562cfac8c72f5a312200ee8e99cdb8fd01bec3728e152c55e9182ac1443e013adc1a800489e3d28ec46ba6e2a6ea1199c083105c0498b733d270ab9c6aee1f6c14f6bf9680c22c0f4ca2b11cb6dec78d89e6c30caf0ea7cea616cc44e3a2f1d80303216f02bcf2cd67d58025dbc31cabb48f5fbc16c580250a9b57807ce0b61cd56ad53085033f857a577f01980881cf891abf290e6314bf817a85df11c2f0e6b0d8aaca1d8bfcc66a16193d33ef8b3bda39ca4247d948ed78211d44ce29a1cb78a01e6f514c851c5c9002297ee01b095caef8be8107f563292d455b30e7437183d17e2e6d2810f4b49e320e12f6dd6d18b31ec21168e0690337efb89cdaf798fe58b2dbd39a867094aa60cb1cab56d17e7f50f78010eca7d5cfebf1073e635fec8deb611a1783942f7b1df22bd7ee685995313a41356b323072b09d214c292ef6517e83ced79c626e98c5f25b124df5821418a4591a56f5d17da9eba8256718fbd6a83f393040838e033fb72bd1b531617b53d2166a9eb5fffcbd21a5fc4d7204d3b0f87b1511b1cd0f60a2bd226952c3a0de4762b224c39e3eb775bc2456d30cee139b032f67e4c17763892241276d7ac7524233609d68b59bac7ceeefb0c816bdd40f1a24e6baa3ee7bdb5df8f9a408e6892da7fb4e7728dd151010d467b2f8e6f3f9b19a67865b4e527f5696ac62078f25cf008ac7408eab934949c889eceeadbebe07780befc7eafdddd63467271542c0ba42dbe7cea2573b6512725b94f294a928a37bdb052730865afc00a7d6971fd0915750a5702f9fff55fc13a215e9a931da0dbbbdcc42f0c1daf93a02a52bf51e0b35049eba92f983a3bbe4fb9f7bf8df3e942c085983c7e3162ca63e982b128efc13393c56b0b3f9c6e07a2eede0b77f8fb53d35e114886b99b85882a0f8fcb846f8ad9dcb9e62aa9024ba1942a24e58a88640d99105bcf80eb18ea033a0dc0cd9d082ea58f67173608b9414765e24eaee0fc41e335acd4e2c8f4558722def0bb57ba74e4f82ce3d1196c9605dcde56a9d0f229ef945098d7e97034ae64a69639977ca0ea395efd4ecb994139ac90d408d7d76d4574f4cf863d0f57902f4816b160fa1c0d8e95fdad4d4469aa41d5aac2f1cfde27a9e9d6efc0cf5eebc0ad5da672925b990cec8b3e7a121f9b42dea2d886b42e2fa9628802de46a03a9b47c1f3ed87393f8a50d5ca6d763b72cf2cf31ab682eb49283e1de634c54541ed61368d0d73750bfbe3db4f78bc34a6a6265abad4e40ee008b22fc15c61e0ea61927e4fc1d5f206d40fb2d06b3f05acb1be1f08e0745077c6b0992d87392734f982182171c2a8fc7206b51121829fb6aa3d4e0df547330d90ae4f7b1f07f51888e6baaadb5bf315194fafa2ef3a4bc32a8aca538e9ce34b77fded4252accd1417c1a6a65605095cbf9b9a9ea8ffcca025fec237b676a1b86bde6b280542a11973eb2a34a00744d649738369230b73078de3ed626981f8a7917ad7963a8e045edb85271ff9c00821403aeeb016a6471f47b778bcbaa00e2ef3609672e55b3cee430043a18274c467683c05fd42c12c05c205846171fb6254f3a329e7807096bf5ae158cb5e160af4f70d665f964def13c2a7c920e2d0a00e3206d642b6d0b79ef28bf5b088664d4f5ae2594ce1fb97c17c046b15f2eea57efe25f3ac2924967e5297a9dea2d415a411fef48323a4a7bad38671cb4edf365f357ad02a2b6f5d74899c554c7affc1df852b9c3c18b29f81c2abca8b9437088c2e1e40aa811c91f175669f2ab23a9f5109ca69787ce4da16b100eee50ef0f9ebd595792a73f3eb55cd41fc684f469b929afa553d9384fd3a26aee9ff2a864cb2a75b35c31066c05af7eb5f05ee61a0d27b53683874841270f9541a7721a2f994615403beb8c31cfb5c5cc7cb6b0f14f20e96e71a6b057c3a8d79dc237be2a541b6806777d61bc6f246dd8e10c1865e6c621b48a02d1109c8b1e6a285b6a4e27d2dbc20eeb8e925c3e1f175cb0f75a3960533624ad50e944c03c5380913a9b073608e940a1bdfffc4c4ead4845f8e6f3e909b4886b12508b3bc269e15edc2da05e162b1f651c9e44f772656a55dc822c06afead34170fdd70c30e58cdede37f075aff66c621f6fd70434eb4bf0c647f632112654a4ba660002c5c274e1afd8d04489d214cc9d274b4319c25fc835bf2471ba96a6ddc4c2b35940f3e9cc35594ea133e158e9c8667e7ccc2fc10bf9df9b504f58af70b2ea24512350ffd9c4967d14808294dae54e0db31d565f200589960130d4db72fe64cd098fb6980daeeae8742fd70d9c4c487ca4b945461cecb8462f71c17100f5310c6e5e5786efce16e5d377a04dc68feb7b74ad8bc7488f462413e7cf76853a22182fe51c6a6f45eb5675fdb675b8280e435ab19dafaa5fa83f20cf4e7eed6692d8a2ee7f6a0e1391833b9829c9cf05b37e00e0c9de5b8cbb50cf7057c4818912dc9ebf5661f8a95af57823f04eca3557acb2ca5f98bef5ae09ed12061eda5ea8cd2b1a224e7434401c8f84dc40dd7f390fdf50f33e2a80cdc4a9db529cfd91b4c50a12d6232b420c836a5ac7ff2c9f278ca3fae57dc719d046f4cec7aa59b134d316a9e0563fbcd09b1c2062fc3d7bcd7e193c94056d5319777bec397f1d60ea26975ba6bc7023a775148625cc22087b820b445e9d49f9c2e1828712af6436c9755cb3b8828552371695ec0750d32d860b58d0fc096411c36e4d1ed8e2e3b964cdddfcee407355dc35da8b8a90e2a13885b90f5ea786258fd064b9ca3cd8cdebc4d73971d6ad43c6af64f6b2970662e51dffda4d3a8e5c2ff5e9deb6a4a2a27ded534055e92ab63ae72617022913a13b35dd1772097a0e2d0d02fd8441b1c66ca5172578610c28bc88024859665e6749e739df884e787d03ac7f6445034e0c7bf7dafadfcbeb851a3e49cd6d4eed76369d9934207ecf0d4b8998844962af2f717bdc2e2370f97da9325a634da448f3d04f0d6ddae17dccf875a2cf3e0a323b0335b5a6ad8204f76580d306f25621b80f7245c249ed379fa5e2fdd1b2bb6d689c2c63d73c008b0f7cd2acf1786d0f5b51af6361fdcfe607c247a5d3a7c7074bad30edab33dcd43e063579f677a9941e65dcfb5b2c1d9e103403f71446a09068a81e11ab7d040e4f340126a80ec64197c8ad79cfcfde7446a94dc7ec2d18958b8252fb489422134fab01cf871a478801d4501bcfb70e6039aaac5720d6268e35ea33993bd6fd60454a033a4ecdab4204885e6bad8e4e67e2b4ed422e4d33b0964af1c6797d6056af2a59db6d14f6db65544b98bfb218fbed547964822585c65dfe9b8d56f7f89df566d4e25b8295a50d98cf440b047cc6b4cdfeaa204a3d8cb21945bf596f4157bd323decd36704f16695edd29fea911d0add042161b814420b2b75288030beadb9a6bc5c1e096bc92b37487dabc2fdc129347265ea0d007dcabfde4dc6a5947a4eb1f50146b877899ef6b3c34cfa5089251be8891703da7a7b149b5f20101d83cf6f270829ea52e46fa91ccce0e185353d69af5aa2b8507653926cce0faf96fb47d09fe007bc4f49cd0140fcc87da948328dce440a4010a899ff645ed6c747f127ecace1f62bf03a020e72af951d1178386ec83a8c33c997659c91df159b043992388a1f8fc6b9f599e78d374e750bf81a9ed663ff6f2dc3ab6b274fab07833794f93d78cc9aaf1ad37ade521c9cc6c8ca056d38eaa061fb87886d053e3d63ce91cf5dc479436576a9fe4a091eb0eb05633b19dd184aa27a93b79b19040979418a229e4c28daa7f6202adc4d69c0dc7b083223abb70e7ef8d35ccafab4a79788b1488e90a369945cb1fd8c0c314162f3e18b8497850ae0471534f51901b70f9d34ce3a8f762dc7de32c5a544648e03883308e274382212958de37a0deb1634b47a3953a75fa194b44ee1e1a4358c6ab88e88b08fa6f9e1f9a586c193210c5bf52e8c99567b0e64d308acc7dfd1c4cc705d383695bfdfbe061b9996278388ba2a5dc3d1c60bc2e314c9b543322b6866785b830eee613caf8e433294a158b0c9345053550cc00193e3da7ee8d5f708ce01bda978ad487526f4d511be595978317258c21aee04936f87438a7792e72a355691925de21a87845219c30d7bfb422039c40c260a49235d276805ba7d6fa9f9aef07e35dc2f9381e652b761202e4e59e95d81d07c27c7807516c7503500fe040a0e8b729444740c74daa5bac336aed2b3dd7aa1faf84e24fecfd5e1ced56255714be44dc45efe20ea25f906b4235e7aaacf1da09b80b55afab2e13701f29f865373c912096e8b51e598b466488c791ad4100e3b7c8bd3b1be5fe88a3a8131ef142073a1981f3f1c5a4b46f76c869a6e74ec1a767175db8962fdefc5f9d1c365bfafb512b9651ce65fede4236da9788f1edc18687b47a75606ffe5c087d28af56a7c7e013f92092dca9111587c7ad46603c6350d803da953b67ac9d4cea9b5972b73448db1b979a0e3f3ab08384c632c20fe228735fa15597b76ed332e737f3ad307a3f411775fb306218a43821906221a00869a849e65f34a30fcbe938b965f34e21f2d07b0d16f2da102ea89e713096b4699f33a65fe7890d8c7ff1231bb6da78fce4798412ac6a2a669ce199dfeb554c817c75a8d967e2be81c92da68531a5be620b33be32074fe69934c8850dd9f6136e8a7a8cc0c99303bed24447721c7a34ec5039540e577ec2aae5e784fac7689aad76dd0832a1c8bd6749a95b14d67cdf6dbf767517d40ef06292447432e140be37d51d6679dd3ede70ba666ac2e634db1056721101332155e1434d3411e90ebed7cbb1ba9c939b74a4c3cfd15813b8c91320a1d84c8bc1e07e429b703b444a8a59e9e6e9a5910923aee8c54f02d27e10f73abea829b981b61da6dfe09369bee9deae5d257098c0fa21be5d112678c051ade4d77bc826d0b59a509030f32679a02ef5e3096524f7f2f6cd3d6af4dcdcd516e50482b454dd342495c37e58567f06d665a45b6b7bb4fed446a523631e20ea6ad507b7415216f365e77a37f63fc68dfd8f37f2391683b784a23c369ef9cdf09f3ce07d454b3c6aa07db3d98af1af020b027c9e33a2b1f7da8ead2045c543fc8f5ccdbd35d45bb76858cdec445d56061f2457ff8b9afeb54bc72424428327b9cecc0f95a16451dc078ba77858206b43cd5cdea9dc3a22d634ff3171b1242b6d19fc9411a71e4ec2d15e169625d410a6e107d0ac80c717552046d9c9d6186761c8cb45ffd1a38be0242a427e52bfd896cda074b97ca43778567d144a5cc0a5bbca24890b82c7af592e35e66412e682cf8be1996f0dfb23464e03089929b52195b49008be0cc4ac5e9076a40a875a0a21ba8ff9457afdecb8d33b7fa67a0b2b2763393ed6c3b86a24723f67605be24ec67b26e66c2b188e856ca3cec230c8ee43b2d35b10a75c7bb4bec0cb5c0e8cbb45c286981cad80bf57fa888d11cd8aa824084c2af48ed721739650b39db589bdfeb2ed8371d0b0bc6f49292038faf0b0195edcb404197f3f49cd10f5f2eca8970db7b678bfe782ea94b8e2be5cec5ed322e968b28b01fec892010aa41e6df0ae58e8a7eb15e9ef1c85f47238921c9f4196995c791481801dfe8a2c7bbf8acc2b1ee32399bd94703796c0ae5997b02484f50feb149da24cf946d4d865812a7100e50bd4629b1ec7fb363c357532ffc2c291d564c01c5cf1d1b2b4dcd2a4c369dd33a293bc4b1db490ab1eebf33d9854b20f187e3a591face0793e21d16502f021323e70ac53146d8a2362a2f45ea4bf17d03bec83105f9f6bc1f4e6a90277450ac2c4b1a19198b31d8b88df920aefc7df320d5a28d4c87b7c7f03d1ad0446f2c1bf4bb686b02a5db06359c6e14d8c076937f62f8a3a6869bf232bfba9b23f77ed784b25c68b2f127be1651d546d3adb1cb29567597aedb584a7058c1a22d33f7dc7f7c7d3ef2a8032db9f4864070c4618979f852aa5fc484a04ba506a1ebc185372e87f922587bc9e587f3ec4f0caa08283bcf3452c7fe83f10ae31acace1c6cc324082bf9cd3bff052b8beaa061421225c71428995939e58f58ce815b5f10d1717e9b9f836728e825f0ca98fdbd4fb6a436cb14350dd8160cb94aed8b53781995b0c74ce9bbe5369406319837e0f9f8fc6533e23eebd409e9b91357f71cb6c9bd20cc53eff2f067bab5d63baf4d4da11662f149a113ca248fbce192b45eff9d7e1d150b6cc864e1bff039ec0ecb4be699a5e781f4b02c3462ff8ec0234e8c8979e1566d1dddc3a370ac25d4c0f67a7477c2d8adcef6d2bf599caf24b66c2641e95815f0fb6b91137376218fc40752587d3de22a2bb7fcebd08dd5e406666c731b269cea95e65ac6b21621a2a12db21dd381e69fd8042b593549cd0cf51d032ff1cd32e13416f5902c4f691bedb9a6cfdde71d8a83ec54f6df0232565fb04d377147559071c12fc5f88974adba50bdf9e32ba17701a628a5c74a9d82d92b2fa2111e4748c45137f64d9dfc771ead55e231c1eecf229787871e03c504242e82e9d4340d301f59ed79c6b2bd3763cf53eb43f300d334b33ed67b4b49318c2aef3a8ca7d3831f457b04eb13aaa92f14a6e2b694a802d251ac9407e0e150bc745d526fb8b1f19e27f10fdba53e2a06978e08d40161ca5b05f627e2af9911dede8ef1aca8b479ef86bc5856c1508e2546f4e8c0bb1862b3f779e298023716fceea4b4c5263dcfca84a2419d1e15baddb417f5d0a88abed9fde124ff344d926577cc64ee882c4b4aab77fa93f0b7fcb2128c77438e9335a3393661ee8c6ac6743686f266998a852c931f42149f518ae0877adae508cfa5e87c5a391f01e6521912b0f57080d9cc2cc712777afc1292b2c840a3e8055a6b0b4378c0987cd5a43520b8899263e1f5e3a3ae3a6d6e9115a0c24d325439f7d746a36c46a31b97b799c04e0e8a89e9ec5e6ea07bb8274380097622e04a766232ce58e1c660d77eb78dfe1fc41c62f9ea724b12956c66142ca0460f3023a9bd12ccfc9898100af474369add8a2210698b72e107f98f99f9bf4af6cbcee9bf689c764aeccca41e7e38f6bf376521aadb6b7fde83a74945cfca757396cf52827b5f7dd054cded5563b3911940afc8f744aefb6794b4a03c5b9c2cd292bdbd06ca28f4f6a38465cf9866130bd5bb8f7e4e6cd8f31811b5f7ec70acf7663e23d312674ad2e2e893df77ee3ebf893137c4cd93b86d42e3d109319df904413e33f4d3a7c03b3565a48f07a7402673462de365b9a331dd76a117a5b83ec3e66acf96f2ebb46eaf5537ffa2198929029ba6fbda32294efb60e2deca3e96467a7d10f3ff1a15ce54e42532f2603ac514fe905b8ef39d620db2e70bc488afa24b06779b45c14e913830317fc615cf984eca407f2e06933bf0f2feedbda642ff6cf8fc8ee6deaf8bd7bddebd12969bb28aea9ee888fbdefb1978728e0d530b3857098bb36dc63eba0a4cf4f161e036cd3e0dde986f4bb61ed0577fd053c53ec00bdea63af9bd03a81a035ab4174f597029ad47c506169d52826f2da092c13b14809e16e0b11bf6902ba138c3baf3ff9cef8e3bc90f0898a45c8be1011b374d52f5e0231bf81234d46979fba4859c8f425a91743bbbc314004edacf119361353ed091ffef001c1a41cc3f45f9294b6eaee37aae9cbbc028cd20c80c8eabb7f66861dfd6cafa3c7022b046af0043041b37da0054f780dc67ea1c1d49e2b1e2596ebbb9689ce867422eca5563af642f855a3dcbb2893bc713c39a8e9604cbee156e5ae360ba501ad798531eb636d1fc90abf2759ecac491f9c1d456a7caf6026e4f6bcbc62f316c1dd574991f63a00ec418a2598696c23425992f88d3f7689a9b3b4cb5a7299770fb218b204349812d06d6a3c202576bbce17c4bb015214eb36311ce62d07305b18d86e314ef0de3170f5d2c60e4b997d803b4f64c72386b280609ef49059772cc7e8f5526f11b0ceeab886582171c0fbe2bd3da192b55f47ee2990ba88df66b2403deb91c3ed4cc9a18cc0c0dd33c12ecb1ab03409324dcbd7e2139c5389b45e7b8a3b59da6a9fd18b36e35240fd8fcfdc2ba9b715ab38f3c6ccee2810f9ef859770ed8c59d8672fad77d2f3503b1a83bc9b202e012a5150a3333be892a731e7261734ef28fe2c091732cce5c98f01dcda8f9166257169354f8ccfba6e0f39fe59e31db4088820f1375a64b0bb2dd7fae660bfa3b8974aeb849efd12fcffc7d6efd723ab7a9d68782bfad2856a674859b431bdf8d8f6fea20c3ada3e6d3af66d8395ea4bcc33fba9e381b21ae2d4c47b4064c1e5bc341dbb65fab420fcb7e6d93d8d8f013a1cb81cb4c879683c97582adfabb856ecc17da4ae926b133d77f6cdd77798719f20f5ace8a461eab7f3832b3c796d3e2e5c13bd1fc89fcf6f1af40234156d2645fd2f656d638cb371f95f2a800a6a684d8f7291ae863f375a733fb3261acad21a9a37149dbec26334c38b4639f9ef5da1960d90c7a6fb8b68f225b8d3686b33027cd4a7eb78a146ecb93f94b06db21284d9e6d79742dfa86ec627e63c1fc7583022af111e2329bfb4a22b0ae4fb60d88b0b0e68be1aa9fafaa4b36a2a1f6716f6892d52dd6e7a11e8c193d6564f9166aed24cc0788340f5b83aed14d907ef975d3b7050498cda881d6604aa0200d800071651377ec514895de04ca94e42e791fe89979eb2323b4c2678fa2e9839adc4757ce7f5ff22df4afa92314858d34e929d13ba4e7d367b14b7820e6ca025bd8a11f5e22aba0d446849beeb295e6bcba18c004c14053364a7c1a1cc56363aa2c3fa9fb23ee376d2f9ceda88ac3b2c89c8a8ae52697b29d194c8622b8a305c679b370fafeffc98f84a73f4a590388845e1b2d3c81f2d944d75e6edd398169cfa8bcc912eefe2a50ab82f1fbbf41fb7c049e0faa0512ec01ed4fa228fba4d5b5e7d9b512847a9c1665c5e958ca3e09ad6b8d8876a6f83c387b77d20353c03d8b9303ecc82cf394a0467b85e430580</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">gem5实验报告</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> 计算机体系结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Gem5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 核心编程</title>
      <link href="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/"/>
      <url>/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h3 id="C-核心编程"><a href="#C-核心编程" class="headerlink" title="C++核心编程"></a>C++核心编程</h3><h4 id="1-程序四个分区"><a href="#1-程序四个分区" class="headerlink" title="1 程序四个分区"></a>1 程序四个分区</h4><p>在程序编译后，生成了exe可执行程序，<strong>未执行该程序前</strong>分为两个区域</p><p>​    <strong>代码区：</strong></p><p>​        存放 CPU 执行的机器指令</p><p>​        代码区是<strong>共享</strong>的，共享的目的是对于频繁被执行的程序，只需要在内存中有一份代码即可</p><p>​        代码区是<strong>只读</strong>的，使其只读的原因是防止程序意外地修改了它的指令</p><p>​    <strong>全局区：</strong></p><p>​        全局变量和静态变量存放在此.</p><p>​        全局区还包含了常量区, 字符串常量和其他常量也存放在此.</p><p>​        ==该区域的数据在程序结束后由操作系统释放==.</p><p>总结：</p><ul><li>C++中在程序运行前分为全局区和代码区</li><li>代码区特点是共享和只读</li><li>全局区中存放全局变量、静态变量、常量</li><li>常量区中存放 const修饰的全局常量  和 字符串常量</li></ul><h5 id="1-1-内存分区模型"><a href="#1-1-内存分区模型" class="headerlink" title="1.1 内存分区模型"></a>1.1 内存分区模型</h5><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211219211614927.png" class="" title="image-20211219211614927"><p>四区的意义: 不同区域的数据,赋予不同的生命周期, 给我们更大的灵活编程.</p><h5 id="1-2-程序运行后"><a href="#1-2-程序运行后" class="headerlink" title="1.2 程序运行后"></a>1.2 程序运行后</h5><h6 id="1-2-1-栈区"><a href="#1-2-1-栈区" class="headerlink" title="1.2.1 栈区:"></a>1.2.1 栈区:</h6><p>​        由编译器自动分配释放, 存放函数的参数值, 局部变量等</p><p>​        **注意: **不要返回局部变量的地址, 栈区开辟的数据由编译器自动释放</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">return</span> &amp;a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>* ptr = func();  <span class="comment">// </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ptr; <span class="comment">// 第一次可以打印出来</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ptr; <span class="comment">// 再次输出, 问题来了.  编译器做了一次保留,只能打印一次</span></span><br></pre></td></tr></table></figure><h6 id="1-2-2-堆区"><a href="#1-2-2-堆区" class="headerlink" title="1.2.2 堆区"></a>1.2.2 堆区</h6><p>​        由程序员分配释放, 若程序员不释放, 程序结束后由操作系统回收</p><p>​        在C++ 中主要使用new在堆区开辟内存</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *a = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span>* ptr = func();  <span class="comment">// </span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ptr; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *ptr; </span><br></pre></td></tr></table></figure><h6 id="1-2-3-new操作符"><a href="#1-2-3-new操作符" class="headerlink" title="1.2.3 new操作符"></a>1.2.3 new操作符</h6><p>使用new操作符开辟区域, delete释放数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> * arr = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">arr[i] = <span class="number">100</span> + i;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; arr[i] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span>[] arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-引用"><a href="#2-引用" class="headerlink" title="2 引用"></a>2 引用</h4><h5 id="2-1-引用的基本使用"><a href="#2-1-引用的基本使用" class="headerlink" title="2.1 引用的基本使用"></a>2.1 引用的基本使用</h5><p>作用: 给变量起别名</p><p>语法: 数据类型 &amp;别名 = 原名</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;b = a; <span class="comment">//b就是a的别名</span></span><br></pre></td></tr></table></figure><h5 id="2-2-引用注意事项"><a href="#2-2-引用注意事项" class="headerlink" title="2.2 引用注意事项"></a>2.2 引用注意事项</h5><ul><li>引用必须初始化</li><li>引用初始化后, 不可更改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> b =<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;c = a;  <span class="comment">//一旦初始化就不能更改</span></span><br><span class="line">c = b;     <span class="comment">// 赋值操作, 不是更改引用</span></span><br></pre></td></tr></table></figure><h5 id="2-3-引用作为函数参数"><a href="#2-3-引用作为函数参数" class="headerlink" title="2.3 引用作为函数参数"></a>2.3 引用作为函数参数</h5><p>作用: 函数传参的时候, 可以利用引用的技术让形参修饰实参</p><p>优点: 可以简化指针修饰实参</p><h5 id="2-4-引用作为函数的返回值"><a href="#2-4-引用作为函数的返回值" class="headerlink" title="2.4 引用作为函数的返回值"></a>2.4 引用作为函数的返回值</h5><ol><li><h5 id="不要返回局部变量的引用"><a href="#不要返回局部变量的引用" class="headerlink" title="不要返回局部变量的引用"></a>不要返回局部变量的引用</h5></li><li><h5 id="函数的调用可以作为左值"><a href="#函数的调用可以作为左值" class="headerlink" title="函数的调用可以作为左值"></a>函数的调用可以作为左值</h5></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// int &amp; ref = test_2_3();</span></span><br><span class="line"><span class="comment">// test_2_3() = 1000; 相当于将a的值改为了1000</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>&amp; <span class="title">test_2_3</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 静态变量 放在全局区  由系统释放</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a = <span class="number">10</span>;\</span><br><span class="line"><span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-5-引用的本质"><a href="#2-5-引用的本质" class="headerlink" title="2.5 引用的本质"></a>2.5 引用的本质</h5><p>是指针常量, 指向不可更改,值可以更改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> ref = &amp;a;</span><br></pre></td></tr></table></figure><h5 id="2-6-常量引用-修饰形参防止误操作"><a href="#2-6-常量引用-修饰形参防止误操作" class="headerlink" title="2.6 常量引用:  修饰形参防止误操作"></a>2.6 常量引用:  修饰形参防止误操作</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp; ref = <span class="number">10</span></span><br></pre></td></tr></table></figure><h4 id="3-函数提高"><a href="#3-函数提高" class="headerlink" title="3 函数提高"></a>3 函数提高</h4><h5 id="3-1-函数默认参数"><a href="#3-1-函数默认参数" class="headerlink" title="3.1 函数默认参数"></a>3.1 函数默认参数</h5><ul><li>如果某个位置有了默认参数,从这个位置之后,从左到右都必须有默认值</li><li>如果函数声明有默认参数, 实现就不能有默认参数</li></ul><h5 id="3-2-函数占位参数"><a href="#3-2-函数占位参数" class="headerlink" title="3.2 函数占位参数"></a>3.2 函数占位参数</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 目前阶段的占位参数,我们还用不到,后面课程会用到  第二个参数没法使用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span>)</span></span>&#123;  <span class="comment">//这里只写一个int就是占位</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;this is func&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">fun(<span class="number">10</span>,<span class="number">10</span>); <span class="comment">// 调用</span></span><br></pre></td></tr></table></figure><h5 id="3-3-函数重载"><a href="#3-3-函数重载" class="headerlink" title="3.3 函数重载"></a>3.3 函数重载</h5><p>注意: 函数返回值不可以作为函数重载条件</p><p>函数重载满足条件:</p><ul><li>同一个作用域下</li><li>函数名称相同</li><li>函数参数的类型不同或者个数不同或者顺序不同</li></ul><p>注意事项:</p><ol><li>引用作为重载的条件</li><li>函数重载碰到默认参数</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span> &amp; a)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;int &amp; a&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> &amp; a)</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;const int &amp; a&quot;</span>;</span><br><span class="line">&#125; <span class="comment">//func(10)调用第二个,因为const int &amp; a = 10是合法的</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b=<span class="number">10</span>)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;func2(int a, int b = 10)&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot;func2(int a)&quot;</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="4-类和对象"><a href="#4-类和对象" class="headerlink" title="4 类和对象"></a>4 类和对象</h4><p>封装 继承 多态</p><h5 id="4-1-封装"><a href="#4-1-封装" class="headerlink" title="4.1  封装"></a>4.1  封装</h5><p>封装的意义:</p><ul><li>将属性和行为作为一个整体, 表现生活中的事物</li><li>将属性和行为加以权限控制 <ul><li>private:  私有 </li><li>protected: 保护 类内成员可以访问</li><li>public: 共有  类内类外都可以访问</li></ul></li></ul><p><code>struct</code>与class的区别: <code>struct</code>默认权限是public, class默认是private</p><h5 id="4-2-对象的初始化和清理"><a href="#4-2-对象的初始化和清理" class="headerlink" title="4.2 对象的初始化和清理"></a>4.2 对象的初始化和清理</h5><p>一个对象或者变量没有初始状态,对其使用后果是未知, 同样使用完一个对象或者变量,没有及时清理,也会造成一定的安全问题</p><h6 id="4-2-1-构造函数和析构函数"><a href="#4-2-1-构造函数和析构函数" class="headerlink" title="4.2.1 构造函数和析构函数"></a>4.2.1 构造函数和析构函数</h6><p>如果我们自己不提供构造和析构, 编译器会提供, 编译器提供的构造函数和析构函数是空实现</p><ul><li>构造函数: 主要作用在于创建对象时为对象的成员属性赋值,构造函数由编译器自动调用,无需手动调用</li><li>析构函数: 主要作用于对象销毁前系统自动调用, 执行一些清理工作</li></ul><p><strong>构造参数语法: 类名()</strong></p><ol><li>构造函数, 没有返回值也不用写void</li><li>函数名与类名相同</li><li>构造函数可以有参数, 因此可以发生重载</li><li>程序在调用对象的时候自动调用构造, 无需手动调用,而且只会调用一次</li></ol><p><strong>析构函数语法: 类名()</strong></p><ol><li>没有返回值也不用写void</li><li>函数名与类名相同,在名称前加上 <code>~</code></li><li>析构函数不可以有参数, 因此不可以发生重载</li><li>程序在对象销毁的时候自动调用, 无需手动调用,而且只会调用一次</li></ol><h6 id="4-2-2-构造函数的分类以及调用"><a href="#4-2-2-构造函数的分类以及调用" class="headerlink" title="4.2.2 构造函数的分类以及调用"></a>4.2.2 构造函数的分类以及调用</h6><p>两种分类方式:</p><ul><li>按参数分为:  有参构造和无参构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Person()&#123;  <span class="comment">// 默认构造函数自己不写的话, 系统会自动生成</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;无参构造&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">Person(<span class="keyword">int</span> a)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;有参 int a 构造&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>按照类型分类: 普通构造和拷贝构造</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拷贝构造函数  将一个对象的属性拷贝到另一个对象身上</span></span><br><span class="line">Peoson(<span class="keyword">const</span> Person &amp;p)&#123;</span><br><span class="line">age = p.age;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; <span class="string">&quot; 拷贝构造函数&quot;</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用演示:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 括号法</span></span><br><span class="line">Person p;  <span class="comment">// 默认构造函数   调用默认构造函数时, 不要加().  Person p(); 编译器会认为是函数的声明, 不会认为是创建对象</span></span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">// 有参构造函数调用</span></span><br><span class="line"><span class="function">Person <span class="title">p3</span><span class="params">(p2)</span></span>; <span class="comment">// 拷贝构造函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 显式法</span></span><br><span class="line">Person p1;</span><br><span class="line">Person p2 = Person(<span class="number">10</span>); </span><br><span class="line">Person(<span class="number">10</span>); <span class="comment">// 等号右边单独拿出来 称为匿名对象, 当前行结束后, 系统立即回收</span></span><br><span class="line">Person p3 = Person(p2);</span><br><span class="line"><span class="comment">// 注意不要使用拷贝构造初始化匿名对象   Person(p3);  编译器会认为 Person(p3) === Person p3; 对象声明</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 隐式转换法</span></span><br><span class="line">Person p1 = <span class="number">10</span>;  相当于Person p1 = Person(<span class="number">10</span>);</span><br><span class="line">person p4 = p3; 相当于Person p4 = Person(p3);</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="4-2-3-拷贝调用函数使用时机"><a href="#4-2-3-拷贝调用函数使用时机" class="headerlink" title="4.2.3 拷贝调用函数使用时机"></a>4.2.3 拷贝调用函数使用时机</h6><ul><li>使用一个已经创建完毕的对象初始化一个新对象</li><li>值传递方式方式给函数参数传值</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(Person p1)</span></span>&#123;</span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Person p;  <span class="comment">//调用默认构造函数</span></span><br><span class="line">    doWork(p);<span class="comment">// 调用拷贝构造函数  形参中p1 是p的复制品</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>值方式返回局部变量</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p1;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)&amp; p1 &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 地址一</span></span><br><span class="line"><span class="keyword">return</span> p1;</span><br><span class="line">&#125;  <span class="comment">// 局部变量p1 在test函数执行完就销毁了, 编译器调用拷贝构造函数创建了一个新的对象</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Person p = test();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; (<span class="keyword">int</span>*)&amp; p &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 地址二 与地址一并不相同</span></span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="4-2-4-构造函数的调用规则"><a href="#4-2-4-构造函数的调用规则" class="headerlink" title="4.2.4 构造函数的调用规则"></a>4.2.4 构造函数的调用规则</h6><p>默认情况下, C++ 编译器至少给一个类添加3个函数</p><ol><li>默认构造无参</li><li>默认析构函数</li><li>默认拷贝构造函数, 对属性值进行值拷贝</li></ol><p>构造函数调用规则:  自己写的高级构造函数会屏蔽编译器提供的默认构造函数</p><ol><li>如果用户定义有参构造函数, c++不再提供无参构造, 但是会提供默认拷贝函数</li><li>如果用户定义拷贝构造函数, C++ 不在提供其他构造函数</li></ol><h6 id="4-2-5-深拷贝与浅拷贝"><a href="#4-2-5-深拷贝与浅拷贝" class="headerlink" title="4.2.5 深拷贝与浅拷贝"></a>4.2.5 深拷贝与浅拷贝</h6><p>浅拷贝: 简单的赋值拷贝操作  </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;  <span class="comment">//编译器做的拷贝构造函数 浅拷贝</span></span><br></pre></td></tr></table></figure><p>深拷贝: 在堆中</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  示范浅拷贝存在的错误</span></span><br><span class="line">~Person()&#123;  <span class="comment">//析构函数的作用</span></span><br><span class="line">    <span class="keyword">if</span>(m_height!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_height;</span><br><span class="line">        m_height = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_age;</span><br><span class="line"><span class="keyword">int</span> *m_height;  <span class="comment">// 把身高的数据 开辟到堆区域</span></span><br><span class="line">Person(<span class="keyword">int</span> age, <span class="keyword">int</span> height)&#123;</span><br><span class="line">m_age = age;</span><br><span class="line">m_height = <span class="keyword">new</span> <span class="keyword">int</span>(height);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="number">10</span>, <span class="number">160</span>)</span></span>;  <span class="comment">// 假如p1的身高160存在区域0X0011, 对象p2直接把0x0011复制过去了</span></span><br><span class="line">    <span class="function">Person <span class="title">p2</span><span class="params">(p1)</span></span>;    <span class="comment">//  执行报错误</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 栈里面先进后出 所以先释放p2</span></span><br><span class="line"><span class="comment">// 这里是浅拷贝存在的问题: 释放已经释放的内存, 是非法操作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自己实现拷贝,实现深拷贝</span></span><br><span class="line">Person(<span class="keyword">const</span> Person &amp; p)&#123;</span><br><span class="line">    m_age = p.m_age;</span><br><span class="line">    m_height = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_height);</span><br><span class="line">&#125;  <span class="comment">// 这个m_height的地址就和原本的地址不同了</span></span><br></pre></td></tr></table></figure><h6 id="4-2-6-初始化列表"><a href="#4-2-6-初始化列表" class="headerlink" title="4.2.6 初始化列表"></a>4.2.6 初始化列表</h6><p>作用: 用来初始化属性</p><p>语法: 构造函数():属性1(值1), 属性2(值2),</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 注意冒号的位置</span><br><span class="line">Person(int a, int b, int c):m_a(a),m_b(b),m_c(c)&#123;</span><br><span class="line">&#125;</span><br><span class="line">Person p;</span><br></pre></td></tr></table></figure><h6 id="4-2-7-类对象作为类成员"><a href="#4-2-7-类对象作为类成员" class="headerlink" title="4.2.7 类对象作为类成员"></a>4.2.7 类对象作为类成员</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span>&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&#123;</span></span><br><span class="line">A a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 先构造A的对象, 再构造B的对象</span></span><br><span class="line"><span class="comment">// 析构的时候, 先销毁B, 在销毁A</span></span><br></pre></td></tr></table></figure><h6 id="4-2-8-静态成员"><a href="#4-2-8-静态成员" class="headerlink" title="4.2.8  静态成员"></a>4.2.8  静态成员</h6><p>在成员变量和函数前加上static</p><p>静态成员变量</p><ul><li>所有的对象共享一份数据</li><li>在编译阶段分配内存</li><li>类内声明,类外初始化</li><li>可以通过类名直接访问, 也可以使用对象调用</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 这个函数的数据在内存中 只有一份</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_a = <span class="number">100</span>;   <span class="comment">//静态成员函数可以访问静态成员变量</span></span><br><span class="line">m_b =<span class="number">200</span>; <span class="comment">//这一行报错  当用对象p1 p2 调用的时候, 编译器不知道m_b是谁的数据</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> m_a; <span class="comment">//类内声明</span></span><br><span class="line"><span class="keyword">int</span> m_b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Person::m_a = <span class="number">0</span>;  <span class="comment">//类外初始化</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>静态成员函数</p><ul><li>所有对象共享一个函数</li><li>静态成员函数只能访问静态成员变量</li></ul><h5 id="4-3-C-对象模型和this指针"><a href="#4-3-C-对象模型和this指针" class="headerlink" title="4.3 C++ 对象模型和this指针"></a>4.3 C++ 对象模型和this指针</h5><h6 id="4-3-1-成员变量和成员函数分开存储"><a href="#4-3-1-成员变量和成员函数分开存储" class="headerlink" title="4.3.1 成员变量和成员函数分开存储"></a>4.3.1 成员变量和成员函数分开存储</h6><p>C++中,类内的成员变量和成员函数分开存储.  只有非静态成员变量才属于类的对象上</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 空对象占用一个字节 , 为了区分空对象占内存的位置, 每个空对象都该有自己的内存地址</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_a; <span class="comment">//只要没有static 都是非静态变量  4个字节</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_b;  <span class="comment">//不占用大小</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fun</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">//分开存储的  也不占用大小</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func2</span><span class="params">()</span></span>&#123;&#125;  <span class="comment">//  也不占用大小</span></span><br><span class="line">&#125;;</span><br><span class="line">Person p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;size of p&quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(p);  <span class="comment">// 大小为4字节 </span></span><br></pre></td></tr></table></figure><h6 id="4-3-2-this指针概念"><a href="#4-3-2-this指针概念" class="headerlink" title="4.3.2  this指针概念"></a>4.3.2  this指针概念</h6><p>C++中,类内的成员变量和成员函数分开存储, 每个非静态成员函数只会诞生一份函数实例, 也就是说多个同类型的对象会共用一块代码. 问题是这一块代码如何区分哪个对象调用自己?</p><p>C++ 通过提供的特殊的对象指针, this 指针, <strong>this指针指向被调用的成员函数所属的对象.</strong> </p><p>this指针是隐含每一个非静态成员函数内的一种指针, 不需要定义,直接使用</p><p>this指针的用途:</p><ul><li>当形参和成员变量同名的时候, 可以用this区分   解决名称冲突.</li><li>在类的非静态成员函数中返回对象本身, 可使用return *this</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不加引用的话, 返回的是p2的拷贝</span></span><br><span class="line"><span class="function">Person&amp; <span class="title">funct</span><span class="params">(Person &amp; p)</span></span>&#123; <span class="comment">//要返回本体,需要用引用的方式返回</span></span><br><span class="line"><span class="keyword">this</span>-&gt;age += p.age;</span><br><span class="line"><span class="keyword">return</span> *<span class="keyword">this</span>;  <span class="comment">// 返回对象本身    </span></span><br><span class="line">&#125;</span><br><span class="line">p2.funct(p1).funct(p1).funct(p1);  <span class="comment">//链式编程思想</span></span><br></pre></td></tr></table></figure><h6 id="4-3-3-空指针访问成员函数"><a href="#4-3-3-空指针访问成员函数" class="headerlink" title="4.3.3 空指针访问成员函数"></a>4.3.3 空指针访问成员函数</h6><p>C++中空指针也是可以调用成员函数, 但是要注意有没有用到this指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person * p =<span class="literal">NULL</span>;</span><br><span class="line">p.showAge();  <span class="comment">//报错, this-&gt;age  是一个空的值, 访问年龄出错</span></span><br><span class="line">p.showClaaName();   <span class="comment">//可以正常运行</span></span><br></pre></td></tr></table></figure><h6 id="4-3-4-const修饰成员函数"><a href="#4-3-4-const修饰成员函数" class="headerlink" title="4.3.4 const修饰成员函数"></a>4.3.4 <code>const</code>修饰成员函数</h6><p>常函数与常对象通常是配对出现的</p><p>常函数</p><ul><li>成员函数后加<code>const</code> 我们称这个函数为常函数</li><li>常函数内不可以修改成员属性</li><li>成员属性声明时加关键字mutable后, 在常函数中依然可以修改</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// this指针的本质是 指针常量  指针的指向不可以修改  举例指针常量 int * const p;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.m_Age = <span class="number">100</span>;  <span class="comment">//指针常量的值可以变</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showPerson</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line"><span class="comment">// this =NULL  错误, this的指向不可以改变</span></span><br><span class="line">    <span class="comment">//  指针指向的值也不可以更改了 因为函数后面加了const</span></span><br><span class="line">    <span class="keyword">this</span>.m_B = <span class="number">100</span>;  <span class="comment">//这个变量前有关键字</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line"><span class="keyword">mutable</span> <span class="keyword">int</span> m_B;  <span class="comment">//常函数,常对象下都可以修改</span></span><br></pre></td></tr></table></figure><p>常对象:</p><ul><li>声明对象前加<code>const</code>称对象为常对象</li><li>常对象只能调用常函数</li></ul><h5 id="4-4-友元函数"><a href="#4-4-友元函数" class="headerlink" title="4,4 友元函数"></a>4,4 友元函数</h5><p>友元函数的目的就是让一个函数或者类访问另一个函数中的私有成员</p><p>友元函数的三种实现</p><ol><li>全局函数做友元</li><li>类做友元</li><li>成员函数做友元</li></ol><h6 id="4-4-1-全局函数作为友元"><a href="#4-4-1-全局函数作为友元" class="headerlink" title="4.4.1 全局函数作为友元"></a>4.4.1 全局函数作为友元</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building &amp;building)</span></span>; <span class="comment">// 加了这一句后, 下面的那一行就不报错了</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Building()&#123;</span><br><span class="line">            SittingRoom = <span class="string">&quot;客厅&quot;</span>;</span><br><span class="line">            Bedroom = <span class="string">&quot;卧室&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    strign SittingRoom;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> Bedroom;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">goodGay</span><span class="params">(Building &amp;building)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 好基友全局函数 正在访问: &quot;</span> &lt;&lt; building.sittingRoom &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; 好基友全局函数 正在访问: &quot;</span> &lt;&lt; building.Bedroom &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-4-2-类做友元"><a href="#4-4-2-类做友元" class="headerlink" title="4.4.2 类做友元"></a>4.4.2 类做友元</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Building</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">goodGay</span>;</span>  <span class="comment">// goodGay类是本类的好朋友 , 可以访问私有成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-4-3-成员函数做友元"><a href="#4-4-3-成员函数做友元" class="headerlink" title="4.4.3 成员函数做友元"></a>4.4.3 成员函数做友元</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">GoodGay::visit</span><span class="params">()</span></span>;<span class="comment">// 告诉编译器GoodGay类下的visit函数可以访问私有成员</span></span><br></pre></td></tr></table></figure><h5 id="4-5-运算符重载"><a href="#4-5-运算符重载" class="headerlink" title="4.5 运算符重载"></a>4.5 运算符重载</h5><p>对已有的运算符重新定义, 富裕另一种功能, 以适应不同的数据类型(如两个Person类型如何相加)</p><p>运算符重载也可以发生函数重载(operator+ 就相当于函数名)</p><h6 id="4-5-1-加号运算符重载"><a href="#4-5-1-加号运算符重载" class="headerlink" title="4.5.1 加号运算符重载"></a>4.5.1 加号运算符重载</h6><p>作用: 实现两个自定义类型相加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">Person p1;</span><br><span class="line">p1.m_a = <span class="number">10</span>;</span><br><span class="line">p1.m_b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">Person p2;</span><br><span class="line">p2.m_a = <span class="number">20</span>;</span><br><span class="line">p2.m_b = <span class="number">20</span>;</span><br><span class="line"><span class="comment">// 求 p1 + p2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过成员函数重载+号 写在Person类里面</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person &amp; p)&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_a = <span class="keyword">this</span>.m_a + p.m_a;</span><br><span class="line">    temp.m_b = <span class="keyword">this</span>.m_b + p.m_b;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person p3 = p1.<span class="keyword">operator</span>+(p2);</span><br><span class="line">Person p3 = p1 + p2;  <span class="comment">//简化写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//通过全局函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person &amp; p1, Person&amp; p2)&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_a = p1.m_a + p2.m_a;</span><br><span class="line">    temp.m_b = p1.m_b + p2.m_b;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person p3 = <span class="keyword">operator</span>+(p1,p2);</span><br><span class="line">Person p3 = p1 + p2;  <span class="comment">//简化写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数重载</span></span><br><span class="line">Person <span class="keyword">operator</span>+ (Person &amp; p1, <span class="keyword">int</span> num)&#123;</span><br><span class="line">    Person temp;</span><br><span class="line">    temp.m_a = p1.m_a + num;</span><br><span class="line">    temp.m_b = p1.m_b + num;</span><br><span class="line">    <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br><span class="line">Person p3 = p1 + <span class="number">100</span>;</span><br></pre></td></tr></table></figure><blockquote><p>总结1: 对于内置的数据类型的表达式的运算符不可能改变</p></blockquote><blockquote><p>总结二: 不要乱用运算符重载</p></blockquote><h6 id="4-5-2-左移运算符重载"><a href="#4-5-2-左移运算符重载" class="headerlink" title="4.5.2 左移运算符重载"></a>4.5.2 左移运算符重载</h6><p><code>&lt;&lt;</code>  作用:  可以输出自定义的数据内容</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 无法使用成员函数重载左移运算符</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt; (Person&amp; p)&#123;  <span class="comment">// 这样写的话 调用p.operator&lt;&lt;(p), 因为是类成员函数,所以只能对象p调用</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.m_a  &lt;&lt; p.m_b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt; (<span class="built_in">cout</span>)&#123;  <span class="comment">// 这样写的话  调用的时候就是 p&lt;&lt;cout; 与预想反了</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 只能利用全局函数重载左移运算符</span></span><br><span class="line"><span class="comment">// 本质 operator&lt;&lt; (cout, p) 简化 cout &lt;&lt; p</span></span><br><span class="line"><span class="keyword">void</span> <span class="keyword">operator</span>&lt;&lt; (ostream <span class="built_in">cout</span>, Person&amp; p)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.m_a  &lt;&lt; p.m_b;</span><br><span class="line">&#125; <span class="comment">//返回类型是void,不能链式编程</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 局部变量, 要返回本体,需要用引用的方式返回, 否则的话 就是cout的拷贝</span></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt; (ostream&amp; <span class="built_in">cout</span>, Person&amp; p)&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; p.m_a  &lt;&lt; p.m_b;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cout</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="4-5-3-递增运算符重载"><a href="#4-5-3-递增运算符重载" class="headerlink" title="4.5.3 递增运算符重载"></a>4.5.3 递增运算符重载</h6><p>通过递增运算符, 实现自己的整型类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a  = <span class="number">10</span>; </span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a++;  <span class="comment">//10</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; a;  <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> b = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; ++b; <span class="comment">//11;</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; b ;  <span class="comment">//11</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyInteger</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyInteger()&#123;</span><br><span class="line">        m_Num = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//重载前置++运算符  这里使用引用和不使用引用产生的结果是相同的 为什么呢?默认情况下: </span></span><br><span class="line">    <span class="comment">// int a = 0;</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; ++a; //1</span></span><br><span class="line">    <span class="comment">//cout &lt;&lt; ++(++a); //2</span></span><br><span class="line">    <span class="comment">// cout &lt;&lt; a;   //2   说明一直是对一个数操作, 也就是一直对a的本体进行操作</span></span><br><span class="line">    MyInteger&amp; <span class="keyword">operator</span>++()&#123;</span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//重载后置++ 运算符  clion中显示 cout&lt;&lt;(a++)++;不合法</span></span><br><span class="line">    <span class="comment">// 后面的那个int是占位参数, 区分前置和后置</span></span><br><span class="line">    <span class="comment">// 后置返回的是值,局部对象  如果返回局部变量的引用, 这个函数结束后, 就是非法操作了</span></span><br><span class="line">    MyInteger <span class="keyword">operator</span>++(<span class="keyword">int</span>)&#123;</span><br><span class="line">        <span class="comment">//先记录结果</span></span><br><span class="line">        MyInteger temp = *<span class="keyword">this</span>;</span><br><span class="line">        m_Num++;</span><br><span class="line">        <span class="keyword">return</span> temp;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-5-4-赋值运算符重载"><a href="#4-5-4-赋值运算符重载" class="headerlink" title="4.5.4 赋值运算符重载"></a>4.5.4 赋值运算符重载</h6><p>默认情况下, C++ 编译器至少给一个类添加4个函数</p><ol><li>默认构造无参</li><li>默认析构函数</li><li>默认拷贝构造函数, 对属性值进行值拷贝</li><li>赋值运算符operator= ,对属性进行值拷贝  上一次没有包括这个</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Person(<span class="keyword">int</span> age)&#123;</span><br><span class="line">        m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> *m_Age;  <span class="comment">// 开辟到堆区域</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 与4.2.5节相似 利用深拷贝解决问题</span></span><br><span class="line"><span class="comment">// 返回Person类型 链式编程思想   如果不知道一个函数的返回值时, 先用void, 后期再更改</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>= (<span class="keyword">const</span> Person&amp; p)&#123;</span><br><span class="line">    <span class="comment">// 应该先判断是否有属性在堆区, 先释放再拷贝</span></span><br><span class="line">    <span class="keyword">if</span>(m_Age != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">delete</span> m_Age;</span><br><span class="line">        m_Age = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    m_Age = <span class="keyword">new</span> <span class="keyword">int</span>(*p.m_Age);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><h6 id="4-5-5-关系运算符重载"><a href="#4-5-5-关系运算符重载" class="headerlink" title="4.5.5 关系运算符重载"></a>4.5.5 关系运算符重载</h6><p>作用: 让两个自定义数据类型进行对比</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Person <span class="title">p1</span><span class="params">(<span class="string">&quot;张三&quot;</span>,<span class="number">10</span>)</span></span>;</span><br><span class="line"><span class="function">Person <span class="title">p2</span><span class="params">(<span class="string">&quot;李四&quot;</span>,<span class="number">20</span>)</span></span>;</span><br><span class="line"><span class="comment">// 全局函数</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Peoson&amp; p1, <span class="keyword">const</span> Person&amp; p2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(p1.m_Age &lt; p2.m_Age)&#123;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 类内成员函数</span></span><br><span class="line">Person&amp; <span class="keyword">operator</span>&lt; (<span class="keyword">const</span> Person&amp; p2)&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_Age &lt; p2.m_Age)&#123;</span><br><span class="line">        <span class="keyword">return</span> p2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-5-6-函数调用运算符-重载"><a href="#4-5-6-函数调用运算符-重载" class="headerlink" title="4.5.6 函数调用运算符 () 重载"></a>4.5.6 函数调用运算符 <code>()</code> 重载</h6><ul><li>函数调用运算符()也可以重载</li><li>重载后非常像函数的调用,因此也叫仿函数</li><li><strong>没有固定的写法, 非常灵活</strong></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyPrint</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 重载函数调用符</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="built_in">string</span> test)</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; test;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数调用</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Myprint</span><span class="params">(<span class="built_in">string</span> test)</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; test;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyPrint myprint;</span><br><span class="line">myprint(<span class="string">&quot;hello world!&quot;</span>);<span class="comment">//仿函数</span></span><br><span class="line">Myprint(<span class="string">&quot;hello world!&quot;</span>); <span class="comment">//函数调用</span></span><br><span class="line"><span class="comment">// 匿名对象,类名加小括号 MyPrint()(&quot;Hello world!&quot;);  当前行执行完立即释放</span></span><br></pre></td></tr></table></figure><h5 id="4-6-继承"><a href="#4-6-继承" class="headerlink" title="4.6 继承"></a>4.6 继承</h5><p>类和类之间存在特殊的关系, 如下图所示</p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211223224735331.png" class="" title="image-20211223224735331"><p>定义这些类时, 下级别的成员除了拥有上一级的共性, 还有自己的特性.  使用继承,减少重复代码</p><h6 id="4-6-1-继承的基本语法"><a href="#4-6-1-继承的基本语法" class="headerlink" title="4.6.1 继承的基本语法"></a>4.6.1 继承的基本语法</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Java</span> :</span> <span class="keyword">public</span> BasePage&#123;  <span class="comment">//继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">content</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; java 内容&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h6 id="4-6-2-继承方式"><a href="#4-6-2-继承方式" class="headerlink" title="4.6.2 继承方式"></a>4.6.2 继承方式</h6><p>继承语法:  <code>class 子类 : 继承方式 父类</code></p><p>继承方式: </p><ul><li>公共继承</li><li>保护继承    保护权限 类内可以访问, 类外不可以</li><li>私有继承     私有权限 友元函数可以访问</li></ul><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211223230422760.png" class="" title="image-20211223230422760"><h6 id="4-6-3-继承中的对象模型"><a href="#4-6-3-继承中的对象模型" class="headerlink" title="4.6.3 继承中的对象模型"></a>4.6.3 继承中的对象模型</h6><p>问题: 从父类继承过来的成员, 哪些属于子类对象中?     使用<code>sizeof</code>打印对象大小. </p><p><strong>父类中所有非静态成员属性都会被子类继承下去, 父类中私有成员属性被编译器隐藏了, 访问不到, 但确实是被继承了</strong> </p><p>在<code>vs2017</code>开发工具命令提示符中  运行下列命令 </p><p><code>cl /d1 reportSingleClassLayout类名 文件名 </code></p><h6 id="4-6-4-继承中构造和析构的顺序"><a href="#4-6-4-继承中构造和析构的顺序" class="headerlink" title="4.6.4 继承中构造和析构的顺序"></a>4.6.4 继承中构造和析构的顺序</h6><p>问题:  父类和子类的构造和析构顺序先后 ?</p><ul><li>父类的构造</li><li>儿子的构造</li><li>儿子的析构</li><li>父类的析构</li></ul><h6 id="4-6-5-继承中同名成员的处理方式"><a href="#4-6-5-继承中同名成员的处理方式" class="headerlink" title="4.6.5 继承中同名成员的处理方式"></a>4.6.5 继承中同名成员的处理方式</h6><p>问题:  当子类中和父类中出现同名的成员, 如何通过子类的对象去访问</p><ul><li>访问子类同名成员, 直接访问即可</li><li>访问父类同名成员, 需加上作用域</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Base()&#123;</span><br><span class="line">        m_A = <span class="number">100</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的func调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Son()&#123;</span><br><span class="line">        m_A =<span class="number">200</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Son下的func调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> m_A ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名的成员属性的处理方式</span></span><br><span class="line">Son s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.m_A; <span class="comment">// 100</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; s.Base::m_A;  <span class="comment">// 200</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同名的成员函数调用的处理方式</span></span><br><span class="line">Son s;</span><br><span class="line">s.func();  <span class="comment">// 调用子类中的成员函数</span></span><br><span class="line">s.Base::func(); <span class="comment">// 调用父类中的成员函数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 总结:只要子类中出现了父类中的同名的函数, 子类的同名会隐藏掉父类的所有同名函数</span></span><br></pre></td></tr></table></figure><h6 id="4-6-6-继承中同名静态成员处理方式"><a href="#4-6-6-继承中同名静态成员处理方式" class="headerlink" title="4.6.6 继承中同名静态成员处理方式"></a>4.6.6 继承中同名静态成员处理方式</h6><p><strong>静态成员 4.2.8</strong> 小节</p><ul><li>所有的对象共享一份数据</li><li>在编译阶段分配内存</li><li>类内声明,类外初始化</li><li>可以类名访问, 也可以对象访问</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的func调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Base::m_A =<span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> :</span> <span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Base下的func调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> m_A;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> Son::m_A = <span class="number">200</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Son::m_A; <span class="comment">// 可以直接通过类名访问</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; Son::Base::m_A; <span class="comment">// 通过第一个::来访问父类作用域下的静态成员</span></span><br><span class="line"></span><br><span class="line">总结:只要子类中出现了父类中的静态同名的函数, 子类的同名会隐藏掉父类的所有静态同名函数</span><br></pre></td></tr></table></figure><h6 id="4-6-7-多继承语法"><a href="#4-6-7-多继承语法" class="headerlink" title="4.6.7 多继承语法"></a>4.6.7 多继承语法</h6><p>语法: <code>class 子类 : 继承方式 父类1, 继承方式 父类2 ...</code></p><p>多继承可能会出现重名函数的问题, 因此需要加上作用域来区分(实际开发中不建议多继承)</p><h6 id="4-6-8-菱形继承"><a href="#4-6-8-菱形继承" class="headerlink" title="4.6.8 菱形继承"></a>4.6.8 菱形继承</h6><p>菱形继承概念: </p><p>​    两个派生类继承一个基类</p><p>​    又有某个类同时继承两个派生类</p><p>又称为菱形继承或者钻石继承</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camel</span> :</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SheepCamel</span> :</span> <span class="keyword">public</span> Sheep, <span class="keyword">public</span> Camel&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当菱形继承的时候, 两个父类具有相同的数据, 需要加数据域区分</span></span><br><span class="line">SheepCamel sc;</span><br><span class="line">sc.Sheep::m_Age = <span class="number">18</span>;</span><br><span class="line">sc.Camel::m_Age = <span class="number">28</span>; <span class="comment">// 菱形继承导致数据有两份, 两个年龄, 资源浪费</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用虚继承可以解决菱形继承的问题</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sheep</span> :</span> <span class="keyword">virtual</span> <span class="keyword">public</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Camel</span> :</span> <span class="keyword">public</span> <span class="keyword">virtual</span> Animal&#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这个时候只剩下一个m_Age</span></span><br><span class="line">sc.Sheep::m_Age = <span class="number">18</span>;  <span class="comment">// 将m_Age赋值为18</span></span><br><span class="line">sc.Camel::m_Age = <span class="number">28</span>;  <span class="comment">// 将m_Age赋值为28</span></span><br><span class="line">sc.m_Age ;  <span class="comment">//  这三个都是同一个数据   </span></span><br><span class="line"><span class="comment">// 虚继承实质是继承了两个指针, 加上偏移量就能指向唯一的数据</span></span><br></pre></td></tr></table></figure><h5 id="4-7-多态"><a href="#4-7-多态" class="headerlink" title="4.7 多态"></a>4.7 多态</h5><h6 id="4-7-1-多态的基本概念"><a href="#4-7-1-多态的基本概念" class="headerlink" title="4.7.1 多态的基本概念"></a>4.7.1 多态的基本概念</h6><p>多态分为两类</p><ul><li>静态多态: 函数重载和运算符重载属于静态多态, 复用函数名</li><li>动态多态: 派生类和虚函数运行时多态</li></ul><p>静态和动态的区别:</p><ul><li>静态多态的函数地址早绑定- 编译阶段确定函数地址</li><li>动态多态的函数地址晚绑定- 运行阶段确定函数地址</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;喵喵!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 地址早绑定, 编译阶段确定了函数地址, 这里是animal</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doSpeak</span><span class="params">(Animal&amp; animal)</span></span>&#123;</span><br><span class="line">    animal.speck();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    doSpeck(cat);  <span class="comment">// 问题:  这个调用哪个说话   结果是 动物在说话</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果想执行猫说话, 那么这个函数地址就需要在运行时绑定, 使用虚函数</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;动物在说话&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    Cat cat;</span><br><span class="line">    doSpeck(cat);  <span class="comment">// 现在调用就是 猫在说话</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>总结:  </p><ul><li>继承关系                 // 重写: 返回值 函数名 参数完全相同</li><li>子类重写父类中的虚函数  </li></ul><p>动态多态的使用条件</p><ul><li><strong>使用父类的指针或者引用, 执行子类对象</strong></li></ul><p><strong>动态多态内部原理</strong></p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211224221916046.png" class="" title="image-20211224221916046"><p>当子类没有重写父类的虚函数,  子类中的虚函数表和父类的相同</p><p>当子类重写了父类的虚函数, <strong>子类中的虚函数表</strong> 内部会替换成 <strong>子类的虚函数地址</strong></p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211224222226243.png" class="" title="image-20211224222226243"><p><strong>当父类的指针或者引用指向子类的对象的时候, 就发生了多态, 就从子类的<code>vftable</code>中函数的确实的地址</strong></p><h6 id="4-7-2-多态案例一-计算器类"><a href="#4-7-2-多态案例一-计算器类" class="headerlink" title="4.7.2 多态案例一: 计算器类"></a>4.7.2 多态案例一: 计算器类</h6><p>案例描述:</p><p>分别利用普通写法和多态技术, 设计两个操作数进行运算的计算器类</p><p>多态的优点:</p><ul><li>代码组织结构清晰</li><li>可读性强</li><li>利于前期和后期的扩展以及维护</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通方法实现 </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Calculator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getresult</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; oper)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (oper==<span class="string">&quot;+&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;-&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 - m_Num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;*&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 * m_Num2;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (oper == <span class="string">&quot;/&quot;</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 / m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> m_Num1;</span><br><span class="line"><span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">Calculator calculator;</span><br><span class="line">calculator.m_Num2 = <span class="number">10</span>;</span><br><span class="line">calculator.m_Num1 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; calculator.getresult(<span class="string">&quot;+&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用多态实现计算器  不需要修改源码</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 实现计算器抽象类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractCalculator</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">int</span> m_Num1;</span><br><span class="line"><span class="keyword">int</span> m_Num2;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 分别写一个加法类 减法类 乘法类 除法类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AddCalcutor</span>:</span><span class="keyword">public</span> AbstractCalculator&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getResult</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> m_Num1 + m_Num2;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多态的使用条件: 引用或者指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">AbstractCalculator *abstractCalculator = <span class="keyword">new</span> AddCalcutor;</span><br><span class="line">abstractCalculator-&gt;m_Num1 = <span class="number">100</span>;</span><br><span class="line">abstractCalculator-&gt;m_Num2 = <span class="number">100</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; abstractCalculator-&gt;getResult();</span><br><span class="line"><span class="keyword">delete</span> abstractCalculator;  <span class="comment">// 用完释放,数据释放了, 指针没变</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>总结</strong>:  代码量变大了, 组织清晰了, 可读性强  不需要修改源码</p><h6 id="4-7-3-纯虚函数和抽象类"><a href="#4-7-3-纯虚函数和抽象类" class="headerlink" title="4.7.3 纯虚函数和抽象类"></a>4.7.3 纯虚函数和抽象类</h6><p>在多态中, 通常父类中虚函数的实现是毫无意义的,   主要是调用子类重写的内容, 可以把这个函数写作纯虚函数</p><p>纯虚函数语法: <code>virtual 返回值类型 函数名 (参数列表) = 0;</code></p><p>当类中有了纯虚函数, 这个类也称为抽象类</p><p>抽象类特点:</p><ul><li>无法实例化对象</li><li>子类必须重写抽象类中的纯虚函数, 否则也属于抽象类</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 纯虚函数 只要有一个纯虚函数,这个类就称为抽象类</span></span><br><span class="line"><span class="comment">// </span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Base b; 错误, 纯虚函数无法实例化对象</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// Son类没有重写Base类, 所以也属于抽象类</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span>:</span><span class="keyword">public</span> Base&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;func函数调用&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">// 利用多态的技术调用  父类的指针或者引用指向子类的对象</span></span><br><span class="line">    Base * b = <span class="keyword">new</span> Son();</span><br><span class="line">    b-&gt;func();  <span class="comment">// 调用子类的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-7-4-多态案例二-制作饮品"><a href="#4-7-4-多态案例二-制作饮品" class="headerlink" title="4.7.4 多态案例二: 制作饮品"></a>4.7.4 多态案例二: 制作饮品</h6><p>案例描述:</p><p>制作饮品大概流程: 注水、冲泡、倒入杯中、加入佐料</p><p>利用多态技术实现本案例， 提供抽象制作饮品基类，提供子类制作咖啡和茶叶</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractDrinking</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 冲泡</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeDrink</span><span class="params">()</span></span>&#123;</span><br><span class="line">Boil();</span><br><span class="line">Brew();</span><br><span class="line">PourInCup();</span><br><span class="line">PutSomething();</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Coffee</span> :</span><span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;煮水&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;冲泡咖啡&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;加入糖和牛奶&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tea</span> :</span><span class="keyword">public</span> AbstractDrinking&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Boil</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;煮矿泉水&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Brew</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;冲泡茶叶&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PourInCup</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;倒入杯中&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PutSomething</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;加入柠檬&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//制作函数  传入参数 父类的指针调用子类的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doWork</span><span class="params">(AbstractDrinking* abstractDrinking)</span></span>&#123;</span><br><span class="line">abstractDrinking-&gt;makeDrink();</span><br><span class="line">    <span class="keyword">delete</span> abstractDrink;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// 制作咖啡  注意:  这里参数是个指针  </span></span><br><span class="line">doWork(<span class="keyword">new</span> Coffee);</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;----------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">doWork(<span class="keyword">new</span> Tea);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="4-7-5-虚析构和纯虚析构"><a href="#4-7-5-虚析构和纯虚析构" class="headerlink" title="4.7.5 虚析构和纯虚析构"></a>4.7.5 虚析构和纯虚析构</h6><p><strong>多态使用时, 如果子类中有属性开辟到堆区,那么父类指针在释放的时候无法调用到子类的析构代码</strong>, 纯虚析构机试为了解决上述问题</p><p>解决方法: 将父类中的析构函数改为虚析构或者纯虚析构</p><p>虚析构和纯虚析构共性:</p><ul><li>都可以解决父类指针释放子类问题</li><li>都需要记得函数实现</li></ul><p>虚析构汉纯虚析构区别:</p><ul><li>如果是纯虚析构,该类属于抽象类, 无法实例化对象</li></ul><p>虚析构语法:    <code>virtual ~类名()</code></p><p>纯虚析构语法: <code>virtual ~类名() = 0  ;</code></p><p>有纯虚析构后, 这个类也属于抽象类,无法初始化对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Animal()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;animal的构造函数调用\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">virtual</span> ~Animal()&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;animal的析构函数调用\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// virtual ~Animal() = 0; 纯虚析构,需要声明,也需要实现 可能父类的数据也能开辟到堆中</span></span><br><span class="line">    <span class="comment">// 因此纯虚析构也需要代码的实现, 下面三行是纯虚析构的实现</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Animal::~Animal()&#123;</span></span><br><span class="line"><span class="comment">//cout&lt;&lt; &quot;animal 纯虚析构调用\n&quot;;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>:</span><span class="keyword">public</span> Animal&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Cat(<span class="built_in">string</span> name)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;cat的构造函数调用\n&quot;</span>;</span><br><span class="line"><span class="comment">// 堆区创建了一个属性, 应该在cat的析构中释放干净</span></span><br><span class="line">m_Name = <span class="keyword">new</span> <span class="built_in">string</span>(name);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *m_Name &lt;&lt; <span class="string">&quot; is &quot;</span> &lt;&lt; <span class="string">&quot;miaomiao\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">~Cat()&#123;</span><br><span class="line"><span class="keyword">if</span> (m_Name)&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot; cat的析构函数调用\n&quot;</span>;</span><br><span class="line"><span class="keyword">delete</span> m_Name;</span><br><span class="line">m_Name = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">string</span> *m_Name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">Animal *animal = <span class="keyword">new</span> Cat(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">animal-&gt;speak();</span><br><span class="line"><span class="comment">// 父类指针在析构的时候,不会调用子类中析构函数,</span></span><br><span class="line"><span class="comment">// 导致子类如果有堆区属性, 导致内存泄漏  解决:把父类中的析构改为虚析构</span></span><br><span class="line"><span class="keyword">delete</span> animal;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>父类的析构不是虚析构::</strong></p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211225230321220.png" class="" title="image-20211225230321220"><p><strong>父类的析构是虚析构:</strong></p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20211225230211672.png" class="" title="image-20211225230211672"><h6 id="4-7-6-多态案例三-电脑组装"><a href="#4-7-6-多态案例三-电脑组装" class="headerlink" title="4.7.6 多态案例三: 电脑组装"></a>4.7.6 多态案例三: 电脑组装</h6><p>案例描述:</p><p>电脑主要组成部分为: CPU、显卡、内存条，将每个零件封装出抽象基类，并且提供不同的厂商提供不同的零件， 例如Intel厂商和lenovo厂商， 创建电脑类提供让电脑工作的函数，并且调用每个零件工作的接口。</p><p>测试时， 组装三台不同的电脑进行工作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPU</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Memory</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span>  <span class="title">store</span><span class="params">()</span></span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graphic</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span>&#123;</span></span><br><span class="line"><span class="comment">//传入三个零件的指针</span></span><br><span class="line"><span class="comment">// 调用每个零件工作的接口</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Computer(CPU *cpu, Graphic *graphic, Memory* memory) &#123;</span><br><span class="line">m_cpu = cpu;</span><br><span class="line">m_graphic = graphic;</span><br><span class="line">m_memory = memory;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供工作的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">work</span><span class="params">()</span></span>&#123;</span><br><span class="line">m_cpu-&gt;calculate();</span><br><span class="line">m_graphic-&gt;display();</span><br><span class="line">m_memory-&gt;store();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供析构函数 释放是哪个电脑零件</span></span><br><span class="line">~Computer()&#123;</span><br><span class="line"><span class="keyword">if</span> (m_cpu) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_cpu;</span><br><span class="line">m_cpu = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_graphic) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_graphic;</span><br><span class="line">m_graphic = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (m_memory) &#123;</span><br><span class="line"><span class="keyword">delete</span> m_memory;</span><br><span class="line">m_memory = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">CPU* m_cpu;</span><br><span class="line">Graphic* m_graphic;</span><br><span class="line">Memory* m_memory;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体厂商</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterCpu</span>:</span><span class="keyword">public</span> CPU&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inter 的 CPU开始计算!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterGraphic</span>:</span><span class="keyword">public</span> Graphic&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inter 的 显卡开始显示!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InterMemory</span>:</span><span class="keyword">public</span> Memory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Inter 的 内存条开始存储!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMDCpu</span>:</span><span class="keyword">public</span> CPU&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">calculate</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;AMD 的 CPU开始计算!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMDGraphic</span>:</span><span class="keyword">public</span> Graphic&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> <span class="keyword">override</span></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;AMD 的 显卡开始显示!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AMDMemory</span>:</span><span class="keyword">public</span> Memory&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">store</span><span class="params">()</span> <span class="keyword">override</span> </span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;AMD 的 内存条开始存储!\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">// 第一台电脑零件</span></span><br><span class="line">CPU *intelCpu = <span class="keyword">new</span> InterCpu;</span><br><span class="line">Graphic *interGraphic = <span class="keyword">new</span> InterGraphic;</span><br><span class="line">Memory *interMemory = <span class="keyword">new</span> InterMemory;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建第一台电脑 放在堆区</span></span><br><span class="line"><span class="comment">// 下面的两种写法也可以 只不过不会放在堆区</span></span><br><span class="line"><span class="comment">// Computer cmp = Computer(intelCpu, interGraphic, interMemory);</span></span><br><span class="line"><span class="comment">//Computer computer1(intelCpu, interGraphic, interMemory);</span></span><br><span class="line">Computer *computer1 = <span class="keyword">new</span> Computer(intelCpu, interGraphic, interMemory);</span><br><span class="line">computer1-&gt;work();</span><br><span class="line"><span class="keyword">delete</span> computer1;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------------------------------------\n&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建第二台电脑</span></span><br><span class="line">Computer *computer2 = <span class="keyword">new</span> Computer(<span class="keyword">new</span> AMDCpu, <span class="keyword">new</span> AMDGraphic, <span class="keyword">new</span> AMDMemory);</span><br><span class="line">computer2-&gt;work();</span><br><span class="line"><span class="keyword">delete</span> computer2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="5-文件操作"><a href="#5-文件操作" class="headerlink" title="5 文件操作"></a>5 文件操作</h4><p>程序运行时产生的数据都是临时数据, 程序一旦结束都会被释放</p><p>通过<strong>文件</strong>可以将数据持久化</p><p>文件包含<fstream></p><p>文件类型分为两种:</p><ol><li>文本文件:  文件以文本的ASCII码形式存储在计算机中</li><li>二进制文件, 文件以文本二进制形式存储在计算机中</li></ol><p>操作文件的三大类:</p><ol><li><code>ofstream</code>: 写操作</li><li><code>ifstream</code>: 读操作</li><li><code>fstream</code>: 读写操作</li></ol><h5 id="5-1-ASCII文件"><a href="#5-1-ASCII文件" class="headerlink" title="5.1 ASCII文件"></a>5.1 ASCII文件</h5><h5 id="5-1-1-写文件"><a href="#5-1-1-写文件" class="headerlink" title="5.1.1 写文件"></a>5.1.1 写文件</h5><p>写文件步骤如下:</p><ol><li><p>包含头文件</p><p>#include<fstream></p></li><li><p>创建流对象</p><p><code>ofstream ofs</code>;</p></li><li><p>打开文件</p><p>默认路径: 运行<code>cpp</code>文件夹下</p><p><code>ofs.open(&quot;文件路径&quot;,打开方式);</code></p></li><li><p>写数据</p><p><code>ofs&lt;&lt;&quot;写入的数据&quot;</code>;</p></li><li><p>关闭文件</p><p><code>ofs.close();</code></p></li></ol><p>文件打开方式:</p><img src="/2022/01/05/C++%E6%A0%B8%E5%BF%83%E7%BC%96%E7%A8%8B/image-20220103205520110.png" class="" title="image-20220103205520110"><p>**注意:**文件打开方式可以配合使用,利用 <code>|</code> 操作符.</p><p><strong>例如:</strong> 用二进制方式写文件 <code>ios::binary|ios:out</code></p><h5 id="5-1-2-读文件"><a href="#5-1-2-读文件" class="headerlink" title="5.1.2 读文件"></a>5.1.2 读文件</h5><p>读文件步骤如下:</p><ol><li><p>包含头文件</p><p>#include<fstream></p></li><li><p>创建流对象</p><p><code>ifstream ifs</code>;</p></li><li><p>打开文件, 判断是否打开成功</p><p><code>ifs.open(&quot;文件路径&quot;,打开方式);</code></p></li><li><p>读数据</p><p>四种方式读取, 第四种不建议,所以下面只写了三种</p></li><li><p>关闭文件</p><p><code>ifs.close();</code></p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(<span class="string">&quot;test.txt&quot;</span>, ios::out);</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;哈哈&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ofs &lt;&lt; <span class="string">&quot;第二行&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test02</span><span class="params">()</span></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(<span class="string">&quot;test.txt&quot;</span>, ios::in);</span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;打开文件失败!&quot;</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="comment">// 这里其实是按行读取,读了三次,不读取换行符,第四次读到空的时候,自动跳出了(遇到空格应该也换行)</span></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; buf) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; buf &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 第二种 遇到空格不换行</span></span><br><span class="line">    <span class="comment">//while (ifs.getline(buf, sizeof(buf))) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第三种</span></span><br><span class="line">    <span class="comment">//string buf;</span></span><br><span class="line"><span class="comment">//while (getline(ifs, buf)) &#123;</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; buf &lt;&lt; endl;</span></span><br><span class="line"><span class="comment">//&#125;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 第四种 一个一个读的效率肯定没有一行快</span></span><br><span class="line">    <span class="comment">//char c;   </span></span><br><span class="line">    <span class="comment">//while((c=ifs.get()!=EOF)&#123;  //EOF ,end of file</span></span><br><span class="line">    <span class="comment">//    cout &lt;&lt; c;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">ifs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-二进制文件"><a href="#5-2-二进制文件" class="headerlink" title="5.2 二进制文件"></a>5.2 二进制文件</h5><h5 id="5-2-1-写文件"><a href="#5-2-1-写文件" class="headerlink" title="5.2.1 写文件"></a>5.2.1 写文件</h5><p>二进制文件主要调用流对象成员函数write</p><p>函数原型:  <code>ofstream&amp; write(const char * buffer, int len)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">fstream fsm;</span><br><span class="line">fsm.open(<span class="string">&quot;person.txt&quot;</span>, ios::binary | ios::out);</span><br><span class="line">Person person=&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">fsm.write((<span class="keyword">const</span> <span class="keyword">char</span> *) &amp;person, <span class="keyword">sizeof</span>(Person));</span><br><span class="line">fsm.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-2-2-读文件"><a href="#5-2-2-读文件" class="headerlink" title="5.2.2 读文件"></a>5.2.2 读文件</h5><p>二进制文件主要调用流对象成员函数read</p><p>函数原型:  <code>ofstream&amp; read(char * buffer, int len)</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">char</span> m_Name[<span class="number">64</span>];</span><br><span class="line"><span class="keyword">int</span> m_Age;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">fstream fsm;</span><br><span class="line">fsm.open(<span class="string">&quot;person.txt&quot;</span>, ios::binary | ios::out);</span><br><span class="line">Person person=&#123;<span class="string">&quot;张三&quot;</span>, <span class="number">18</span>&#125;;</span><br><span class="line">fsm.write((<span class="keyword">const</span> <span class="keyword">char</span> *) &amp;person, <span class="keyword">sizeof</span>(Person));</span><br><span class="line">fsm.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test01</span><span class="params">()</span></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(<span class="string">&quot;person.txt&quot;</span>, ios::binary | ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open()) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件打开失败&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person p;</span><br><span class="line">ifs.read((<span class="keyword">char</span> *) &amp;p, <span class="keyword">sizeof</span>(Person));</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p.m_Name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于多态的企业职工系统</title>
      <link href="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/"/>
      <url>/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="职工管理系统"><a href="#职工管理系统" class="headerlink" title="职工管理系统"></a>职工管理系统</h1><h2 id="1、管理系统需求"><a href="#1、管理系统需求" class="headerlink" title="1、管理系统需求"></a>1、管理系统需求</h2><p>职工管理系统可以用来管理公司内所有员工的信息</p><p>本教程主要利用C++来实现一个基于多态的职工管理系统</p><p>公司中职工分为三类：普通员工、经理、老板，显示信息时，需要显示职工编号、职工姓名、职工岗位、以及职责</p><p>普通员工职责：完成经理交给的任务</p><p>经理职责：完成老板交给的任务，并下发任务给员工</p><p>老板职责：管理公司所有事务</p><p>管理系统中需要实现的功能如下：</p><ul><li>退出管理程序：退出当前管理系统</li></ul><ul><li>增加职工信息：实现批量添加职工功能，将信息录入到文件中，职工信息为：职工编号、姓名、部门编号</li><li>显示职工信息：显示公司内部所有职工的信息</li><li>删除离职职工：按照编号删除指定的职工</li><li>修改职工信息：按照编号修改职工个人信息</li><li>查找职工信息：按照职工的编号或者职工的姓名进行查找相关的人员信息</li><li>按照编号排序：按照职工编号，进行排序，排序规则由用户指定</li><li>清空所有文档：清空文件中记录的所有职工信息 （清空前需要再次确认，防止误删）</li></ul><p>系统界面效果图如下：</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546511409198.png" class="" width="1546511409198"><p>需根据用户不同的选择，完成不同的功能！</p><h2 id="2、创建项目"><a href="#2、创建项目" class="headerlink" title="2、创建项目"></a>2、创建项目</h2><p>创建项目步骤如下：</p><ul><li>创建新项目</li><li>添加文件</li></ul><h3 id="2-1-创建项目"><a href="#2-1-创建项目" class="headerlink" title="2.1 创建项目"></a>2.1 创建项目</h3><p>打开vs2017后，点击创建新项目，创建新的C++项目</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1544151201465.png" class="" width="1544151201465"><p>填写项目名称以及项目路径，点击确定</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349209805.png" class="" width="1546349209805"><h3 id="2-2-添加文件"><a href="#2-2-添加文件" class="headerlink" title="2.2 添加文件"></a>2.2 添加文件</h3><p>右键源文件，进行添加文件操作</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349360960.png" class="" width="1546349360960"><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349421496.png" class="" width="1546349421496"><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349488752.png" class="" width="1546349488752"><p>至此，项目已创建完毕</p><h2 id="3、创建管理类"><a href="#3、创建管理类" class="headerlink" title="3、创建管理类"></a>3、创建管理类</h2><p>​    管理类负责的内容如下：</p><ul><li>与用户的沟通菜单界面</li><li>对职工增删改查的操作</li><li>与文件的读写交互</li></ul><h3 id="3-1创建文件"><a href="#3-1创建文件" class="headerlink" title="3.1创建文件"></a>3.1创建文件</h3><p>在头文件和源文件的文件夹下分别创建workerManager.h 和 workerManager.cpp文件</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546349904944.png" class="" width="1546349904944"><h3 id="3-2-头文件实现"><a href="#3-2-头文件实现" class="headerlink" title="3.2 头文件实现"></a>3.2 头文件实现</h3><p>在workerManager.h中设计管理类</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WorkerManager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">WorkerManager();</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">~WorkerManager();</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-源文件实现"><a href="#3-3-源文件实现" class="headerlink" title="3.3 源文件实现"></a>3.3 源文件实现</h3><p>在workerManager.cpp中将构造和析构函数空实现补全</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;workerManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">WorkerManager::WorkerManager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">WorkerManager::~WorkerManager()</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>至此职工管理类以创建完毕</p><h2 id="4、菜单功能"><a href="#4、菜单功能" class="headerlink" title="4、菜单功能"></a>4、菜单功能</h2><p>功能描述：与用户的沟通界面</p><h3 id="4-1-添加成员函数"><a href="#4-1-添加成员函数" class="headerlink" title="4.1 添加成员函数"></a>4.1 添加成员函数</h3><p>在管理类workerManager.h中添加成员函数  <code>void Show_Menu();</code></p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546351543942.png" class="" width="1546351543942"><h3 id="4-2-菜单功能实现"><a href="#4-2-菜单功能实现" class="headerlink" title="4.2 菜单功能实现"></a>4.2 菜单功能实现</h3><p>在管理类workerManager.cpp中实现  Show_Menu()函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Show_Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*********  欢迎使用职工管理系统！ **********&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  0.退出管理程序  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  1.增加职工信息  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  2.显示职工信息  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  3.删除离职职工  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  4.修改职工信息  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  5.查找职工信息  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  6.按照编号排序  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;*************  7.清空所有文档  *************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;********************************************&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-测试菜单功能"><a href="#4-3-测试菜单功能" class="headerlink" title="4.3 测试菜单功能"></a>4.3 测试菜单功能</h3><p>在职工管理系统.cpp中测试菜单功能</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;workerManager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">WorkerManager wm;</span><br><span class="line"></span><br><span class="line">wm.Show_Menu();</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行效果如图：</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546352771191.png" class="" width="1546352771191"><h2 id="5、退出功能"><a href="#5、退出功能" class="headerlink" title="5、退出功能"></a>5、退出功能</h2><h3 id="5-1-提供功能接口"><a href="#5-1-提供功能接口" class="headerlink" title="5.1  提供功能接口"></a>5.1  提供功能接口</h3><p>在main函数中提供分支选择，提供每个功能接口</p><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">WorkerManager wm;</span><br><span class="line"><span class="keyword">int</span> choice = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//展示菜单</span></span><br><span class="line">wm.Show_Menu();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入您的选择:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; choice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">switch</span> (choice)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">0</span>: <span class="comment">//退出系统</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//添加职工</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//显示职工</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>: <span class="comment">//删除职工</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">4</span>: <span class="comment">//修改职工</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">5</span>: <span class="comment">//查找职工</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">6</span>: <span class="comment">//排序职工</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">7</span>: <span class="comment">//清空文件</span></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-实现退出功能"><a href="#5-2-实现退出功能" class="headerlink" title="5.2 实现退出功能"></a>5.2 实现退出功能</h3><p>在workerManager.h中提供退出系统的成员函数 <code>    void exitSystem();</code></p><p>在workerManager.cpp中提供具体的功能实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::exitSystem</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;欢迎下次使用&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line"><span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3测试功能"><a href="#5-3测试功能" class="headerlink" title="5.3测试功能"></a>5.3测试功能</h3><p>在main函数分支 0  选项中，调用退出程序的接口</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546353199424.png" class="" width="1546353199424"><p>运行测试效果如图：</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546353155490.png" class="" width="1546353155490"><h2 id="6、创建职工类"><a href="#6、创建职工类" class="headerlink" title="6、创建职工类"></a>6、创建职工类</h2><h3 id="6-1-创建职工抽象类"><a href="#6-1-创建职工抽象类" class="headerlink" title="6.1 创建职工抽象类"></a>6.1 创建职工抽象类</h3><p>职工的分类为：普通员工、经理、老板</p><p>将三种职工抽象到一个类（worker）中,利用多态管理不同职工种类</p><p>职工的属性为：职工编号、职工姓名、职工所在部门编号</p><p>职工的行为为：岗位职责信息描述，获取岗位名称</p><p>头文件文件夹下  创建文件worker.h  文件并且添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//职工抽象基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示个人信息</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"><span class="comment">//获取岗位名称</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getDeptName</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> m_Id; <span class="comment">//职工编号</span></span><br><span class="line"><span class="built_in">string</span> m_Name; <span class="comment">//职工姓名</span></span><br><span class="line"><span class="keyword">int</span> m_DeptId; <span class="comment">//职工所在部门名称编号</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="6-2-创建普通员工类"><a href="#6-2-创建普通员工类" class="headerlink" title="6.2 创建普通员工类"></a>6.2 创建普通员工类</h3><p>普通员工类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数</p><p>在头文件和源文件的文件夹下分别创建employee.h 和 employee.cpp文件</p><p>employee.h中代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//员工类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> :</span><span class="keyword">public</span> Worker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">Employee(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="keyword">int</span> dId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示个人信息</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取职工岗位名称</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>employee.cpp中代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;employee.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Employee::Employee(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="keyword">int</span> dId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_DeptId = dId;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Employee::showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;职工编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">&lt;&lt; <span class="string">&quot; \t职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">&lt;&lt; <span class="string">&quot; \t岗位：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;getDeptName()</span><br><span class="line">&lt;&lt; <span class="string">&quot; \t岗位职责：完成经理交给的任务&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Employee::getDeptName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;员工&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-3-创建经理类"><a href="#6-3-创建经理类" class="headerlink" title="6.3 创建经理类"></a>6.3 创建经理类</h3><p>经理类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数，和普通员工类似</p><p>在头文件和源文件的文件夹下分别创建manager.h 和 manager.cpp文件</p><p>manager.h中代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//经理类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Manager</span> :</span><span class="keyword">public</span> Worker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Manager(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="keyword">int</span> dId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示个人信息</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取职工岗位名称</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>manager.cpp中代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Manager::Manager(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="keyword">int</span> dId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_DeptId = dId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Manager::showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;职工编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">&lt;&lt; <span class="string">&quot; \t职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">&lt;&lt; <span class="string">&quot; \t岗位：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;getDeptName()</span><br><span class="line">&lt;&lt; <span class="string">&quot; \t岗位职责：完成老板交给的任务,并下发任务给员工&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Manager::getDeptName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;经理&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-4-创建老板类"><a href="#6-4-创建老板类" class="headerlink" title="6.4 创建老板类"></a>6.4 创建老板类</h3><p>老板类<strong>继承</strong>职工抽象类，并重写父类中纯虚函数，和普通员工类似</p><p>在头文件和源文件的文件夹下分别创建boss.h 和 boss.cpp文件</p><p>boss.h中代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//老板类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Boss</span> :</span><span class="keyword">public</span> Worker</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">Boss(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="keyword">int</span> dId);</span><br><span class="line"></span><br><span class="line"><span class="comment">//显示个人信息</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">showInfo</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取职工岗位名称</span></span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">getDeptName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>boss.cpp中代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;boss.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">Boss::Boss(<span class="keyword">int</span> id, <span class="built_in">string</span> name, <span class="keyword">int</span> dId)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Id = id;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_Name = name;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_DeptId = dId;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Boss::showInfo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;职工编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Id</span><br><span class="line">&lt;&lt; <span class="string">&quot; \t职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_Name</span><br><span class="line">&lt;&lt; <span class="string">&quot; \t岗位：&quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;getDeptName()</span><br><span class="line">&lt;&lt; <span class="string">&quot; \t岗位职责：管理公司所有事务&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">Boss::getDeptName</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">string</span>(<span class="string">&quot;总裁&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="6-5-测试多态"><a href="#6-5-测试多态" class="headerlink" title="6.5 测试多态"></a>6.5 测试多态</h3><p>在职工管理系统.cpp中添加测试函数，并且运行能够产生多态</p><p>测试代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;worker.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;employee.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;manager.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;boss.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line">worker = <span class="keyword">new</span> Employee(<span class="number">1</span>, <span class="string">&quot;张三&quot;</span>, <span class="number">1</span>);</span><br><span class="line">worker-&gt;showInfo();</span><br><span class="line"><span class="keyword">delete</span> worker;</span><br><span class="line"></span><br><span class="line">worker = <span class="keyword">new</span> Manager(<span class="number">2</span>, <span class="string">&quot;李四&quot;</span>, <span class="number">2</span>);</span><br><span class="line">worker-&gt;showInfo();</span><br><span class="line"><span class="keyword">delete</span> worker;</span><br><span class="line"></span><br><span class="line">worker = <span class="keyword">new</span> Boss(<span class="number">3</span>, <span class="string">&quot;王五&quot;</span>, <span class="number">3</span>);</span><br><span class="line">worker-&gt;showInfo();</span><br><span class="line"><span class="keyword">delete</span> worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行效果如图：</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546398236081.png" class="" width="1546398236081"><p>测试成功后，测试代码可以注释保留，或者选择删除</p><h2 id="7、添加职工"><a href="#7、添加职工" class="headerlink" title="7、添加职工"></a>7、添加职工</h2><p>功能描述：批量添加职工，并且保存到文件中</p><h3 id="7-1-功能分析"><a href="#7-1-功能分析" class="headerlink" title="7.1 功能分析"></a>7.1 功能分析</h3><p>分析：</p><p>用户在批量创建时，可能会创建不同种类的职工</p><p>如果想将所有不同种类的员工都放入到一个数组中，可以将所有员工的指针维护到一个数组里</p><p>如果想在程序中维护这个不定长度的数组，可以将数组创建到堆区，并利用Worker **的指针维护</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546399491099.png" class="" width="1546399491099"><h3 id="7-2-功能实现"><a href="#7-2-功能实现" class="headerlink" title="7.2 功能实现"></a>7.2 功能实现</h3><p>在WokerManager.h头文件中添加成员属性 代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录文件中的人数个数</span></span><br><span class="line"><span class="keyword">int</span> m_EmpNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//员工数组的指针</span></span><br><span class="line">Worker ** m_EmpArray;</span><br></pre></td></tr></table></figure><p>在WorkerManager构造函数中初始化属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WorkerManager::WorkerManager()</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//初始化人数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化数组指针</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在workerManager.h中添加成员函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Add_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>workerManager.cpp中实现该函数</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//增加职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Add_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入增加职工数量： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> addNum = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; addNum;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (addNum &gt; <span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//计算新空间大小</span></span><br><span class="line"><span class="keyword">int</span> newSize = <span class="keyword">this</span>-&gt;m_EmpNum + addNum;</span><br><span class="line"></span><br><span class="line"><span class="comment">//开辟新空间</span></span><br><span class="line">Worker ** newSpace = <span class="keyword">new</span> Worker*[newSize];</span><br><span class="line"></span><br><span class="line"><span class="comment">//将原空间下内容存放到新空间下</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">newSpace[i] = <span class="keyword">this</span>-&gt;m_EmpArray[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入新数据</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; addNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> dSelect;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第 &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; 个新职工编号：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入第 &quot;</span> &lt;&lt; i + <span class="number">1</span> &lt;&lt; <span class="string">&quot; 个新职工姓名：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择该职工的岗位：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、普通职工&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、经理&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3、老板&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dSelect;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">switch</span> (dSelect)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: <span class="comment">//普通员工</span></span><br><span class="line">worker = <span class="keyword">new</span> Employee(id, name, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: <span class="comment">//经理</span></span><br><span class="line">worker = <span class="keyword">new</span> Manager(id, name, <span class="number">2</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:  <span class="comment">//老板</span></span><br><span class="line">worker = <span class="keyword">new</span> Boss(id, name, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">newSpace[<span class="keyword">this</span>-&gt;m_EmpNum + i] = worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放原有空间</span></span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_EmpArray;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改新空间的指向</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray = newSpace;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更新新的个数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpNum = newSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//提示信息</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;成功添加&quot;</span> &lt;&lt; addNum &lt;&lt; <span class="string">&quot;名新职工！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入有误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在WorkerManager.cpp的析构函数中，释放堆区数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">WorkerManager::~WorkerManager()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_EmpArray;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="7-3-测试添加"><a href="#7-3-测试添加" class="headerlink" title="7.3 测试添加"></a>7.3 测试添加</h3><p>在main函数分支 1  选项中，调用添加职工接口</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546401705277.png" class="" width="1546401705277"><p>效果如图：</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546401763461.png" class="" width="1546401763461"><p>至此，添加职工到程序中功能实现完毕</p><h2 id="8、文件交互-写文件"><a href="#8、文件交互-写文件" class="headerlink" title="8、文件交互 - 写文件"></a>8、文件交互 - 写文件</h2><p>功能描述：对文件进行读写</p><p>​    在上一个添加功能中，我们只是将所有的数据添加到了内存中，一旦程序结束就无法保存了</p><p>​    因此文件管理类中需要一个与文件进行交互的功能，对于文件进行读写操作</p><h3 id="8-1-设定文件路径"><a href="#8-1-设定文件路径" class="headerlink" title="8.1 设定文件路径"></a>8.1 设定文件路径</h3><p>首先我们将文件路径，在workerManager.h中添加宏常量,并且包含头文件 fstream</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  FILENAME <span class="meta-string">&quot;empFile.txt&quot;</span></span></span><br></pre></td></tr></table></figure><h3 id="8-2-成员函数声明"><a href="#8-2-成员函数声明" class="headerlink" title="8.2 成员函数声明"></a>8.2 成员函数声明</h3><p>在workerManager.h中类里添加成员函数 <code>void save()</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="8-3-保存文件功能实现"><a href="#8-3-保存文件功能实现" class="headerlink" title="8.3 保存文件功能实现"></a>8.3 保存文件功能实现</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::save</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ofstream ofs;</span><br><span class="line">ofs.open(FILENAME, ios::out);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line">ofs &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Id &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">&lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Name &lt;&lt; <span class="string">&quot; &quot;</span> </span><br><span class="line">&lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofs.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="8-4-保存文件功能测试"><a href="#8-4-保存文件功能测试" class="headerlink" title="8.4 保存文件功能测试"></a>8.4 保存文件功能测试</h3><p>在添加职工功能中添加成功后添加保存文件函数</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546432469465.png" class="" width="1546432469465"><p>再次运行代码，添加职工</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546401763461.png" class="" width="1546401763461"><p>同级目录下多出文件，并且保存了添加的信息</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546432343078.png" class="" width="1546432343078"><h2 id="9、文件交互-读文件"><a href="#9、文件交互-读文件" class="headerlink" title="9、文件交互 - 读文件"></a>9、文件交互 - 读文件</h2><p>功能描述：将文件中的内容读取到程序中</p><p>虽然我们实现了添加职工后保存到文件的操作，但是每次开始运行程序，并没有将文件中数据读取到程序中</p><p>而我们的程序功能中还有清空文件的需求</p><p>因此构造函数初始化数据的情况分为三种</p><ol><li>第一次使用，文件未创建</li><li>文件存在，但是数据被用户清空</li><li>文件存在，并且保存职工的所有数据</li></ol><h3 id="9-1-文件未创建"><a href="#9-1-文件未创建" class="headerlink" title="9.1 文件未创建"></a>9.1 文件未创建</h3><p>在workerManager.h中添加新的成员属性 m_FileIsEmpty标志文件是否为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//标志文件是否为空</span></span><br><span class="line"><span class="keyword">bool</span> m_FileIsEmpty;</span><br></pre></td></tr></table></figure><p>修改WorkerManager.cpp中构造函数代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">WorkerManager::WorkerManager()</span><br><span class="line">&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(FILENAME, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="comment">//文件不存在情况</span></span><br><span class="line"><span class="keyword">if</span> (!ifs.is_open())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//测试输出</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;  <span class="comment">//初始化人数</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>; <span class="comment">//初始化文件为空标志</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>; <span class="comment">//初始化数组</span></span><br><span class="line">ifs.close(); <span class="comment">//关闭文件</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除文件后，测试文件不存在时初始化数据功能</p><h3 id="9-2-文件存在且数据为空"><a href="#9-2-文件存在且数据为空" class="headerlink" title="9.2 文件存在且数据为空"></a>9.2 文件存在且数据为空</h3><p>在workerManager.cpp中的构造函数追加代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件存在，并且没有记录</span></span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">ifs &gt;&gt; ch;</span><br><span class="line"><span class="keyword">if</span> (ifs.eof())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件为空!&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>;</span><br><span class="line">ifs.close();</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>追加代码位置如图：</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546435197575.png" class="" width="1546435197575"><p>将文件创建后清空文件内容，并测试该情况下初始化功能</p><p>我们发现文件不存在或者为空清空 m_FileIsEmpty 判断文件是否为空的标志都为真，那何时为假？</p><p>成功添加职工后，应该更改文件不为空的标志</p><p>在<code>void WorkerManager::Add_Emp() </code>成员函数中添加：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//更新职工不为空标志</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">false</span>;</span><br></pre></td></tr></table></figure><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546656256176.png" class="" width="1546656256176"><h3 id="9-3-文件存在且保存职工数据"><a href="#9-3-文件存在且保存职工数据" class="headerlink" title="9.3 文件存在且保存职工数据"></a>9.3 文件存在且保存职工数据</h3><h4 id="9-3-1-获取记录的职工人数"><a href="#9-3-1-获取记录的职工人数" class="headerlink" title="9.3.1 获取记录的职工人数"></a>9.3.1 获取记录的职工人数</h4><p>在workerManager.h中添加成员函数 <code> int get_EmpNum();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//统计人数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_EmpNum</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>workerManager.cpp中实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WorkerManager::get_EmpNum</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(FILENAME, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> dId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">//记录人数</span></span><br><span class="line">num++;</span><br><span class="line">&#125;</span><br><span class="line">ifs.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在workerManager.cpp构造函数中继续追加代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> num =  <span class="keyword">this</span>-&gt;get_EmpNum();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;职工个数为：&quot;</span> &lt;&lt; num &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpNum = num;  <span class="comment">//更新成员属性 </span></span><br></pre></td></tr></table></figure><p>手动添加一些职工数据，测试获取职工数量函数</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546436429055.png" class="" width="1546436429055"><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546436385793.png" class="" width="1546436385793"><h4 id="9-3-2-初始化数组"><a href="#9-3-2-初始化数组" class="headerlink" title="9.3.2 初始化数组"></a>9.3.2 初始化数组</h4><p>根据职工的数据以及职工数据，初始化workerManager中的Worker ** m_EmpArray 指针</p><p>在WorkerManager.h中添加成员函数  <code>void init_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化员工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>在WorkerManager.cpp中实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::init_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">ifstream ifs;</span><br><span class="line">ifs.open(FILENAME, ios::in);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="keyword">int</span> dId;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (ifs &gt;&gt; id &amp;&amp; ifs &gt;&gt; name &amp;&amp; ifs &gt;&gt; dId)</span><br><span class="line">&#123;</span><br><span class="line">Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//根据不同的部门Id创建不同对象</span></span><br><span class="line"><span class="keyword">if</span> (dId == <span class="number">1</span>)  <span class="comment">// 1普通员工</span></span><br><span class="line">&#123;</span><br><span class="line">worker = <span class="keyword">new</span> Employee(id, name, dId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (dId == <span class="number">2</span>) <span class="comment">//2经理</span></span><br><span class="line">&#123;</span><br><span class="line">worker = <span class="keyword">new</span> Manager(id, name, dId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="comment">//总裁</span></span><br><span class="line">&#123;</span><br><span class="line">worker = <span class="keyword">new</span> Boss(id, name, dId);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//存放在数组中</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray[index] = worker;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在workerManager.cpp构造函数中追加代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//根据职工数创建数组</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray = <span class="keyword">new</span> Worker *[<span class="keyword">this</span>-&gt;m_EmpNum];</span><br><span class="line"><span class="comment">//初始化职工</span></span><br><span class="line">init_Emp();</span><br><span class="line"></span><br><span class="line"><span class="comment">//测试代码</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;职工号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Id</span><br><span class="line">&lt;&lt; <span class="string">&quot; 职工姓名： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Name</span><br><span class="line">&lt;&lt; <span class="string">&quot; 部门编号： &quot;</span> &lt;&lt; <span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_DeptId &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行程序，测试从文件中获取的数据</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546436938152.png" class="" width="1546436938152"><p>至此初始化数据功能完毕，测试代码可以注释或删除掉！</p><h2 id="10、显示职工"><a href="#10、显示职工" class="headerlink" title="10、显示职工"></a>10、显示职工</h2><p>功能描述：显示当前所有职工信息</p><h4 id="10-1-显示职工函数声明"><a href="#10-1-显示职工函数声明" class="headerlink" title="10.1 显示职工函数声明"></a>10.1 显示职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Show_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Show_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="10-2-显示职工函数实现"><a href="#10-2-显示职工函数实现" class="headerlink" title="10.2 显示职工函数实现"></a>10.2 显示职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code>void Show_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//显示职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Show_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//利用多态调用接口</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;showInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="10-3-测试显示职工"><a href="#10-3-测试显示职工" class="headerlink" title="10.3 测试显示职工"></a>10.3 测试显示职工</h4><p>在main函数分支 2  选项中，调用显示职工接口</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546497336465.png" class="" width="1546497336465"><p>测试时分别测试 文件为空和文件不为空两种情况</p><p>测试效果：</p><p>测试1-文件不存在或者为空情况</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546497082135.png" class="" width="1546497082135"><p>测试2 - 文件存在且有记录情况</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546496947671.png" class="" width="1546496947671"><p>测试完毕，至此，显示所有职工信息功能实现</p><h2 id="11、删除职工"><a href="#11、删除职工" class="headerlink" title="11、删除职工"></a>11、删除职工</h2><p>功能描述：按照职工的编号进行删除职工操作</p><h4 id="11-1-删除职工函数声明"><a href="#11-1-删除职工函数声明" class="headerlink" title="11.1 删除职工函数声明"></a>11.1 删除职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Del_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Del_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="11-2-职工是否存在函数声明"><a href="#11-2-职工是否存在函数声明" class="headerlink" title="11.2 职工是否存在函数声明"></a>11.2 职工是否存在函数声明</h4><p>很多功能都需要用到根据职工是否存在来进行操作如：删除职工、修改职工、查找职工</p><p>因此添加该公告函数，以便后续调用</p><p>在workerManager.h中添加成员函数  <code>int IsExist(int id);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//按照职工编号判断职工是否存在,若存在返回职工在数组中位置，不存在返回-1</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsExist</span><span class="params">(<span class="keyword">int</span> id)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="11-3-职工是否存在函数实现"><a href="#11-3-职工是否存在函数实现" class="headerlink" title="11.3 职工是否存在函数实现"></a>11.3 职工是否存在函数实现</h4><p>在workerManager.cpp中实现成员函数 <code>int IsExist(int id);</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WorkerManager::IsExist</span><span class="params">(<span class="keyword">int</span> id)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;m_Id == id)</span><br><span class="line">&#123;</span><br><span class="line">index = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-4-删除职工函数实现"><a href="#11-4-删除职工函数实现" class="headerlink" title="11.4 删除职工函数实现"></a>11.4 删除职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Del_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Del_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//按职工编号删除</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入想要删除的职工号：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> id = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> index = <span class="keyword">this</span>-&gt;IsExist(id);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (index != <span class="number">-1</span>)  <span class="comment">//说明index上位置数据需要删除</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = index; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum - <span class="number">1</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray[i] = <span class="keyword">this</span>-&gt;m_EmpArray[i + <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpNum--;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;save(); <span class="comment">//删除后数据同步到文件中</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;删除成功！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;删除失败，未找到该职工&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="11-5-测试删除职工"><a href="#11-5-测试删除职工" class="headerlink" title="11.5 测试删除职工"></a>11.5 测试删除职工</h4><p>在main函数分支 3  选项中，调用删除职工接口</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502698622.png" class="" width="1546502698622"><p>测试1 - 删除不存在职工情况</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546500324196.png" class="" width="1546500324196"><p>测试2 - 删除存在的职工情况</p><p>删除成功提示图：</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546500350526.png" class="" width="1546500350526"><p>再次显示所有职工信息，确保已经删除</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546500361889.png" class="" width="1546500361889"><p>查看文件中信息，再次核实员工已被完全删除</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546500383570.png" class="" width="1546500383570"><p>至此，删除职工功能实现完毕！</p><h2 id="12、修改职工"><a href="#12、修改职工" class="headerlink" title="12、修改职工"></a>12、修改职工</h2><p>功能描述：能够按照职工的编号对职工信息进行修改并保存</p><h4 id="12-1-修改职工函数声明"><a href="#12-1-修改职工函数声明" class="headerlink" title="12.1 修改职工函数声明"></a>12.1 修改职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Mod_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Mod_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="12-2-修改职工函数实现"><a href="#12-2-修改职工函数实现" class="headerlink" title="12.2 修改职工函数实现"></a>12.2 修改职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Mod_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//修改职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Mod_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入修改职工的编号：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = <span class="keyword">this</span>-&gt;IsExist(id);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">&#123; </span><br><span class="line"><span class="comment">//查找到编号的职工</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_EmpArray[ret];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> newId = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">string</span> newName = <span class="string">&quot;&quot;</span>;</span><br><span class="line"><span class="keyword">int</span> dSelect = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查到： &quot;</span> &lt;&lt; id &lt;&lt; <span class="string">&quot;号职工，请输入新职工号： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; newId;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入新姓名： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; newName;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入岗位： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、普通职工&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、经理&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;3、老板&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; dSelect;</span><br><span class="line"></span><br><span class="line">Worker * worker = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">switch</span> (dSelect)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">worker = <span class="keyword">new</span> Employee(newId, newName, dSelect);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">worker = <span class="keyword">new</span> Manager(newId, newName, dSelect);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">worker = <span class="keyword">new</span> Boss(newId, newName, dSelect);</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//更改数据 到数组中</span></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray[ret]= worker;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;修改成功！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存到文件中</span></span><br><span class="line"><span class="keyword">this</span>-&gt;save();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;修改失败，查无此人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按任意键 清屏</span></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="12-3-测试修改职工"><a href="#12-3-测试修改职工" class="headerlink" title="12.3 测试修改职工"></a>12.3 测试修改职工</h4><p>在main函数分支 4  选项中，调用修改职工接口</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502651922.png" class="" width="1546502651922"><p>测试1 - 修改不存在职工情况</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502759643.png" class="" width="1546502759643"><p>测试2 - 修改存在职工情况，例如将职工 “李四” 改为 “赵四”</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502830350.png" class="" width="1546502830350"><p>修改后再次查看所有职工信息，并确认修改成功</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502865443.png" class="" width="1546502865443"><p>再次确认文件中信息也同步更新</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546502898653.png" class="" width="1546502898653"><p>至此，修改职工功能已实现！</p><h2 id="13、查找职工"><a href="#13、查找职工" class="headerlink" title="13、查找职工"></a>13、查找职工</h2><p>功能描述：提供两种查找职工方式，一种按照职工编号，一种按照职工姓名</p><h4 id="13-1-查找职工函数声明"><a href="#13-1-查找职工函数声明" class="headerlink" title="13.1 查找职工函数声明"></a>13.1 查找职工函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Find_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Find_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="13-2-查找职工函数实现"><a href="#13-2-查找职工函数实现" class="headerlink" title="13.2 查找职工函数实现"></a>13.2 查找职工函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Find_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//查找职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Find_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入查找的方式：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、按职工编号查找&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、按姓名查找&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//按职工号查找</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> id;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入查找的职工编号：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = IsExist(id);</span><br><span class="line"><span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找成功！该职工信息如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray[ret]-&gt;showInfo();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找失败，查无此人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(select == <span class="number">2</span>) <span class="comment">//按姓名查找</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">string</span> name;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请输入查找的姓名：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; name;</span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> flag = <span class="literal">false</span>;  <span class="comment">//查找到的标志</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_EmpArray[i]-&gt;m_Name == name)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找成功,职工编号为：&quot;</span></span><br><span class="line">                           &lt;&lt; m_EmpArray[i]-&gt;m_Id</span><br><span class="line">                           &lt;&lt; <span class="string">&quot; 号的信息如下：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">flag = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray[i]-&gt;showInfo();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (flag == <span class="literal">false</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//查无此人</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;查找失败，查无此人&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输入选项有误&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="13-3-测试查找职工"><a href="#13-3-测试查找职工" class="headerlink" title="13.3 测试查找职工"></a>13.3 测试查找职工</h4><p>在main函数分支 5  选项中，调用查找职工接口</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546504714318.png" class="" width="1546504714318"><p>测试1 - 按照职工编号查找 - 查找不存在职工</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546504767229.png" class="" width="1546504767229"><p>测试2 - 按照职工编号查找 -  查找存在职工</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546505046521.png" class="" width="1546505046521"><p>测试3 - 按照职工姓名查找 - 查找不存在职工</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546505115610.png" class="" width="1546505115610"><p>测试4 - 按照职工姓名查找 - 查找存在职工（如果出现重名，也一并显示，在文件中可以添加重名职工）</p><p>例如 添加两个王五的职工，然后按照姓名查找王五</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546507850441.png" class="" width="1546507850441"><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546507760284.png" class="" width="1546507760284"><p>至此，查找职工功能实现完毕！</p><h2 id="14、排序"><a href="#14、排序" class="headerlink" title="14、排序"></a>14、排序</h2><p>功能描述：按照职工编号进行排序，排序的顺序由用户指定</p><h4 id="14-1-排序函数声明"><a href="#14-1-排序函数声明" class="headerlink" title="14.1 排序函数声明"></a>14.1 排序函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Sort_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Sort_Emp</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="14-2-排序函数实现"><a href="#14-2-排序函数实现" class="headerlink" title="14.2 排序函数实现"></a>14.2 排序函数实现</h4><p>在workerManager.cpp中实现成员函数 <code> void Sort_Emp();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//排序职工</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Sort_Emp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_FileIsEmpty)</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;文件不存在或记录为空！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;请选择排序方式： &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、按职工号进行升序&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、按职工号进行降序&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> minOrMax = i;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; m_EmpNum; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>) <span class="comment">//升序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_EmpArray[minOrMax]-&gt;m_Id &gt; m_EmpArray[j]-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line">minOrMax = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>  <span class="comment">//降序</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_EmpArray[minOrMax]-&gt;m_Id &lt; m_EmpArray[j]-&gt;m_Id)</span><br><span class="line">&#123;</span><br><span class="line">minOrMax = j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (i != minOrMax)</span><br><span class="line">&#123;</span><br><span class="line">Worker * temp = m_EmpArray[i];</span><br><span class="line">m_EmpArray[i] = m_EmpArray[minOrMax];</span><br><span class="line">m_EmpArray[minOrMax] = temp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;排序成功,排序后结果为：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;save();</span><br><span class="line"><span class="keyword">this</span>-&gt;Show_Emp();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="14-3-测试排序功能"><a href="#14-3-测试排序功能" class="headerlink" title="14.3 测试排序功能"></a>14.3 测试排序功能</h4><p>在main函数分支 6  选项中，调用排序职工接口</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546510145181.png" class="" width="1546510145181"><p>测试：</p><p>首先我们添加一些职工，序号是无序的，例如：</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658169987.png" class="" width="1546658169987"><p>测试 - 升序排序</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658190479.png" class="" width="1546658190479"><p>文件同步更新</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658273581.png" class="" width="1546658273581"><p>测试 - 降序排序</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658288936.png" class="" width="1546658288936"><p>文件同步更新</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546658313704.png" class="" width="1546658313704"><p>至此，职工按照编号排序的功能实现完毕！</p><h2 id="15、清空文件"><a href="#15、清空文件" class="headerlink" title="15、清空文件"></a>15、清空文件</h2><p>功能描述：将文件中记录数据清空</p><h4 id="15-1-清空函数声明"><a href="#15-1-清空函数声明" class="headerlink" title="15.1 清空函数声明"></a>15.1 清空函数声明</h4><p>在workerManager.h中添加成员函数  <code>void Clean_File();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Clean_File</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h4 id="15-2-清空函数实现"><a href="#15-2-清空函数实现" class="headerlink" title="15.2 清空函数实现"></a>15.2 清空函数实现</h4><p>在workerManager.cpp中实现员函数 <code> void Clean_File();</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//清空文件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">WorkerManager::Clean_File</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;确认清空？&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;1、确认&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;2、返回&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> select = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; select;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (select == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//打开模式 ios::trunc 如果存在删除文件并重新创建</span></span><br><span class="line"><span class="function">ofstream <span class="title">ofs</span><span class="params">(FILENAME, ios::trunc)</span></span>;</span><br><span class="line">ofs.close();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>-&gt;m_EmpNum; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;m_EmpArray[i] != <span class="literal">NULL</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">this</span>-&gt;m_EmpArray[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpNum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">delete</span>[] <span class="keyword">this</span>-&gt;m_EmpArray;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_EmpArray = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;m_FileIsEmpty = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;清空成功！&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">system(<span class="string">&quot;pause&quot;</span>);</span><br><span class="line">system(<span class="string">&quot;cls&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="15-3-测试清空文件"><a href="#15-3-测试清空文件" class="headerlink" title="15.3 测试清空文件"></a>15.3 测试清空文件</h4><p>在main函数分支 7  选项中，调用清空文件接口</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546511085541.png" class="" width="1546511085541"><p>测试：确认清空文件</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546510976745.png" class="" width="1546510976745"><p>再次查看文件中数据，记录已为空</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546510994196.png" class="" width="1546510994196"><p>打开文件，里面数据已确保清空，该功能需要慎用！</p><img src="/2022/01/03/%E8%81%8C%E5%B7%A5%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/1546511018517.png" class="" width="1546511018517"><p>随着清空文件功能实现，本案例制作完毕  ^ _ ^  </p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于C++中指针的理解及其应用</title>
      <link href="/2021/10/24/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/"/>
      <url>/2021/10/24/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h4 id="指针的概念"><a href="#指针的概念" class="headerlink" title="指针的概念"></a>指针的概念</h4><p>指针是一个特殊的变量，它里面存储的数值被解释成为内存里的一个地址。要搞清一个指针需要搞清指针的四方面的内容: </p><ul><li>指针的类型</li><li>指针所指向的类型</li><li>指针的值或者指针所指向的内存区</li><li>指针本身所占的内存区</li></ul><h5 id="指针的类型"><a href="#指针的类型" class="headerlink" title="指针的类型"></a>指针的类型</h5><p>从语法的角度看, 只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr; <span class="comment">//指针的类型是int *  </span></span><br><span class="line"><span class="keyword">char</span> *ptr; <span class="comment">//指针的类型是char *  </span></span><br><span class="line"><span class="keyword">int</span> **ptr; <span class="comment">//指针的类型是 int **  </span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>]; <span class="comment">//指针的类型是 int(*)[3]  </span></span><br><span class="line"><span class="keyword">int</span> *(*ptr)[<span class="number">4</span>]; <span class="comment">//指针的类型是 int *(*)[4] </span></span><br></pre></td></tr></table></figure><h5 id="指针所指向的类型"><a href="#指针所指向的类型" class="headerlink" title="指针所指向的类型"></a>指针所指向的类型</h5><p>当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。</p><p>从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr; <span class="comment">//指针所指向的类型是int  </span></span><br><span class="line"><span class="keyword">char</span> *ptr; <span class="comment">//指针所指向的的类型是char  </span></span><br><span class="line"><span class="keyword">int</span> **ptr; <span class="comment">//指针所指向的的类型是 int *  </span></span><br><span class="line"><span class="keyword">int</span> (*ptr)[<span class="number">3</span>]; <span class="comment">//指针所指向的的类型是 int()[3]  </span></span><br><span class="line"><span class="keyword">int</span> *(*ptr)[<span class="number">4</span>]; <span class="comment">//指针所指向的的类型是 int *()[4]</span></span><br></pre></td></tr></table></figure><h5 id="指针的值"><a href="#指针的值" class="headerlink" title="指针的值"></a><strong>指针的值</strong></h5><p>指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。在32位程序里，所有类型的指针的值都是一个32位整数，因为32位程序里内存地址全都是32位长。 </p><p>指针所指向的内存区就是从指针的值所代表的那个内存地址开始，长度为<code>sizeof</code>(指针所指向的类型)的一片内存区。以后，我们说一个指针的值是XX，就相当于说该指针指向了以XX为首地址的一片内存区域；我们说一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。 </p><p>指针所指向的内存区和指针所指向的类型是两个完全不同的概念。在例一中，指针所指向的类型已经有了，但由于指针还未初始化，所以它所指向的内存区是不存在的，或者说是无意义的。 </p><p>以后，每遇到一个指针，都应该问问：这个指针的类型是什么？指针指向的类型是什么？该指针指向了哪里？ </p><h5 id="指针本身所占据的内存区"><a href="#指针本身所占据的内存区" class="headerlink" title="指针本身所占据的内存区"></a>指针本身所占据的内存区</h5><p>指针本身占了多大的内存？你只要用函数<code>sizeof</code>(指针的类型)测一下就知道了。在32位平台里，指针本身占据了4个字节的长度。</p><p>指针本身占据的内存这个概念在判断一个指针表达式是否是左值时很有用。 </p><h4 id="指针的算术运算"><a href="#指针的算术运算" class="headerlink" title="指针的算术运算"></a>指针的算术运算</h4><p>指针可以加上或减去一个整数。指针的这种运算的意义和通常的数值的加减运算的意义是不一样的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">20</span>];  </span><br><span class="line"><span class="keyword">int</span> *ptr=a;  </span><br><span class="line">ptr++;  </span><br></pre></td></tr></table></figure><p>在上例中，指针<code>ptr</code>的类型是int*,它指向的类型是int，它被初始化为指向整形变量a。接下来的第3句中，指针<code>ptr</code>被加了1，编译器是这样处理的：它把指针<code>ptr</code>的值加上了<code>sizeof(int)</code>，在32位程序中，是被加上了4。由于地址是用字节做单位的，故<code>ptr</code>所指向的地址由原来的变量a的地址向高地址方向增加了4个字节。注意: 由于char类型的长度是一个字节，所以，原来<code>ptr</code>是指向数组a的第0号单元开始的四个字节，此时指向了数组a中从第4号单元开始的四个字节。</p><p>我们可以用一个指针和一个循环来遍历一个数组，看例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">20</span>];  </span><br><span class="line"><span class="keyword">int</span> *ptr=<span class="built_in">array</span>;  </span><br><span class="line">...  </span><br><span class="line"><span class="comment">//此处略去为整型数组赋值的代码。  </span></span><br><span class="line">...  </span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;<span class="number">20</span>;i++)  </span><br><span class="line">&#123;  </span><br><span class="line">    (*ptr)++;  </span><br><span class="line">    ptr++；  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure><p>这个例子将整型数组中各个单元的值加1。由于每次循环都将指针<code>ptr</code>加1，所以每次循环都能访问数组的下一个单元。</p><p>总结一下，一个指针<code>ptrold</code>加上一个整数n后，结果是一个新的指针<code>ptrnew</code>，<code>ptrnew</code>的类型和<code>ptrold</code>的类型相同，<code>ptrnew</code>所指向的类型和<code>ptrold</code>所指向的类型也相同。<code>ptrnew</code>的值将比<code>ptrold</code>的值增加了n乘<code>sizeof</code>(<code>ptrold</code>所指向的类型)个字节。就是说，<code>ptrnew</code>所指向的内存区将比<code>ptrold</code>所指向的内存区向高地址方向移动了n乘<code>sizeof</code>(<code>ptrold</code>所指向的类型)个字节。一个指针<code>ptrold</code>减去一个整数n后，结果是一个新的指针<code>ptrnew</code>，<code>ptrnew</code>的类型和<code>ptrold</code>的类型相同，<code>ptrnew</code>所指向的类型和<code>ptrold</code>所指向的类型也相同。<code>ptrnew</code>的值将比<code>ptrold</code>的值减少了n乘<code>sizeof</code>(<code>ptrold</code>所指向的类型)个字节，就是说，<code>ptrnew</code>所指向的内存区将比<code>ptrold</code>所指向的内存区向低地址方向移动了n乘<code>sizeof</code>(<code>ptrold</code>所指向的类型)个字节。</p><h4 id="运算符-amp-和"><a href="#运算符-amp-和" class="headerlink" title="运算符 &amp; 和 *"></a>运算符 <code>&amp;</code> 和 <code>*</code></h4><p>这里&amp;是取地址运算符，<em>是…书上叫做“间接运算符”。&amp;a的运算结果是一个指针，指针的类型是a的类型加个</em>，指针所指向的类型是a的类型，指针所指向的地址嘛，那就是a的地址。<em>p的运算结果就五花八门了。总之</em>p的结果是p所指向的东西，这个东西有这些特点：它的类型是p指向的类型，它所占用的地址是p所指向的地址。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">12</span>;  <span class="keyword">int</span> b;  </span><br><span class="line"><span class="keyword">int</span> *p;  </span><br><span class="line"><span class="keyword">int</span> **ptr;  </span><br><span class="line">p=&amp;a;<span class="comment">//&amp;a的结果是一个指针，类型是int*，指向的类型是int，指向的地址是a的地址。  </span></span><br><span class="line">*p=<span class="number">24</span>;<span class="comment">//*p的结果，在这里它的类型是int，它所占用的地址是p所指向的地址，显然，*p就是变量a。</span></span><br><span class="line">ptr=&amp;p;<span class="comment">//&amp;p的结果是个指针，该指针的类型是p的类型加个*，在这里是int**。该指针所指向的类型是p的类型，这里是int*。该指针所指向的地址就是指针p自己的地址。 </span></span><br><span class="line">*ptr=&amp;b; <span class="comment">//*ptr是个指针，&amp;b的结果也是个指针，且这两个指针的类型和所指向的类型是一样的，所以&amp;b来给*ptr赋值就是毫无问题的了。</span></span><br><span class="line">**ptr=<span class="number">34</span>;<span class="comment">//*ptr的结果是ptr所指向的东西，在这里是一个指针，对这个指针再做一次*运算，结果就是一个int类型的变量。</span></span><br></pre></td></tr></table></figure><h4 id="指针表达式"><a href="#指针表达式" class="headerlink" title="指针表达式"></a><strong>指针表达式</strong></h4><p>一个表达式的最后结果如果是一个指针，那么这个表达式就叫指针表达式。下面是一些指针表达式的例子： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a,b;  </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">10</span>];  </span><br><span class="line"><span class="keyword">int</span> *pa;  </span><br><span class="line">pa=&amp;a;<span class="comment">//&amp;a是一个指针表达式。  </span></span><br><span class="line"><span class="keyword">int</span> **ptr=&amp;pa;<span class="comment">//&amp;pa也是一个指针表达式。  </span></span><br><span class="line">*ptr=&amp;b;<span class="comment">//*ptr和&amp;b都是指针表达式。  </span></span><br><span class="line">pa=<span class="built_in">array</span>;  </span><br><span class="line">pa++;<span class="comment">//这也是指针表达式。</span></span><br></pre></td></tr></table></figure><p>再比如:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *arr[<span class="number">20</span>];  </span><br><span class="line"><span class="keyword">char</span> **parr=arr;<span class="comment">//如果把arr看作指针的话，arr也是指针表达式  </span></span><br><span class="line"><span class="keyword">char</span> *str;  </span><br><span class="line">str=*parr;<span class="comment">//*parr是指针表达式  </span></span><br><span class="line">str=*(parr+<span class="number">1</span>);<span class="comment">//*(parr+1)是指针表达式  </span></span><br><span class="line">str=*(parr+<span class="number">2</span>);<span class="comment">//*(parr+2)是指针表达式 </span></span><br></pre></td></tr></table></figure><p>由于指针表达式的结果是一个指针，所以指针表达式也具有指针所具有的四个要素：指针的类型，指针所指向的类型，指针指向的内存区，指针自身占据的内存。</p><p>好了，当一个指针表达式的结果指针已经明确地具有了指针自身占据的内存的话，这个指针表达式就是一个左值，否则就不是一个左值。 在例七中，&amp;a不是一个左值，因为它还没有占据明确的内存。<code>*ptr</code>是一个左值，因为<code>*ptr</code>这个指针已经占据了内存，其实<code>*ptr</code>就是指针pa，既然pa已经在内存中有了自己的位置，那么<code>*ptr</code>当然也有了自己的位置。</p><h4 id="数组和指针的关系"><a href="#数组和指针的关系" class="headerlink" title="数组和指针的关系"></a>数组和指针的关系</h4><p>关于数组和指针, 以及多维指针, 声明一些赏识:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1、实际上并不存在多维数组，所谓的多维数组本质上是用一维数组模拟的。</span><br><span class="line"></span><br><span class="line">2、数组名是一个常量（意味着不允许对其进行赋值操作），其代表数组首元素的首地址。</span><br><span class="line"></span><br><span class="line">3、数组与指针的关系是因为数组下标操作符[]，比如，int a[3][2]相当于*(*(a+3)+2) 。</span><br><span class="line"></span><br><span class="line">4、指针是一种变量，也具有类型，其占用内存空间大小和系统有关，一般32位系统下，sizeof(指针变量)&#x3D;4。</span><br><span class="line"></span><br><span class="line">5、指针可以进行加减算术运算，加减的基本单位是sizeof(指针所指向的数据类型)。</span><br><span class="line"></span><br><span class="line">6、对数组的数组名进行取地址(&amp;)操作，其类型为整个数组类型。</span><br><span class="line"></span><br><span class="line">7、对数组的数组名进行sizeof运算符操作，其值为整个数组的大小(以字节为单位)。</span><br><span class="line"></span><br><span class="line">8、数组作为函数形参时会退化为指针。</span><br></pre></td></tr></table></figure><h5 id="一维数组与指针"><a href="#一维数组与指针" class="headerlink" title="一维数组与指针"></a>一维数组与指针</h5><p>假设有一维数组如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>];</span><br></pre></td></tr></table></figure><p>该数组一共有3个元素，元素的类型为char，如果想定义一个指针指向该数组，也就是如果想把数组名a赋值给一个指针变量，那么该指针变量的类型应该是什么呢？前文说过，一个数组的数组名代表其首元素的首地址，也就是相当于&amp;a[0]，而a[0]的类型为char，因此&amp;a[0]类型为char *，因此，可以定义如下的指针变量： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> * p = a;<span class="comment">//相当于char * p = &amp;a[0]</span></span><br></pre></td></tr></table></figure><p> 以上文字可用如下内存模型图表示:</p><img src="/2021/10/24/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/592743-20160227110509240-1709127045.png" class=""><p>大家都应该知道，a和&amp;a[0]代表的都是数组首元素的首地址，而如果你将&amp;a的值打印出来，会发现<strong>该值也等于数组首元素的首地址</strong>。请注意我这里的措辞，也就是说，&amp;a虽然在数值上也等于数组首元素首地址的值，但是其类型并不是数组首元素首地址类型，也就是char *p = &amp;a是错误的。</p><p>前文第6条常识已经说过，对数组名进行取地址操作，其类型为整个数组，因此，&amp;a的类型是char (*)[3]，所以正确的赋值方式如下: </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*p)[<span class="number">3</span>] = &amp;a;</span><br></pre></td></tr></table></figure><h5 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针"></a>二维数组与指针</h5><p> 假如有如下二维数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> a[<span class="number">3</span>][<span class="number">2</span>];</span><br></pre></td></tr></table></figure><p>由于实际上并不存在多维数组，因此，可以将<code>a[3][2]</code>看成是一个具有3个元素的一维数组，只是这三个元素分别又是一个一维数组。实际上，在内存中，该数组的确是按照一维数组的形式存储的，存储顺序为(低地址在前)：<code>a[0][0]</code>、<code>a[0][1]</code>、<code>a[1][0]</code>、<code>a[1][1]</code>、<code>a[2][0]</code>、<code>a[2][1]</code>。(此种方式也不是绝对，也有按列优先存储的模式)。</p><p>为了方便理解，我画了一张逻辑上的内存图，之所以说是逻辑上的，是因为该图只是便于理解，并不是数组在内存中实际的存储模型（实际模型为前文所述）。</p><img src="/2021/10/24/%E5%85%B3%E4%BA%8EC-%E4%B8%AD%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%94%E7%94%A8/592743-20160227122557865-606035369.png" class="" title="img"><p> 如上图所示，我们可以将数组分成两个维度来看，首先是第一维，将<code>a[3][2]</code>看成一个具有三个元素的一维数组，元素分别为：<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>，其中，<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>又分别是一个具有两个元素的一维数组(元素类型为char)。从第二个维度看，此处可以<strong>将<code>a[0]</code>、<code>a[1]</code>、<code>a[2]</code>看成自己代表”第二维”数组的数组名，</strong>以a[0]为例，<code>a[0](数组名)</code>代表的一维数组是一个具有两个char类型元素的数组，而a[0]是这个数组的数组名(代表数组首元素首地址)，因此a[0]类型为<code>char *</code>，同理<code>a[1]</code>和<code>a[2]</code>类型都是char <em>。</em>而a是第一维数组的数组名，代表首元素首地址，而首元素是一个具有两个char类型元素的一维数组，因此a就是一个指向具有两个char类型元素数组的数组指针，也就是<code>char(*)[2]</code>。</p><p>也就是说，如下的赋值是正确的:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*p)[<span class="number">2</span>]  = a;<span class="comment">//a为第一维数组的数组名，类型为char (*)[2]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> * p = a[<span class="number">0</span>];<span class="comment">//a[0]维第二维数组的数组名，类型为char *</span></span><br></pre></td></tr></table></figure><p>同样，对a取地址操作代表整个数组的首地址，类型为数组类型(请允许我暂且这么称呼)，也就是char (*)[3][2]，所以如下赋值是正确的： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> (*p)[<span class="number">3</span>][<span class="number">2</span>] = &amp;a;</span><br></pre></td></tr></table></figure><h4 id="指针和结构类型的关系"><a href="#指针和结构类型的关系" class="headerlink" title="指针和结构类型的关系"></a><strong>指针和结构类型的关系</strong></h4><p>可以声明一个指向结构类型对象的指针。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span>  </span></span><br><span class="line"><span class="class">&#123;</span>  </span><br><span class="line"><span class="keyword">int</span> a;  </span><br><span class="line"><span class="keyword">int</span> b;  </span><br><span class="line"><span class="keyword">int</span> c;  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">MyStruct ss=&#123;<span class="number">20</span>,<span class="number">30</span>,<span class="number">40</span>&#125;;<span class="comment">//声明了结构对象ss，并把ss的三个成员初始化为20，30和40。</span></span><br><span class="line">MyStruct *ptr=&amp;ss;<span class="comment">//声明了一个指向结构对象ss的指针。它的类型是</span></span><br><span class="line">MyStruct*,它指向的类型是MyStruct。</span><br><span class="line"><span class="keyword">int</span> *pstr=(<span class="keyword">int</span>*)&amp;ss;<span class="comment">//声明了一个指向结构对象ss的指针。但是它的类型和它指向的类型和ptr是不同的。</span></span><br></pre></td></tr></table></figure><p>请问怎样通过指针<code>ptr</code>来访问<code>ss</code>的三个成员变量？</p><p>答案： </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ptr-&gt;a;  </span><br><span class="line">ptr-&gt;b;  </span><br><span class="line">ptr-&gt;c; </span><br></pre></td></tr></table></figure><h4 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h4><p>本篇博客作者只用于自己对C++的学习， 无意传播。</p><p>参考：</p><p><a href="https://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html">https://www.cnblogs.com/ggjucheng/archive/2011/12/13/2286391.html</a></p><p><a href="https://www.cnblogs.com/chenyangyao/p/5222696.html">https://www.cnblogs.com/chenyangyao/p/5222696.html</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp配置</title>
      <link href="/2021/10/09/frp%E9%85%8D%E7%BD%AE/"/>
      <url>/2021/10/09/frp%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="本文主要介绍linux下frp服务端与客户端的配置"><a href="#本文主要介绍linux下frp服务端与客户端的配置" class="headerlink" title="本文主要介绍linux下frp服务端与客户端的配置"></a>本文主要介绍linux下frp服务端与客户端的配置</h2><h3 id="1-源文件的下载"><a href="#1-源文件的下载" class="headerlink" title="1 源文件的下载"></a>1 源文件的下载</h3><p>根据硬件架构的不同下载不同的源文件, <code>github</code>仓库地址: <a href="https://github.com/fatedier/frp/releases">https://github.com/fatedier/frp/releases</a>,  客户端和服务端分别下载相对应的源文件,  <code>ubuntu</code>下载 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://github.com/fatedier/frp/releases/download/v0.37.1/frp_0.37.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><img src="/2021/10/09/frp%E9%85%8D%E7%BD%AE/image-20220311150130190.png" class="" title="image-20220311150130190">下载完成, 解压文件<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf frp_0.37.1_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><h3 id="2-服务器端frps-ini的配置"><a href="#2-服务器端frps-ini的配置" class="headerlink" title="2 服务器端frps.ini的配置"></a>2 服务器端<code>frps.ini</code>的配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.37.1_linux_amd64</span><br><span class="line">vim frps.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line"><span class="meta">#</span><span class="bash"> frps绑定端口</span></span><br><span class="line">bind_port = 7000</span><br><span class="line"><span class="meta">#</span><span class="bash"> http 访问端口</span></span><br><span class="line"><span class="meta">#</span><span class="bash">vhost_http_port = 80</span></span><br><span class="line"><span class="meta">#</span><span class="bash">服务端监控</span></span><br><span class="line">dashboard_port = 7500</span><br><span class="line">dashboard_user = admin</span><br><span class="line">dashboard_pwd = admin</span><br><span class="line"><span class="meta">#</span><span class="bash">用这个可以指定域名，客户端可以使用 subdomain，指定一个二级域名。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">用了这个属性，客户端无法开启 custom_domains ，否则服务异常。</span></span><br><span class="line"><span class="meta">#</span><span class="bash">subdomain_host = raven520.top</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> token校验</span></span><br><span class="line">token=raven</span><br></pre></td></tr></table></figure><h3 id="3-客户端frpc-ini的配置"><a href="#3-客户端frpc-ini的配置" class="headerlink" title="3 客户端frpc.ini的配置"></a>3 客户端<code>frpc.ini</code>的配置</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.37.1_linux_amd64</span><br><span class="line">vim frpc.ini</span><br><span class="line"></span><br><span class="line">[common]</span><br><span class="line"><span class="meta">#</span><span class="bash"> 公网ip地址</span></span><br><span class="line">server_addr = 35.75.xxx.x</span><br><span class="line"><span class="meta">#</span><span class="bash"> 服务监听端口</span></span><br><span class="line">server_port = 7000</span><br><span class="line"><span class="meta">#</span><span class="bash"> token校验</span></span><br><span class="line">token = raven</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> tcp穿透 反向代理</span></span><br><span class="line">[ssh_server5]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 22</span><br><span class="line"><span class="meta">#</span><span class="bash"> 指定服务器监听哪个端口进行监听。使用 ip:3388 即可远程连接本地主机</span></span><br><span class="line">remote_port = 65455</span><br><span class="line">local_ip = 0.0.0.0</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">配置http</span></span><br><span class="line">[httpname8]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 80</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">remote_port = 8080</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="4-客户端配置frp自启"><a href="#4-客户端配置frp自启" class="headerlink" title="4 客户端配置frp自启"></a>4 客户端配置frp自启</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd frp_0.37.1_linux_amd64/systemd/</span><br><span class="line">cat frpc.service</span><br><span class="line"></span><br><span class="line">显示结果如下:</span><br><span class="line">[Unit]</span><br><span class="line">Description=Frp Server Service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=simple</span><br><span class="line">User=nobody</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line">ExecStart=/usr/bin/frpc -c /etc/frp/frpc.ini</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">然后按照结果中的 ExecStart=/usr/bin/frps -c /etc/frp/frps.ini, 把frps复制到/usr/bin/目录下, frps.ini复制到/etc/frp/目录下.</span> </span><br><span class="line"></span><br><span class="line">sudo cp frpc /usr/bin</span><br><span class="line">sudo mkdir /etc/frp</span><br><span class="line">sudo cp frpc.ini /etc/frp</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">将system文件中的 frpc.service 放到/etc/systemd/system</span></span><br><span class="line">sudo cp frpc.service /etc/systemd/system</span><br></pre></td></tr></table></figure><p>启动<code>fpc</code>服务</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl enable frpc</span><br><span class="line">sudo systemctl start frpc</span><br></pre></td></tr></table></figure><h3 id="5-同理配置服务端-frps-自启"><a href="#5-同理配置服务端-frps-自启" class="headerlink" title="5 同理配置服务端 frps 自启"></a>5 同理配置服务端 frps 自启</h3>]]></content>
      
      
      <categories>
          
          <category> 工欲善其事, 必先利其器 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> frp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker--ankiserver</title>
      <link href="/2021/02/03/docker-ankiserver/"/>
      <url>/2021/02/03/docker-ankiserver/</url>
      
        <content type="html"><![CDATA[<p>docker 安装参考 <a href="https://blog.csdn.net/u012563853/article/details/125295985">https://blog.csdn.net/u012563853/article/details/125295985</a></p><h3 id="一-部署到服务器"><a href="#一-部署到服务器" class="headerlink" title="一 部署到服务器"></a>一 部署到服务器</h3><ul><li>注意：服务器开放27701端口</li><li>确保服务器已安装docker</li><li>使用root运行</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">export DOCKER_USER=root</span><br><span class="line">export ANKI_SYNC_DATA_DIR=/etc/anki-sync-server</span><br><span class="line">export HOST_PORT=27701</span><br><span class="line"></span><br><span class="line">mkdir -p &quot;$ANKI_SYNC_DATA_DIR&quot;</span><br><span class="line">chown &quot;$DOCKER_USER&quot; &quot;$ANKI_SYNC_DATA_DIR&quot;</span><br><span class="line">chmod 700 &quot;$ANKI_SYNC_DATA_DIR&quot;</span><br><span class="line"></span><br><span class="line">docker run -itd \</span><br><span class="line">   --mount type=bind,source=&quot;$ANKI_SYNC_DATA_DIR&quot;,target=/app/data \</span><br><span class="line">   -p &quot;$HOST_PORT&quot;:27701 \</span><br><span class="line">   --name anki-container \</span><br><span class="line">   --restart always \</span><br><span class="line">   kuklinistvan/anki-sync-server:latest</span><br></pre></td></tr></table></figure><h3 id="二-运行并配置用户"><a href="#二-运行并配置用户" class="headerlink" title="二 运行并配置用户"></a>二 运行并配置用户</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">进入anki-sync-server容器终端</span><br><span class="line"><span class="meta">#</span><span class="bash"> docker <span class="built_in">exec</span> -it anki-container /bin/sh</span> </span><br><span class="line"></span><br><span class="line">查看使用帮助</span><br><span class="line">/app/anki-sync-server # ./ankisyncctl.py --help</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  adduser &lt;username&gt; - add a new user</span><br><span class="line">  deluser &lt;username&gt; - delete a user</span><br><span class="line">  lsuser             - list users</span><br><span class="line">  passwd &lt;username&gt;  - change password of a user</span><br><span class="line"></span><br><span class="line">添加用户示例：</span><br><span class="line">/app/anki-sync-server # ./ankisyncctl.py adduser kuklinistvan</span><br><span class="line">Enter password for kuklinistvan:</span><br><span class="line">/app/anki-sync-server #</span><br></pre></td></tr></table></figure><h3 id="三-电脑端配置"><a href="#三-电脑端配置" class="headerlink" title="三 电脑端配置"></a>三 电脑端配置</h3><p>作者本人并未使用最新版 <code>Anki</code>，使用的版本是 <code>2.1.19</code>，插件安装过程 ：工具-&gt;附加组件-&gt;获取插件-&gt;输入代码 <code>231066250</code> ，下载成功后，在插件文件中进行 <code>ip</code>或者与域名配置，这里作者使用的是域名，但并未使用https，高版本好像要求https。</p><img src="/2021/02/03/docker-ankiserver/image-20210203154040716-1646984418253.png" class="" title="image-20210203154040716"><img src="/2021/02/03/docker-ankiserver/image-20210203154126012-1646984423074.png" class="" title="image-20210203154126012"><h3 id="四-安卓端配置"><a href="#四-安卓端配置" class="headerlink" title="四 安卓端配置"></a>四 安卓端配置</h3><p>AnkiDroid使用的版本是 <code>v2.9.7</code>, 在高级设置中点击 “自定义同步服务器”，同步地址设为 <code>http://ip 或者 域名:27701</code> ，媒体文件同步地址设为 <code>http://ip 或者 域名:27701/msync</code>，最后在常用设置中登录用户。</p><h3 id="五-参考"><a href="#五-参考" class="headerlink" title="五 参考"></a>五 参考</h3><p><a href="https://github.com/tsudoko/anki-sync-server">https://github.com/tsudoko/anki-sync-server</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> anki </tag>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora常用语法</title>
      <link href="/2021/01/13/Typora%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/"/>
      <url>/2021/01/13/Typora%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="Markdown-常用结构体"><a href="#Markdown-常用结构体" class="headerlink" title="Markdown 常用结构体"></a>Markdown 常用结构体</h3><h4 id="1-1-标题"><a href="#1-1-标题" class="headerlink" title="1.1 标题"></a>1.1 标题</h4><p>使用 # 或者 <code>ctrl+数字 </code>    例如：<code>ctrl + 1</code> 对应一级标题</p><h4 id="1-2-段落"><a href="#1-2-段落" class="headerlink" title="1.2 段落"></a>1.2 段落</h4><p><code>ctrl + 0</code></p><h4 id="1-3-区块引用"><a href="#1-3-区块引用" class="headerlink" title="1.3 区块引用"></a>1.3 区块引用</h4><p>在段落的每行或者只在第一行使用符号<code>&gt;</code>,还可使用多个嵌套引用，如：</p><blockquote><p>区块应用   <code>&gt;</code></p><p>&gt;嵌套引用</p></blockquote><h4 id="1-4-代码区块"><a href="#1-4-代码区块" class="headerlink" title="1.4 代码区块"></a>1.4 代码区块</h4><p><code>ctrl + shift + K</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void main()</span><br><span class="line">&#123;    </span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><h4 id="1-5-强调"><a href="#1-5-强调" class="headerlink" title="1.5 强调"></a>1.5 强调</h4><p>在强调内容两侧分别加上<code>*</code>或者<code>_</code>，如：</p><blockquote><p><em>斜体</em> ，<em>斜体</em>    <code>ctrl + I</code></p><p><strong>粗体</strong>   <code>ctrl + B</code></p></blockquote><h4 id="1-6-列表"><a href="#1-6-列表" class="headerlink" title="1.6 列表"></a>1.6 列表</h4><p>有序使用：<code>ctrl+shift+[</code></p><ol><li>第一项</li><li>第二项</li><li>第三项</li></ol><p>无序使用：<code>ctrl+shift+]</code></p><ul><li>无序列表第一</li><li>第二</li></ul><h4 id="1-7-分割线"><a href="#1-7-分割线" class="headerlink" title="1.7 分割线"></a>1.7 分割线</h4><p>分割线最常使用就是三个或以上<code>*</code>，还可以使用<code>-</code>和<code>_</code>。</p><hr><hr><hr><h4 id="1-8-链接"><a href="#1-8-链接" class="headerlink" title="1.8 链接"></a>1.8 链接</h4><h5 id="1-8-1-行内式"><a href="#1-8-1-行内式" class="headerlink" title="1.8.1 行内式"></a>1.8.1 行内式</h5><p><strong>语法说明:</strong>  <code>[]</code>里面写链接文字, <code>()</code> 里面写链接地址, <code>()</code> 里面的 <code>&quot;&quot;</code> 写链接的title, title 属性的效果是鼠标悬停在链接上会出现的 title 文字。快捷键  <code>ctrl + k</code></p><p>显示效果如下:    欢迎来到<a href="https://www.baidu.com/" title="点击跳转百度首页">百度</a></p><h5 id="1-8-2-参考式"><a href="#1-8-2-参考式" class="headerlink" title="1.8.2 参考式"></a>1.8.2 参考式</h5><p><strong>语法说明:</strong>  参考式链接分为两部分，文中的写法**<code>[链接文字][链接标记]</code>**，在文本的任意位置添加<code>[链接标记]: 链接地址 &quot;链接标题&quot;</code>，链接地址和链接标题前有一个空格。</p><p><strong>举例:</strong> </p><p>经常使用的网站有<code>[Google][1]</code>、<code>[csdn][2]</code>以及<code>[博客园][网站]</code></p><p>显示效果如下:  </p><p>经常使用的网站有<a href="http://www.google.com/" title="Google">Google</a>、<a href="https://blog.csdn.net/" title="csdn">csdn</a>以及<a href="https://blog.csdn.net/">博客园</a></p><h5 id="1-8-3-自动链接"><a href="#1-8-3-自动链接" class="headerlink" title="1.8.3 自动链接"></a>1.8.3 自动链接</h5><p>语法说明:  Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用<code>&lt;&gt;</code>包裹起来，Markdown 就会自动把它转成链接。</p><p>举例:  百度: <code>&lt;www.baidu.com&gt;</code></p><p>显示效果:  百度: <a href="http://www.baidu.com/">http://www.baidu.com</a></p><h5 id="1-8-4-页面内超链接"><a href="#1-8-4-页面内超链接" class="headerlink" title="1.8.4 页面内超链接"></a>1.8.4 页面内超链接</h5><p>页内超链接也叫锚点，也就是链接本文档内部的某些元素，实现当前页面中的跳转。比如我这里写下一个锚点，点击回到目录，就能跳转到目录。在目录中点击这一节，就能跳过来。注意：Markdown Extra 只支持将标题作为锚点，其它地方无效。</p><p><strong>语法说明:</strong>   在文档的其它地方写上连接到标题锚点的链接</p><p>举例: 跳转到<code>[链接](#Markdown 常用结构体)</code></p><p>显示效果: 跳转到 [链接](#Markdown 常用结构体)  (注:  这里在博客中并不显示)</p><h4 id="1-9-图片"><a href="#1-9-图片" class="headerlink" title="1.9 图片"></a>1.9 图片</h4><p><code>ctrl + shift +i</code>, 也可以手动 <code>!</code>  +  <code>[]</code>  + <code>()</code></p><h4 id="1-10-反斜杠"><a href="#1-10-反斜杠" class="headerlink" title="1.10 反斜杠"></a>1.10 反斜杠</h4><p><code>\</code>相当于<strong>反转义</strong>作用，使符号成为普通符号.</p><h4 id="1-11-符号"><a href="#1-11-符号" class="headerlink" title="1.11 符号   `"></a>1.11 符号   `</h4><p>ctrl + shift + `</p><p> 起到标记作用，用于字母或数字，例如：<code>abc</code>，<code>123</code> 。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
